const LEETCODE_SOLUTIONS = {"1": "class Solution {\n public:\n  vector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (const auto it = numToIndex.find(target - nums[i]);\n          it != numToIndex.cend())\n        return {it->second, i};\n      numToIndex[nums[i]] = i;\n    }\n\n    throw;\n  }\n};\n", "10": "class Solution {\n public:\n  bool isMatch(string s, string p) {\n    const int m = s.length();\n    const int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    auto isMatch = [&](int i, int j) -> bool {\n      return j >= 0 && p[j] == '.' || s[i] == p[j];\n    };\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p[j] == '*' && dp[0][j - 1])\n        dp[0][j + 1] = true;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p[j] == '*') {\n          // The minimum index of '*' is 1.\n          const bool noRepeat = dp[i + 1][j - 1];\n          const bool doRepeat = isMatch(i, j - 1) && dp[i][j + 1];\n          dp[i + 1][j + 1] = noRepeat || doRepeat;\n        } else if (isMatch(i, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        }\n\n    return dp[m][n];\n  }\n};\n", "100": "class Solution {\n public:\n  bool isSameTree(TreeNode* p, TreeNode* q) {\n    if (!p || !q)\n      return p == q;\n    return p->val == q->val &&              //\n           isSameTree(p->left, q->left) &&  //\n           isSameTree(p->right, q->right);\n  }\n};\n", "1000": "class Solution {\n public:\n  int mergeStones(vector<int>& stones, int K) {\n    const int n = stones.size();\n    if ((n - 1) % (K - 1))\n      return -1;\n\n    constexpr int kMax = 1'000'000'000;\n    // dp[i][j][k] := the minimum cost to merge stones[i..j] into k piles\n    vector<vector<vector<int>>> dp(\n        n, vector<vector<int>>(n, vector<int>(K + 1, kMax)));\n    vector<int> prefix(n + 1);\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i][1] = 0;\n\n    partial_sum(stones.begin(), stones.end(), prefix.begin() + 1);\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        for (int k = 2; k <= K; ++k)\n          for (int m = i; m < j; m += K - 1)\n            dp[i][j][k] = min(dp[i][j][k], dp[i][m][1] + dp[m + 1][j][k - 1]);\n        dp[i][j][1] = dp[i][j][K] + prefix[j + 1] - prefix[i];\n      }\n\n    return dp[0][n - 1][1];\n  }\n};\n", "1001": "class Solution {\n public:\n  vector<int> gridIllumination(int n, vector<vector<int>>& lamps,\n                               vector<vector<int>>& queries) {\n    vector<int> ans;\n    unordered_map<int, int> rows;\n    unordered_map<int, int> cols;\n    unordered_map<int, int> diag1;\n    unordered_map<int, int> diag2;\n    unordered_set<pair<int, int>, PairHash> lampsSet;\n\n    for (const vector<int>& lamp : lamps) {\n      const int i = lamp[0];\n      const int j = lamp[1];\n      if (lampsSet.insert({i, j}).second) {\n        ++rows[i];\n        ++cols[j];\n        ++diag1[i + j];\n        ++diag2[i - j];\n      }\n    }\n\n    for (const vector<int>& query : queries) {\n      const int i = query[0];\n      const int j = query[1];\n      if (rows[i] || cols[j] || diag1[i + j] || diag2[i - j]) {\n        ans.push_back(1);\n        for (int y = max(0, i - 1); y < min(n, i + 2); ++y)\n          for (int x = max(0, j - 1); x < min(n, j + 2); ++x)\n            if (lampsSet.erase({y, x})) {\n              --rows[y];\n              --cols[x];\n              --diag1[y + x];\n              --diag2[y - x];\n            }\n      } else {\n        ans.push_back(0);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "1002": "class Solution {\n public:\n  vector<string> commonChars(vector<string>& words) {\n    vector<string> ans;\n    vector<int> commonCount(26, INT_MAX);\n\n    for (const string& word : words) {\n      vector<int> count(26);\n      for (const char c : word)\n        ++count[c - 'a'];\n      for (int i = 0; i < 26; ++i)\n        commonCount[i] = min(commonCount[i], count[i]);\n    }\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      for (int i = 0; i < commonCount[c - 'a']; ++i)\n        ans.push_back(string(1, c));\n\n    return ans;\n  }\n};\n", "1003": "class Solution {\n public:\n  bool isValid(string s) {\n    stack<char> stack;\n\n    for (const char c : s)\n      if (c == 'c') {\n        if (stack.size() < 2)\n          return false;\n        if (stack.top() != 'b')\n          return false;\n        stack.pop();\n        if (stack.top() != 'a')\n          return false;\n        stack.pop();\n      } else {\n        stack.push(c);\n      }\n\n    return stack.empty();\n  }\n};\n", "1004": "class Solution {\n public:\n  int longestOnes(vector<int>& nums, int k) {\n    int ans = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (nums[r] == 0)\n        --k;\n      while (k < 0)\n        if (nums[l++] == 0)\n          ++k;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "1005": "class Solution {\n public:\n  int largestSumAfterKNegations(vector<int>& nums, int k) {\n    ranges::sort(nums);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] > 0 || k == 0)\n        break;\n      nums[i] = -nums[i];\n      --k;\n    }\n\n    return accumulate(nums.begin(), nums.end(), 0) -\n           (k % 2) * ranges::min(nums) * 2;\n  }\n};\n", "1006": "class Solution {\n public:\n  int clumsy(int n) {\n    if (n == 1)\n      return 1;\n    if (n == 2)\n      return 2;\n    if (n == 3)\n      return 6;\n    if (n == 4)\n      return 7;\n    if (n % 4 == 1)\n      return n + 2;\n    if (n % 4 == 2)\n      return n + 2;\n    if (n % 4 == 3)\n      return n - 1;\n    return n + 1;\n  }\n};\n", "1007": "class Solution {\n public:\n  int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {\n    const int n = tops.size();\n    vector<int> countTops(7);\n    vector<int> countBottoms(7);\n    vector<int> countBoth(7);\n\n    for (int i = 0; i < n; ++i) {\n      ++countTops[tops[i]];\n      ++countBottoms[bottoms[i]];\n      if (tops[i] == bottoms[i])\n        ++countBoth[tops[i]];\n    }\n\n    for (int i = 1; i <= 6; ++i)\n      if (countTops[i] + countBottoms[i] - countBoth[i] == n)\n        return n - max(countTops[i], countBottoms[i]);\n\n    return -1;\n  }\n};\n", "1008": "class Solution {\n public:\n  TreeNode* bstFromPreorder(vector<int>& preorder) {\n    TreeNode* root = new TreeNode(preorder[0]);\n    stack<TreeNode*> stack{{root}};\n\n    for (int i = 1; i < preorder.size(); ++i) {\n      TreeNode* parent = stack.top();\n      TreeNode* child = new TreeNode(preorder[i]);\n      // Adjust the parent.\n      while (!stack.empty() && stack.top()->val < child->val)\n        parent = stack.top(), stack.pop();\n      // Create parent-child link according to BST property.\n      if (parent->val > child->val)\n        parent->left = child;\n      else\n        parent->right = child;\n      stack.push(child);\n    }\n\n    return root;\n  }\n};\n", "1009": "class Solution {\n public:\n  int bitwiseComplement(int n) {\n    int mask = 1;\n    while (mask < n)\n      mask = (mask << 1) + 1;\n    return mask ^ n;\n  }\n};\n", "101": "class Solution {\n public:\n  bool isSymmetric(TreeNode* root) {\n    return isSymmetric(root, root);\n  }\n\n private:\n  bool isSymmetric(TreeNode* p, TreeNode* q) {\n    if (!p || !q)\n      return p == q;\n\n    return p->val == q->val &&                //\n           isSymmetric(p->left, q->right) &&  //\n           isSymmetric(p->right, q->left);\n  }\n};\n", "1010": "class Solution {\n public:\n  int numPairsDivisibleBy60(vector<int>& time) {\n    int ans = 0;\n    vector<int> count(60);\n\n    for (int t : time) {\n      t %= 60;\n      ans += count[(60 - t) % 60];\n      ++count[t];\n    }\n\n    return ans;\n  }\n};\n", "1011": "class Solution {\n public:\n  int shipWithinDays(vector<int>& weights, int days) {\n    int l = ranges::max(weights);\n    int r = accumulate(weights.begin(), weights.end(), 0);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (shipDays(weights, m) <= days)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int shipDays(const vector<int>& weights, int shipCapacity) {\n    int days = 1;\n    int capacity = 0;\n    for (const int weight : weights)\n      if (capacity + weight > shipCapacity) {\n        ++days;\n        capacity = weight;\n      } else {\n        capacity += weight;\n      }\n    return days;\n  };\n};\n", "1012": "class Solution {\n public:\n  int numDupDigitsAtMostN(int n) {\n    return n - countSpecialNumbers(n);\n  }\n\n private:\n  // Same as 2376. Count Special Integers\n  int countSpecialNumbers(int n) {\n    const int digitSize = log10(n) + 1;\n    vector<vector<vector<int>>> mem(\n        digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));\n    return count(to_string(n), 0, 0, true, mem) - 1;  // - 0;\n  }\n\n private:\n  // Returns the number of special integers, considering the i-th digit, where\n  // `used` is the bitmask of the used digits, and `tight` indicates if the\n  // current digit is tightly bound.\n  int count(const string& s, int i, int used, bool tight,\n            vector<vector<vector<int>>>& mem) {\n    if (i == s.length())\n      return 1;\n    if (mem[i][used][tight] != -1)\n      return mem[i][used][tight];\n\n    int res = 0;\n    const int maxDigit = tight ? s[i] - '0' : 9;\n\n    for (int d = 0; d <= maxDigit; ++d) {\n      // `d` is used.\n      if (used >> d & 1)\n        continue;\n      // Use `d` now.\n      const bool nextTight = tight && (d == maxDigit);\n      if (used == 0 && d == 0)  // Don't count leading 0s as used.\n        res += count(s, i + 1, used, nextTight, mem);\n      else\n        res += count(s, i + 1, used | 1 << d, nextTight, mem);\n    }\n\n    return mem[i][used][tight] = res;\n  }\n};\n", "1013": "class Solution {\n public:\n  bool canThreePartsEqualSum(vector<int>& arr) {\n    const int sum = accumulate(arr.begin(), arr.end(), 0);\n    if (sum % 3 != 0)\n      return false;\n\n    const int average = sum / 3;\n    int partCount = 0;\n    int partSum = 0;\n\n    for (const int a : arr) {\n      partSum += a;\n      if (partSum == average) {\n        ++partCount;\n        partSum = 0;\n      }\n    }\n\n    // edge case: arr = [0, 0, 0, 0] -> partCount = 4.\n    return partCount >= 3;\n  }\n};\n", "1014": "class Solution {\n public:\n  int maxScoreSightseeingPair(vector<int>& values) {\n    int ans = 0;\n    int bestPrev = 0;\n\n    for (const int value : values) {\n      ans = max(ans, value + bestPrev);\n      bestPrev = max(bestPrev, value) - 1;\n    }\n\n    return ans;\n  }\n};\n", "1015": "class Solution {\n public:\n  int smallestRepunitDivByK(int k) {\n    if (k % 10 != 1 && k % 10 != 3 && k % 10 != 7 && k % 10 != 9)\n      return -1;\n\n    unordered_set<int> seen;\n    int n = 0;\n\n    for (int length = 1; length <= k; ++length) {\n      n = (n * 10 + 1) % k;\n      if (n == 0)\n        return length;\n      if (seen.contains(n))\n        return -1;\n      seen.insert(n);\n    }\n\n    return -1;\n  }\n};\n", "1016": "class Solution {\n public:\n  bool queryString(string s, int n) {\n    if (n > 1511)\n      return false;\n\n    for (int i = n; i > n / 2; --i) {\n      string binary = bitset<32>(i).to_string();\n      binary = binary.substr(binary.find(\"1\"));\n      if (s.find(binary) == string::npos)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "1017": "class Solution {\n public:\n  string baseNeg2(int n) {\n    string ans;\n\n    while (n != 0) {\n      ans += to_string(n % 2);\n      n = -(n >> 1);\n    }\n\n    return ans.empty() ? \"0\" : string{ans.rbegin(), ans.rend()};\n  }\n};\n", "1018": "class Solution {\n public:\n  vector<bool> prefixesDivBy5(vector<int>& nums) {\n    vector<bool> ans;\n    int curr = 0;\n\n    for (const int num : nums) {\n      curr = (curr * 2 + num) % 5;\n      ans.push_back(curr % 5 == 0);\n    }\n\n    return ans;\n  }\n};\n", "1019": "class Solution {\n public:\n  vector<int> nextLargerNodes(ListNode* head) {\n    vector<int> ans;\n    stack<int> stack;\n\n    for (; head; head = head->next) {\n      while (!stack.empty() && head->val > ans[stack.top()]) {\n        int index = stack.top();\n        stack.pop();\n        ans[index] = head->val;\n      }\n      stack.push(ans.size());\n      ans.push_back(head->val);\n    }\n\n    for (; !stack.empty(); stack.pop())\n      ans[stack.top()] = 0;\n\n    return ans;\n  }\n};\n", "102": "class Solution {\n public:\n  vector<vector<int>> levelOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(currLevel);\n    }\n\n    return ans;\n  }\n};\n", "1020": "class Solution {\n public:\n  int numEnclaves(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    // Remove the lands connected to the edge.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i * j == 0 || i == m - 1 || j == n - 1)\n          if (grid[i][j] == 1)\n            dfs(grid, i, j);\n\n    return accumulate(grid.begin(), grid.end(), 0,\n                      [](int acc, const vector<int>& row) {\n      return acc + ranges::count(row, 1);\n    });\n  }\n\n private:\n  void dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] == 0)\n      return;\n    grid[i][j] = 0;\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n  };\n};\n", "1021": "class Solution {\n public:\n  string removeOuterParentheses(string s) {\n    string ans;\n    int opened = 0;\n\n    for (const char c : s)\n      if (c == '(') {\n        if (++opened > 1)\n          ans += c;\n      } else if (--opened > 0) {  // c == ')'\n        ans += c;\n      }\n\n    return ans;\n  }\n};\n", "1022": "class Solution {\n public:\n  int sumRootToLeaf(TreeNode* root) {\n    int ans = 0;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int val, int& ans) {\n    if (root == nullptr)\n      return;\n    val = val * 2 + root->val;\n    if (root->left == nullptr && root->right == nullptr)\n      ans += val;\n    dfs(root->left, val, ans);\n    dfs(root->right, val, ans);\n  }\n};\n", "1023": "class Solution {\n public:\n  vector<bool> camelMatch(vector<string>& queries, string pattern) {\n    vector<bool> ans;\n    for (const string& query : queries)\n      ans.push_back(isMatch(query, pattern));\n    return ans;\n  }\n\n private:\n  bool isMatch(const string& query, const string& pattern) {\n    int j = 0;\n    for (const char c : query)\n      if (j < pattern.length() && c == pattern[j])\n        ++j;\n      else if (isupper(c))\n        return false;\n    return j == pattern.length();\n  }\n};\n", "1024": "class Solution {\n public:\n  int videoStitching(vector<vector<int>>& clips, int time) {\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    ranges::sort(clips);\n\n    int i = 0;\n    while (farthest < time) {\n      while (i < clips.size() && clips[i][0] <= end)\n        farthest = max(farthest, clips[i++][1]);\n      if (end == farthest)\n        return -1;\n      ++ans;\n      end = farthest;\n    }\n\n    return ans;\n  }\n};\n", "1025": "class Solution {\n public:\n  bool divisorGame(int n) {\n    return n % 2 == 0;\n  }\n};\n", "1026": "class Solution {\n public:\n  int maxAncestorDiff(TreeNode* root) {\n    return maxAncestorDiff(root, root->val, root->val);\n  }\n\n private:\n  // Returns |the maximum - the minimum| of the tree.\n  int maxAncestorDiff(TreeNode* root, int mn, int mx) {\n    if (root == nullptr)\n      return 0;\n    mn = min(mn, root->val);\n    mx = max(mx, root->val);\n    const int l = maxAncestorDiff(root->left, mn, mx);\n    const int r = maxAncestorDiff(root->right, mn, mx);\n    return max({mx - mn, l, r});\n  }\n};\n", "1027": "class Solution {\n public:\n  int longestArithSeqLength(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][k] := the length of the longest arithmetic subsequence of\n    // nums[0..i] with k = diff + 500\n    vector<vector<int>> dp(n, vector<int>(1001));\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const int k = nums[i] - nums[j] + 500;\n        dp[i][k] = max(2, dp[j][k] + 1);\n        ans = max(ans, dp[i][k]);\n      }\n\n    return ans;\n  }\n};\n", "1028": "class Solution {\n public:\n  TreeNode* recoverFromPreorder(string traversal) {\n    int i = 0;\n    return recoverFromPreorder(traversal, 0, i);\n  }\n\n private:\n  TreeNode* recoverFromPreorder(const string& traversal, int depth, int& i) {\n    int nDashes = 0;\n    while (i + nDashes < traversal.length() && traversal[i + nDashes] == '-')\n      ++nDashes;\n    if (nDashes != depth)\n      return nullptr;\n\n    i += depth;\n    const int start = i;\n    while (i < traversal.length() && isdigit(traversal[i]))\n      ++i;\n\n    return new TreeNode(stoi(traversal.substr(start, i - start)),\n                        recoverFromPreorder(traversal, depth + 1, i),\n                        recoverFromPreorder(traversal, depth + 1, i));\n  }\n};\n", "1029": "class Solution {\n public:\n  int twoCitySchedCost(vector<vector<int>>& costs) {\n    const int n = costs.size() / 2;\n    int ans = 0;\n\n    // How much money can we save if we fly a person to A instead of B?\n    // To save money, we should\n    //   1. Fly the person with the maximum saving to A.\n    //   2. Fly the person with the minimum saving to B.\n\n    // Sort `costs` in ascending order by the money saved if we fly a person to\n    // B instead of A.\n    ranges::sort(costs, ranges::less{},\n                 [](const vector<int>& cost) { return cost[0] - cost[1]; });\n\n    for (int i = 0; i < n; ++i)\n      ans += costs[i][0] + costs[i + n][1];\n\n    return ans;\n  }\n};\n", "103": "class Solution {\n public:\n  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<TreeNode*> q{{root}};\n    bool isLeftToRight = true;\n\n    while (!q.empty()) {\n      const int size = q.size();\n      vector<int> currLevel(size);\n      for (int i = 0; i < size; ++i) {\n        TreeNode* node = q.front();\n        q.pop();\n        const int index = isLeftToRight ? i : size - i - 1;\n        currLevel[index] = node->val;\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(currLevel);\n      isLeftToRight = !isLeftToRight;\n    }\n\n    return ans;\n  }\n};\n", "1030": "class Solution {\n public:\n  vector<vector<int>> allCellsDistOrder(int rows, int cols, int rCenter,\n                                        int cCenter) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> ans;\n    vector<vector<int>> seen(rows, vector<int>(cols));\n    queue<pair<int, int>> q{{{rCenter, cCenter}}};\n    seen[rCenter][cCenter] = true;\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      ans.push_back({i, j});\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == rows || y < 0 || y == cols)\n          continue;\n        if (seen[x][y])\n          continue;\n        seen[x][y] = true;\n        q.emplace(x, y);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1031": "class Solution {\n public:\n  int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\n    return max(helper(nums, firstLen, secondLen),\n               helper(nums, secondLen, firstLen));\n  }\n\n private:\n  int helper(vector<int>& nums, int l, int r) {\n    const int n = nums.size();\n    vector<int> left(n);\n    int sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n      sum += nums[i];\n      if (i >= l)\n        sum -= nums[i - l];\n      if (i >= l - 1)\n        left[i] = i > 0 ? max(left[i - 1], sum) : sum;\n    }\n\n    vector<int> right(n);\n    sum = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n      sum += nums[i];\n      if (i <= n - r - 1)\n        sum -= nums[i + r];\n      if (i <= n - r)\n        right[i] = i < n - 1 ? max(right[i + 1], sum) : sum;\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n - 1; ++i)\n      ans = max(ans, left[i] + right[i + 1]);\n\n    return ans;\n  }\n};\n", "1032": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass StreamChecker {\n public:\n  StreamChecker(vector<string>& words) {\n    for (const string& word : words)\n      insert(word);\n  }\n\n  bool query(char letter) {\n    letters += letter;\n    shared_ptr<TrieNode> node = root;\n\n    for (int i = letters.length() - 1; i >= 0; --i) {\n      const int index = letters[i] - 'a';\n      if (node->children[index] == nullptr)\n        return false;\n      node = node->children[index];\n      if (node->isWord)\n        return true;\n    }\n\n    return false;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n  string letters;\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        node->children[index] = make_shared<TrieNode>();\n      node = node->children[index];\n    }\n    node->isWord = true;\n  }\n};\n", "1033": "class Solution {\n public:\n  vector<int> numMovesStones(int a, int b, int c) {\n    vector<int> nums = {a, b, c};\n\n    ranges::sort(nums);\n\n    if (nums[2] - nums[0] == 2)\n      return {0, 0};\n    return {min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 ? 1 : 2,\n            nums[2] - nums[0] - 2};\n  }\n};\n", "1034": "class Solution {\n public:\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,\n                                  int color) {\n    dfs(grid, r0, c0, grid[r0][c0]);\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] < 0)\n          grid[i][j] = color;\n\n    return grid;\n  }\n\n private:\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] != startColor)\n      return;\n\n    grid[i][j] = -startColor;\n    dfs(grid, i + 1, j, startColor);\n    dfs(grid, i - 1, j, startColor);\n    dfs(grid, i, j + 1, startColor);\n    dfs(grid, i, j - 1, startColor);\n\n    // If this cell is already on the boarder, it must be painted later.\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\n      return;\n\n    if (abs(grid[i + 1][j]) == startColor &&  //\n        abs(grid[i - 1][j]) == startColor &&  //\n        abs(grid[i][j + 1]) == startColor &&  //\n        abs(grid[i][j - 1]) == startColor)\n      grid[i][j] = startColor;\n  }\n};\n", "1035": "class Solution {\n public:\n  int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n    const int m = nums1.size();\n    const int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        dp[i][j] = nums1[i - 1] == nums2[j - 1]\n                       ? dp[i - 1][j - 1] + 1\n                       : max(dp[i - 1][j], dp[i][j - 1]);\n\n    return dp[m][n];\n  }\n};\n", "1036": "class Solution {\n public:\n  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source,\n                        vector<int>& target) {\n    unordered_set<long> blockedSet;\n    for (const vector<int>& b : blocked)\n      blockedSet.insert(hash(b[0], b[1]));\n\n    return dfs(blockedSet, source[0], source[1], hash(target[0], target[1]),\n               {}) &&\n           dfs(blockedSet, target[0], target[1], hash(source[0], source[1]),\n               {});\n  }\n\n private:\n  bool dfs(unordered_set<long>& blockedSet, int i, int j, long target,\n           unordered_set<long>&& seen) {\n    if (i < 0 || i >= 1'000'000 || j < 0 || j >= 1'000'000 ||\n        blockedSet.contains(hash(i, j)) || seen.contains(hash(i, j)))\n      return false;\n\n    seen.insert(hash(i, j));\n    if (seen.size() > (1 + 199) * 199 / 2 || hash(i, j) == target)\n      return true;\n    return dfs(blockedSet, i + 1, j, target, std::move(seen)) ||\n           dfs(blockedSet, i - 1, j, target, std::move(seen)) ||\n           dfs(blockedSet, i, j + 1, target, std::move(seen)) ||\n           dfs(blockedSet, i, j - 1, target, std::move(seen));\n  }\n\n  long hash(int i, int j) {\n    return (static_cast<long>(i) << 16) + j;\n  }\n};\n", "1037": "class Solution {\n public:\n  bool isBoomerang(vector<vector<int>>& points) {\n    return (points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=\n           (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]);\n  }\n};\n", "1038": "class Solution {\n public:\n  TreeNode* bstToGst(TreeNode* root) {\n    int prefix = 0;\n\n    function<void(TreeNode*)> reversedInorder = [&](TreeNode* root) {\n      if (root == nullptr)\n        return;\n\n      reversedInorder(root->right);\n\n      root->val += prefix;\n      prefix = root->val;\n\n      reversedInorder(root->left);\n    };\n\n    reversedInorder(root);\n    return root;\n  }\n};\n", "1039": "class Solution {\n public:\n  int minScoreTriangulation(vector<int>& values) {\n    const int n = values.size();\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int j = 2; j < n; ++j)\n      for (int i = j - 2; i >= 0; --i) {\n        dp[i][j] = INT_MAX;\n        for (int k = i + 1; k < j; ++k)\n          dp[i][j] =\n              min(dp[i][j],\n                  dp[i][k] + values[i] * values[k] * values[j] + dp[k][j]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "104": "class Solution {\n public:\n  int maxDepth(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n  }\n};\n", "1040": "class Solution {\n public:\n  vector<int> numMovesStonesII(vector<int>& stones) {\n    const int n = stones.size();\n    int minMoves = n;\n\n    ranges::sort(stones);\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      while (stones[r] - stones[l] + 1 > n)\n        ++l;\n      int alreadyStored = r - l + 1;\n      if (alreadyStored == n - 1 && stones[r] - stones[l] + 1 == n - 1)\n        minMoves = min(minMoves, 2);\n      else\n        minMoves = min(minMoves, n - alreadyStored);\n    }\n\n    return {minMoves, max(stones[n - 1] - stones[1] - n + 2,\n                          stones[n - 2] - stones[0] - n + 2)};\n  }\n};\n", "1041": "class Solution {\n public:\n  bool isRobotBounded(string instructions) {\n    int x = 0;\n    int y = 0;\n    int d = 0;\n    vector<vector<int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (char instruction : instructions) {\n      if (instruction == 'G') {\n        x += directions[d][0];\n        y += directions[d][1];\n      } else if (instruction == 'L')\n        d = (d + 3) % 4;\n      else\n        d = (d + 1) % 4;\n    }\n\n    return x == 0 && y == 0 || d > 0;\n  }\n};\n", "1042": "class Solution {\n public:\n  vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {\n    vector<int> ans(n);  // ans[i] := 1, 2, 3, or 4\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& path : paths) {\n      const int u = path[0] - 1;\n      const int v = path[1] - 1;\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int u = 0; u < n; ++u) {\n      int used = 0;\n      for (const int v : graph[u])\n        used |= 1 << ans[v];\n      ans[u] = getFirstUnusedType(used);\n    }\n\n    return ans;\n  }\n\n private:\n  int getFirstUnusedType(int used) {\n    for (int type = 1; type <= 4; ++type)\n      if ((used >> type & 1) == 0)\n        return type;\n    throw;\n  }\n};\n", "1043": "class Solution {\n public:\n  int maxSumAfterPartitioning(vector<int>& arr, int k) {\n    const int n = arr.size();\n    vector<int> dp(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n      int mx = INT_MIN;\n      for (int j = 1; j <= min(i, k); ++j) {\n        mx = max(mx, arr[i - j]);\n        dp[i] = max(dp[i], dp[i - j] + mx * j);\n      }\n    }\n\n    return dp[n];\n  }\n};\n", "1044": "class Solution {\n public:\n  string longestDupSubstring(string s) {\n    const int n = s.length();\n    vector<int> pows(n, 1);\n    int bestStart = -1;\n    int l = 1;\n    int r = n;\n\n    for (int i = 1; i < n; ++i)\n      pows[i] = pows[i - 1] * kBase % kHash;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const int start = getStart(s, m, pows);\n      if (start == -1) {\n        r = m;\n      } else {\n        bestStart = start;\n        l = m + 1;\n      }\n    }\n\n    if (bestStart == -1)\n      return \"\";\n    if (getStart(s, l, pows) == -1)\n      return s.substr(bestStart, l - 1);\n    return s.substr(bestStart, l);\n  }\n\n private:\n  static constexpr long kBase = 26;\n  static constexpr int kHash = 1'000'000'007;\n\n  static constexpr int val(char c) {\n    return c - 'a';\n  }\n\n  // k := the length of the substring to be hashed\n  int getStart(const string& s, int k, const vector<int>& pows) {\n    unordered_map<int, vector<int>> hashToStarts;\n    long h = 0;\n\n    // Compute the hash value of s[:k].\n    for (int i = 0; i < k; ++i)\n      h = (h * kBase % kHash + val(s[i])) % kHash;\n    hashToStarts[h].push_back(0);\n\n    // Compute the rolling hash by Rabin Karp.\n    for (int i = k; i < s.length(); ++i) {\n      const int startIndex = i - k + 1;\n      h = ((h - static_cast<long>(pows[k - 1]) * val(s[i - k])) % kHash +\n           kHash) %\n          kHash;\n      h = (h * kBase + val(s[i])) % kHash;\n      if (const auto it = hashToStarts.find(h); it != hashToStarts.cend()) {\n        const string currSub = s.substr(startIndex, k);\n        for (const int start : it->second)\n          if (s.substr(start, k) == currSub)\n            return startIndex;\n      }\n      hashToStarts[h].push_back(startIndex);\n    }\n\n    return -1;\n  }\n};\n", "1046": "class Solution {\n public:\n  int lastStoneWeight(vector<int>& stones) {\n    priority_queue<int> pq{stones.begin(), stones.end()};\n\n    while (pq.size() >= 2) {\n      const int n1 = pq.top();\n      pq.pop();\n      const int n2 = pq.top();\n      pq.pop();\n      if (n1 != n2)\n        pq.push(n1 - n2);\n    }\n\n    return pq.empty() ? 0 : pq.top();\n  }\n};\n", "1047": "class Solution {\n public:\n  string removeDuplicates(const string& S) {\n    string ans;\n\n    for (const char c : S)\n      if (!ans.empty() && ans.back() == c)\n        ans.pop_back();\n      else\n        ans.push_back(c);\n\n    return ans;\n  }\n};\n", "1048": "class Solution {\n public:\n  int longestStrChain(vector<string>& words) {\n    int ans = 0;\n    // dp[s] := the longest string chain, where s is the last word\n    unordered_map<string, int> dp;\n\n    ranges::sort(words, ranges::less{},\n                 [](const string& word) { return word.length(); });\n\n    for (const string& word : words) {\n      for (int i = 0; i < word.length(); ++i) {\n        const string pred = word.substr(0, i) + word.substr(i + 1);\n        dp[word] = max(dp[word], (dp.contains(pred) ? dp[pred] : 0) + 1);\n      }\n      ans = max(ans, dp[word]);\n    }\n\n    return ans;\n  }\n};\n", "1049": "class Solution {\n public:\n  int lastStoneWeightII(vector<int>& stones) {\n    const int sum = accumulate(stones.begin(), stones.end(), 0);\n    vector<bool> dp(sum + 1);\n    dp[0] = true;\n    int s = 0;\n\n    for (int stone : stones)\n      for (int w = sum / 2; w > 0; --w) {\n        if (w >= stone)\n          dp[w] = dp[w] || dp[w - stone];\n        if (dp[w])\n          s = max(s, w);\n      }\n\n    return sum - 2 * s;\n  }\n};\n", "105": "class Solution {\n public:\n  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    unordered_map<int, int> inToIndex;\n\n    for (int i = 0; i < inorder.size(); ++i)\n      inToIndex[inorder[i]] = i;\n\n    return build(preorder, 0, preorder.size() - 1, inorder, 0,\n                 inorder.size() - 1, inToIndex);\n  }\n\n private:\n  TreeNode* build(const vector<int>& preorder, int preStart, int preEnd,\n                  const vector<int>& inorder, int inStart, int inEnd,\n                  const unordered_map<int, int>& inToIndex) {\n    if (preStart > preEnd)\n      return nullptr;\n\n    const int rootVal = preorder[preStart];\n    const int rootInIndex = inToIndex.at(rootVal);\n    const int leftSize = rootInIndex - inStart;\n\n    TreeNode* root = new TreeNode(rootVal);\n    root->left = build(preorder, preStart + 1, preStart + leftSize, inorder,\n                       inStart, rootInIndex - 1, inToIndex);\n    root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder,\n                        rootInIndex + 1, inEnd, inToIndex);\n    return root;\n  }\n};\n", "1051": "class Solution {\n public:\n  int heightChecker(vector<int>& heights) {\n    int ans = 0;\n    int currentHeight = 1;\n    vector<int> count(101);\n\n    for (int height : heights)\n      ++count[height];\n\n    for (int height : heights) {\n      while (count[currentHeight] == 0)\n        ++currentHeight;\n      if (height != currentHeight)\n        ++ans;\n      --count[currentHeight];\n    }\n\n    return ans;\n  }\n};\n", "1052": "class Solution {\n public:\n  int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\n    int satisfied = 0;\n    int madeSatisfied = 0;\n    int windowSatisfied = 0;\n\n    for (int i = 0; i < customers.size(); ++i) {\n      if (grumpy[i] == 0)\n        satisfied += customers[i];\n      else\n        windowSatisfied += customers[i];\n      if (i >= X && grumpy[i - X] == 1)\n        windowSatisfied -= customers[i - X];\n      madeSatisfied = max(madeSatisfied, windowSatisfied);\n    }\n\n    return satisfied + madeSatisfied;\n  }\n};\n", "1053": "class Solution {\n public:\n  vector<int> prevPermOpt1(vector<int>& arr) {\n    const int n = arr.size();\n    int l = n - 2;\n    int r = n - 1;\n\n    while (l >= 0 && arr[l] <= arr[l + 1])\n      l--;\n    if (l < 0)\n      return arr;\n    while (arr[r] >= arr[l] || arr[r] == arr[r - 1])\n      r--;\n    swap(arr[l], arr[r]);\n\n    return arr;\n  }\n};\n", "1054": "class Solution {\n public:\n  vector<int> rearrangeBarcodes(vector<int>& barcodes) {\n    vector<int> ans(barcodes.size());\n    vector<int> count(10001);\n    int i = 0;  // ans' index\n\n    for (const int b : barcodes)\n      ++count[b];\n\n    const auto maxIt = ranges::max_element(count);\n    const int maxNum = maxIt - count.begin();\n\n    auto fillAns = [&](int num) {\n      while (count[num]-- > 0) {\n        ans[i] = num;\n        i = i + 2 < barcodes.size() ? i + 2 : 1;\n      }\n    };\n\n    fillAns(maxNum);\n    for (int num = 1; num < 10001; ++num)\n      fillAns(num);\n\n    return ans;\n  }\n};\n", "1055": "class Solution {\n public:\n  int shortestWay(string source, string target) {\n    const int m = source.length();\n    const int n = target.length();\n    // dp[i][c] := the earliest index >= i s.t. source[index] = c\n    // dp[i][c] := -1 if c isn't in the source\n    vector<vector<int>> dp(m, vector<int>(26, -1));\n\n    dp[m - 1][source[m - 1] - 'a'] = m - 1;\n    for (int i = m - 2; i >= 0; --i) {\n      dp[i] = dp[i + 1];\n      dp[i][source[i] - 'a'] = i;\n    }\n\n    int ans = 0;\n    int i = 0;  // source's index\n\n    for (const char c : target) {\n      if (dp[0][c - 'a'] == -1)\n        return -1;\n      // If there are no c's left in source that occur more than i times but\n      // there are c's from earlier in the subsequence, add 1 to subsequence\n      // count and reset source's index to 0.\n      if (dp[i][c - 'a'] == -1) {\n        ++ans;\n        i = 0;\n      }\n      // Continue taking letters from the subsequence.\n      i = dp[i][c - 'a'] + 1;\n      if (i == m) {\n        ++ans;\n        i = 0;\n      }\n    }\n\n    return ans + (i == 0 ? 0 : 1);\n  }\n};\n", "1056": "class Solution {\n public:\n  bool confusingNumber(int n) {\n    const string s = to_string(n);\n    const vector<char> rotated{'0', '1', 'x', 'x', 'x',\n                               'x', '9', 'x', '8', '6'};\n    string rotatedNum;\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      if (rotated[s[i] - '0'] == 'x')\n        return false;\n      rotatedNum += rotated[s[i] - '0'];\n    }\n\n    return rotatedNum != s;\n  }\n};\n", "1057": "class Solution {\n public:\n  vector<int> assignBikes(vector<vector<int>>& workers,\n                          vector<vector<int>>& bikes) {\n    const int n = workers.size();\n    const int m = bikes.size();\n    vector<int> ans(n, -1);\n    vector<bool> usedBikes(m);\n    // buckets[k] := (i, j), where k = dist(workers[i], bikes[j])\n    vector<vector<pair<int, int>>> buckets(2001);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j)\n        buckets[dist(workers[i], bikes[j])].emplace_back(i, j);\n\n    for (int k = 0; k < 2001; ++k)\n      for (const auto& [i, j] : buckets[k])\n        if (ans[i] == -1 && !usedBikes[j]) {\n          ans[i] = j;\n          usedBikes[j] = true;\n        }\n\n    return ans;\n  }\n\n private:\n  int dist(const vector<int>& p1, const vector<int>& p2) {\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);\n  }\n};\n", "1058": "class Solution {\n public:\n  string minimizeError(vector<string>& prices, int target) {\n    // A[i] := (costCeil - costFloor, costCeil, costFloor)\n    // The lower the costCeil - costFloor is, the cheaper to ceil it.\n    vector<tuple<double, double, double>> A;\n    int sumFloored = 0;\n    int sumCeiled = 0;\n\n    for (const string& p : prices) {\n      const double price = stod(p);\n      const int floored = floor(price);\n      const int ceiled = ceil(price);\n      sumFloored += floored;\n      sumCeiled += ceiled;\n      const double costFloor = price - static_cast<double>(floored);\n      const double costCeil = static_cast<double>(ceiled) - price;\n      A.emplace_back(costCeil - costFloor, costCeil, costFloor);\n    }\n\n    if (sumFloored > target || sumCeiled < target)\n      return \"-1\";\n\n    ranges::sort(A);\n\n    double sumError = 0.0;\n    const int nCeiled = target - sumFloored;\n    for (int i = 0; i < nCeiled; ++i)\n      sumError += get<1>(A[i]);\n    for (int i = nCeiled; i < A.size(); ++i)\n      sumError += get<2>(A[i]);\n\n    stringstream ss;\n    ss << std::fixed << std::setprecision(3) << sumError;\n    return ss.str();\n  }\n};\n", "1059": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  bool leadsToDestination(int n, vector<vector<int>>& edges, int source,\n                          int destination) {\n    vector<vector<int>> graph(n);\n    vector<State> states(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n    }\n\n    return acyclic(graph, source, destination, states);\n  }\n\n private:\n  bool acyclic(const vector<vector<int>>& graph, int u, int dest,\n               vector<State>& states) {\n    if (graph[u].empty())\n      return u == dest;\n    if (states[u] == State::kVisiting)\n      return false;\n    if (states[u] == State::kVisited)\n      return true;\n\n    states[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (!acyclic(graph, v, dest, states))\n        return false;\n    states[u] = State::kVisited;\n\n    return true;\n  }\n};\n", "106": "class Solution {\n public:\n  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n    unordered_map<int, int> inToIndex;\n\n    for (int i = 0; i < inorder.size(); ++i)\n      inToIndex[inorder[i]] = i;\n\n    return build(inorder, 0, inorder.size() - 1, postorder, 0,\n                 postorder.size() - 1, inToIndex);\n  }\n\n private:\n  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,\n                  const vector<int>& postorder, int postStart, int postEnd,\n                  const unordered_map<int, int>& inToIndex) {\n    if (inStart > inEnd)\n      return nullptr;\n\n    const int rootVal = postorder[postEnd];\n    const int rootInIndex = inToIndex.at(rootVal);\n    const int leftSize = rootInIndex - inStart;\n\n    TreeNode* root = new TreeNode(rootVal);\n    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,\n                       postStart + leftSize - 1, inToIndex);\n    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,\n                        postStart + leftSize, postEnd - 1, inToIndex);\n    return root;\n  }\n};\n", "1060": "class Solution {\n public:\n  int missingElement(vector<int>& nums, int k) {\n    int l = 0;\n    int r = nums.size();\n\n    // the number of missing numbers in [nums[0], nums[i]]\n    auto nMissing = [&](int i) { return nums[i] - nums[0] - i; };\n\n    // Find the first index l s.t. nMissing(l) >= k\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nMissing(m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return nums[l - 1] + (k - nMissing(l - 1));\n  }\n};\n", "1061": "class UnionFind {\n public:\n  UnionFind(int n) : id(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void union_(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i > j)\n      id[i] = j;\n    else\n      id[j] = i;\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n};\n\nclass Solution {\n public:\n  string smallestEquivalentString(string s1, string s2, string baseStr) {\n    string ans;\n    UnionFind uf(26);\n\n    for (int i = 0; i < s1.length(); ++i)\n      uf.union_(s1[i] - 'a', s2[i] - 'a');\n\n    for (const char c : baseStr)\n      ans += 'a' + uf.find(c - 'a');\n\n    return ans;\n  }\n};\n", "1062": "class Solution {\n public:\n  int longestRepeatingSubstring(string s) {\n    const int n = s.length();\n    int ans = 0;\n    // dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = i + 1; j <= n; ++j)\n        if (s[i - 1] == s[j - 1]) {\n          dp[i][j] = 1 + dp[i - 1][j - 1];\n          ans = max(ans, dp[i][j]);\n        }\n\n    return ans;\n  }\n};\n", "1063": "class Solution {\n public:\n  int validSubarrays(vector<int>& nums) {\n    // For each `num` in `nums`, each element x in the stack can be the leftmost\n    // element s.t. [x, num] forms a valid subarray, so the size of the stack is\n    // the number of valid subarrays ending in the current number.\n    //\n    // e.g. nums = [1, 3, 2]\n    // num = 1, stack = [1] -> valid subarray is [1]\n    // num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]\n    // num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]\n    int ans = 0;\n    stack<int> stack;\n\n    for (const int num : nums) {\n      while (!stack.empty() && stack.top() > num)\n        stack.pop();\n      stack.push(num);\n      ans += stack.size();\n    }\n\n    return ans;\n  }\n};\n", "1064": "class Solution {\n public:\n  int fixedPoint(vector<int>& arr) {\n    int l = 0;\n    int r = arr.size() - 1;\n\n    // Since arr[i] is strictly increasing, arr[i] - i will also be increasing.\n    // Therefore, binary search `arr` for the first arr[i] - i = 0.\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (arr[m] - m >= 0)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return arr[l] == l ? l : -1;\n  }\n};\n", "1065": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  vector<vector<int>> indexPairs(string text, vector<string>& words) {\n    vector<vector<int>> ans;\n    shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n    for (const string& word : words) {\n      shared_ptr<TrieNode> node = root;\n      for (const char c : word) {\n        const int i = c - 'a';\n        if (node->children[i] == nullptr)\n          node->children[i] = make_shared<TrieNode>();\n        node = node->children[i];\n      }\n      node->isWord = true;\n    }\n\n    for (int i = 0; i < text.length(); ++i) {\n      shared_ptr<TrieNode> node = root;\n      for (int j = i; j < text.length(); j++) {\n        const int index = text[j] - 'a';\n        if (node->children[index] == nullptr)\n          break;\n        node = node->children[index];\n        if (node->isWord)\n          ans.push_back({i, j});\n      }\n    }\n\n    return ans;\n  }\n};\n", "1066": "class Solution {\n public:\n  int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {\n    vector<int> mem(1 << bikes.size(), INT_MAX);\n    return assignBikes(workers, bikes, 0, 0, mem);\n  }\n\n private:\n  // Returns the minimum Manhattan distances to assign bikes to\n  // workers[workerIndex..n), where `used` is the bitmask of the used bikes.\n  int assignBikes(const vector<vector<int>>& workers,\n                  const vector<vector<int>>& bikes, int workerIndex, int used,\n                  vector<int>& mem) {\n    if (workerIndex == workers.size())\n      return 0;\n    if (mem[used] != INT_MAX)\n      return mem[used];\n\n    for (int bikeIndex = 0; bikeIndex < bikes.size(); ++bikeIndex)\n      if ((used >> bikeIndex & 1) == 0)\n        mem[used] =\n            min(mem[used], dist(workers[workerIndex], bikes[bikeIndex]) +\n                               assignBikes(workers, bikes, workerIndex + 1,\n                                           used | 1 << bikeIndex, mem));\n\n    return mem[used];\n  }\n\n  int dist(const vector<int>& p1, const vector<int>& p2) {\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);\n  }\n};\n", "1067": "class Solution {\n public:\n  int digitsCount(int d, int low, int high) {\n    return countDigit(high, d) - countDigit(low - 1, d);\n  }\n\n private:\n  int countDigit(int n, int d) {\n    int count = 0;\n\n    for (int pow10 = 1; pow10 <= n; pow10 *= 10) {\n      const int divisor = pow10 * 10;\n      const int quotient = n / divisor;\n      const int remainder = n % divisor;\n      if (quotient > 0)\n        count += quotient * pow10;\n      if (d == 0)\n        count -= pow10;\n      if (remainder >= d * pow10)\n        count += min(remainder - d * pow10 + 1, pow10);\n    }\n\n    return count;\n  }\n};\n", "107": "class Solution {\n public:\n  vector<vector<int>> levelOrderBottom(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(currLevel);\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "1071": "class Solution {\n public:\n  string gcdOfStrings(string str1, string str2) {\n    if (str1 + str2 != str2 + str1)\n      return \"\";\n    const int g = gcd(str1.length(), str2.length());\n    return str1.substr(0, g);\n  }\n};\n", "1072": "class Solution {\n public:\n  int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = 0;\n    vector<int> flip(n);\n    unordered_set<int> seen;\n\n    for (int i = 0; i < m; ++i) {\n      if (seen.contains(i))\n        continue;\n      int count = 0;\n      for (int j = 0; j < n; ++j)\n        flip[j] = 1 ^ matrix[i][j];\n      for (int k = 0; k < m; ++k)\n        if (matrix[k] == matrix[i] || matrix[k] == flip) {\n          seen.insert(k);\n          ++count;\n        }\n      ans = max(ans, count);\n    }\n\n    return ans;\n  }\n};\n", "1073": "class Solution {\n public:\n  vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {\n    deque<int> ans;\n    int carry = 0;\n    int i = arr1.size() - 1;\n    int j = arr2.size() - 1;\n\n    while (carry != 0 || i >= 0 || j >= 0) {\n      if (i >= 0)\n        carry += arr1[i--];\n      if (j >= 0)\n        carry += arr2[j--];\n      ans.push_front(carry & 1);\n      carry = -(carry >> 1);\n    }\n\n    while (ans.size() > 1 && ans.front() == 0)\n      ans.pop_front();\n\n    return {ans.begin(), ans.end()};\n  }\n};\n", "1074": "class Solution {\n public:\n  int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = 0;\n\n    // Transfer each row in the matrix to the prefix sum.\n    for (auto& row : matrix)\n      for (int i = 1; i < n; ++i)\n        row[i] += row[i - 1];\n\n    for (int baseCol = 0; baseCol < n; ++baseCol)\n      for (int j = baseCol; j < n; ++j) {\n        unordered_map<int, int> prefixCount{{0, 1}};\n        int sum = 0;\n        for (int i = 0; i < m; ++i) {\n          if (baseCol > 0)\n            sum -= matrix[i][baseCol - 1];\n          sum += matrix[i][j];\n          if (const auto it = prefixCount.find(sum - target);\n              it != prefixCount.cend())\n            ans += it->second;\n          ++prefixCount[sum];\n        }\n      }\n\n    return ans;\n  }\n};\n", "1078": "class Solution {\n public:\n  vector<string> findOcurrences(string text, string first, string second) {\n    vector<string> ans;\n    stringstream ss(text);\n\n    for (string prev2, prev, word; ss >> word;) {\n      if (prev2 == first && prev == second)\n        ans.push_back(word);\n      prev2 = prev;\n      prev = word;\n    }\n\n    return ans;\n  }\n};\n", "1079": "class Solution {\n public:\n  int numTilePossibilities(string tiles) {\n    vector<int> count(26);\n\n    for (const char t : tiles)\n      ++count[t - 'A'];\n\n    return dfs(count);\n  }\n\n private:\n  int dfs(vector<int>& count) {\n    int possibleSequences = 0;\n\n    for (int& c : count) {\n      if (c == 0)\n        continue;\n      // Put c in the current position. We only care about the number of\n      // possible sequences of letters but don't care about the actual\n      // combination.\n      --c;\n      possibleSequences += 1 + dfs(count);\n      ++c;\n    }\n\n    return possibleSequences;\n  }\n};\n", "108": "class Solution {\n public:\n  TreeNode* sortedArrayToBST(vector<int>& nums) {\n    return build(nums, 0, nums.size() - 1);\n  }\n\n private:\n  TreeNode* build(const vector<int>& nums, int l, int r) {\n    if (l > r)\n      return nullptr;\n    const int m = (l + r) / 2;\n    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));\n  }\n};\n", "1080": "class Solution {\n public:\n  TreeNode* sufficientSubset(TreeNode* root, int limit) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->left == nullptr && root->right == nullptr)\n      return root->val < limit ? nullptr : root;\n    root->left = sufficientSubset(root->left, limit - root->val);\n    root->right = sufficientSubset(root->right, limit - root->val);\n    return root->left == nullptr && root->right == nullptr ? nullptr : root;\n  }\n};\n", "1081": "class Solution {\n public:\n  string smallestSubsequence(string text) {\n    string ans;\n    vector<int> count(128);\n    vector<bool> used(128);\n\n    for (const char c : text)\n      ++count[c];\n\n    for (const char c : text) {\n      --count[c];\n      if (used[c])\n        continue;\n      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {\n        used[ans.back()] = false;\n        ans.pop_back();\n      }\n      used[c] = true;\n      ans.push_back(c);\n    }\n\n    return ans;\n  }\n};\n", "1085": "class Solution {\n public:\n  int sumOfDigits(vector<int>& nums) {\n    int mn = ranges::min(nums);\n    int sum = 0;\n\n    while (mn > 0) {\n      sum += mn % 10;\n      mn /= 10;\n    }\n\n    return sum & 1 ^ 1;\n  }\n};\n", "1086": "class Solution {\n public:\n  vector<vector<int>> highFive(vector<vector<int>>& items) {\n    vector<vector<int>> ans;\n    map<int, priority_queue<int, vector<int>, greater<int>>> idToScores;\n\n    for (const vector<int>& item : items) {\n      const int id = item[0];\n      const int score = item[1];\n      auto& scores = idToScores[id];\n      scores.push(score);\n      if (scores.size() > 5)\n        scores.pop();\n    }\n\n    for (auto& [id, scores] : idToScores) {\n      int sum = 0;\n      while (!scores.empty())\n        sum += scores.top(), scores.pop();\n      ans.push_back({id, sum / 5});\n    }\n\n    return ans;\n  }\n};\n", "1087": "class Solution {\n public:\n  vector<string> expand(string s) {\n    vector<string> ans;\n    string path;\n    dfs(s, 0, path, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int i, string& path, vector<string>& ans) {\n    if (i == s.length()) {\n      ans.push_back(path);\n      return;\n    }\n    if (s[i] == '{') {\n      const int nextRightBraceIndex = s.find_first_of('}', i);\n      for (const char c :\n           split(s.substr(i + 1, nextRightBraceIndex - i - 1), ',')) {\n        path.push_back(c);\n        dfs(s, nextRightBraceIndex + 1, path, ans);\n        path.pop_back();\n      }\n    } else {  // s[i] != '{'\n      path.push_back(s[i]);\n      dfs(s, i + 1, path, ans);\n      path.pop_back();\n    }\n  }\n\n  vector<char> split(const string& s, char delimiter) {\n    vector<char> splitted;\n    for (const char c : s)\n      if (c != delimiter)\n        splitted.push_back(c);\n    return splitted;\n  }\n};\n", "1088": "class Solution {\n public:\n  int confusingNumberII(int n) {\n    return dfs(n, 0, 0, 1);\n  }\n\n private:\n  vector<pair<int, int>> digitToRotated{{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};\n\n  int dfs(int n, long num, long rotatedNum, long unit) {\n    int ans = num != rotatedNum;\n    // Add one more digit\n    for (const auto& [digit, rotated] : digitToRotated) {\n      if (digit == 0 && num == 0)\n        continue;\n      const long nextNum = num * 10 + digit;\n      if (nextNum > n)\n        break;\n      ans += dfs(n, nextNum, rotated * unit + rotatedNum, unit * 10);\n    }\n    return ans;\n  }\n};\n", "1089": "class Solution {\n public:\n  void duplicateZeros(vector<int>& arr) {\n    int zeros = ranges::count_if(arr, [](int a) { return a == 0; });\n\n    for (int i = arr.size() - 1, j = arr.size() + zeros - 1; i < j; --i, --j) {\n      if (j < arr.size())\n        arr[j] = arr[i];\n      if (arr[i] == 0)\n        if (--j < arr.size())\n          arr[j] = arr[i];\n    }\n  }\n};\n", "109": "class Solution {\n public:\n  TreeNode* sortedListToBST(ListNode* head) {\n    vector<int> arr;\n\n    // Construct the array.\n    for (ListNode* curr = head; curr; curr = curr->next)\n      arr.push_back(curr->val);\n\n    return helper(arr, 0, arr.size() - 1);\n  }\n\n private:\n  TreeNode* helper(const vector<int>& arr, int l, int r) {\n    if (l > r)\n      return nullptr;\n    const int m = (l + r) / 2;\n    TreeNode* root = new TreeNode(arr[m]);\n    root->left = helper(arr, l, m - 1);\n    root->right = helper(arr, m + 1, r);\n    return root;\n  }\n};\n", "1090": "class Solution {\n public:\n  int largestValsFromLabels(vector<int>& values, vector<int>& labels,\n                            int numWanted, int useLimit) {\n    const int n = values.size();\n    int ans = 0;\n    vector<pair<int, int>> items;\n    unordered_map<int, int> labelsUsed;\n\n    for (int i = 0; i < n; ++i)\n      items.emplace_back(values[i], labels[i]);\n\n    ranges::sort(items, ranges::greater{},\n                 [](const pair<int, int>& item) { return item.first; });\n\n    for (const auto& [value, label] : items)\n      if (labelsUsed[label] < useLimit) {\n        ans += value;\n        ++labelsUsed[label];\n        if (--numWanted == 0)\n          break;\n      }\n\n    return ans;\n  }\n};\n", "1091": "class Solution {\n public:\n  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    if (grid[0][0] == 0 && n == 1)\n      return 1;\n    if (grid[0][0] == 1 || grid.back().back() == 1)\n      return -1;\n\n    constexpr int kDirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                 {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n    queue<pair<int, int>> q{{{0, 0}}};\n    vector<vector<bool>> seen(n, vector<bool>(n));\n    seen[0][0] = true;\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == n || y < 0 || y == n)\n            continue;\n          if (grid[x][y] != 0 || seen[x][y])\n            continue;\n          if (x == n - 1 && y == n - 1)\n            return step + 1;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  }\n};\n", "1092": "class Solution {\n public:\n  string shortestCommonSupersequence(string str1, string str2) {\n    string ans;\n    int i = 0;  // str1's index\n    int j = 0;  // str2's index\n\n    for (const char c : lcs(str1, str2)) {\n      // Append the letters that are not part of the LCS.\n      while (str1[i] != c)\n        ans += str1[i++];\n      while (str2[j] != c)\n        ans += str2[j++];\n      // Append the letter of the LCS and match it with str1 and str2.\n      ans += c;\n      ++i;\n      ++j;\n    }\n\n    // Append the remaining letters.\n    return ans + str1.substr(i) + str2.substr(j);\n  }\n\n private:\n  string lcs(const string& a, const string& b) {\n    const int m = a.length();\n    const int n = b.length();\n    // dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    vector<vector<string>> dp(m + 1, vector<string>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (a[i - 1] == b[j - 1])\n          dp[i][j] = dp[i - 1][j - 1] + a[i - 1];\n        else\n          dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length()\n                         ? dp[i - 1][j]\n                         : dp[i][j - 1];\n\n    return dp[m][n];\n  }\n};\n", "1093": "class Solution {\n public:\n  vector<double> sampleStats(vector<int>& count) {\n    const int n = accumulate(count.begin(), count.end(), 0);\n    const double mode = ranges::max_element(count) - count.begin();\n    return {\n        getMinimum(count),\n        getMaximum(count),\n        getMean(count, n),\n        (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,\n        mode,\n    };\n  }\n\n private:\n  double getMinimum(const vector<int>& count) {\n    for (int i = 0; i < count.size(); ++i)\n      if (count[i])\n        return i;\n    return -1;\n  }\n\n  double getMaximum(const vector<int>& count) {\n    for (int i = count.size() - 1; i >= 0; --i)\n      if (count[i])\n        return i;\n    return -1;\n  }\n\n  double getMean(const vector<int>& count, double n) {\n    double mean = 0;\n    for (long i = 0; i < count.size(); ++i)\n      mean += (i * count[i]) / n;\n    return mean;\n  }\n\n  double getLeftMedian(const vector<int>& count, double n) {\n    int numCount = 0;\n    for (int i = 0; i < count.size(); ++i) {\n      numCount += count[i];\n      if (numCount >= n / 2)\n        return i;\n    }\n    return -1;\n  }\n\n  double getRightMedian(const vector<int>& count, double n) {\n    int numCount = 0;\n    for (int i = count.size() - 1; i >= 0; --i) {\n      numCount += count[i];\n      if (numCount >= n / 2)\n        return i;\n    }\n    return -1;\n  }\n};\n", "1094": "class Solution {\n public:\n  bool carPooling(vector<vector<int>>& trips, int capacity) {\n    int currentPassengers = 0;\n    vector<int> line(1001);\n\n    for (const vector<int>& trip : trips) {\n      const int nPassengers = trip[0];\n      const int start = trip[1];\n      const int end = trip[2];\n      line[start] += nPassengers;\n      line[end] -= nPassengers;\n    }\n\n    for (const int passengerChange : line) {\n      currentPassengers += passengerChange;\n      if (currentPassengers > capacity)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "1095": "/**\n * // This is the MountainArray's API interface.\n * // You should not implement it, or speculate about its implementation\n * class MountainArray {\n *  public:\n *   int get(int index);\n *   int length();\n * };\n */\n\nclass Solution {\n public:\n  int findInMountainArray(int target, MountainArray& mountainArr) {\n    const int n = mountainArr.length();\n    const int peakIndex = peakIndexInMountainArray(mountainArr, 0, n - 1);\n\n    const int leftIndex = searchLeft(mountainArr, target, 0, peakIndex);\n    if (mountainArr.get(leftIndex) == target)\n      return leftIndex;\n\n    const int rightIndex =\n        searchRight(mountainArr, target, peakIndex + 1, n - 1);\n    if (mountainArr.get(rightIndex) == target)\n      return rightIndex;\n\n    return -1;\n  }\n\n private:\n  // 852. Peak Index in a Mountain Array\n  int peakIndexInMountainArray(MountainArray& A, int l, int r) {\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (A.get(m) < A.get(m + 1))\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n\n  int searchLeft(MountainArray& A, int target, int l, int r) {\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (A.get(m) < target)\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n\n  int searchRight(MountainArray& A, int target, int l, int r) {\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (A.get(m) > target)\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n};\n", "1096": "class Solution {\n public:\n  vector<string> braceExpansionII(string expression) {\n    return dfs(expression, 0, expression.length() - 1);\n  }\n\n private:\n  vector<string> dfs(const string& expression, int s, int e) {\n    set<string> ans;\n    vector<vector<string>> groups{{}};\n    int layer = 0;\n    int left = 0;\n\n    for (int i = s; i <= e; ++i)\n      if (expression[i] == '{' && ++layer == 1)\n        left = i + 1;\n      else if (expression[i] == '}' && --layer == 0)\n        merge(groups, dfs(expression, left, i - 1));\n      else if (expression[i] == ',' && layer == 0)\n        groups.push_back({});\n      else if (layer == 0)\n        merge(groups, {string(1, expression[i])});\n\n    for (const vector<string>& group : groups)\n      for (const string& word : group)\n        ans.insert(word);\n\n    return {ans.begin(), ans.end()};\n  }\n\n  void merge(vector<vector<string>>& groups, const vector<string> group) {\n    if (groups.back().empty()) {\n      groups[groups.size() - 1] = group;\n      return;\n    }\n\n    vector<string> mergedGroup;\n\n    for (auto& word1 : groups.back())\n      for (auto& word2 : group)\n        mergedGroup.push_back(word1 + word2);\n\n    groups[groups.size() - 1] = mergedGroup;\n  }\n};\n", "1099": "class Solution {\n public:\n  int twoSumLessThanK(vector<int>& nums, int k) {\n    if (nums.size() < 2)\n      return -1;\n\n    int ans = -1;  // Note the constraint that nums[i] > 0.\n    int l = 0;\n    int r = nums.size() - 1;\n\n    ranges::sort(nums);\n\n    while (l < r)\n      if (nums[l] + nums[r] < k) {\n        ans = max(ans, nums[l] + nums[r]);\n        ++l;\n      } else {\n        --r;\n      }\n\n    return ans;\n  }\n};\n", "11": "class Solution {\n public:\n  int maxArea(vector<int>& height) {\n    int ans = 0;\n    int l = 0;\n    int r = height.size() - 1;\n\n    while (l < r) {\n      const int minHeight = min(height[l], height[r]);\n      ans = max(ans, minHeight * (r - l));\n      if (height[l] < height[r])\n        ++l;\n      else\n        --r;\n    }\n\n    return ans;\n  }\n};\n", "110": "class Solution {\n public:\n  bool isBalanced(TreeNode* root) {\n    bool ans = true;\n    maxDepth(root, ans);\n    return ans;\n  }\n\n  // Returns the height of root and sets ans to false if root unbalanced.\n  int maxDepth(TreeNode* root, bool& ans) {\n    if (root == nullptr || !ans)\n      return 0;\n    const int left = maxDepth(root->left, ans);\n    const int right = maxDepth(root->right, ans);\n    if (abs(left - right) > 1)\n      ans = false;\n    return max(left, right) + 1;\n  }\n};\n", "1100": "class Solution {\n public:\n  int numKLenSubstrNoRepeats(string s, int k) {\n    int ans = 0;\n    int unique = 0;\n    vector<int> count(26);\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (++count[s[i] - 'a'] == 1)\n        ++unique;\n      if (i >= k && --count[s[i - k] - 'a'] == 0)\n        --unique;\n      if (unique == k)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1101": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int earliestAcq(vector<vector<int>>& logs, int n) {\n    UnionFind uf(n);\n\n    // Sort `logs` by timestamp.\n    ranges::sort(logs, ranges::less{},\n                 [](const vector<int>& log) { return log[0]; });\n\n    for (const vector<int>& log : logs) {\n      const int timestamp = log[0];\n      const int x = log[1];\n      const int y = log[2];\n      uf.unionByRank(x, y);\n      if (uf.getCount() == 1)\n        return timestamp;\n    }\n\n    return -1;\n  }\n};\n", "1102": "struct T {\n  int i;\n  int j;\n  int val;\n};\n\nclass Solution {\n public:\n  int maximumMinimumPath(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = grid[0][0];\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    auto compare = [](const T& a, const T& b) { return a.val < b.val; };\n    priority_queue<T, vector<T>, decltype(compare)> maxHeap(compare);\n\n    maxHeap.emplace(0, 0, grid[0][0]);\n\n    while (!maxHeap.empty()) {\n      const auto [i, j, val] = maxHeap.top();\n      maxHeap.pop();\n      ans = min(ans, val);\n      if (i == m - 1 && j == n - 1)\n        return ans;\n      seen[i][j] = true;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        maxHeap.emplace(x, y, grid[x][y]);\n      }\n    }\n\n    throw;\n  }\n};\n", "1103": "class Solution {\n public:\n  vector<int> distributeCandies(int candies, long n) {\n    vector<int> ans(n);\n    int rows = (-n + sqrt(n * n + 8 * n * n * candies)) / (2 * n * n);\n    int accumN = rows * (rows - 1) * n / 2;\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = accumN + rows * (i + 1);\n\n    int givenCandies = (n * n * rows * rows + n * rows) / 2;\n    candies -= givenCandies;\n\n    for (int i = 0, lastGiven = rows * n + 1; candies > 0; ++i, ++lastGiven) {\n      int actualGiven = min(lastGiven, candies);\n      candies -= actualGiven;\n      ans[i] += actualGiven;\n    }\n\n    return ans;\n  }\n};\n", "1104": "class Solution {\n public:\n  vector<int> pathInZigZagTree(int label) {\n    deque<int> ans;\n    int level;\n\n    for (int l = 0; l < 21; ++l)\n      if (pow(2, l) > label) {\n        level = l - 1;\n        break;\n      }\n\n    if (level % 2 == 1)\n      label = boundarySum(level) - label;\n\n    for (int l = level; l >= 0; --l) {\n      ans.push_front(l % 2 == 0 ? label : boundarySum(l) - label);\n      label /= 2;\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n\n private:\n  int boundarySum(int level) {\n    return pow(2, level) + pow(2, level + 1) - 1;\n  }\n};\n", "1105": "class Solution {\n public:\n  int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {\n    // dp[i] := the minimum height to place the first i books\n    vector<int> dp(books.size() + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 0; i < books.size(); ++i) {\n      int sumThickness = 0;\n      int maxHeight = 0;\n      // Place books[j..i] on a new shelf.\n      for (int j = i; j >= 0; --j) {\n        const int thickness = books[j][0];\n        const int height = books[j][1];\n        sumThickness += thickness;\n        if (sumThickness > shelfWidth)\n          break;\n        maxHeight = max(maxHeight, height);\n        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight);\n      }\n    }\n\n    return dp.back();\n  }\n};\n", "1106": "class Solution {\n public:\n  bool parseBoolExpr(string expression) {\n    int i = 0;\n    return parse(expression, i);\n  }\n\n private:\n  bool parse(const string& exp, int& i) {\n    if (exp[i] == 't') {\n      ++i;\n      return true;\n    }\n    if (exp[i] == 'f') {\n      ++i;\n      return false;\n    }\n    if (exp[i] == '!') {\n      i += 2;\n      bool ans = !parse(exp, i);\n      ++i;\n      return ans;\n    }\n\n    bool isAnd = exp[i] == '&';\n    bool ans = isAnd;\n    i += 2;\n    while (exp[i] != ')') {\n      bool parsed = parse(exp, i);\n      if (isAnd)\n        ans &= parsed;\n      else\n        ans |= parsed;\n      if (exp[i] == ',')\n        ++i;\n    }\n    ++i;\n    return ans;\n  }\n};\n", "1108": "class Solution {\n public:\n  string defangIPaddr(string address) {\n    return regex_replace(address, regex(\"[.]\"), \"[.]\");\n  }\n};\n", "1109": "class Solution {\n public:\n  vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\n    vector<int> ans(n);\n\n    for (vector<int>& booking : bookings) {\n      ans[booking[0] - 1] += booking[2];\n      if (booking[1] < n)\n        ans[booking[1]] -= booking[2];\n    }\n\n    for (int i = 1; i < n; ++i)\n      ans[i] += ans[i - 1];\n\n    return ans;\n  }\n};\n", "111": "class Solution {\n public:\n  int minDepth(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n\n    queue<TreeNode*> q{{root}};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        if (node->left == nullptr && node->right == nullptr)\n          return step;\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n\n    throw;\n  }\n};\n", "1110": "class Solution {\n public:\n  vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n    vector<TreeNode*> ans;\n    dfs(root, {to_delete.begin(), to_delete.end()}, true, ans);\n    return ans;\n  }\n\n private:\n  TreeNode* dfs(TreeNode*& root, const unordered_set<int>&& toDeleteSet,\n                bool isRoot, vector<TreeNode*>& ans) {\n    if (root == nullptr)\n      return nullptr;\n\n    const bool deleted = toDeleteSet.contains(root->val);\n    if (isRoot && !deleted)\n      ans.push_back(root);\n\n    // If root is deleted, both children have the possibility to be a new root\n    root->left = dfs(root->left, std::move(toDeleteSet), deleted, ans);\n    root->right = dfs(root->right, std::move(toDeleteSet), deleted, ans);\n    return deleted ? nullptr : root;\n  }\n};\n", "1111": "class Solution {\n public:\n  vector<int> maxDepthAfterSplit(string seq) {\n    vector<int> ans;\n    int depth = 1;\n\n    // Put all odd-depth parentheses in one group and even-depth parentheses in\n    // the other group.\n    for (const char c : seq)\n      if (c == '(')\n        ans.push_back(++depth % 2);\n      else\n        ans.push_back(depth-- % 2);\n\n    return ans;\n  }\n};\n", "1114": "class Foo {\n public:\n  Foo() {\n    firstDone.lock();\n    secondDone.lock();\n  }\n\n  void first(function<void()> printFirst) {\n    printFirst();\n    firstDone.unlock();\n  }\n\n  void second(function<void()> printSecond) {\n    firstDone.lock();\n    printSecond();\n    secondDone.unlock();\n  }\n\n  void third(function<void()> printThird) {\n    secondDone.lock();\n    printThird();\n  }\n\n private:\n  mutex firstDone;\n  mutex secondDone;\n};\n", "1115": "// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore\n// or binary_semaphore.\n#include <semaphore.h>\n\nclass FooBar {\n public:\n  FooBar(int n) : n(n) {\n    sem_init(&fooSemaphore, /*pshared=*/0, /*value=*/1);\n    sem_init(&barSemaphore, /*pshared=*/0, /*value=*/0);\n  }\n\n  ~FooBar() {\n    sem_destroy(&fooSemaphore);\n    sem_destroy(&barSemaphore);\n  }\n\n  void foo(function<void()> printFoo) {\n    for (int i = 0; i < n; ++i) {\n      sem_wait(&fooSemaphore);\n      printFoo();\n      sem_post(&barSemaphore);\n    }\n  }\n\n  void bar(function<void()> printBar) {\n    for (int i = 0; i < n; ++i) {\n      sem_wait(&barSemaphore);\n      printBar();\n      sem_post(&fooSemaphore);\n    }\n  }\n\n private:\n  const int n;\n  sem_t fooSemaphore;\n  sem_t barSemaphore;\n};\n", "1116": "// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore\n// or binary_semaphore.\n#include <semaphore.h>\n\nclass ZeroEvenOdd {\n public:\n  ZeroEvenOdd(int n) : n(n) {\n    sem_init(&zeroSemaphore, /*pshared=*/0, /*value=*/1);\n    sem_init(&evenSemaphore, /*pshared=*/0, /*value=*/0);\n    sem_init(&oddSemaphore, /*pshared=*/0, /*value=*/0);\n  }\n\n  ~ZeroEvenOdd() {\n    sem_destroy(&zeroSemaphore);\n    sem_destroy(&evenSemaphore);\n    sem_destroy(&oddSemaphore);\n  }\n\n  // printNumber(x) outputs \"x\", where x is an integer.\n  void zero(function<void(int)> printNumber) {\n    for (int i = 0; i < n; ++i) {\n      sem_wait(&zeroSemaphore);\n      printNumber(0);\n      sem_post(&(i % 2 == 0 ? oddSemaphore : evenSemaphore));\n    }\n  }\n\n  void even(function<void(int)> printNumber) {\n    for (int i = 2; i <= n; i += 2) {\n      sem_wait(&evenSemaphore);\n      printNumber(i);\n      sem_post(&zeroSemaphore);\n    }\n  }\n\n  void odd(function<void(int)> printNumber) {\n    for (int i = 1; i <= n; i += 2) {\n      sem_wait(&oddSemaphore);\n      printNumber(i);\n      sem_post(&zeroSemaphore);\n    }\n  }\n\n private:\n  const int n;\n  sem_t zeroSemaphore;\n  sem_t evenSemaphore;\n  sem_t oddSemaphore;\n};\n", "1117": "// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore\n// or binary_semaphore.\n#include <semaphore.h>\n\nclass H2O {\n public:\n  H2O() {\n    sem_init(&hSemaphore, /*pshared=*/0, /*value=*/1);\n    sem_init(&oSemaphore, /*pshared=*/0, /*value=*/0);\n  }\n\n  ~H2O() {\n    sem_destroy(&hSemaphore);\n    sem_destroy(&oSemaphore);\n  }\n\n  void hydrogen(function<void()> releaseHydrogen) {\n    sem_wait(&hSemaphore);\n    ++h;\n    // releaseHydrogen() outputs \"H\". Do not change or remove this line.\n    releaseHydrogen();\n    if (h % 2 == 0)\n      sem_post(&oSemaphore);\n    else\n      sem_post(&hSemaphore);\n  }\n\n  void oxygen(function<void()> releaseOxygen) {\n    sem_wait(&oSemaphore);\n    // releaseOxygen() outputs \"O\". Do not change or remove this line.\n    releaseOxygen();\n    sem_post(&hSemaphore);\n  }\n\n private:\n  sem_t hSemaphore;\n  sem_t oSemaphore;\n  int h = 0;\n};\n", "1118": "class Solution {\n public:\n  int numberOfDays(int year, int month) {\n    const vector<int> days = {0,  31, 28, 31, 30, 31, 30,\n                              31, 31, 30, 31, 30, 31};\n    return month == 2 && isLeapYear(year) ? 29 : days[month];\n  }\n\n private:\n  bool isLeapYear(int year) {\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n  };\n};\n", "1119": "class Solution {\n public:\n  string removeVowels(string s) {\n    s.erase(remove_if(s.begin(), s.end(), [&](char c) { return isVowel(c); }),\n            s.end());\n    return s;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "112": "class Solution {\n public:\n  bool hasPathSum(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return false;\n    if (root->val == sum && root->left == nullptr && root->right == nullptr)\n      return true;\n    return hasPathSum(root->left, sum - root->val) ||\n           hasPathSum(root->right, sum - root->val);\n  }\n};\n", "1120": "struct T {\n  int sum;\n  int count;\n  double maxAverage;\n};\n\nclass Solution {\n public:\n  double maximumAverageSubtree(TreeNode* root) {\n    return maximumAverage(root).maxAverage;\n  }\n\n private:\n  T maximumAverage(TreeNode* root) {\n    if (root == nullptr)\n      return {0, 0, 0.0};\n\n    const T left = maximumAverage(root->left);\n    const T right = maximumAverage(root->right);\n\n    const int sum = root->val + left.sum + right.sum;\n    const int count = 1 + left.count + right.count;\n    const double maxAverage =\n        max({sum / (double)count, left.maxAverage, right.maxAverage});\n    return {sum, count, maxAverage};\n  }\n};\n", "1121": "class Solution {\n public:\n  bool canDivideIntoSubsequences(vector<int>& nums, int k) {\n    // Find the number with the maxFreq, we need at least maxFreq * k elements\n    // e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to\n    // Split nums into two subsequences say k = 3, the minimum length of nums is\n    // 2 x 3 = 6, which is impossible if nums.size() = 5\n    const int n = nums.size();\n    int freq = 1;\n    int maxFreq = 1;\n\n    for (int i = 1; i < n; ++i) {\n      freq = nums[i - 1] < nums[i] ? 1 : ++freq;\n      maxFreq = max(maxFreq, freq);\n    }\n\n    return n >= maxFreq * k;\n  }\n};\n", "1122": "class Solution {\n public:\n  vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {\n    vector<int> ans;\n    vector<int> count(1001);\n\n    for (int a : arr1)\n      ++count[a];\n\n    for (int a : arr2)\n      while (count[a]-- > 0)\n        ans.push_back(a);\n\n    for (int num = 0; num < 1001; ++num)\n      while (count[num]-- > 0)\n        ans.push_back(num);\n\n    return ans;\n  }\n};\n", "1123": "struct T {\n  TreeNode* lca;\n  int depth;\n};\n\nclass Solution {\n public:\n  TreeNode* lcaDeepestLeaves(TreeNode* root) {\n    return dfs(root).lca;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {nullptr, 0};\n    const T left = dfs(root->left);\n    const T right = dfs(root->right);\n    if (left.depth > right.depth)\n      return {left.lca, left.depth + 1};\n    if (left.depth < right.depth)\n      return {right.lca, right.depth + 1};\n    return {root, left.depth + 1};\n  }\n};\n", "1124": "class Solution {\n public:\n  int longestWPI(vector<int>& hours) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> map;\n\n    for (int i = 0; i < hours.size(); ++i) {\n      prefix += hours[i] > 8 ? 1 : -1;\n      if (prefix > 0) {\n        ans = i + 1;\n      } else {\n        if (!map.contains(prefix))\n          map[prefix] = i;\n        if (const auto it = map.find(prefix - 1); it != map.cend())\n          ans = max(ans, i - it->second);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1125": "class Solution {\n public:\n  vector<int> smallestSufficientTeam(vector<string>& req_skills,\n                                     vector<vector<string>>& people) {\n    const int n = req_skills.size();\n    const int nSkills = 1 << n;\n    unordered_map<string, int> skillToId;\n    // dp[i] := the minimum people's indices to cover skillset of mask i\n    unordered_map<int, vector<int>> dp;\n    dp.reserve(nSkills);  // Avoid rehash.\n    dp[0] = {};\n\n    for (int i = 0; i < n; ++i)\n      skillToId[req_skills[i]] = i;\n\n    auto getSkill = [&](const vector<string>& person) {\n      int mask = 0;\n      for (const string& skill : person)\n        if (const auto it = skillToId.find(skill); it != skillToId.cend())\n          mask |= 1 << it->second;\n      return mask;\n    };\n\n    for (int i = 0; i < people.size(); ++i) {\n      const int currSkill = getSkill(people[i]);\n      for (const auto& [mask, indices] : dp) {\n        const int newSkillSet = mask | currSkill;\n        if (newSkillSet == mask)  // Adding people[i] doesn't increase skill set\n          continue;\n        if (!dp.contains(newSkillSet) ||\n            dp[newSkillSet].size() > indices.size() + 1) {\n          dp[newSkillSet] = indices;\n          dp[newSkillSet].push_back(i);\n        }\n      }\n    }\n\n    return dp[nSkills - 1];\n  }\n};\n", "1128": "class Solution {\n public:\n  int numEquivDominoPairs(vector<vector<int>>& dominoes) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (vector<int>& domino : dominoes) {\n      int key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1]);\n      ans += count[key];\n      ++count[key];\n    }\n\n    return ans;\n  }\n};\n", "1129": "enum class Color { kInit, kRed, kBlue };\n\nclass Solution {\n public:\n  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,\n                                       vector<vector<int>>& blueEdges) {\n    vector<int> ans(n, -1);\n    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]\n    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]\n\n    for (const vector<int>& edge : redEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kRed);\n    }\n\n    for (const vector<int>& edge : blueEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kBlue);\n    }\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [u, prevColor] = q.front();\n        q.pop();\n        ans[u] = ans[u] == -1 ? step : ans[u];\n        for (auto& [v, edgeColor] : graph[u]) {\n          if (v == -1 || edgeColor == prevColor)\n            continue;\n          q.emplace(v, edgeColor);\n          v = -1;  // Mark (u, v) as used.\n        }\n      }\n\n    return ans;\n  }\n};\n", "113": "class Solution {\n public:\n  vector<vector<int>> pathSum(TreeNode* root, int sum) {\n    vector<vector<int>> ans;\n    dfs(root, sum, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int sum, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (root == nullptr)\n      return;\n    if (root->val == sum && root->left == nullptr && root->right == nullptr) {\n      path.push_back(root->val);\n      ans.push_back(path);\n      path.pop_back();\n      return;\n    }\n\n    path.push_back(root->val);\n    dfs(root->left, sum - root->val, std::move(path), ans);\n    dfs(root->right, sum - root->val, std::move(path), ans);\n    path.pop_back();\n  }\n};\n", "1130": "class Solution {\n public:\n  int mctFromLeafValues(vector<int>& arr) {\n    int ans = 0;\n    vector<int> stack{INT_MAX};\n\n    for (const int a : arr) {\n      while (stack.back() <= a) {\n        const int mid = stack.back();\n        stack.pop_back();\n        // Multiply mid with next greater element in the array,\n        // On the left (stack[-1]) or on the right (current number a)\n        ans += min(stack.back(), a) * mid;\n      }\n      stack.push_back(a);\n    }\n\n    for (int i = 2; i < stack.size(); ++i)\n      ans += stack[i] * stack[i - 1];\n\n    return ans;\n  }\n};\n", "1131": "class Solution {\n public:\n  int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {\n    const int n = arr1.size();\n    vector<int> a(n);\n    vector<int> b(n);\n    vector<int> c(n);\n    vector<int> d(n);\n\n    for (int i = 0; i < n; ++i) {\n      a[i] = arr1[i] + arr2[i] + i;\n      b[i] = arr1[i] + arr2[i] - i;\n      c[i] = arr1[i] - arr2[i] + i;\n      d[i] = arr1[i] - arr2[i] - i;\n    }\n\n    return max(max(diff(a), diff(b)), max(diff(c), diff(d)));\n  }\n\n private:\n  int diff(vector<int>& nums) {\n    return ranges::max(nums) - ranges::min(nums);\n  }\n};\n", "1133": "class Solution {\n public:\n  int largestUniqueNumber(vector<int>& nums) {\n    constexpr int kMax = 1000;\n    vector<short> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int num = kMax; num >= 0; --num)\n      if (count[num] == 1)\n        return num;\n\n    return -1;\n  }\n};\n", "1134": "class Solution {\n public:\n  bool isArmstrong(int n) {\n    const string s = to_string(n);\n    const int k = s.length();\n    for (const char c : s)\n      n -= pow(c - '0', k);\n    return n == 0;\n  }\n};\n", "1135": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int minimumCost(int n, vector<vector<int>>& connections) {\n    int ans = 0;\n    UnionFind uf(n + 1);\n\n    // Sort by cost.\n    ranges::sort(connections, ranges::less{},\n                 [](const vector<int>& connection) { return connection[2]; });\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      const int cost = connection[2];\n      if (uf.find(u) == uf.find(v))\n        continue;\n      uf.unionByRank(u, v);\n      ans += cost;\n    }\n\n    const int root = uf.find(1);\n    for (int i = 1; i <= n; ++i)\n      if (uf.find(i) != root)\n        return -1;\n\n    return ans;\n  }\n};\n", "1136": "class Solution {\n public:\n  int minimumSemesters(int n, vector<vector<int>>& relations) {\n    vector<vector<int>> graph(n);\n    vector<int> inDegrees(n);\n    queue<int> q;\n\n    // Build the graph.\n    for (const vector<int>& relation : relations) {\n      const int u = relation[0] - 1;\n      const int v = relation[1] - 1;\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    int step = 0;\n    for (; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        --n;\n        for (const int v : graph[u])\n          if (--inDegrees[v] == 0)\n            q.push(v);\n      }\n\n    return n == 0 ? step : -1;\n  }\n};\n", "1137": "class Solution {\n public:\n  int tribonacci(int n) {\n    vector<int> dp{0, 1, 1};\n\n    for (int i = 3; i <= n; ++i)\n      dp[i % 3] = dp[0] + dp[1] + dp[2];\n\n    return dp[n % 3];\n  }\n};\n", "1138": "class Solution {\n public:\n  string alphabetBoardPath(string target) {\n    string ans;\n    int x = 0;\n    int y = 0;\n\n    for (char c : target) {\n      int newX = (c - 'a') % 5;\n      int newY = (c - 'a') / 5;\n      ans += string(max(0, y - newY), 'U') + string(max(0, newX - x), 'R') +\n             string(max(0, x - newX), 'L') + string(max(0, newY - y), 'D') +\n             '!';\n      x = newX;\n      y = newY;\n    }\n\n    return ans;\n  }\n};\n", "1139": "class Solution {\n public:\n  int largest1BorderedSquare(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    // leftOnes[i][j] := consecutive 1s in the left of grid[i][j]\n    vector<vector<int>> leftOnes(m, vector<int>(n));\n    // topOnes[i][j] := consecutive 1s in the top of grid[i][j]\n    vector<vector<int>> topOnes(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1) {\n          leftOnes[i][j] = j == 0 ? 1 : 1 + leftOnes[i][j - 1];\n          topOnes[i][j] = i == 0 ? 1 : 1 + topOnes[i - 1][j];\n        }\n\n    for (int sz = min(m, n); sz > 0; --sz)\n      for (int i = 0; i + sz - 1 < m; ++i)\n        for (int j = 0; j + sz - 1 < n; ++j) {\n          const int x = i + sz - 1;\n          const int y = j + sz - 1;\n          // If grid[i..x][j..y] has all 1s on its border.\n          if (min(leftOnes[i][y], leftOnes[x][y]) >= sz &&\n              min(topOnes[x][j], topOnes[x][y]) >= sz)\n            return sz * sz;\n        }\n\n    return 0;\n  }\n};\n", "114": "class Solution {\n public:\n  void flatten(TreeNode* root) {\n    if (root == nullptr)\n      return;\n\n    stack<TreeNode*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      if (root->right)\n        stack.push(root->right);\n      if (root->left)\n        stack.push(root->left);\n      if (!stack.empty())\n        root->right = stack.top();\n      root->left = nullptr;\n    }\n  }\n};\n", "1140": "class Solution {\n public:\n  int stoneGameII(vector<int>& piles) {\n    const int n = piles.size();\n    vector<vector<int>> mem(n, vector<int>(n));\n    vector<int> suffix = piles;  // suffix[i] := sum(piles[i..n))\n    for (int i = n - 2; i >= 0; --i)\n      suffix[i] += suffix[i + 1];\n    return stoneGameII(suffix, 0, 1, mem);\n  }\n\n private:\n  // Returns the maximum number of stones Alice can get from piles[i..n) with M.\n  int stoneGameII(const vector<int>& suffix, int i, int M,\n                  vector<vector<int>>& mem) {\n    if (i + 2 * M >= mem.size())\n      return suffix[i];\n    if (mem[i][M] > 0)\n      return mem[i][M];\n\n    int opponent = suffix[i];\n\n    for (int X = 1; X <= 2 * M; ++X)\n      opponent = min(opponent, stoneGameII(suffix, i + X, max(M, X), mem));\n\n    return mem[i][M] = suffix[i] - opponent;\n  }\n};\n", "1143": "class Solution {\n public:\n  int longestCommonSubsequence(string text1, string text2) {\n    const int m = text1.length();\n    const int n = text2.length();\n    // dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        dp[i + 1][j + 1] = text1[i] == text2[j]\n                               ? 1 + dp[i][j]\n                               : max(dp[i][j + 1], dp[i + 1][j]);\n\n    return dp[m][n];\n  }\n};\n", "1144": "class Solution {\n public:\n  int movesToMakeZigzag(vector<int>& nums) {\n    vector<int> decreasing(2);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      int l = i > 0 ? nums[i - 1] : 1001;\n      int r = i + 1 < nums.size() ? nums[i + 1] : 1001;\n      decreasing[i % 2] += max(0, nums[i] - min(l, r) + 1);\n    }\n\n    return min(decreasing[0], decreasing[1]);\n  }\n};\n", "1145": "class Solution {\n public:\n  bool btreeGameWinningMove(TreeNode* root, int n, int x) {\n    count(root, x);\n    return max({leftCount, rightCount, n - leftCount - rightCount - 1}) > n / 2;\n  }\n\n private:\n  int leftCount;   // the number of nodes of n's left\n  int rightCount;  // the number of nodes of n's right\n\n  int count(TreeNode* root, int x) {\n    if (root == nullptr)\n      return 0;\n    const int l = count(root->left, x);\n    const int r = count(root->right, x);\n    if (root->val == x) {\n      leftCount = l;\n      rightCount = r;\n    }\n    return 1 + l + r;\n  }\n};\n", "1146": "class SnapshotArray {\n public:\n  SnapshotArray(int length) : snaps(length) {\n    for (auto& snap : snaps)\n      snap.emplace_back(0, 0);\n  }\n\n  void set(int index, int val) {\n    auto& [lastSnapId, lastVal] = snaps[index].back();\n    if (lastSnapId == snap_id)\n      lastVal = val;\n    else\n      snaps[index].emplace_back(snap_id, val);\n  }\n\n  int snap() {\n    return snap_id++;\n  }\n\n  int get(int index, int snap_id) {\n    const vector<pair<int, int>>& snap = snaps[index];\n    auto it = ranges::lower_bound(snap, pair<int, int>{snap_id + 1, 0});\n    return prev(it)->second;\n  }\n\n private:\n  // snaps[i] := [(snap_id, val)]\n  vector<vector<pair<int, int>>> snaps;\n  int snap_id = 0;\n};\n", "1147": "class Solution {\n public:\n  int longestDecomposition(string text) {\n    int count = 0;\n    int l = 0;\n\n    for (int r = 1; 2 * r <= text.length(); ++r)\n      if (equal(text.begin() + l, text.begin() + r, text.end() - r)) {\n        count += 2;\n        l = r;\n      }\n\n    return count + (2 * l < text.length());\n  }\n};\n", "115": "class Solution {\n public:\n  int numDistinct(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    vector<unsigned long> dp(n + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = n; j >= 1; --j)\n        if (s[i - 1] == t[j - 1])\n          dp[j] += dp[j - 1];\n\n    return dp[n];\n  }\n};\n", "1150": "class Solution {\n public:\n  bool isMajorityElement(vector<int>& nums, int target) {\n    const int n = nums.size();\n    const int i = ranges::lower_bound(nums, target) - nums.begin();\n    return i + n / 2 < n && nums[i + n / 2] == target;\n  }\n};\n", "1151": "class Solution {\n public:\n  int minSwaps(vector<int>& data) {\n    const int k = ranges::count(data, 1);\n    int ones = 0;     // the number of ones in the window\n    int maxOnes = 0;  // the maximum number of ones in the window\n\n    for (int i = 0; i < data.size(); ++i) {\n      if (i >= k && data[i - k])\n        --ones;\n      if (data[i])\n        ++ones;\n      maxOnes = max(maxOnes, ones);\n    }\n\n    return k - maxOnes;\n  }\n};\n", "1153": "class Solution {\n public:\n  bool canConvert(string str1, string str2) {\n    if (str1 == str2)\n      return true;\n\n    vector<int> mappings(128);\n\n    for (int i = 0; i < str1.length(); ++i) {\n      const int a = str1[i];\n      const int b = str2[i];\n      if (mappings[a] != 0 && mappings[a] != b)\n        return false;\n      mappings[a] = b;\n    }\n\n    // No letter in the str1 maps to > 1 letter in the str2 and there is at\n    // lest one temporary letter can break any loops.\n    return unordered_set<char>(str2.begin(), str2.end()).size() < 26;\n  }\n};\n", "1154": "class Solution {\n public:\n  int dayOfYear(string date) {\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8));\n    vector<int> days = {\n        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    return accumulate(days.begin(), days.begin() + month - 1, 0) + day;\n  }\n\n private:\n  bool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  }\n};\n", "1155": "class Solution {\n public:\n  int numRollsToTarget(int n, int k, int target) {\n    constexpr int kMod = 1'000'000'007;\n    vector<int> dp(target + 1);\n    dp[0] = 1;\n\n    while (n-- > 0) {  // n dices\n      vector<int> newDp(target + 1);\n      for (int i = 1; i <= k; ++i)           // numbers 1, 2, ..., f\n        for (int t = i; t <= target; ++t) {  // all the possible targets\n          newDp[t] += dp[t - i];\n          newDp[t] %= kMod;\n        }\n      dp = std::move(newDp);\n    }\n\n    return dp[target];\n  }\n};\n", "1156": "class Solution {\n public:\n  int maxRepOpt1(string text) {\n    int ans = 0;\n    vector<int> count(26);\n    vector<pair<char, int>> groups{{text[0], 1}};\n\n    for (const char c : text)\n      ++count[c - 'a'];\n\n    for (int i = 1; i < text.length(); ++i)\n      if (text[i] == text[i - 1])\n        ++groups[groups.size() - 1].second;\n      else\n        groups.emplace_back(text[i], 1);\n\n    for (const auto& [c, length] : groups)\n      ans = max(ans, min(length + 1, count[c - 'a']));\n\n    for (int i = 1; i + 1 < groups.size(); ++i)\n      if (groups[i - 1].first == groups[i + 1].first && groups[i].second == 1)\n        ans = max(ans, min(groups[i - 1].second + groups[i + 1].second + 1,\n                           count[groups[i - 1].first - 'a']));\n\n    return ans;\n  }\n};\n", "1157": "class MajorityChecker {\n public:\n  MajorityChecker(vector<int>& arr) : arr(arr) {\n    for (int i = 0; i < arr.size(); ++i)\n      numToIndices[arr[i]].push_back(i);\n  }\n\n  int query(int left, int right, int threshold) {\n    for (int i = 0; i < kTimes; ++i) {\n      const int randIndex = rand() % (right - left + 1) + left;\n      const int num = arr[randIndex];\n      const vector<int>& indices = numToIndices[num];\n      const auto lit = ranges::lower_bound(indices, left);\n      const auto rit = ranges::upper_bound(indices, right);\n      if (rit - lit >= threshold)\n        return num;\n    }\n\n    return -1;\n  }\n\n private:\n  const vector<int> arr;\n  static constexpr int kTimes = 20;  // 2^kTimes >> |arr| = n\n  unordered_map<int, vector<int>> numToIndices;\n};\n", "116": "class Solution {\n public:\n  Node* connect(Node* root) {\n    Node* node = root;  // the node that is above the current needling\n\n    while (node && node->left) {\n      Node dummy(0);  // the dummy node before needling\n      // Needle the children of the node.\n      for (Node* needle = &dummy; node; node = node->next) {\n        needle->next = node->left;\n        needle = needle->next;\n        needle->next = node->right;\n        needle = needle->next;\n      }\n      node = dummy.next;  // Move the node to the next level.\n    }\n\n    return root;\n  }\n};\n", "1160": "class Solution {\n public:\n  int countCharacters(vector<string>& words, string chars) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : chars)\n      ++count[c - 'a'];\n\n    for (const string& word : words) {\n      vector<int> tempCount(count);\n      for (const char c : word)\n        if (--tempCount[c - 'a'] < 0) {\n          ans -= word.length();\n          break;\n        }\n      ans += word.length();\n    }\n\n    return ans;\n  }\n};\n", "1161": "class Solution {\n public:\n  int maxLevelSum(TreeNode* root) {\n    // levelSums[i] := the sum of level (i + 1) (1-indexed)\n    vector<int> levelSums;\n    dfs(root, 0, levelSums);\n    return 1 + ranges::max_element(levelSums) - levelSums.begin();\n  }\n\n private:\n  void dfs(TreeNode* root, int level, vector<int>& levelSums) {\n    if (root == nullptr)\n      return;\n    if (levelSums.size() == level)\n      levelSums.push_back(0);\n    levelSums[level] += root->val;\n    dfs(root->left, level + 1, levelSums);\n    dfs(root->right, level + 1, levelSums);\n  }\n};\n", "1162": "class Solution {\n public:\n  int maxDistance(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    queue<pair<int, int>> q;\n    int water = 0;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 0)\n          ++water;\n        else\n          q.emplace(i, j);\n\n    if (water == 0 || water == m * n)\n      return -1;\n\n    int ans = 0;\n\n    for (int d = 0; !q.empty(); ++d)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        ans = d;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (grid[x][y] > 0)\n            continue;\n          q.emplace(x, y);\n          grid[x][y] = 2;  // Mark as visited.\n        }\n      }\n\n    return ans;\n  }\n};\n", "1163": "class Solution {\n public:\n  string lastSubstring(string s) {\n    int i = 0;\n    int j = 1;\n    int k = 0;  // the number of the same letters of s[i..n) and s[j..n)\n\n    while (j + k < s.length())\n      if (s[i + k] == s[j + k]) {\n        ++k;\n      } else if (s[i + k] > s[j + k]) {\n        // Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        // lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        // and s[i + k] > s[j + k).\n        j = j + k + 1;\n        k = 0;\n      } else {\n        // Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        // possible lexicographically larger substring since\n        // s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        // Note that it's unnecessary to explore s[i + k + 1..j) if\n        // i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j);\n        j = i + 1;\n        k = 0;\n      }\n\n    return s.substr(i);\n  }\n};\n", "1165": "class Solution {\n public:\n  int calculateTime(string keyboard, string word) {\n    int ans = 0;\n    int prevIndex = 0;\n    vector<int> letterToIndex(26);\n\n    for (int i = 0; i < keyboard.length(); ++i)\n      letterToIndex[keyboard[i] - 'a'] = i;\n\n    for (const char c : word) {\n      const int currIndex = letterToIndex[c - 'a'];\n      ans += abs(currIndex - prevIndex);\n      prevIndex = currIndex;\n    }\n\n    return ans;\n  }\n};\n", "1166": "struct TrieNode {\n  unordered_map<string, shared_ptr<TrieNode>> children;\n  int value;\n  TrieNode(int value) : value(value) {}\n};\n\nclass FileSystem {\n public:\n  bool createPath(string path, int value) {\n    const vector<string> subpaths = getSubpaths(path);\n    shared_ptr<TrieNode> node = root;\n\n    for (int i = 0; i < subpaths.size() - 1; ++i) {\n      auto it = node->children.find(subpaths[i]);\n      if (it == node->children.end())\n        return false;\n      node = it->second;\n    }\n\n    if (node->children.contains(subpaths.back()))\n      return false;\n    node->children[subpaths.back()] = make_shared<TrieNode>(value);\n    return true;\n  }\n\n  int get(string path) {\n    shared_ptr<TrieNode> node = root;\n    for (const string& subpath : getSubpaths(path)) {\n      auto it = node->children.find(subpath);\n      if (it == node->children.end())\n        return -1;\n      node = it->second;\n    }\n    return node->value;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>(0);\n\n  vector<string> getSubpaths(const string& path) {\n    vector<string> subpaths;\n    istringstream iss(path);\n    for (string subpath; getline(iss, subpath, '/');)\n      if (!subpath.empty())\n        subpaths.push_back(subpath);\n    return subpaths;\n  }\n};\n", "1167": "class Solution {\n public:\n  int connectSticks(vector<int>& sticks) {\n    int ans = 0;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int stick : sticks)\n      minHeap.push(stick);\n\n    while (minHeap.size() > 1) {\n      const int x = minHeap.top();\n      minHeap.pop();\n      const int y = minHeap.top();\n      minHeap.pop();\n      ans += x + y;\n      minHeap.push(x + y);\n    }\n\n    return ans;\n  }\n};\n", "1168": "class Solution {\n public:\n  int minCostToSupplyWater(int n, vector<int>& wells,\n                           vector<vector<int>>& pipes) {\n    int ans = 0;\n    using P = pair<int, int>;\n    vector<vector<P>> graph(n + 1);\n    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)\n\n    for (const vector<int>& pipe : pipes) {\n      const int u = pipe[0];\n      const int v = pipe[1];\n      const int w = pipe[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    // Connect virtual 0 with nodes 1 to n.\n    for (int i = 0; i < n; ++i) {\n      graph[0].emplace_back(i + 1, wells[i]);\n      minHeap.emplace(wells[i], i + 1);\n    }\n\n    unordered_set<int> mst{{0}};\n\n    while (mst.size() < n + 1) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (mst.contains(u))\n        continue;\n      // Add the new vertex.\n      mst.insert(u);\n      ans += d;\n      // Expand if possible.\n      for (const auto [v, w] : graph[u])\n        if (!mst.contains(v))\n          minHeap.emplace(w, v);\n    }\n\n    return ans;\n  }\n};\n", "1169": "struct Transaction {\n  string name;\n  int time;\n  int amount;\n  string city;\n};\n\nclass Solution {\n public:\n  vector<string> invalidTransactions(vector<string>& transactions) {\n    vector<string> ans;\n    unordered_map<string, vector<Transaction>> nameToTransactions;\n\n    for (const string& t : transactions) {\n      const Transaction transaction = getTransaction(t);\n      nameToTransactions[transaction.name].push_back(transaction);\n    }\n\n    for (const string& t : transactions) {\n      const Transaction currTransaction = getTransaction(t);\n      if (currTransaction.amount > 1000) {\n        ans.push_back(t);\n      } else if (const auto it = nameToTransactions.find(currTransaction.name);\n                 it != nameToTransactions.cend()) {\n        // Iterate through all the transactions with the same name, check if\n        // they're within 60 minutes in a different city.\n        for (Transaction transaction : it->second)\n          if (abs(transaction.time - currTransaction.time) <= 60 &&\n              transaction.city != currTransaction.city) {\n            ans.push_back(t);\n            break;\n          }\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  Transaction getTransaction(const string& t) {\n    istringstream iss(t);\n    vector<string> s(4, \"\");\n    for (int i = 0; getline(iss, s[i++], ',');)\n      ;\n    return {s[0], stoi(s[1]), stoi(s[2]), s[3]};  // [name, time, amount, city]\n  }\n};\n", "117": "class Solution {\n public:\n  Node* connect(Node* root) {\n    Node* node = root;  // the node that is above the current needling\n\n    while (node != nullptr) {\n      Node dummy(0);  // the dummy node before needling\n      // Needle the children of the node.\n      for (Node* needle = &dummy; node; node = node->next) {\n        if (node->left != nullptr) {  // Needle the left child.\n          needle->next = node->left;\n          needle = needle->next;\n        }\n        if (node->right != nullptr) {  // Needle the right child.\n          needle->next = node->right;\n          needle = needle->next;\n        }\n      }\n      node = dummy.next;  // Move the node to the next level.\n    }\n\n    return root;\n  }\n};\n", "1170": "class Solution {\n public:\n  vector<int> numSmallerByFrequency(vector<string>& queries,\n                                    vector<string>& words) {\n    vector<int> ans;\n    vector<int> wordsFreq;\n\n    for (const string& word : words)\n      wordsFreq.push_back(f(word));\n    ranges::sort(wordsFreq);\n\n    for (const string& query : queries) {\n      const int freq = f(query);\n      ans.push_back(wordsFreq.end() - ranges::upper_bound(wordsFreq, freq));\n    }\n\n    return ans;\n  }\n\n private:\n  int f(const string& word) {\n    int count = 0;\n    char currentChar = 'z' + 1;\n\n    for (const char c : word)\n      if (c < currentChar) {\n        currentChar = c;\n        count = 1;\n      } else if (c == currentChar) {\n        ++count;\n      }\n\n    return count;\n  }\n};\n", "1171": "class Solution {\n public:\n  ListNode* removeZeroSumSublists(ListNode* head) {\n    ListNode dummy(0, head);\n    int prefix = 0;\n    unordered_map<int, ListNode*> prefixToNode;\n    prefixToNode[0] = &dummy;\n\n    for (; head; head = head->next) {\n      prefix += head->val;\n      prefixToNode[prefix] = head;\n    }\n\n    prefix = 0;\n\n    for (head = &dummy; head; head = head->next) {\n      prefix += head->val;\n      head->next = prefixToNode[prefix]->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "1172": "class DinnerPlates {\n public:\n  DinnerPlates(int capacity) : capacity(capacity) {\n    minHeap.push(0);\n  }\n\n  void push(int val) {\n    const int index = minHeap.top();\n    // Add a new stack on demand.\n    if (index == stacks.size())\n      stacks.push_back({});\n    // Push the new value.\n    stacks[index].push(val);\n    // If the stack pushed is full, remove its candidacy from `minHeap`.\n    if (stacks[index].size() == capacity) {\n      minHeap.pop();\n      // If `minHeap` is empty, the next available stack index is |stacks|.\n      if (minHeap.empty())\n        minHeap.push(stacks.size());\n    }\n  }\n\n  int pop() {\n    // Remove empty stacks from the back.\n    while (!stacks.empty() && stacks.back().empty())\n      stacks.pop_back();\n    if (stacks.empty())\n      return -1;\n    return popAtStack(stacks.size() - 1);\n  }\n\n  int popAtStack(int index) {\n    if (index >= stacks.size() || stacks[index].empty())\n      return -1;\n    // If the stack is going to have space, add its candiday to `minHeap`.\n    if (stacks[index].size() == capacity)\n      minHeap.push(index);\n    const int val = stacks[index].top();\n    stacks[index].pop();\n    return val;\n  }\n\n private:\n  const int capacity;\n  vector<stack<int>> stacks;\n  // the minimum indices of the stacks to push\n  priority_queue<int, vector<int>, greater<>> minHeap;\n};\n", "1175": "class Solution {\n public:\n  int numPrimeArrangements(int n) {\n    const int count = countPrimes(n);\n    return factorial(count) * factorial(n - count) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  int countPrimes(int n) {\n    vector<bool> prime(n + 1, true);\n    prime[0] = false;\n    prime[1] = false;\n    for (int i = 0; i <= sqrt(n); ++i)\n      if (prime[i])\n        for (int j = i * i; j <= n; j += i)\n          prime[j] = false;\n    return ranges::count(prime, true);\n  }\n\n  long factorial(int n) {\n    long res = 1;\n    for (int i = 2; i <= n; ++i)\n      res = res * i % kMod;\n    return res;\n  }\n};\n", "1176": "class Solution {\n public:\n  int dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {\n    int ans = 0;\n    int sum = 0;\n\n    for (int i = 0; i < calories.size(); ++i) {\n      sum += calories[i];\n      if (i < k - 1)\n        continue;\n      if (i >= k)\n        sum -= calories[i - k];\n      if (sum < lower)\n        --ans;\n      else if (sum > upper)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1177": "class Solution {\n public:\n  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\n    vector<bool> ans;\n    vector<unsigned int> dp(s.length() + 1);\n\n    for (int i = 1; i <= s.length(); ++i)\n      dp[i] = dp[i - 1] ^ 1 << s[i - 1] - 'a';\n\n    for (const vector<int>& query : queries) {\n      const int odds = popcount(dp[query[1] + 1] ^ dp[query[0]]);\n      ans.push_back(odds / 2 <= query[2]);\n    }\n\n    return ans;\n  }\n};\n", "1178": "class Solution {\n public:\n  vector<int> findNumOfValidWords(vector<string>& words,\n                                  vector<string>& puzzles) {\n    vector<int> ans;\n    unordered_map<int, int> binaryCount;\n\n    for (const string& word : words) {\n      int mask = 0;\n      for (char c : word)\n        mask |= 1 << c - 'a';\n      ++binaryCount[mask];\n    }\n\n    for (const string& puzzle : puzzles) {\n      int valid = 0;\n      const int n = puzzle.length() - 1;\n      for (int i = 0; i < (1 << n); ++i) {\n        int mask = 1 << puzzle[0] - 'a';\n        for (int j = 0; j < n; ++j)\n          if (i >> j & 1)\n            mask |= 1 << puzzle[j + 1] - 'a';\n        if (const auto it = binaryCount.find(mask); it != binaryCount.cend())\n          valid += it->second;\n      }\n      ans.push_back(valid);\n    }\n\n    return ans;\n  }\n};\n", "118": "class Solution {\n public:\n  vector<vector<int>> generate(int numRows) {\n    vector<vector<int>> ans;\n\n    for (int i = 0; i < numRows; ++i)\n      ans.push_back(vector<int>(i + 1, 1));\n\n    for (int i = 2; i < numRows; ++i)\n      for (int j = 1; j < ans[i].size() - 1; ++j)\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];\n\n    return ans;\n  }\n};\n", "1180": "class Solution {\n public:\n  int countLetters(string s) {\n    int ans = 0;\n    int dp = 0;         // the length of the running letter\n    char letter = '@';  // the running letter\n\n    for (const char c : s) {\n      if (c == letter) {\n        ++dp;\n      } else {\n        dp = 1;\n        letter = c;\n      }\n      // Add the number of substrings ending in the current letter.\n      ans += dp;\n    }\n\n    return ans;\n  }\n};\n", "1181": "class Solution {\n public:\n  vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {\n    set<string> ans;\n    unordered_map<string, set<string>> firstWordToLasts;\n    unordered_map<string, set<string>> lastWordToFirsts;\n\n    for (const string& phrase : phrases) {\n      const int firstSpaceIndex = phrase.find(' ');\n      const int lastSpaceIndex = phrase.rfind(' ');\n      // the index after the firstWord\n      const int i =\n          firstSpaceIndex == string::npos ? phrase.length() : firstSpaceIndex;\n      // the index of the lastWord\n      const int j = lastSpaceIndex == string::npos ? 0 : lastSpaceIndex + 1;\n      const string firstWord = phrase.substr(0, i);\n      const string lastWord = phrase.substr(j);\n\n      // Concatenate `phrase` with `last` having the same `firstWord`.\n      if (const auto it = firstWordToLasts.find(lastWord);\n          it != firstWordToLasts.cend())\n        for (const string& last : it->second)\n          ans.insert(phrase + last);\n\n      // Concatenate `first` having the same `lastWord` with `phrase`.\n      if (const auto it = lastWordToFirsts.find(firstWord);\n          it != lastWordToFirsts.cend())\n        for (const string& first : it->second)\n          ans.insert(first + phrase);\n\n      // e.g. \"a b c\" -> {\"a\": \" b c\"}\n      //          \"a\" -> {\"a\": \"\"}\n      firstWordToLasts[firstWord].insert(phrase.substr(i));\n\n      // e.g. \"a b c\" -> {\"c\": \"a b \"}\n      //          \"a\" -> {\"a\": \"\"}\n      lastWordToFirsts[lastWord].insert(phrase.substr(0, j));\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n};\n", "1182": "class Solution {\n public:\n  vector<int> shortestDistanceColor(vector<int>& colors,\n                                    vector<vector<int>>& queries) {\n    constexpr int kNumColor = 3;\n    const int n = colors.size();\n    vector<int> ans;\n    // left[i][c] := the closest index of color c in index i to the left\n    vector<vector<int>> left(n, vector<int>(kNumColor + 1));\n    // right[i][c] := the closest index of color c in index i to the right\n    vector<vector<int>> right(n, vector<int>(kNumColor + 1));\n\n    vector<int> colorToClosestIndex{0, -1, -1, -1};  // 0-indexed, -1 := N/A\n    for (int i = 0; i < n; ++i) {\n      colorToClosestIndex[colors[i]] = i;\n      for (int c = 1; c <= kNumColor; ++c)\n        left[i][c] = colorToClosestIndex[c];\n    }\n\n    colorToClosestIndex = {0, -1, -1, -1};  // Reset.\n    for (int i = n - 1; i >= 0; --i) {\n      colorToClosestIndex[colors[i]] = i;\n      for (int c = 1; c <= kNumColor; ++c)\n        right[i][c] = colorToClosestIndex[c];\n    }\n\n    for (const vector<int>& query : queries) {\n      const int i = query[0];\n      const int c = query[1];\n      const int leftDist = left[i][c] == -1 ? INT_MAX : i - left[i][c];\n      const int rightDist = right[i][c] == -1 ? INT_MAX : right[i][c] - i;\n      const int minDist = min(leftDist, rightDist);\n      ans.push_back(minDist == INT_MAX ? -1 : minDist);\n    }\n\n    return ans;\n  }\n};\n", "1183": "class Solution {\n public:\n  int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\n    vector<int> subCount;\n\n    auto getCount = [sideLength](int length, int index) -> int {\n      return (length - index - 1) / sideLength + 1;\n    };\n\n    for (int i = 0; i < sideLength; ++i)\n      for (int j = 0; j < sideLength; ++j)\n        subCount.push_back(getCount(width, i) * getCount(height, j));\n\n    ranges::sort(subCount, greater<>());\n    return accumulate(subCount.begin(), subCount.begin() + maxOnes, 0);\n  }\n};\n", "1184": "class Solution {\n public:\n  int distanceBetweenBusStops(vector<int>& distance, int start,\n                              int destination) {\n    int clockwise = 0;\n    int counterclockwise = 0;\n\n    if (start > destination)\n      swap(start, destination);\n\n    for (int i = 0; i < distance.size(); ++i) {\n      if (i >= start && i < destination)\n        clockwise += distance[i];\n      else\n        counterclockwise += distance[i];\n    }\n\n    return min(clockwise, counterclockwise);\n  }\n};\n", "1185": "class Solution {\n public:\n  string dayOfTheWeek(int day, int month, int year) {\n    vector<string> week = {\"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n                           \"Thursday\", \"Friday\", \"Saturday\"};\n    vector<int> days = {\n        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int count = 0;\n\n    for (int i = 1971; i < year; ++i)\n      count += i % 4 == 0 ? 366 : 365;\n    for (int i = 0; i < month - 1; ++i)\n      count += days[i];\n    count += day;\n\n    return week[(count + 4) % 7];\n  }\n\n private:\n  bool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n  }\n};\n", "1186": "class Solution {\n public:\n  // Similar to 53. Maximum Subarray\n  int maximumSum(vector<int>& arr) {\n    constexpr int kMin = INT_MIN / 2;\n    int ans = kMin;\n    int zero = kMin;  // no deletion\n    int one = kMin;   // <= 1 deletion\n\n    for (const int a : arr) {\n      one = max({a, one + a, zero /*delete a*/});\n      zero = max(a, zero + a);\n      ans = max(ans, one);\n    }\n\n    return ans;\n  }\n};\n", "1187": "class Solution {\n public:\n  int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {\n    // dp[i] := the minimum steps to reach i at previous round\n    unordered_map<int, int> dp{{-1, 0}};\n\n    ranges::sort(arr2);\n\n    for (const int a : arr1) {\n      unordered_map<int, int> newDp;\n      for (const auto& [val, steps] : dp) {\n        // It's possible to use the value in the arr1.\n        if (a > val)\n          newDp[a] = min(newDp.contains(a) ? newDp[a] : INT_MAX, steps);\n        // Also try the value in the arr2.\n        if (const auto it = ranges::upper_bound(arr2, val); it != arr2.cend())\n          newDp[*it] =\n              min(newDp.contains(*it) ? newDp[*it] : INT_MAX, steps + 1);\n      }\n      if (newDp.empty())\n        return -1;\n      dp = std::move(newDp);\n    }\n\n    int ans = INT_MAX;\n    for (const auto& [_, steps] : dp)\n      ans = min(ans, steps);\n    return ans;\n  }\n};\n", "1188": "// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore\n// or binary_semaphore.\n#include <semaphore.h>\n\nclass BoundedBlockingQueue {\n public:\n  BoundedBlockingQueue(int capacity) {\n    sem_init(&enqueueSemaphore, /*pshared=*/0, /*value=*/capacity);\n    sem_init(&dequeueSemaphore, /*pshared=*/0, /*value=*/0);\n  }\n\n  ~BoundedBlockingQueue() {\n    sem_destroy(&enqueueSemaphore);\n    sem_destroy(&dequeueSemaphore);\n  }\n\n  void enqueue(int element) {\n    sem_wait(&enqueueSemaphore);\n    q.push(element);\n    sem_post(&dequeueSemaphore);\n  }\n\n  int dequeue() {\n    sem_wait(&dequeueSemaphore);\n    const int element = q.front();\n    q.pop();\n    sem_post(&enqueueSemaphore);\n    return element;\n  }\n\n  int size() {\n    return q.size();\n  }\n\n private:\n  queue<int> q;\n  sem_t enqueueSemaphore;\n  sem_t dequeueSemaphore;\n};\n", "1189": "class Solution {\n public:\n  int maxNumberOfBalloons(string text) {\n    int ans = INT_MAX;\n    vector<int> count(26);\n\n    for (char c : text)\n      ++count[c - 'a'];\n\n    for (char c : string(\"ban\"))\n      ans = min(ans, count[c - 'a']);\n\n    for (char c : string(\"lo\"))\n      ans = min(ans, count[c - 'a'] / 2);\n\n    return ans;\n  }\n};\n", "119": "class Solution {\n public:\n  vector<int> getRow(int rowIndex) {\n    vector<int> ans(rowIndex + 1, 1);\n\n    for (int i = 2; i < rowIndex + 1; ++i)\n      for (int j = 1; j < i; ++j)\n        ans[i - j] += ans[i - j - 1];\n\n    return ans;\n  }\n};\n", "1190": "class Solution {\n public:\n  string reverseParentheses(string s) {\n    string ans;\n    stack<int> stack;\n    unordered_map<int, int> pair;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == '(') {\n        stack.push(i);\n      } else if (s[i] == ')') {\n        const int j = stack.top();\n        stack.pop();\n        pair[i] = j;\n        pair[j] = i;\n      }\n\n    for (int i = 0, d = 1; i < s.length(); i += d)\n      if (s[i] == '(' || s[i] == ')') {\n        i = pair[i];\n        d = -d;\n      } else {\n        ans += s[i];\n      }\n\n    return ans;\n  }\n};\n", "1191": "class Solution {\n public:\n  int kConcatenationMaxSum(vector<int>& arr, int k) {\n    constexpr int kMod = 1'000'000'007;\n    const int sz = arr.size() * (k == 1 ? 1 : 2);\n    const int sum = accumulate(arr.begin(), arr.end(), 0);\n    // The concatenated array will be [arr1, arr2, ..., arrk].\n    // If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.\n    // Equivalently, maxSubarraySum is from arr1 and arrk.\n    return (sum > 0 && k > 2\n                ? kadane(arr, sz) + static_cast<long>(sum) * (k - 2)\n                : kadane(arr, sz)) %\n           kMod;\n  }\n\n private:\n  int kadane(const vector<int>& arr, int sz) {\n    int ans = 0;\n    int sum = 0;\n    for (int i = 0; i < sz; ++i) {\n      const int a = arr[i % arr.size()];\n      sum = max(a, sum + a);\n      ans = max(ans, sum);\n    }\n    return ans;\n  }\n};\n", "1192": "class Solution {\n public:\n  vector<vector<int>> criticalConnections(int n,\n                                          vector<vector<int>>& connections) {\n    vector<vector<int>> ans;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    // rank[i] := the minimum node that node i can reach with forward edges\n    // Initialize with NO_RANK = -2 to indicate not visited.\n    getRank(graph, 0, 0, vector<int>(n, NO_RANK), ans);\n    return ans;\n  }\n\n private:\n  static constexpr int NO_RANK = -2;\n\n  // Gets the minimum rank that u can reach with forward edges.\n  int getRank(const vector<vector<int>>& graph, int u, int currRank,\n              vector<int>&& rank, vector<vector<int>>& ans) {\n    if (rank[u] != NO_RANK)  // The rank is already determined.\n      return rank[u];\n\n    rank[u] = currRank;\n    int minRank = currRank;\n\n    for (const int v : graph[u]) {\n      // visited || parent (that's why NO_RANK = -2 instead of -1)\n      if (rank[u] == rank.size() || rank[v] == currRank - 1)\n        continue;\n      const int nextRank =\n          getRank(graph, v, currRank + 1, std::move(rank), ans);\n      // (u, v) is the only way for u go to v.\n      if (nextRank == currRank + 1)\n        ans.push_back({u, v});\n      minRank = min(minRank, nextRank);\n    }\n\n    rank[u] = rank.size();  // Mark as visited.\n    return minRank;\n  }\n};\n", "1195": "// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore\n// or binary_semaphore.\n#include <semaphore.h>\n\nclass FizzBuzz {\n public:\n  FizzBuzz(int n) : n(n) {\n    sem_init(&fizzSemaphore, /*pshared=*/0, /*value=*/0);\n    sem_init(&buzzSemaphore, /*pshared=*/0, /*value=*/0);\n    sem_init(&fizzbuzzSemaphore, /*pshared=*/0, /*value=*/0);\n    sem_init(&numberSemaphore, /*pshared=*/0, /*value=*/1);\n  }\n\n  ~FizzBuzz() {\n    sem_destroy(&fizzSemaphore);\n    sem_destroy(&buzzSemaphore);\n    sem_destroy(&fizzbuzzSemaphore);\n    sem_destroy(&numberSemaphore);\n  }\n\n  // printFizz() outputs \"fizz\".\n  void fizz(function<void()> printFizz) {\n    for (int i = 1; i <= n; ++i)\n      if (i % 3 == 0 && i % 15 != 0) {\n        sem_wait(&fizzSemaphore);\n        printFizz();\n        sem_post(&numberSemaphore);\n      }\n  }\n\n  // printBuzz() outputs \"buzz\".\n  void buzz(function<void()> printBuzz) {\n    for (int i = 1; i <= n; ++i)\n      if (i % 5 == 0 && i % 15 != 0) {\n        sem_wait(&buzzSemaphore);\n        printBuzz();\n        sem_post(&numberSemaphore);\n      }\n  }\n\n  // printFizzBuzz() outputs \"fizzbuzz\".\n  void fizzbuzz(function<void()> printFizzBuzz) {\n    for (int i = 1; i <= n; ++i)\n      if (i % 15 == 0) {\n        sem_wait(&fizzbuzzSemaphore);\n        printFizzBuzz();\n        sem_post(&numberSemaphore);\n      }\n  }\n\n  // printNumber(x) outputs \"x\", where x is an integer.\n  void number(function<void(int)> printNumber) {\n    for (int i = 1; i <= n; ++i) {\n      sem_wait(&numberSemaphore);\n      if (i % 15 == 0)\n        sem_post(&fizzbuzzSemaphore);\n      else if (i % 3 == 0)\n        sem_post(&fizzSemaphore);\n      else if (i % 5 == 0)\n        sem_post(&buzzSemaphore);\n      else {\n        printNumber(i);\n        sem_post(&numberSemaphore);\n      }\n    }\n  }\n\n private:\n  const int n;\n  sem_t fizzSemaphore;\n  sem_t buzzSemaphore;\n  sem_t fizzbuzzSemaphore;\n  sem_t numberSemaphore;\n};\n", "1196": "class Solution {\n public:\n  int maxNumberOfApples(vector<int>& weight) {\n    int sum = 0;\n\n    ranges::sort(weight);\n\n    for (int i = 0; i < weight.size(); ++i) {\n      sum += weight[i];\n      if (sum > 5000)\n        return i;\n    }\n\n    return weight.size();\n  }\n};\n", "1197": "class Solution {\n public:\n  int minKnightMoves(int x, int y) {\n    return dp(abs(x), abs(y));\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n\n  unordered_map<pair<int, int>, int, PairHash> mem;\n\n  int dp(int x, int y) {\n    if (x + y == 0)  // (0, 0)\n      return 0;\n    if (x + y == 2)  // (0, 2), (1, 1), (2, 0)\n      return 2;\n    if (const auto it = mem.find({x, y}); it != mem.cend())\n      return it->second;\n\n    return mem[{x, y}] = 1 + min(dp(abs(x - 2), abs(y - 1)),  //\n                                 dp(abs(x - 1), abs(y - 2)));\n  }\n};\n", "1198": "class Solution {\n public:\n  int smallestCommonElement(vector<vector<int>>& mat) {\n    constexpr int kMax = 10000;\n    vector<int> count(kMax + 1);\n\n    for (const vector<int>& row : mat)\n      for (const int a : row)\n        if (++count[a] == mat.size())\n          return a;\n\n    return -1;\n  }\n};\n", "1199": "class Solution {\n public:\n  int minBuildTime(vector<int>& blocks, int split) {\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int block : blocks)\n      minHeap.push(block);\n\n    while (minHeap.size() > 1) {\n      minHeap.pop();                // the minimum\n      const int x = minHeap.top();  // the second minimum\n      minHeap.pop();\n      minHeap.push(x + split);\n    }\n\n    return minHeap.top();\n  }\n};\n", "12": "class Solution {\n public:\n  string intToRoman(int num) {\n    const vector<string> M{\"\", \"M\", \"MM\", \"MMM\"};\n    const vector<string> C{\"\",  \"C\",  \"CC\",  \"CCC\",  \"CD\",\n                           \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    const vector<string> X{\"\",  \"X\",  \"XX\",  \"XXX\",  \"XL\",\n                           \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    const vector<string> I{\"\",  \"I\",  \"II\",  \"III\",  \"IV\",\n                           \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num / 1000] + C[num % 1000 / 100] + X[num % 100 / 10] +\n           I[num % 10];\n  }\n};\n", "120": "class Solution {\n public:\n  int minimumTotal(vector<vector<int>>& triangle) {\n    for (int i = triangle.size() - 2; i >= 0; --i)\n      for (int j = 0; j <= i; ++j)\n        triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n    return triangle[0][0];\n  }\n};\n", "1200": "class Solution {\n public:\n  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n    vector<vector<int>> ans;\n    int mn = INT_MAX;\n\n    ranges::sort(arr);\n\n    for (int i = 1; i < arr.size(); ++i) {\n      const int diff = arr[i] - arr[i - 1];\n      if (diff < mn) {\n        mn = diff;\n        ans.clear();\n      }\n      if (diff == mn)\n        ans.push_back({arr[i - 1], arr[i]});\n    }\n\n    return ans;\n  }\n};\n", "1201": "class Solution {\n public:\n  int nthUglyNumber(int n, long a, long b, long c) {\n    const long ab = a * b / __gcd(a, b);\n    const long ac = a * c / __gcd(a, c);\n    const long bc = b * c / __gcd(b, c);\n    const long abc = a * bc / __gcd(a, bc);\n    int l = 1;\n    int r = 2'000'000'000;\n\n    while (l < r) {\n      const int m = l + (r - l) / 2;\n      if (m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc >= n)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n};\n", "1202": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n    string ans;\n    UnionFind uf(s.length());\n    unordered_map<int, priority_queue<char, vector<char>, greater<>>>\n        indexToLetters;\n\n    for (const vector<int>& pair : pairs) {\n      const int a = pair[0];\n      const int b = pair[1];\n      uf.unionByRank(a, b);\n    }\n\n    for (int i = 0; i < s.length(); ++i)\n      indexToLetters[uf.find(i)].push(s[i]);\n\n    for (int i = 0; i < s.length(); ++i)\n      ans += indexToLetters[uf.find(i)].top(), indexToLetters[uf.find(i)].pop();\n\n    return ans;\n  }\n};\n", "1203": "class Solution {\n public:\n  vector<int> sortItems(int n, int m, vector<int>& group,\n                        vector<vector<int>>& beforeItems) {\n    vector<vector<int>> graph(n + m);\n    vector<int> inDegrees(n + m);\n\n    // Build the graph by remapping the k-th group to k + n imaginary node.\n    for (int i = 0; i < group.size(); ++i) {\n      if (group[i] == -1)\n        continue;\n      graph[group[i] + n].push_back(i);\n      ++inDegrees[i];\n    }\n\n    for (int i = 0; i < beforeItems.size(); ++i)\n      for (const int b : beforeItems[i]) {\n        const int u = group[b] == -1 ? b : group[b] + n;\n        const int v = group[i] == -1 ? i : group[i] + n;\n        if (u == v) {  // u and v are already in the same group.\n          graph[b].push_back(i);\n          ++inDegrees[i];\n        } else {\n          graph[u].push_back(v);\n          ++inDegrees[v];\n        }\n      }\n\n    // Perform topological sorting.\n    vector<int> ans;\n\n    for (int i = 0; i < n + m; ++i)\n      if (inDegrees[i] == 0)  // inDegrees[i] == -1 means visited.\n        dfs(graph, i, inDegrees, n, ans);\n\n    return ans.size() == n ? ans : vector<int>();\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, vector<int>& inDegrees,\n           int n, vector<int>& ans) {\n    if (u < n)\n      ans.push_back(u);\n\n    inDegrees[u] = -1;  // Mark as visited.\n\n    for (const int v : graph[u])\n      if (--inDegrees[v] == 0)\n        dfs(graph, v, inDegrees, n, ans);\n  }\n};\n", "1206": "struct Node {\n  int val = -1;\n  shared_ptr<Node> next;\n  shared_ptr<Node> down;\n};\n\nclass Skiplist {\n public:\n  bool search(int target) {\n    for (shared_ptr<Node> node = dummy; node; node = node->down) {\n      advance(node, target);\n      if (node->next && node->next->val == target)\n        return true;\n    }\n    return false;\n  }\n\n  void add(int num) {\n    // Collect nodes that are before the insertion point.\n    stack<shared_ptr<Node>> nodes;\n    for (shared_ptr<Node> node = dummy; node; node = node->down) {\n      advance(node, num);\n      nodes.push(node);\n    }\n\n    shared_ptr<Node> down;\n    bool shouldInsert = true;\n    while (shouldInsert && !nodes.empty()) {\n      shared_ptr<Node> prev = nodes.top();\n      nodes.pop();\n      prev->next = make_shared<Node>(num, prev->next, down);\n      down = prev->next;\n      shouldInsert = rand() % 2 == 1;\n    }\n\n    // Create a topmost new level dummy that points to the existing dummy.\n    if (shouldInsert)\n      dummy = make_shared<Node>(-1, nullptr, dummy);\n  }\n\n  bool erase(int num) {\n    bool found = false;\n    for (shared_ptr<Node> node = dummy; node; node = node->down) {\n      advance(node, num);\n      if (node->next && node->next->val == num) {\n        node->next = node->next->next;\n        found = true;\n      }\n    }\n    return found;\n  }\n\n private:\n  shared_ptr<Node> dummy = make_shared<Node>(-1);\n\n  void advance(shared_ptr<Node>& node, int target) {\n    while (node->next && node->next->val < target)\n      node = node->next;\n  }\n};\n", "1207": "class Solution {\n public:\n  bool uniqueOccurrences(vector<int>& arr) {\n    unordered_map<int, int> count;\n    unordered_set<int> occurrences;\n\n    for (const int a : arr)\n      ++count[a];\n\n    for (const auto& [_, value] : count)\n      if (!occurrences.insert(value).second)\n        return false;\n\n    return true;\n  }\n};\n", "1208": "class Solution {\n public:\n  int equalSubstring(string s, string t, int maxCost) {\n    int j = 0;\n    for (int i = 0; i < s.length(); ++i) {\n      maxCost -= abs(s[i] - t[i]);\n      if (maxCost < 0)\n        maxCost += abs(s[j] - t[j++]);\n    }\n\n    return s.length() - j;\n  }\n};\n", "1209": "class Solution {\n public:\n  string removeDuplicates(const string& s, int k) {\n    string ans;\n    vector<pair<char, int>> stack;\n\n    for (const char c : s)\n      if (stack.empty() || stack.back().first != c)\n        stack.emplace_back(c, 1);\n      else if (++stack.back().second == k)  // stack[-1] == c\n        stack.pop_back();\n\n    for (const auto& [c, count] : stack)\n      ans.append(count, c);\n\n    return ans;\n  }\n};\n", "121": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sellOne = 0;\n    int holdOne = INT_MIN;\n\n    for (const int price : prices) {\n      sellOne = max(sellOne, holdOne + price);\n      holdOne = max(holdOne, -price);\n    }\n\n    return sellOne;\n  }\n};\n", "1210": "enum class Pos { kHorizontal, kVertical };\n\nclass Solution {\n public:\n  int minimumMoves(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    queue<tuple<int, int, Pos>> q{{{0, 0, Pos::kHorizontal}}};\n    vector<vector<vector<bool>>> seen(n,\n                                      vector<vector<bool>>(n, vector<bool>(2)));\n    seen[0][0][static_cast<int>(Pos::kHorizontal)] = true;\n\n    auto canMoveRight = [&](int x, int y, Pos pos) -> bool {\n      if (pos == Pos::kHorizontal)\n        return y + 2 < n && !grid[x][y + 2];\n      return y + 1 < n && !grid[x][y + 1] && !grid[x + 1][y + 1];\n    };\n\n    auto canMoveDown = [&](int x, int y, Pos pos) -> bool {\n      if (pos == Pos::kVertical)\n        return x + 2 < n && !grid[x + 2][y];\n      return x + 1 < n && !grid[x + 1][y] && !grid[x + 1][y + 1];\n    };\n\n    auto canRotateClockwise = [&](int x, int y, Pos pos) -> bool {\n      return pos == Pos::kHorizontal && x + 1 < n && !grid[x + 1][y + 1] &&\n             !grid[x + 1][y];\n    };\n\n    auto canRotateCounterclockwise = [&](int x, int y, Pos pos) -> bool {\n      return pos == Pos::kVertical && y + 1 < n && !grid[x + 1][y + 1] &&\n             !grid[x][y + 1];\n    };\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [x, y, pos] = q.front();\n        q.pop();\n        if (x == n - 1 && y == n - 2 && pos == Pos::kHorizontal)\n          return step;\n        if (canMoveRight(x, y, pos) && !seen[x][y + 1][static_cast<int>(pos)]) {\n          q.emplace(x, y + 1, pos);\n          seen[x][y + 1][static_cast<int>(pos)] = true;\n        }\n        if (canMoveDown(x, y, pos) && !seen[x + 1][y][static_cast<int>(pos)]) {\n          q.emplace(x + 1, y, pos);\n          seen[x + 1][y][static_cast<int>(pos)] = true;\n        }\n        const Pos newPos =\n            pos == Pos::kHorizontal ? Pos::kVertical : Pos::kHorizontal;\n        if ((canRotateClockwise(x, y, pos) ||\n             canRotateCounterclockwise(x, y, pos)) &&\n            !seen[x][y][static_cast<int>(newPos)]) {\n          q.emplace(x, y, newPos);\n          seen[x][y][static_cast<int>(newPos)] = true;\n        }\n      }\n\n    return -1;\n  }\n};\n", "1213": "class Solution {\n public:\n  vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2,\n                                 vector<int>& arr3) {\n    vector<int> ans;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\n    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {\n      const int mn = min({arr1[i], arr2[j], arr3[k]});\n      if (arr1[i] == mn && arr2[j] == mn && arr3[k] == mn) {\n        ans.push_back(mn);\n        ++i;\n        ++j;\n        ++k;\n      } else if (arr1[i] == mn) {\n        ++i;\n      } else if (arr2[j] == mn) {\n        ++j;\n      } else {\n        ++k;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1214": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {\n    pushUntilNull(root);\n  }\n\n  bool hasNext() {\n    return !stack.empty();\n  }\n\n  int next() {\n    TreeNode* root = stack.top();\n    stack.pop();\n    pushUntilNull(leftToRight ? root->right : root->left);\n    return root->val;\n  }\n\n private:\n  stack<TreeNode*> stack;\n  bool leftToRight;\n\n  void pushUntilNull(TreeNode* root) {\n    while (root != nullptr) {\n      stack.push(root);\n      root = leftToRight ? root->left : root->right;\n    }\n  }\n};\n\nclass Solution {\n public:\n  bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {\n    BSTIterator bst1(root1, true);\n    BSTIterator bst2(root2, false);\n\n    for (int l = bst1.next(), r = bst2.next(); true;) {\n      const int sum = l + r;\n      if (sum == target)\n        return true;\n      if (sum < target) {\n        if (!bst1.hasNext())\n          return false;\n        l = bst1.next();\n      } else {\n        if (!bst2.hasNext())\n          return false;\n        r = bst2.next();\n      }\n    }\n  }\n};\n", "1215": "class Solution {\n public:\n  vector<int> countSteppingNumbers(int low, int high) {\n    vector<int> ans;\n    if (low == 0)\n      ans.push_back(0);\n\n    for (int i = 1; i <= 9; ++i)\n      dfs(i, low, high, ans);\n\n    ranges::sort(ans);\n    return ans;\n  }\n\n private:\n  void dfs(long curr, int low, int high, vector<int>& ans) {\n    if (curr > high)\n      return;\n    if (curr >= low)\n      ans.push_back(curr);\n\n    const int lastDigit = curr % 10;\n    if (lastDigit > 0)\n      dfs(curr * 10 + lastDigit - 1, low, high, ans);\n    if (lastDigit < 9)\n      dfs(curr * 10 + lastDigit + 1, low, high, ans);\n  }\n};\n", "1216": "class Solution {\n public:\n  bool isValidPalindrome(string s, int k) {\n    return s.length() - longestPalindromeSubseq(s) <= k;\n  }\n\n private:\n  // Same as 516. Longest Palindromic Subsequence\n  int longestPalindromeSubseq(const string& s) {\n    const int n = s.length();\n    // dp[i][j] := the length of LPS(s[i..j])\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j])\n          dp[i][j] = 2 + dp[i + 1][j - 1];\n        else\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "1217": "class Solution {\n public:\n  int minCostToMoveChips(vector<int>& position) {\n    vector<int> count(2);\n    for (const int p : position)\n      ++count[p % 2];\n    return min(count[0], count[1]);\n  }\n};\n", "1218": "class Solution {\n public:\n  int longestSubsequence(vector<int>& arr, int difference) {\n    int ans = 0;\n    unordered_map<int, int> lengthAt;\n\n    for (const int a : arr) {\n      if (const auto it = lengthAt.find(a - difference); it != lengthAt.cend())\n        lengthAt[a] = it->second + 1;\n      else\n        lengthAt[a] = 1;\n      ans = max(ans, lengthAt[a]);\n    }\n\n    return ans;\n  }\n};\n", "1219": "class Solution {\n public:\n  int getMaximumGold(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        ans = max(ans, dfs(grid, i, j));\n\n    return ans;\n  }\n\n private:\n  int dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || j < 0 || i == grid.size() || j == grid[0].size())\n      return 0;\n    if (grid[i][j] == 0)\n      return 0;\n\n    const int gold = grid[i][j];\n    grid[i][j] = 0;  // Mark as visited.\n    const int maxPath = max({dfs(grid, i + 1, j), dfs(grid, i - 1, j),\n                             dfs(grid, i, j + 1), dfs(grid, i, j - 1)});\n    grid[i][j] = gold;\n    return gold + maxPath;\n  }\n};\n", "122": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sell = 0;\n    int hold = INT_MIN;\n\n    for (const int price : prices) {\n      sell = max(sell, hold + price);\n      hold = max(hold, sell - price);\n    }\n\n    return sell;\n  }\n};\n", "1221": "class Solution {\n public:\n  int balancedStringSplit(string s) {\n    int ans = 0;\n    int count = 0;\n\n    for (const char c : s) {\n      count += c == 'L' ? 1 : -1;\n      if (count == 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1222": "class Solution {\n public:\n  vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens,\n                                          vector<int>& king) {\n    vector<vector<int>> ans;\n    unordered_set<int> queensSet;\n\n    for (vector<int>& queen : queens)\n      queensSet.insert(hash(queen[0], queen[1]));\n\n    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n    for (vector<int> d : directions)\n      for (int i = king[0] + d[0], j = king[1] + d[1];\n           0 <= i && i < 8 && 0 <= j && j < 8; i += d[0], j += d[1])\n        if (queensSet.contains(hash(i, j))) {\n          ans.push_back({i, j});\n          break;\n        }\n\n    return ans;\n  }\n\n private:\n  int hash(int i, int j) {\n    return i * 8 + j;\n  }\n};\n", "1224": "class Solution {\n public:\n  int maxEqualFreq(vector<int>& nums) {\n    int ans = 0;\n    int maxFreq = 0;\n    unordered_map<int, int> count;\n    unordered_map<int, int> freq;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int num = nums[i];\n      --freq[count[num]];\n      ++count[num];\n      ++freq[count[num]];\n      maxFreq = max(maxFreq, count[num]);\n      if (maxFreq == 1 || maxFreq * freq[maxFreq] == i ||\n          (maxFreq - 1) * (freq[maxFreq - 1] + 1) == i)\n        ans = i + 1;\n    }\n\n    return ans;\n  }\n};\n", "1226": "class DiningPhilosophers {\n  std::mutex mutex;\n\n public:\n  void wantsToEat(int philosopher, function<void()> pickLeftFork,\n                  function<void()> pickRightFork, function<void()> eat,\n                  function<void()> putLeftFork, function<void()> putRightFork) {\n    mutex.lock();\n    pickLeftFork();\n    pickRightFork();\n    eat();\n    putLeftFork();\n    putRightFork();\n    mutex.unlock();\n  }\n};\n", "1227": "class Solution {\n public:\n  double nthPersonGetsNthSeat(int n) {\n    return n == 1 ? 1 : 0.5;\n  }\n};\n", "1228": "class Solution {\n public:\n  int missingNumber(vector<int>& arr) {\n    const int n = arr.size();\n    const int delta = (arr.back() - arr.front()) / n;\n    int l = 0;\n    int r = n - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (arr[m] == arr[0] + m * delta)\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return arr[0] + l * delta;\n  }\n};\n", "1229": "class Solution {\n public:\n  vector<int> minAvailableDuration(vector<vector<int>>& slots1,\n                                   vector<vector<int>>& slots2, int duration) {\n    ranges::sort(slots1);\n    ranges::sort(slots2);\n\n    int i = 0;  // slots1's index\n    int j = 0;  // slots2's index\n\n    while (i < slots1.size() && j < slots2.size()) {\n      const int start = max(slots1[i][0], slots2[j][0]);\n      const int end = min(slots1[i][1], slots2[j][1]);\n      if (start + duration <= end)\n        return {start, start + duration};\n      if (slots1[i][1] < slots2[j][1])\n        ++i;\n      else\n        ++j;\n    }\n\n    return {};\n  }\n};\n", "123": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sellTwo = 0;\n    int holdTwo = INT_MIN;\n    int sellOne = 0;\n    int holdOne = INT_MIN;\n\n    for (const int price : prices) {\n      sellTwo = max(sellTwo, holdTwo + price);\n      holdTwo = max(holdTwo, sellOne - price);\n      sellOne = max(sellOne, holdOne + price);\n      holdOne = max(holdOne, -price);\n    }\n\n    return sellTwo;\n  }\n};\n", "1230": "class Solution {\n public:\n  double probabilityOfHeads(vector<double>& prob, int target) {\n    // dp[j] := the probability of tossing the coins so far with j heads\n    vector<double> dp(target + 1);\n    dp[0] = 1.0;\n\n    for (const double p : prob)\n      for (int j = target; j >= 0; --j)\n        dp[j] = (j > 0 ? dp[j - 1] * p : 0) + dp[j] * (1 - p);\n\n    return dp[target];\n  }\n};\n", "1231": "class Solution {\n public:\n  int maximizeSweetness(vector<int>& sweetness, int k) {\n    int l = sweetness.size() / (k + 1);\n    int r = accumulate(sweetness.begin(), sweetness.end(), 0) / (k + 1);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (canEat(sweetness, k, m))\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return canEat(sweetness, k, l) ? l : l - 1;\n  }\n\n private:\n  // Returns true if can eat m sweetness (the minimum sweetness of each piece).\n  bool canEat(const vector<int>& sweetness, int k, int m) {\n    int pieces = 0;\n    int sum = 0;  // the running sum\n\n    for (const int s : sweetness) {\n      sum += s;\n      if (sum >= m) {\n        if (++pieces > k)\n          return true;\n        sum = 0;\n      }\n    }\n\n    return false;\n  };\n};\n", "1232": "class Solution {\n public:\n  bool checkStraightLine(vector<vector<int>>& coordinates) {\n    int x0 = coordinates[0][0];\n    int y0 = coordinates[0][1];\n    int x1 = coordinates[1][0];\n    int y1 = coordinates[1][1];\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    for (int i = 2; i < coordinates.size(); ++i) {\n      int x = coordinates[i][0];\n      int y = coordinates[i][1];\n      if ((x - x0) * dy != (y - y0) * dx)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "1233": "class Solution {\n public:\n  vector<string> removeSubfolders(vector<string>& folder) {\n    vector<string> ans;\n    string prev;\n\n    ranges::sort(folder);\n\n    for (const string& f : folder) {\n      if (!prev.empty() && f.find(prev) == 0 && f[prev.length()] == '/')\n        continue;\n      ans.push_back(f);\n      prev = f;\n    }\n\n    return ans;\n  }\n};\n", "1234": "class Solution {\n public:\n  int balancedString(string s) {\n    const int n = s.length();\n    const int k = n / 4;\n    int ans = n;\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (int i = 0, j = 0; i < n; ++i) {\n      --count[s[i]];\n      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k &&\n             count['R'] <= k) {\n        ans = min(ans, i - j + 1);\n        ++count[s[j]];\n        ++j;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1235": "struct Job {\n  int startTime;\n  int endTime;\n  int profit;\n};\n\nclass Solution {\n public:\n  int jobScheduling(vector<int>& startTime, vector<int>& endTime,\n                    vector<int>& profit) {\n    const int n = startTime.size();\n    // dp[i] := the maximum profit to schedule jobs[i..n)\n    vector<int> dp(n + 1);\n    vector<Job> jobs;\n\n    for (int i = 0; i < n; ++i)\n      jobs.emplace_back(startTime[i], endTime[i], profit[i]);\n\n    ranges::sort(jobs, ranges::less{},\n                 [](const Job& job) { return job.startTime; });\n\n    for (int i = 0; i < n; ++i)\n      startTime[i] = jobs[i].startTime;\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int j = firstGreaterEqual(startTime, i + 1, jobs[i].endTime);\n      const int pick = jobs[i].profit + dp[j];\n      const int skip = dp[i + 1];\n      dp[i] = max(pick, skip);\n    }\n\n    return dp[0];\n  }\n\n  int firstGreaterEqual(const vector<int>& arr, int startFrom, int target) {\n    return lower_bound(arr.begin() + startFrom, arr.end(), target) -\n           arr.begin();\n  }\n};\n", "1236": "/**\n * // This is the HtmlParser's API interface.\n * // You should not implement it, or speculate about its implementation\n * class HtmlParser {\n *  public:\n *   vector<string> getUrls(string url);\n * };\n */\n\nclass Solution {\n public:\n  vector<string> crawl(string startUrl, HtmlParser htmlParser) {\n    queue<string> q{{startUrl}};\n    unordered_set<string> seen{{startUrl}};\n    const string& hostname = getHostname(startUrl);\n\n    while (!q.empty()) {\n      const string currUrl = q.front();\n      q.pop();\n      for (const string& url : htmlParser.getUrls(currUrl)) {\n        if (seen.contains(url))\n          continue;\n        if (url.find(hostname) != string::npos) {\n          q.push(url);\n          seen.insert(url);\n        }\n      }\n    }\n\n    return {seen.begin(), seen.end()};\n  }\n\n private:\n  string getHostname(const string& url) {\n    const int firstSlash = url.find_first_of('/');\n    const int thirdSlash = url.find_first_of('/', firstSlash + 2);\n    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);\n  }\n};\n", "1237": "class Solution {\n public:\n  vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {\n    vector<vector<int>> ans;\n    int x = 1;\n    int y = 1000;\n\n    while (x <= 1000 && y >= 1) {\n      int f = customfunction.f(x, y);\n      if (f < z)\n        ++x;\n      else if (f > z)\n        --y;\n      else\n        ans.push_back({x++, y--});\n    }\n\n    return ans;\n  }\n};\n", "1238": "class Solution {\n public:\n  vector<int> circularPermutation(int n, int start) {\n    vector<int> ans;\n\n    for (int i = 0; i < 1 << n; ++i)\n      ans.push_back(start ^ i ^ i >> 1);\n\n    return ans;\n  }\n};\n", "1239": "class Solution {\n public:\n  int maxLength(vector<string>& arr) {\n    vector<bitset<26>> masks;\n\n    for (const string& s : arr) {\n      const bitset<26> mask = getMask(s);\n      if (mask.contains() == s.length())\n        masks.push_back(mask);\n    }\n\n    return dfs(masks, 0, /*used=*/bitset<26>());\n  }\n\n private:\n  int dfs(const vector<bitset<26>>& masks, int s, bitset<26> used) {\n    int res = used.contains();\n    for (int i = s; i < masks.size(); ++i)\n      if (!(used & masks[i]).any())\n        res = max(res, dfs(masks, i + 1, used | masks[i]));\n    return res;\n  }\n\n  bitset<26> getMask(const string& s) {\n    bitset<26> mask;\n    for (const char c : s)\n      mask.set(c - 'a');\n    return mask;\n  }\n};\n", "124": "class Solution {\n public:\n  int maxPathSum(TreeNode* root) {\n    int ans = INT_MIN;\n    maxPathSumDownFrom(root, ans);\n    return ans;\n  }\n\n private:\n  // Returns the maximum path sum starting from the current root, where\n  // root->val is always included.\n  int maxPathSumDownFrom(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = max(0, maxPathSumDownFrom(root->left, ans));\n    const int r = max(0, maxPathSumDownFrom(root->right, ans));\n    ans = max(ans, root->val + l + r);\n    return root->val + max(l, r);\n  }\n};\n", "1240": "class Solution {\n public:\n  int tilingRectangle(int n, int m) {\n    unordered_map<long, int> mem;\n    return tilingRectangle(n, m, 0, /*heights=*/vector<int>(m), mem);\n  }\n\n private:\n  static constexpr int kBase = 13;\n\n  int tilingRectangle(int n, int m, long hashedHeights, vector<int>&& heights,\n                      unordered_map<long, int>& mem) {\n    if (const auto it = mem.find(hashedHeights); it != mem.cend())\n      return it->second;\n\n    const auto it = ranges::min_element(heights);\n    const int minHeight = *it;\n    if (minHeight == n)  // All filled.\n      return 0;\n\n    int ans = m * n;\n    const int start = it - heights.begin();\n    // Try to put square of different size that doesn't exceed the width/height.\n    for (int sz = 1; sz <= min(m - start, n - minHeight); ++sz) {\n      // heights[start..start + sz) must has the same height.\n      if (heights[start + sz - 1] != minHeight)\n        break;\n      // Put a square of size `sz` to cover heights[start..start + sz).\n      for (int i = start; i < start + sz; ++i)\n        heights[i] += sz;\n      ans = min(ans,\n                tilingRectangle(n, m, hash(heights), std::move(heights), mem));\n      for (int i = start; i < start + sz; ++i)\n        heights[i] -= sz;\n    }\n\n    return mem[hashedHeights] = 1 + ans;\n  }\n\n  long hash(const vector<int>& heights) {\n    long hashed = 0;\n    for (int i = heights.size() - 1; i >= 0; --i)\n      hashed = hashed * kBase + heights[i];\n    return hashed;\n  }\n};\n", "1242": "/**\n * // This is the HtmlParser's API interface.\n * // You should not implement it, or speculate about its implementation\n * class HtmlParser {\n *  public:\n *   vector<string> getUrls(string url);\n * };\n */\n\nclass Solution {\n public:\n  vector<string> crawl(string startUrl, HtmlParser htmlParser) {\n    queue<string> q{{startUrl}};\n    unordered_set<string> seen{{startUrl}};\n    const string& hostname = getHostname(startUrl);\n    const int nThreads = std::thread::hardware_concurrency();\n    vector<thread> threads;\n    std::mutex mtx;\n    std::condition_variable cv;\n\n    auto t = [&]() {\n      while (true) {\n        unique_lock<mutex> lock(mtx);\n        cv.wait_for(lock, 30ms, [&]() { return q.size(); });\n        if (q.empty())\n          return;\n        auto cur = q.front();\n        q.pop();\n        lock.unlock();\n        const vector<string> urls = htmlParser.getUrls(cur);\n        lock.lock();\n        for (const string& url : urls) {\n          if (seen.contains(url))\n            continue;\n          if (url.find(hostname) != string::npos) {\n            q.push(url);\n            seen.insert(url);\n          }\n        }\n        lock.unlock();\n        cv.notify_all();\n      }\n    };\n\n    for (int i = 0; i < nThreads; ++i)\n      threads.emplace_back(t);\n\n    for (std::thread& t : threads)\n      t.join();\n\n    return {seen.begin(), seen.end()};\n  }\n\n private:\n  string getHostname(const string& url) {\n    const int firstSlash = url.find_first_of('/');\n    const int thirdSlash = url.find_first_of('/', firstSlash + 2);\n    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);\n  }\n};\n", "1243": "class Solution {\n public:\n  vector<int> transformArray(vector<int>& arr) {\n    if (arr.size() < 3)\n      return arr;\n\n    vector<int> ans(arr.size());\n\n    while (ans != arr) {\n      ans = arr;\n      for (int i = 1; i < arr.size() - 1; ++i) {\n        if (ans[i - 1] > ans[i] && ans[i] < ans[i + 1])\n          ++arr[i];\n        else if (ans[i - 1] < ans[i] && ans[i] > ans[i + 1])\n          --arr[i];\n      }\n    }\n\n    return ans;\n  }\n};\n", "1244": "class Leaderboard {\n public:\n  void addScore(int playerId, int score) {\n    idToScore[playerId] += score;\n  }\n\n  int top(int K) {\n    int ans = 0;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const auto& [id, score] : idToScore) {\n      minHeap.push(score);\n      if (minHeap.size() > K)\n        minHeap.pop();\n    }\n\n    while (!minHeap.empty())\n      ans += minHeap.top(), minHeap.pop();\n\n    return ans;\n  }\n\n  void reset(int playerId) {\n    idToScore.erase(playerId);\n  }\n\n private:\n  unordered_map<int, int> idToScore;\n};\n", "1245": "class Solution {\n public:\n  int treeDiameter(vector<vector<int>>& edges) {\n    const int n = edges.size();\n    int ans = 0;\n    vector<vector<int>> tree(n + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    maxDepth(tree, 0, -1, ans);\n    return ans;\n  }\n\n private:\n  int maxDepth(const vector<vector<int>>& tree, int u, int prev, int& ans) {\n    int maxDepth1 = 0;   // the maximum depth\n    int maxDepth2 = -1;  // the second maximum depth\n\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      const int depth = maxDepth(tree, v, u, ans);\n      if (depth > maxDepth1) {\n        maxDepth2 = maxDepth1;\n        maxDepth1 = depth;\n      } else if (depth > maxDepth2) {\n        maxDepth2 = depth;\n      }\n    }\n\n    ans = max(ans, maxDepth1 + maxDepth2);\n    return 1 + maxDepth1;\n  }\n};\n", "1246": "class Solution {\n public:\n  int minimumMoves(vector<int>& arr) {\n    const int n = arr.size();\n    // dp[i][j] := the minimum number of moves to remove all numbers from\n    // arr[i..j]\n    vector<vector<int>> dp(n, vector<int>(n, n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int i = 0; i + 1 < n; ++i)\n      dp[i][i + 1] = arr[i] == arr[i + 1] ? 1 : 2;\n\n    for (int d = 2; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        // Remove arr[i] and arr[j] within the move of removing\n        // arr[i + 1..j - 1]\n        if (arr[i] == arr[j])\n          dp[i][j] = dp[i + 1][j - 1];\n        // Try all the possible partitions.\n        for (int k = i; k < j; ++k)\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "1247": "class Solution {\n public:\n  int minimumSwap(string s1, string s2) {\n    // (\"xx\", \"yy\") = (2 \"xy\"s) -> 1 swap\n    // (\"yy\", \"xx\") = (2 \"yx\"s) -> 1 swap\n    // (\"xy\", \"yx\") = (1 \"xy\" and 1 \"yx\") -> 2 swaps\n    int xy = 0;  // the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'\n    int yx = 0;  // the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'\n\n    for (int i = 0; i < s1.length(); ++i) {\n      if (s1[i] == s2[i])\n        continue;\n      if (s1[i] == 'x')\n        ++xy;\n      else\n        ++yx;\n    }\n\n    if ((xy + yx) % 2 == 1)\n      return -1;\n    return xy / 2 + yx / 2 + (xy % 2 == 0 ? 0 : 2);\n  }\n};\n", "1248": "class Solution {\n public:\n  int numberOfSubarrays(vector<int>& nums, int k) {\n    return numberOfSubarraysAtMost(nums, k) -\n           numberOfSubarraysAtMost(nums, k - 1);\n  }\n\n private:\n  int numberOfSubarraysAtMost(vector<int>& nums, int k) {\n    int ans = 0;\n\n    for (int l = 0, r = 0; r <= nums.size();)\n      if (k >= 0) {\n        ans += r - l;\n        if (r == nums.size())\n          break;\n        if (nums[r] % 2 == 1)\n          --k;\n        ++r;\n      } else {\n        if (nums[l] % 2 == 1)\n          ++k;\n        ++l;\n      }\n\n    return ans;\n  }\n};\n", "1249": "class Solution {\n public:\n  string minRemoveToMakeValid(string s) {\n    stack<int> stack;  // unpaired '(' indices\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == '(') {\n        stack.push(i);  // Record the unpaired '(' index.\n      } else if (s[i] == ')') {\n        if (stack.empty())\n          s[i] = '*';  // Mark the unpaired ')' as '*'.\n        else\n          stack.pop();  // Find a pair!\n      }\n\n    // Mark the unpaired '(' as '*'.\n    while (!stack.empty())\n      s[stack.top()] = '*', stack.pop();\n\n    std::erase(s, '*');\n    return s;\n  }\n};\n", "125": "class Solution {\n public:\n  bool isPalindrome(string s) {\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !isalnum(s[l]))\n        ++l;\n      while (l < r && !isalnum(s[r]))\n        --r;\n      if (tolower(s[l]) != tolower(s[r]))\n        return false;\n      ++l;\n      --r;\n    }\n\n    return true;\n  }\n};\n", "1250": "class Solution {\n public:\n  bool isGoodArray(vector<int>& nums) {\n    int g = nums[0];\n\n    for (const int num : nums)\n      g = __gcd(g, num);\n\n    return g == 1;\n  }\n};\n", "1252": "class Solution {\n public:\n  int oddCells(int m, int n, vector<vector<int>>& indices) {\n    // rows[i] and cols[i] :=\n    //   1. true (flipped even times)\n    //   2. false (flipped odd times)\n    vector<bool> rows(m);\n    vector<bool> cols(n);\n\n    for (const vector<int>& index : indices) {\n      rows[index[0]] = rows[index[0]] ^ true;\n      cols[index[1]] = cols[index[1]] ^ true;\n    }\n\n    const int oddRowsCount = ranges::count(rows, true);\n    const int oddColsCount = ranges::count(cols, true);\n    const int evenRowsCount = m - oddRowsCount;\n    const int evenColsCount = n - oddColsCount;\n    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount;\n  }\n};\n", "1253": "class Solution {\n public:\n  vector<vector<int>> reconstructMatrix(int upper, int lower,\n                                        vector<int>& colsum) {\n    if (upper + lower != accumulate(colsum.begin(), colsum.end(), 0))\n      return {};\n    if (min(upper, lower) <\n        ranges::count_if(colsum, [](int c) { return c == 2; }))\n      return {};\n\n    vector<vector<int>> ans(2, vector<int>(colsum.size()));\n\n    for (int j = 0; j < colsum.size(); ++j)\n      if (colsum[j] == 2) {\n        ans[0][j] = 1;\n        ans[1][j] = 1;\n        --upper;\n        --lower;\n      }\n\n    for (int j = 0; j < colsum.size(); ++j) {\n      if (colsum[j] == 1 && upper > 0) {\n        ans[0][j] = 1;\n        --colsum[j];\n        --upper;\n      }\n\n      if (colsum[j] == 1 && lower > 0) {\n        ans[1][j] = 1;\n        --lower;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1254": "class Solution {\n public:\n  int closedIsland(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    // Remove the lands connected to the edge.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i * j == 0 || i == m - 1 || j == n - 1)\n          if (grid[i][j] == 0)\n            dfs(grid, i, j);\n\n    int ans = 0;\n\n    // Reduce to 200. Number of Islands\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 0) {\n          dfs(grid, i, j);\n          ++ans;\n        }\n\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] == 1)\n      return;\n    grid[i][j] = 1;\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n  };\n};\n", "1255": "class Solution {\n public:\n  int maxScoreWords(vector<string>& words, vector<char>& letters,\n                    vector<int>& score) {\n    vector<int> count(26);\n    for (const char c : letters)\n      ++count[c - 'a'];\n    return dfs(words, 0, count, score);\n  }\n\n private:\n  // Returns the maximum score you can get from words[s..n).\n  int dfs(const vector<string>& words, int s, vector<int>& count,\n          const vector<int>& score) {\n    int ans = 0;\n    for (int i = s; i < words.size(); ++i) {\n      const int earned = useWord(words, i, count, score);\n      if (earned > 0)\n        ans = max(ans, earned + dfs(words, i + 1, count, score));\n      unuseWord(words, i, count);\n    }\n    return ans;\n  }\n\n  int useWord(const vector<string>& words, int i, vector<int>& count,\n              const vector<int>& score) {\n    bool isValid = true;\n    int earned = 0;\n    for (const char c : words[i]) {\n      if (--count[c - 'a'] < 0)\n        isValid = false;\n      earned += score[c - 'a'];\n    }\n    return isValid ? earned : -1;\n  }\n\n  void unuseWord(const vector<string>& words, int i, vector<int>& count) {\n    for (const char c : words[i])\n      ++count[c - 'a'];\n  }\n};\n", "1256": "class Solution {\n public:\n  string encode(int num) {\n    string binaryStr = bitset<30>(num + 1).to_string();\n    binaryStr.erase(0, binaryStr.find_first_not_of('0'));\n    return binaryStr.substr(1);\n  }\n};\n", "1257": "class Solution {\n public:\n  string findSmallestRegion(vector<vector<string>>& regions, string region1,\n                            string region2) {\n    unordered_map<string, string> parent;\n    unordered_set<string> ancestors;  // region1's ancestors\n\n    for (const vector<string>& region : regions)\n      for (int i = 1; i < region.size(); ++i)\n        parent[region[i]] = region[0];\n\n    // Add all the region1's ancestors.\n    while (region1 != \"\") {\n      ancestors.insert(region1);\n      region1 = parent[region1];  // Region1 becomes \"\" in the end\n    }\n\n    // Go up from region2 until meet any of region1's ancestors.\n    while (!ancestors.contains(region2))\n      region2 = parent[region2];\n\n    return region2;\n  }\n};\n", "1258": "class Solution {\n public:\n  vector<string> generateSentences(vector<vector<string>>& synonyms,\n                                   string text) {\n    set<string> ans;\n    unordered_map<string, vector<string>> graph;\n    queue<string> q{{text}};\n\n    for (const vector<string>& synonym : synonyms) {\n      const string& s = synonym[0];\n      const string& t = synonym[1];\n      graph[s].push_back(t);\n      graph[t].push_back(s);\n    }\n\n    while (!q.empty()) {\n      const string u = q.front();\n      q.pop();\n      ans.insert(u);\n      vector<string> words = split(u);\n      for (string& word : words) {\n        const auto it = graph.find(word);\n        if (it == graph.cend())\n          continue;\n        for (const string& synonym : it->second) {\n          // Replace words[i] with its synonym.\n          word = synonym;\n          const string newText = join(words, ' ');\n          if (!ans.contains(newText))\n            q.push(newText);\n        }\n      }\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n\n private:\n  vector<string> split(const string& s) {\n    vector<string> words;\n    istringstream iss(s);\n    for (string token; iss >> token;)\n      words.push_back(token);\n    return words;\n  }\n\n  string join(const vector<string>& words, char c) {\n    string joined;\n    for (int i = 0; i < words.size(); ++i) {\n      joined += words[i];\n      if (i != words.size() - 1)\n        joined += c;\n    }\n    return joined;\n  }\n};\n", "1259": "class Solution {\n public:\n  int numberOfWays(int numPeople) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i] := the number of ways i handshakes could occure s.t. none of the\n    // handshakes cross\n    vector<long> dp(numPeople / 2 + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= numPeople / 2; ++i)\n      for (int j = 0; j < i; ++j) {\n        dp[i] += dp[j] * dp[i - 1 - j];\n        dp[i] %= kMod;\n      }\n\n    return dp[numPeople / 2];\n  }\n};\n", "126": "class Solution {\n public:\n  vector<vector<string>> findLadders(string beginWord, string endWord,\n                                     vector<string>& wordList) {\n    unordered_set<string> wordSet{wordList.begin(), wordList.end()};\n    if (!wordSet.contains(endWord))\n      return {};\n\n    // {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    unordered_map<string, vector<string>> graph;\n\n    // Build the graph from the beginWord to the endWord.\n    if (!bfs(beginWord, endWord, wordSet, graph))\n      return {};\n\n    vector<vector<string>> ans;\n    dfs(graph, beginWord, endWord, {beginWord}, ans);\n    return ans;\n  }\n\n private:\n  bool bfs(const string& beginWord, const string& endWord,\n           unordered_set<string>& wordSet,\n           unordered_map<string, vector<string>>& graph) {\n    unordered_set<string> forwardWords{beginWord};\n    unordered_set<string> backwardWords{endWord};\n    bool backward = false;\n\n    while (!forwardWords.empty() && !backwardWords.empty()) {\n      for (const string& word : forwardWords)\n        wordSet.erase(word);\n      for (const string& word : backwardWords)\n        wordSet.erase(word);\n      // Always expand the smaller queue.\n      if (forwardWords.size() > backwardWords.size()) {\n        swap(forwardWords, backwardWords);\n        backward = !backward;\n      }\n      unordered_set<string> nextLevelWords;\n      bool reachEndWord = false;\n      for (const string& parent : forwardWords) {\n        for (const string& child :\n             getChildren(parent, wordSet, backwardWords)) {\n          // Should check if `child` is in `backwardWords` since we erase them\n          // at the beginning of each while loop.\n          if (wordSet.contains(child) || backwardWords.contains(child)) {\n            nextLevelWords.insert(child);\n            if (backward)\n              graph[child].push_back(parent);\n            else\n              graph[parent].push_back(child);\n          }\n          // We've reached the end word since there's a word in the\n          // `forwardWords` connecting to a word in `backwardWords`. Note that\n          // we can't return here since we need to completely explore this\n          // level.\n          if (backwardWords.contains(child))\n            reachEndWord = true;\n        }\n      }\n      if (reachEndWord)\n        return true;\n      forwardWords = std::move(nextLevelWords);\n    }\n\n    return true;\n  }\n\n  vector<string> getChildren(const string& parent,\n                             const unordered_set<string>& wordSet,\n                             const unordered_set<string>& backwardWords) {\n    vector<string> children;\n    string s(parent);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char cache = s[i];\n      for (char c = 'a'; c <= 'z'; ++c) {\n        if (c == cache)\n          continue;\n        s[i] = c;  // Now is `child`\n        if (wordSet.contains(s) || backwardWords.contains(s))\n          children.push_back(s);\n      }\n      s[i] = cache;\n    }\n\n    return children;\n  }\n\n  void dfs(const unordered_map<string, vector<string>>& graph,\n           const string& word, const string& endWord, vector<string>&& path,\n           vector<vector<string>>& ans) {\n    if (word == endWord) {\n      ans.push_back(path);\n      return;\n    }\n    if (!graph.contains(word))\n      return;\n\n    for (const string& child : graph.at(word)) {\n      path.push_back(child);\n      dfs(graph, child, endWord, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "1260": "class Solution {\n public:\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    k %= m * n;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        const int index = (i * n + j + k) % (m * n);\n        const int x = index / n;\n        const int y = index % n;\n        ans[x][y] = grid[i][j];\n      }\n\n    return ans;\n  }\n};\n", "1261": "class FindElements {\n public:\n  FindElements(TreeNode* root) {\n    dfs(root, 0);\n  }\n\n  bool find(int target) {\n    return vals.contains(target);\n  }\n\n private:\n  unordered_set<int> vals;\n\n  void dfs(TreeNode* root, int val) {\n    if (root == nullptr)\n      return;\n\n    root->val = val;\n    vals.insert(val);\n    dfs(root->left, val * 2 + 1);\n    dfs(root->right, val * 2 + 2);\n  }\n};\n", "1262": "class Solution {\n public:\n  int maxSumDivThree(vector<int>& nums) {\n    vector<int> dp(3);  // dp[i] := the maximum sum so far s.t. sum % 3 == i\n\n    for (const int num : nums)\n      for (const int sum : vector<int>(dp))\n        dp[(sum + num) % 3] = max(dp[(sum + num) % 3], sum + num);\n\n    return dp[0];\n  }\n};\n", "1263": "class Solution {\n public:\n  int minPushBox(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> box;\n    vector<int> player;\n    vector<int> target;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 'B')\n          box = {i, j};\n        else if (grid[i][j] == 'S')\n          player = {i, j};\n        else if (grid[i][j] == 'T')\n          target = {i, j};\n\n    // (boxX, boxY, playerX, playerY)\n    queue<tuple<int, int, int, int>> q{\n        {{box[0], box[1], player[0], player[1]}}};\n    vector<vector<vector<vector<bool>>>> seen(\n        m, vector<vector<vector<bool>>>(\n               n, vector<vector<bool>>(m, vector<bool>(n))));\n    seen[box[0]][box[1]][player[0]][player[1]] = true;\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [boxX, boxY, playerX, playerY] = q.front();\n        q.pop();\n        if (boxX == target[0] && boxY == target[1])\n          return step;\n        for (int k = 0; k < 4; ++k) {\n          const int nextBoxX = boxX + kDirs[k % 4][0];\n          const int nextBoxY = boxY + kDirs[k % 4][1];\n          if (isInvalid(grid, nextBoxX, nextBoxY))\n            continue;\n          if (seen[nextBoxX][nextBoxY][boxX][boxY])\n            continue;\n          const int fromX = boxX + kDirs[(k + 2) % 4][0];\n          const int fromY = boxY + kDirs[(k + 2) % 4][1];\n          if (isInvalid(grid, fromX, fromY))\n            continue;\n          if (canGoTo(grid, playerX, playerY, fromX, fromY, boxX, boxY)) {\n            seen[nextBoxX][nextBoxY][boxX][boxY] = true;\n            q.emplace(nextBoxX, nextBoxY, boxX, boxY);\n          }\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  // Returns true if (playerX, playerY) can go to (fromX, fromY).\n  bool canGoTo(const vector<vector<char>>& grid, int playerX, int playerY,\n               int fromX, int fromY, int boxX, int boxY) {\n    queue<pair<int, int>> q{{{playerX, playerY}}};\n    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));\n    seen[playerX][playerY] = true;\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      if (i == fromX && j == fromY)\n        return true;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (isInvalid(grid, x, y))\n          continue;\n        if (seen[x][y])\n          continue;\n        if (x == boxX && y == boxY)\n          continue;\n        q.emplace(x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    return false;\n  }\n\n  bool isInvalid(const vector<vector<char>>& grid, int playerX, int playerY) {\n    return playerX < 0 || playerX == grid.size() || playerY < 0 ||\n           playerY == grid[0].size() || grid[playerX][playerY] == '#';\n  }\n};\n", "1265": "/**\n * // This is the ImmutableListNode's API interface.\n * // You should not implement it, or speculate about its implementation.\n * class ImmutableListNode {\n *  public:\n *   void printValue(); // Print the value of the node.\n *   ImmutableListNode* getNext(); // Returns the next node.\n * };\n */\n\nclass Solution {\n public:\n  void printLinkedListInReverse(ImmutableListNode* head) {\n    stack<ImmutableListNode*> stack;\n\n    while (head != nullptr) {\n      stack.push(head);\n      head = head->getNext();\n    }\n\n    while (!stack.empty())\n      stack.top()->printValue(), stack.pop();\n  }\n};\n", "1266": "class Solution {\n public:\n  int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n    int ans = 0;\n\n    for (int i = 1; i < points.size(); ++i)\n      ans += max(abs(points[i][0] - points[i - 1][0]),\n                 abs(points[i][1] - points[i - 1][1]));\n\n    return ans;\n  }\n};\n", "1267": "class Solution {\n public:\n  int countServers(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    vector<int> rows(m);\n    vector<int> cols(n);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1) {\n          ++rows[i];\n          ++cols[j];\n        }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1))\n          ++ans;\n\n    return ans;\n  }\n};\n", "1268": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  const string* word = nullptr;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  vector<vector<string>> suggestedProducts(vector<string>& products,\n                                           string searchWord) {\n    vector<vector<string>> ans;\n\n    for (const string& product : products)\n      insert(product);\n\n    shared_ptr<TrieNode> node = root;\n\n    for (const char c : searchWord) {\n      if (node == nullptr || node->children[c - 'a'] == nullptr) {\n        node = nullptr;\n        ans.push_back({});\n        continue;\n      }\n      node = node->children[c - 'a'];\n      ans.push_back(search(node));\n    }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->word = &word;\n  }\n\n  vector<string> search(shared_ptr<TrieNode> node) {\n    vector<string> res;\n    dfs(node, res);\n    return res;\n  }\n\n  void dfs(shared_ptr<TrieNode> node, vector<string>& ans) {\n    if (ans.size() == 3)\n      return;\n    if (node == nullptr)\n      return;\n    if (node->word != nullptr)\n      ans.push_back(*node->word);\n    for (shared_ptr<TrieNode> child : node->children)\n      dfs(child, ans);\n  }\n};\n", "1269": "class Solution {\n public:\n  int numWays(int steps, int arrLen) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = min(arrLen, steps / 2 + 1);\n    // dp[i] := the number of ways to stay at index i\n    vector<long> dp(n);\n    dp[0] = 1;\n\n    while (steps-- > 0) {\n      vector<long> newDp(n);\n      for (int i = 0; i < n; ++i) {\n        newDp[i] = dp[i];\n        if (i - 1 >= 0)\n          newDp[i] += dp[i - 1];\n        if (i + 1 < n)\n          newDp[i] += dp[i + 1];\n        newDp[i] %= kMod;\n      }\n      dp = std::move(newDp);\n    }\n\n    return dp[0];\n  }\n};\n", "127": "class Solution {\n public:\n  int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> wordSet(wordList.begin(), wordList.end());\n    if (!wordSet.contains(endWord))\n      return 0;\n\n    queue<string> q{{beginWord}};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        string word = q.front();\n        q.pop();\n        for (int i = 0; i < word.length(); ++i) {\n          const char cache = word[i];\n          for (char c = 'a'; c <= 'z'; ++c) {\n            word[i] = c;\n            if (word == endWord)\n              return step + 1;\n            if (wordSet.contains(word)) {\n              q.push(word);\n              wordSet.erase(word);\n            }\n          }\n          word[i] = cache;\n        }\n      }\n\n    return 0;\n  }\n};\n", "1271": "class Solution {\n public:\n  string toHexspeak(string num) {\n    const long n = stol(num);\n    stringstream ss;\n    ss << hex << uppercase << n;\n    string ans(ss.str());\n\n    for (char& c : ans) {\n      if (c > '1' && c <= '9')\n        return \"ERROR\";\n      if (c == '0')\n        c = 'O';\n      else if (c == '1')\n        c = 'I';\n    }\n\n    return ans;\n  }\n};\n", "1272": "class Solution {\n public:\n  vector<vector<int>> removeInterval(vector<vector<int>>& intervals,\n                                     vector<int>& toBeRemoved) {\n    vector<vector<int>> ans;\n\n    for (const vector<int>& interval : intervals) {\n      const int a = interval[0];\n      const int b = interval[1];\n      if (a >= toBeRemoved[1] || b <= toBeRemoved[0]) {\n        ans.push_back(interval);\n      } else {  // a < toBeRemoved[1] && b > toBeRemoved[0]\n        if (a < toBeRemoved[0])\n          ans.push_back({a, toBeRemoved[0]});\n        if (b > toBeRemoved[1])\n          ans.push_back({toBeRemoved[1], b});\n      }\n    }\n\n    return ans;\n  }\n};\n", "1273": "struct T {\n  int sum;\n  int count;\n};\n\nclass Solution {\n public:\n  int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {\n    vector<vector<int>> tree(nodes);\n\n    for (int i = 1; i < parent.size(); ++i)\n      tree[parent[i]].push_back(i);\n\n    return dfs(tree, 0, value).count;\n  }\n\n private:\n  T dfs(const vector<vector<int>>& tree, int u, const vector<int>& value) {\n    int sum = value[u];  // the root value\n    int count = 1;       // this root\n\n    for (const int v : tree[u]) {\n      const T t = dfs(tree, v, value);\n      sum += t.sum;\n      count += t.count;\n    }\n\n    if (sum == 0)     // Delete this root.\n      return {0, 0};  // So, its count = 0.\n    return {sum, count};\n  }\n};\n", "1274": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *  public:\n *   bool hasShips(vector<int> topRight, vector<int> bottomLeft);\n * };\n */\n\nclass Solution {\n public:\n  int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {\n    if (topRight[0] < bottomLeft[0] || topRight[1] < bottomLeft[1])\n      return 0;\n    if (!sea.hasShips(topRight, bottomLeft))\n      return 0;\n\n    // sea.hashShips(topRight, bottomLeft) == true\n    if (topRight[0] == bottomLeft[0] && topRight[1] == bottomLeft[1])\n      return 1;\n\n    const int mx = (topRight[0] + bottomLeft[0]) / 2;\n    const int my = (topRight[1] + bottomLeft[1]) / 2;\n    int ans = 0;\n    // the top-right\n    ans += countShips(sea, topRight, {mx + 1, my + 1});\n    // the bottom-right\n    ans += countShips(sea, {topRight[0], my}, {mx + 1, bottomLeft[1]});\n    // the top-left\n    ans += countShips(sea, {mx, topRight[1]}, {bottomLeft[0], my + 1});\n    // the bottom-left\n    ans += countShips(sea, {mx, my}, bottomLeft);\n    return ans;\n  }\n};\n", "1275": "class Solution {\n public:\n  string tictactoe(vector<vector<int>>& moves) {\n    vector<vector<int>> row(2, vector<int>(3));\n    vector<vector<int>> col(2, vector<int>(3));\n    vector<int> diag1(2);\n    vector<int> diag2(2);\n\n    for (int i = 0; i < moves.size(); ++i) {\n      const int r = moves[i][0];\n      const int c = moves[i][1];\n      const int j = i & 1;\n      if (++row[j][r] == 3 || ++col[j][c] == 3 || r == c && ++diag1[j] == 3 ||\n          r + c == 2 && ++diag2[j] == 3)\n        return j == 0 ? \"A\" : \"B\";\n    }\n\n    return moves.size() == 9 ? \"Draw\" : \"Pending\";\n  }\n};\n", "1276": "class Solution {\n public:\n  vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\n    if (tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices ||\n        tomatoSlices > cheeseSlices * 4)\n      return {};\n\n    int jumboBurgers = (tomatoSlices - 2 * cheeseSlices) / 2;\n\n    return {jumboBurgers, cheeseSlices - jumboBurgers};\n  }\n};\n", "1277": "class Solution {\n public:\n  int countSquares(vector<vector<int>>& matrix) {\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        if (matrix[i][j] == 1 && i > 0 && j > 0)\n          matrix[i][j] +=\n              min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});\n    return accumulate(matrix.begin(), matrix.end(), 0,\n                      [](int subtotal, const vector<int>& row) {\n      return subtotal + accumulate(row.begin(), row.end(), 0);\n    });\n  }\n};\n", "1278": "class Solution {\n public:\n  int palindromePartition(string s, int K) {\n    const int n = s.length();\n    // dp[i][k] := the minimum cost to make k palindromes by s[0..i)\n    vector<vector<int>> dp(n + 1, vector<int>(K + 1, n));\n    // cost[i][j] := the minimum cost to make s[i..j] palindrome\n    vector<vector<int>> cost(n, vector<int>(n));\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0, j = d; j < n; ++i, ++j)\n        cost[i][j] = (s[i] != s[j]) + cost[i + 1][j - 1];\n\n    for (int i = 1; i <= n; ++i)\n      dp[i][1] = cost[0][i - 1];\n\n    for (int k = 2; k <= K; ++k)\n      for (int i = k; i <= n; ++i)\n        for (int j = k - 1; j < i; ++j)\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + cost[j][i - 1]);\n\n    return dp[n][K];\n  }\n};\n", "1279": "class TrafficLight {\n public:\n  void carArrived(\n      // ID of the car\n      int carId,\n      // ID of the road the car travels on. Can be 1 (road A) or 2 (road B).\n      int roadId,\n      // direction of the car\n      int direction,\n      // Use turnGreen() to turn light to green on current road.\n      function<void()> turnGreen,\n      // Use crossCar() to make car cross the intersection.\n      function<void()> crossCar\n\n  ) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (canPassRoadId != roadId) {\n      canPassRoadId = roadId;\n      turnGreen();\n    }\n    crossCar();\n  }\n\n private:\n  int canPassRoadId = 1;  // 1 := road A, 2 := road B\n  std::mutex mutex;\n};\n", "128": "class Solution {\n public:\n  int longestConsecutive(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> seen{nums.begin(), nums.end()};\n\n    for (int num : seen) {\n      // `num` is the start of a sequence.\n      if (seen.contains(num - 1))\n        continue;\n      int length = 1;\n      while (seen.contains(++num))\n        ++length;\n      ans = max(ans, length);\n    }\n\n    return ans;\n  }\n};\n", "1281": "class Solution {\n public:\n  int subtractProductAndSum(int n) {\n    int prod = 1;\n    int summ = 0;\n\n    for (; n > 0; n /= 10) {\n      prod *= n % 10;\n      summ += n % 10;\n    }\n\n    return prod - summ;\n  }\n};\n", "1282": "class Solution {\n public:\n  vector<vector<int>> groupThePeople(vector<int>& groupSizes) {\n    vector<vector<int>> ans;\n    unordered_map<int, vector<int>> groupSizeToIndices;\n\n    for (int i = 0; i < groupSizes.size(); ++i)\n      groupSizeToIndices[groupSizes[i]].push_back(i);\n\n    for (const auto& [groupSize, indices] : groupSizeToIndices) {\n      vector<int> groupIndices;\n      for (const int index : indices) {\n        groupIndices.push_back(index);\n        if (groupIndices.size() == groupSize) {\n          ans.push_back(groupIndices);\n          groupIndices.clear();\n        }\n      }\n    }\n\n    return ans;\n  }\n};\n", "1283": "class Solution {\n public:\n  int smallestDivisor(vector<int>& nums, int threshold) {\n    int l = 1;\n    int r = ranges::max(nums);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (sumDivision(nums, m) <= threshold)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int sumDivision(const vector<int>& nums, int m) {\n    int sum = 0;\n    for (const int num : nums)\n      sum += (num - 1) / m + 1;\n    return sum;\n  }\n};\n", "1284": "class Solution {\n public:\n  int minFlips(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    const int hash = getHash(mat, m, n);\n    if (hash == 0)\n      return 0;\n\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    queue<int> q{{hash}};\n    unordered_set<int> seen{hash};\n\n    for (int step = 1; !q.empty(); ++step) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int curr = q.front();\n        q.pop();\n        for (int i = 0; i < m; ++i) {\n          for (int j = 0; j < n; ++j) {\n            int next = curr ^ 1 << (i * n + j);\n            // Flie the four neighbors.\n            for (const auto& [dx, dy] : kDirs) {\n              const int x = i + dx;\n              const int y = j + dy;\n              if (x < 0 || x == m || y < 0 || y == n)\n                continue;\n              next ^= 1 << (x * n + y);\n            }\n            if (next == 0)\n              return step;\n            if (seen.contains(next))\n              continue;\n            q.push(next);\n            seen.insert(next);\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n\n private:\n  int getHash(const vector<vector<int>>& mat, int m, int n) {\n    int hash = 0;\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j])\n          hash |= 1 << (i * n + j);\n    return hash;\n  }\n};\n", "1287": "class Solution {\n public:\n  int findSpecialInteger(vector<int>& arr) {\n    const int n = arr.size();\n    const int quarter = n / 4;\n\n    for (int i = 0; i < n - quarter; ++i)\n      if (arr[i] == arr[i + quarter])\n        return arr[i];\n\n    throw;\n  }\n};\n", "1288": "class Solution {\n public:\n  int removeCoveredIntervals(vector<vector<int>>& intervals) {\n    ranges::sort(intervals, ranges::less{}, [](const vector<int>& interval) {\n      const int l = interval[0];\n      const int r = interval[1];\n      return pair<int, int>{l, -r};\n    });\n\n    int ans = 0;\n    int prevEnd = 0;\n\n    for (const vector<int>& interval : intervals)\n      // The current interval is not covered by the previous one.\n      if (prevEnd < interval[1]) {\n        prevEnd = interval[1];\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "1289": "class Solution {\n public:\n  int minFallingPathSum(vector<vector<int>>& grid) {\n    const int n = grid.size();\n\n    for (int i = 1; i < n; ++i) {\n      const vector<pair<int, int>> twoMinNumAndIndexs =\n          getTwoMinNumAndIndexs(grid[i - 1]);\n      const auto& [firstMinNum, firstMinIndex] = twoMinNumAndIndexs[0];\n      const auto& [secondMinNum, _] = twoMinNumAndIndexs[1];\n      for (int j = 0; j < n; ++j)\n        if (j == firstMinIndex)\n          grid[i][j] += secondMinNum;\n        else\n          grid[i][j] += firstMinNum;\n    }\n\n    return ranges::min(grid.back());\n  }\n\n private:\n  vector<pair<int, int>> getTwoMinNumAndIndexs(const vector<int>& A) {\n    vector<pair<int, int>> numAndIndexs;\n    for (int i = 0; i < A.size(); ++i)\n      numAndIndexs.emplace_back(A[i], i);\n    ranges::sort(numAndIndexs);\n    return {numAndIndexs[0], numAndIndexs[1]};\n  }\n};\n", "129": "class Solution {\n public:\n  int sumNumbers(TreeNode* root) {\n    int ans = 0;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int path, int& ans) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      ans += path * 10 + root->val;\n      return;\n    }\n\n    dfs(root->left, path * 10 + root->val, ans);\n    dfs(root->right, path * 10 + root->val, ans);\n  }\n};\n", "1290": "class Solution {\n public:\n  int getDecimalValue(ListNode* head) {\n    int ans = 0;\n\n    for (; head; head = head->next)\n      ans = ans * 2 + head->val;\n\n    return ans;\n  }\n};\n", "1291": "class Solution {\n public:\n  vector<int> sequentialDigits(int low, int high) {\n    vector<int> ans;\n    queue<int> q{{1, 2, 3, 4, 5, 6, 7, 8, 9}};\n\n    while (!q.empty()) {\n      const int num = q.front();\n      q.pop();\n      if (num > high)\n        return ans;\n      if (low <= num && num <= high)\n        ans.push_back(num);\n      const int lastDigit = num % 10;\n      if (lastDigit < 9)\n        q.push(num * 10 + lastDigit + 1);\n    }\n\n    return ans;\n  }\n};\n", "1292": "class Solution {\n public:\n  int maxSideLength(vector<vector<int>>& mat, int threshold) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    int ans = 0;\n    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] =\n            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int length = ans; length < min(m - i, n - j); ++length) {\n          if (squareSum(prefix, i, j, i + length, j + length) > threshold)\n            break;\n          ans = max(ans, length + 1);\n        }\n\n    return ans;\n  }\n\n private:\n  int squareSum(vector<vector<int>>& prefix, int r1, int c1, int r2, int c2) {\n    return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] +\n           prefix[r1][c1];\n  }\n};\n", "1293": "class Solution {\n public:\n  int shortestPath(vector<vector<int>>& grid, int k) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    if (m == 1 && n == 1)\n      return 0;\n\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    queue<tuple<int, int, int>> q{{{0, 0, k}}};  // (i, j, eliminate)\n    vector<vector<vector<bool>>> seen(\n        m, vector<vector<bool>>(n, vector<bool>(k + 1)));\n    seen[0][0][k] = true;\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j, eliminate] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (x == m - 1 && y == n - 1)\n            return step;\n          if (grid[x][y] == 1 && eliminate == 0)\n            continue;\n          const int newEliminate = eliminate - grid[x][y];\n          if (seen[x][y][newEliminate])\n            continue;\n          q.emplace(x, y, newEliminate);\n          seen[x][y][newEliminate] = true;\n        }\n      }\n\n    return -1;\n  }\n};\n", "1295": "class Solution {\n public:\n  int findNumbers(vector<int>& nums) {\n    int ans = 0;\n\n    for (int num : nums)\n      if (9 < num && num < 100 || 999 < num && num < 10000 || num == 100000)\n        ++ans;\n\n    return ans;\n  }\n};\n", "1296": "class Solution {\n public:\n  bool isPossibleDivide(vector<int>& nums, int k) {\n    map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [start, _] : count) {\n      const int value = count[start];\n      if (value > 0)\n        for (int i = start; i < start + k; ++i) {\n          count[i] -= value;\n          if (count[i] < 0)\n            return false;\n        }\n    }\n\n    return true;\n  }\n};\n", "1297": "class Solution {\n public:\n  int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\n    // Greedily consider strings with `minSize`, so ignore `maxSize`.\n    int ans = 0;\n    int letters = 0;\n    vector<int> count(26);\n    unordered_map<string, int> substringCount;\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r] - 'a'] == 1)\n        ++letters;\n      while (letters > maxLetters || r - l + 1 > minSize)\n        if (--count[s[l++] - 'a'] == 0)\n          --letters;\n      if (r - l + 1 == minSize)\n        ans = max(ans, ++substringCount[s.substr(l, minSize)]);\n    }\n\n    return ans;\n  }\n};\n", "1298": "class Solution {\n public:\n  int maxCandies(vector<int>& status, vector<int>& candies,\n                 vector<vector<int>>& keys, vector<vector<int>>& containedBoxes,\n                 vector<int>& initialBoxes) {\n    int ans = 0;\n    queue<int> q;\n    vector<bool> reachedClosedBoxes(status.size());\n\n    auto pushBoxesIfPossible = [&status, &q,\n                                &reachedClosedBoxes](const vector<int>& boxes) {\n      for (const int box : boxes)\n        if (status[box])\n          q.push(box);\n        else\n          reachedClosedBoxes[box] = true;\n    };\n\n    pushBoxesIfPossible(initialBoxes);\n\n    while (!q.empty()) {\n      const int currBox = q.front();\n      q.pop();\n\n      // Add the candies.\n      ans += candies[currBox];\n\n      // Push `reachedClosedBoxes` by `key` obtained in this turn and change\n      // their statuses.\n      for (const int key : keys[currBox]) {\n        if (!status[key] && reachedClosedBoxes[key])\n          q.push(key);\n        status[key] = 1;  // boxes[key] is now open.\n      }\n\n      // Push the boxes contained in `currBox`.\n      pushBoxesIfPossible(containedBoxes[currBox]);\n    }\n\n    return ans;\n  }\n};\n", "1299": "class Solution {\n public:\n  vector<int> replaceElements(vector<int>& arr) {\n    int maxOfRight = -1;\n    for (int i = arr.size() - 1; i >= 0; --i)\n      maxOfRight = max(maxOfRight, exchange(arr[i], maxOfRight));\n    return arr;\n  }\n};\n", "13": "class Solution {\n public:\n  int romanToInt(string s) {\n    int ans = 0;\n    vector<int> roman(128);\n\n    roman['I'] = 1;\n    roman['V'] = 5;\n    roman['X'] = 10;\n    roman['L'] = 50;\n    roman['C'] = 100;\n    roman['D'] = 500;\n    roman['M'] = 1000;\n\n    for (int i = 0; i + 1 < s.length(); ++i)\n      if (roman[s[i]] < roman[s[i + 1]])\n        ans -= roman[s[i]];\n      else\n        ans += roman[s[i]];\n\n    return ans + roman[s.back()];\n  }\n};\n", "130": "class Solution {\n public:\n  void solve(vector<vector<char>>& board) {\n    if (board.empty())\n      return;\n\n    const int m = board.size();\n    const int n = board[0].size();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i * j == 0 || i == m - 1 || j == n - 1)\n          dfs(board, i, j);\n\n    for (vector<char>& row : board)\n      for (char& c : row)\n        if (c == '*')\n          c = 'O';\n        else if (c == 'O')\n          c = 'X';\n  }\n\n private:\n  // Marks the grids with 'O' that stretch from the four sides to '*'.\n  void dfs(vector<vector<char>>& board, int i, int j) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return;\n    if (board[i][j] != 'O')\n      return;\n    board[i][j] = '*';\n    dfs(board, i + 1, j);\n    dfs(board, i - 1, j);\n    dfs(board, i, j + 1);\n    dfs(board, i, j - 1);\n  }\n};\n", "1300": "class Solution {\n public:\n  int findBestValue(vector<int>& arr, int target) {\n    const int n = arr.size();\n    const double err = 1e-9;\n\n    int prefix = 0;\n\n    ranges::sort(arr);\n\n    for (int i = 0; i < n; ++i) {\n      int ans = round((target - prefix - err) / (double)(n - i));\n      if (ans <= arr[i])\n        return ans;\n      prefix += arr[i];\n    }\n\n    return arr.back();\n  }\n};\n", "1301": "class Solution {\n public:\n  vector<int> pathsWithMaxScore(vector<string>& board) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kDirs[3][2] = {{0, 1}, {1, 0}, {1, 1}};\n    const int n = board.size();\n    // dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\n    // count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to\n    // (i, j)\n    vector<vector<int>> count(n + 1, vector<int>(n + 1));\n\n    dp[0][0] = 0;\n    dp[n - 1][n - 1] = 0;\n    count[n - 1][n - 1] = 1;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        if (board[i][j] == 'S' || board[i][j] == 'X')\n          continue;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (dp[i][j] < dp[x][y]) {\n            dp[i][j] = dp[x][y];\n            count[i][j] = count[x][y];\n          } else if (dp[i][j] == dp[x][y]) {\n            count[i][j] += count[x][y];\n            count[i][j] %= kMod;\n          }\n        }\n        // If there's path(s) from 'S' to (i, j) and the cell is not 'E'.\n        if (dp[i][j] != -1 && board[i][j] != 'E') {\n          dp[i][j] += board[i][j] - '0';\n          dp[i][j] %= kMod;\n        }\n      }\n\n    return {dp[0][0], count[0][0]};\n  }\n};\n", "1302": "class Solution {\n public:\n  int deepestLeavesSum(TreeNode* root) {\n    int ans = 0;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      ans = 0;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        ans += node->val;\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1304": "class Solution {\n public:\n  vector<int> sumZero(int n) {\n    vector<int> ans(n);\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = i * 2 - n + 1;\n\n    return ans;\n  }\n};\n", "1305": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root) {\n    pushLeftsUntilNull(root);\n  }\n\n  int peek() {\n    return stack.top()->val;\n  }\n\n  void next() {\n    TreeNode* node = stack.top();\n    stack.pop();\n    pushLeftsUntilNull(node->right);\n  }\n\n  bool hasNext() {\n    return !stack.empty();\n  }\n\n private:\n  stack<TreeNode*> stack;\n\n  void pushLeftsUntilNull(TreeNode* node) {\n    while (node != nullptr) {\n      stack.push(node);\n      node = node->left;\n    }\n  }\n};\n\nclass Solution {\n public:\n  vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> ans;\n    BSTIterator bstIterator1(root1);\n    BSTIterator bstIterator2(root2);\n\n    while (bstIterator1.hasNext() && bstIterator2.hasNext())\n      if (bstIterator1.peek() < bstIterator2.peek()) {\n        ans.push_back(bstIterator1.peek());\n        bstIterator1.next();\n      } else {\n        ans.push_back(bstIterator2.peek());\n        bstIterator2.next();\n      }\n\n    while (bstIterator1.hasNext()) {\n      ans.push_back(bstIterator1.peek());\n      bstIterator1.next();\n    }\n\n    while (bstIterator2.hasNext()) {\n      ans.push_back(bstIterator2.peek());\n      bstIterator2.next();\n    }\n\n    return ans;\n  }\n};\n", "1306": "class Solution {\n public:\n  bool canReach(vector<int>& arr, int start) {\n    return canReach(arr, start, vector<bool>(arr.size()));\n  }\n\n private:\n  bool canReach(const vector<int>& arr, int node, vector<bool>&& seen) {\n    if (node < 0 || node >= arr.size())\n      return false;\n    if (seen[node])\n      return false;\n    if (arr[node] == 0)\n      return true;\n    seen[node] = true;\n    return canReach(arr, node + arr[node], std::move(seen)) ||\n           canReach(arr, node - arr[node], std::move(seen));\n  }\n};\n", "1307": "class Solution {\n public:\n  bool isSolvable(vector<string>& words, string result) {\n    usedDigit = vector<bool>(10);\n    words.push_back(result);\n    rows = words.size();\n    for (const string& word : words)\n      cols = max(cols, static_cast<int>(word.length()));\n    return dfs(words, 0, 0, 0);\n  }\n\n private:\n  unordered_map<char, int> letterToDigit;\n  vector<bool> usedDigit;\n  int rows;\n  int cols;\n\n  bool dfs(vector<string>& words, int row, int col, int sum) {\n    if (col == cols)\n      return sum == 0;\n    if (row == rows)\n      return sum % 10 == 0 && dfs(words, 0, col + 1, sum / 10);\n\n    string word = words[row];\n    if (col >= word.length())\n      return dfs(words, row + 1, col, sum);\n\n    char letter = word[word.length() - col - 1];\n    int sign = row == rows - 1 ? -1 : 1;\n\n    if (const auto it = letterToDigit.find(letter);\n        it != letterToDigit.cend() &&\n        (it->second > 0 || col < word.length() - 1))\n      return dfs(words, row + 1, col, sum + sign * letterToDigit[letter]);\n\n    for (int digit = 0; digit < 10; ++digit)\n      if (!usedDigit[digit] && (digit > 0 || col + 1 < word.length())) {\n        letterToDigit[letter] = digit;\n        usedDigit[digit] = true;\n        if (dfs(words, row + 1, col, sum + sign * digit))\n          return true;\n        usedDigit[digit] = false;\n        letterToDigit.erase(letter);\n      }\n\n    return false;\n  }\n};\n", "1309": "class Solution {\n public:\n  string freqAlphabets(string s) {\n    string ans;\n\n    for (int i = 0; i < s.length();) {\n      if (i + 2 < s.length() && s[i + 2] == '#') {\n        ans += stoi(s.substr(i, 2)) + 'a' - 1;\n        i += 3;\n      } else {\n        ans += (s[i] - '0') + 'a' - 1;\n        i += 1;\n      }\n    }\n\n    return ans;\n  }\n};\n", "131": "class Solution {\n public:\n  vector<vector<string>> partition(string s) {\n    vector<vector<string>> ans;\n    dfs(s, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int start, vector<string>&& path,\n           vector<vector<string>>& ans) {\n    if (start == s.length()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = start; i < s.length(); ++i)\n      if (isPalindrome(s, start, i)) {\n        path.push_back(s.substr(start, i - start + 1));\n        dfs(s, i + 1, std::move(path), ans);\n        path.pop_back();\n      }\n  }\n\n  bool isPalindrome(const string& s, int l, int r) {\n    while (l < r)\n      if (s[l++] != s[r--])\n        return false;\n    return true;\n  }\n};\n", "1310": "class Solution {\n public:\n  vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> xors(arr.size() + 1);\n\n    for (int i = 0; i < arr.size(); ++i)\n      xors[i + 1] = xors[i] ^ arr[i];\n\n    for (const vector<int>& query : queries) {\n      const int left = query[0];\n      const int right = query[1];\n      ans.push_back(xors[left] ^ xors[right + 1]);\n    }\n\n    return ans;\n  }\n};\n", "1311": "class Solution {\n public:\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,\n                                        vector<vector<int>>& friends, int id,\n                                        int level) {\n    vector<string> ans;\n    queue<int> q{{id}};\n    vector<bool> seen(friends.size());\n    seen[id] = true;\n    unordered_map<string, int> count;\n    set<pair<int, string>> freqAndVideo;\n\n    for (int i = 0; i < level; ++i)\n      for (int sz = q.size(); sz > 0; --sz) {\n        for (const int friend_ : friends[q.front()])\n          if (!seen[friend_]) {\n            seen[friend_] = true;\n            q.push(friend_);\n          }\n        q.pop();\n      }\n\n    for (int i = q.size(); i > 0; --i) {\n      for (const string& video : watchedVideos[q.front()])\n        ++count[video];\n      q.pop();\n    }\n\n    for (const auto& [video, freq] : count)\n      freqAndVideo.insert({freq, video});\n\n    for (const auto& [_, video] : freqAndVideo)\n      ans.push_back(video);\n\n    return ans;\n  }\n};\n", "1312": "class Solution {\n public:\n  int minInsertions(string s) {\n    return s.length() - longestPalindromeSubseq(s);\n  }\n\n private:\n  // Same as 516. Longest Palindromic Subsequence\n  int longestPalindromeSubseq(const string& s) {\n    const int n = s.length();\n    // dp[i][j] := the length of LPS(s[i..j])\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j])\n          dp[i][j] = 2 + dp[i + 1][j - 1];\n        else\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "1313": "class Solution {\n public:\n  vector<int> decompressRLElist(vector<int>& nums) {\n    vector<int> ans;\n\n    for (int i = 0; i < nums.size(); i += 2)\n      ans.insert(ans.end(), nums[i], nums[i + 1]);\n\n    return ans;\n  }\n};\n", "1314": "class Solution {\n public:\n  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] =\n            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        const int r1 = max(0, i - k) + 1;\n        const int c1 = max(0, j - k) + 1;\n        const int r2 = min(m - 1, i + k) + 1;\n        const int c2 = min(n - 1, j + k) + 1;\n        ans[i][j] = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] +\n                    prefix[r1 - 1][c1 - 1];\n      }\n\n    return ans;\n  }\n};\n", "1315": "class Solution {\n public:\n  int sumEvenGrandparent(TreeNode* root) {\n    return dfs(root, 1, 1);  // The parent and the grandparent are odd at first.\n  }\n\n private:\n  int dfs(TreeNode* root, int p, int gp) {\n    if (root == nullptr)\n      return 0;\n    return (gp % 2 == 0 ? root->val : 0) +  //\n           dfs(root->left, root->val, p) +  //\n           dfs(root->right, root->val, p);\n  }\n};\n", "1316": "class Solution {\n public:\n  int distinctEchoSubstrings(string text) {\n    unordered_set<string> seen;\n\n    for (int k = 1; k <= text.length() / 2; ++k) {  // the target length\n      int same = 0;\n      for (int l = 0, r = k; r < text.length(); ++l, ++r) {\n        if (text[l] == text[r])\n          ++same;\n        else\n          same = 0;\n        if (same == k) {\n          seen.insert(text.substr(l - k + 1, k));\n          // Move the window thus leaving a letter behind, so we need to\n          // decrease the counter.\n          --same;\n        }\n      }\n    }\n\n    return seen.size();\n  }\n};\n", "1317": "class Solution {\n public:\n  vector<int> getNoZeroIntegers(int n) {\n    for (int A = 1; A < n; ++A) {\n      int B = n - A;\n      if (to_string(A).find('0') == string::npos &&\n          to_string(B).find('0') == string::npos)\n        return {A, B};\n    }\n\n    throw;\n  }\n};\n", "1318": "class Solution {\n public:\n  int minFlips(int a, int b, int c) {\n    constexpr int kMaxBit = 30;\n    int ans = 0;\n\n    for (int i = 0; i < kMaxBit; ++i)\n      if (c >> i & 1)\n        ans += (a >> i & 1) == 0 && (b >> i & 1) == 0;\n      else  // (c >> i & 1) == 0\n        ans += (a >> i & 1) + (b >> i & 1);\n\n    return ans;\n  }\n};\n", "1319": "class Solution {\n public:\n  int makeConnected(int n, vector<vector<int>>& connections) {\n    // To connect n nodes, we need at least n - 1 edges\n    if (connections.size() < n - 1)\n      return -1;\n\n    int numOfConnected = 0;\n    vector<vector<int>> graph(n);\n    unordered_set<int> seen;\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (seen.insert(i).second) {\n        dfs(graph, i, seen);\n        ++numOfConnected;\n      }\n\n    return numOfConnected - 1;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {\n    for (const int v : graph[u])\n      if (seen.insert(v).second)\n        dfs(graph, v, seen);\n  }\n};\n", "132": "class Solution {\n public:\n  int minCut(string s) {\n    const int n = s.length();\n    // isPalindrome[i][j] := true if s[i..j] is a palindrome\n    vector<vector<bool>> isPalindrome(n, vector<bool>(n, true));\n    // dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]\n    vector<int> dp(n, n);\n\n    for (int l = 2; l <= n; ++l)\n      for (int i = 0, j = l - 1; j < n; ++i, ++j)\n        isPalindrome[i][j] = s[i] == s[j] && isPalindrome[i + 1][j - 1];\n\n    for (int i = 0; i < n; ++i) {\n      if (isPalindrome[0][i]) {\n        dp[i] = 0;\n        continue;\n      }\n\n      // Try all the possible partitions.\n      for (int j = 0; j < i; ++j)\n        if (isPalindrome[j + 1][i])\n          dp[i] = min(dp[i], dp[j] + 1);\n    }\n\n    return dp.back();\n  }\n};\n", "1320": "class Solution {\n public:\n  int minimumDistance(string word) {\n    vector<vector<vector<int>>> mem(\n        27, vector<vector<int>>(27, vector<int>(word.length(), -1)));\n    return minimumDistance(word, 26, 26, 0, mem);\n  }\n\n private:\n  // Returns the minimum distance to type `word`, where the left finger is on\n  // the i-th letter, the right finger is on the j-th letter, and word[0..k)\n  // have been written.\n  int minimumDistance(const string& word, int i, int j, int k,\n                      vector<vector<vector<int>>>& mem) {\n    if (k == word.length())\n      return 0;\n    if (mem[i][j][k] != -1)\n      return mem[i][j][k];\n    const int c = word[k] - 'A';\n    const int moveLeft = dist(i, c) + minimumDistance(word, c, j, k + 1, mem);\n    const int moveRight = dist(j, c) + minimumDistance(word, i, c, k + 1, mem);\n    return mem[i][j][k] = min(moveLeft, moveRight);\n  }\n\n  int dist(int a, int b) {\n    if (a == 26)  // the first hovering state\n      return 0;\n    const int x1 = a / 6;\n    const int y1 = a % 6;\n    const int x2 = b / 6;\n    const int y2 = b % 6;\n    return abs(x1 - x2) + abs(y1 - y2);\n  }\n};\n", "1323": "class Solution {\n public:\n  int maximum69Number(int num) {\n    string ans = to_string(num);\n\n    for (char& c : ans)\n      if (c == '6') {\n        c = '9';\n        break;\n      }\n\n    return stoi(ans);\n  }\n};\n", "1324": "class Solution {\n public:\n  vector<string> printVertically(string s) {\n    vector<string> ans;\n    vector<string> words = split(s);\n    size_t maxLength = 0;\n\n    for (const string& word : words)\n      maxLength = max(maxLength, word.length());\n\n    for (size_t i = 0; i < maxLength; ++i) {\n      string row;\n      for (const string& word : words)\n        row += i < word.length() ? word[i] : ' ';\n      while (row.back() == ' ')\n        row.pop_back();\n      ans.push_back(row);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<string> split(const string& s) {\n    vector<string> words;\n    istringstream iss(s);\n    for (string token; iss >> token;)\n      words.push_back(token);\n    return words;\n  }\n};\n", "1325": "class Solution {\n public:\n  TreeNode* removeLeafNodes(TreeNode* root, int target) {\n    if (root == nullptr)\n      return nullptr;\n    root->left = removeLeafNodes(root->left, target);\n    root->right = removeLeafNodes(root->right, target);\n    return isLeaf(root) && root->val == target ? nullptr : root;\n  }\n\n private:\n  bool isLeaf(TreeNode* root) {\n    return root->left == nullptr && root->right == nullptr;\n  }\n};\n", "1326": "class Solution {\n public:\n  int minTaps(int n, vector<int>& ranges) {\n    vector<int> nums(n + 1);\n\n    for (int i = 0; i <= n; ++i) {\n      int l = max(0, i - ranges[i]);\n      int r = min(n, i + ranges[i]);\n      nums[l] = max(nums[l], r - l);\n    }\n\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    for (int i = 0; i < n; i++) {\n      farthest = max(farthest, i + nums[i]);\n      if (i == end) {\n        ++ans;\n        end = farthest;\n      }\n    }\n\n    return end == n ? ans : -1;\n  }\n};\n", "1328": "class Solution {\n public:\n  string breakPalindrome(string palindrome) {\n    if (palindrome.length() == 1)\n      return \"\";\n\n    for (int i = 0; i < palindrome.length() / 2; ++i)\n      if (palindrome[i] != 'a') {\n        palindrome[i] = 'a';\n        return palindrome;\n      }\n\n    palindrome.back() = 'b';\n    return palindrome;\n  }\n};\n", "1329": "class Solution {\n public:\n  vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n\n    unordered_map<int, priority_queue<int>> count;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        count[i - j].push(mat[i][j]);\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j)\n        mat[i][j] = count[i - j].top(), count[i - j].pop();\n\n    return mat;\n  }\n};\n", "133": "class Solution {\n public:\n  Node* cloneGraph(Node* node) {\n    if (node == nullptr)\n      return nullptr;\n    if (const auto it = map.find(node); it != map.cend())\n      return it->second;\n\n    Node* newNode = new Node(node->val);\n    map[node] = newNode;\n\n    for (Node* neighbor : node->neighbors)\n      newNode->neighbors.push_back(cloneGraph(neighbor));\n\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, Node*> map;\n};\n", "1330": "class Solution {\n public:\n  int maxValueAfterReverse(vector<int>& nums) {\n    int total = 0;\n    int mn = INT_MAX;\n    int mx = INT_MIN;\n\n    for (int i = 0; i + 1 < nums.size(); ++i) {\n      const int a = nums[i];\n      const int b = nums[i + 1];\n      total += abs(a - b);\n      mn = min(mn, max(a, b));\n      mx = max(mx, min(a, b));\n    }\n    int diff = max(0, (mx - mn) * 2);\n\n    for (int i = 0; i + 1 < nums.size(); ++i) {\n      const int a = nums[i];\n      const int b = nums[i + 1];\n      const int headDiff = -abs(a - b) + abs(nums.front() - b);\n      const int tailDiff = -abs(a - b) + abs(nums.back() - a);\n      diff = max({diff, headDiff, tailDiff});\n    }\n\n    return total + diff;\n  }\n};\n", "1331": "class Solution {\n public:\n  vector<int> arrayRankTransform(vector<int>& arr) {\n    vector<int> sortedArr(arr);\n    unordered_map<int, int> rank;\n\n    ranges::sort(sortedArr);\n\n    for (const int a : sortedArr)\n      if (!rank.contains(a))\n        rank[a] = rank.size() + 1;\n\n    for (int& a : arr)\n      a = rank[a];\n\n    return arr;\n  }\n};\n", "1332": "class Solution {\n public:\n  int removePalindromeSub(string s) {\n    return equal(s.begin(), s.end(), s.rbegin()) ? 1 : 2;\n  }\n};\n", "1333": "class Solution {\n public:\n  vector<int> filterRestaurants(vector<vector<int>>& restaurants,\n                                int veganFriendly, int maxPrice,\n                                int maxDistance) {\n    vector<int> ans;\n    vector<vector<int>> filteredRestaurants;\n\n    for (const vector<int>& restaurant : restaurants)\n      if (restaurant[2] >= veganFriendly && restaurant[3] <= maxPrice &&\n          restaurant[4] <= maxDistance)\n        filteredRestaurants.push_back(restaurant);\n\n    ranges::sort(filteredRestaurants, ranges::less{},\n                 [](const vector<int>& restaurant) {\n      const int rating = restaurant[1];\n      const int id = restaurant[0];\n      return pair<int, int>{-rating, -id};\n    });\n\n    for (const vector<int>& restaurant : filteredRestaurants)\n      ans.push_back(restaurant[0]);\n\n    return ans;\n  }\n};\n", "1334": "class Solution {\n public:\n  int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n    int ans = -1;\n    int minCitiesCount = n;\n    const vector<vector<int>> dist = floydWarshall(n, edges, distanceThreshold);\n\n    for (int i = 0; i < n; ++i) {\n      int citiesCount = 0;\n      for (int j = 0; j < n; ++j)\n        if (dist[i][j] <= distanceThreshold)\n          ++citiesCount;\n      if (citiesCount <= minCitiesCount) {\n        ans = i;\n        minCitiesCount = citiesCount;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges,\n                                    int distanceThreshold) {\n    vector<vector<int>> dist(n, vector<int>(n, distanceThreshold + 1));\n\n    for (int i = 0; i < n; ++i)\n      dist[i][i] = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      dist[u][v] = w;\n      dist[v][u] = w;\n    }\n\n    for (int k = 0; k < n; ++k)\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    return dist;\n  }\n};\n", "1335": "class Solution {\n public:\n  int minDifficulty(vector<int>& jobDifficulty, int d) {\n    const int n = jobDifficulty.size();\n    if (n < d)\n      return -1;\n\n    // dp[i][k] := the minimum difficulty to schedule the first i jobs in k days\n    vector<vector<int>> dp(n + 1, vector<int>(d + 1, INT_MAX / 2));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i)\n      for (int k = 1; k <= d; ++k) {\n        int maxDifficulty = 0;                  // max(job[j + 1..i])\n        for (int j = i - 1; j >= k - 1; --j) {  // 1-based\n          maxDifficulty = max(maxDifficulty, jobDifficulty[j]);  // 0-based\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty);\n        }\n      }\n\n    return dp[n][d];\n  }\n};\n", "1337": "class Solution {\n public:\n  vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n    vector<int> ans;\n    vector<pair<int, int>> rowSums;  // (sum(mat[i]), i)\n\n    for (int i = 0; i < mat.size(); ++i)\n      rowSums.emplace_back(accumulate(mat[i].begin(), mat[i].end(), 0), i);\n\n    ranges::sort(rowSums, ranges::less{},\n                 [](const pair<int, int>& rowSum) { return rowSum; });\n\n    for (int i = 0; i < k; ++i)\n      ans.push_back(rowSums[i].second);\n\n    return ans;\n  }\n};\n", "1338": "class Solution {\n public:\n  int minSetSize(vector<int>& arr) {\n    const int n = arr.size();\n    int sum = 0;\n    unordered_map<int, int> count;\n    vector<pair<int, int>> numAndFreqs;\n\n    for (const int a : arr)\n      ++count[a];\n\n    for (const auto& [a, freq] : count)\n      numAndFreqs.emplace_back(a, freq);\n\n    ranges::sort(\n        numAndFreqs, ranges::greater{},\n        [](const pair<int, int>& numAndFreq) { return numAndFreq.second; });\n\n    for (int i = 0; i < numAndFreqs.size(); ++i) {\n      sum += numAndFreqs[i].second;\n      if (sum >= n / 2)\n        return i + 1;\n    }\n\n    throw;\n  }\n};\n", "1339": "class Solution {\n public:\n  int maxProduct(TreeNode* root) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    vector<int> allSums;\n    const long totalSum = treeSum(root, allSums);\n\n    for (const long sum : allSums)\n      ans = max(ans, sum * (totalSum - sum));\n\n    return ans % kMod;\n  }\n\n private:\n  int treeSum(TreeNode* root, vector<int>& allSums) {\n    if (root == nullptr)\n      return 0;\n\n    const int leftSum = treeSum(root->left, allSums);\n    const int rightSum = treeSum(root->right, allSums);\n    const int sum = root->val + leftSum + rightSum;\n    allSums.push_back(sum);\n    return sum;\n  }\n};\n", "134": "class Solution {\n public:\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n    const int gasSum = accumulate(gas.begin(), gas.end(), 0);\n    const int costSum = accumulate(cost.begin(), cost.end(), 0);\n    if (gasSum - costSum < 0)\n      return -1;\n\n    int ans = 0;\n    int sum = 0;\n\n    // Try to start from each index.\n    for (int i = 0; i < gas.size(); ++i) {\n      sum += gas[i] - cost[i];\n      if (sum < 0) {\n        sum = 0;\n        ans = i + 1;  // Start from the next index.\n      }\n    }\n\n    return ans;\n  }\n};\n", "1340": "class Solution {\n public:\n  int maxJumps(vector<int>& arr, int d) {\n    const int n = arr.size();\n    // dp[i] := the maximum jumps starting from arr[i]\n    vector<int> dp(n, 1);\n    // a dcreasing stack that stores indices\n    stack<int> stack;\n\n    for (int i = 0; i <= n; ++i) {\n      while (!stack.empty() && (i == n || arr[stack.top()] < arr[i])) {\n        vector<int> indices{stack.top()};\n        stack.pop();\n        while (!stack.empty() && arr[stack.top()] == arr[indices[0]])\n          indices.push_back(stack.top()), stack.pop();\n        for (const int j : indices) {\n          if (i < n && i - j <= d)\n            // Can jump from i to j.\n            dp[i] = max(dp[i], dp[j] + 1);\n          if (!stack.empty() && j - stack.top() <= d)\n            // Can jump from stack[-1] to j.\n            dp[stack.top()] = max(dp[stack.top()], dp[j] + 1);\n        }\n      }\n      stack.push(i);\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "1342": "class Solution {\n public:\n  int numberOfSteps(unsigned num) {\n    if (num == 0)\n      return 0;\n    const int subtractSteps = popcount(num);\n    const int divideSteps = 31 - __builtin_clz(num);\n    return subtractSteps + divideSteps;\n  }\n};\n", "1343": "class Solution {\n public:\n  int numOfSubarrays(vector<int>& arr, int k, int threshold) {\n    int ans = 0;\n    int windowSum = 0;\n\n    for (int i = 0; i < arr.size(); ++i) {\n      windowSum += arr[i];\n      if (i >= k)\n        windowSum -= arr[i - k];\n      if (i >= k - 1 && windowSum / k >= threshold)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1344": "class Solution {\n public:\n  double angleClock(int hour, int minutes) {\n    const double hourHand = (hour % 12 + minutes / 60.0) * 30;\n    const double minuteHand = minutes * 6;\n    const double diff = abs(hourHand - minuteHand);\n    return min(diff, 360 - diff);\n  }\n};\n", "1345": "class Solution {\n public:\n  int minJumps(vector<int>& arr) {\n    const int n = arr.size();\n    // {a: indices}\n    unordered_map<int, vector<int>> graph;\n    queue<int> q{{0}};\n    vector<bool> seen(n);\n    seen[0] = true;\n\n    for (int i = 0; i < n; ++i)\n      graph[arr[i]].push_back(i);\n\n    for (int step = 0; !q.empty(); ++step) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int i = q.front();\n        q.pop();\n        if (i == n - 1)\n          return step;\n        seen[i] = true;\n        const int u = arr[i];\n        if (i + 1 < n)\n          graph[u].push_back(i + 1);\n        if (i - 1 >= 0)\n          graph[u].push_back(i - 1);\n        for (const int v : graph[u]) {\n          if (seen[v])\n            continue;\n          q.push(v);\n        }\n        graph[u].clear();\n      }\n    }\n\n    throw;\n  }\n};\n", "1346": "class Solution {\n public:\n  bool checkIfExist(vector<int>& arr) {\n    unordered_set<int> seen;\n\n    for (const int a : arr) {\n      if (seen.contains(a * 2) || a % 2 == 0 && seen.contains(a / 2))\n        return true;\n      seen.insert(a);\n    }\n\n    return false;\n  }\n};\n", "1347": "class Solution {\n public:\n  int minSteps(string s, string t) {\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : t)\n      --count[c - 'a'];\n\n    return accumulate(count.begin(), count.end(), 0, [](int acc, int c) {\n      return acc + abs(c);\n    }) / 2;\n  }\n};\n", "1348": "class TweetCounts {\n public:\n  void recordTweet(string tweetName, int time) {\n    ++tweetNameToTimeCount[tweetName][time];\n  }\n\n  vector<int> getTweetCountsPerFrequency(string freq, string tweetName,\n                                         int startTime, int endTime) {\n    const int chunkSize = freq == \"minute\" ? 60 : freq == \"hour\" ? 3600 : 86400;\n    vector<int> counts((endTime - startTime) / chunkSize + 1);\n    const map<int, int>& timeCount = tweetNameToTimeCount[tweetName];\n    const auto lo = timeCount.lower_bound(startTime);\n    const auto hi = timeCount.upper_bound(endTime);\n\n    for (auto it = lo; it != hi; ++it) {\n      const int index = (it->first - startTime) / chunkSize;\n      counts[index] += it->second;\n    }\n\n    return counts;\n  }\n\n private:\n  unordered_map<string, map<int, int>> tweetNameToTimeCount;\n};\n", "1349": "class Solution {\n public:\n  int maxStudents(vector<vector<char>>& seats) {\n    return accumulate(seats.begin(), seats.end(), 0,\n                      [&](int acc, const auto& seat) {\n      return acc + ranges::count(seat, '.');\n    }) - hungarian(seats);\n  }\n\n private:\n  static constexpr int kDirs[6][2] = {{-1, -1}, {0, -1}, {1, -1},\n                                      {-1, 1},  {0, 1},  {1, 1}};\n\n  int hungarian(const vector<vector<char>>& seats) {\n    const int m = seats.size();\n    const int n = seats[0].size();\n    int count = 0;\n    vector<vector<int>> seen(m, vector<int>(n));\n    vector<vector<int>> match(m, vector<int>(n, -1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (seats[i][j] == '.' && match[i][j] == -1) {\n          const int sessionId = i * n + j;\n          seen[i][j] = sessionId;\n          count += dfs(seats, i, j, sessionId, seen, match);\n        }\n\n    return count;\n  }\n\n  int dfs(const vector<vector<char>>& seats, int i, int j, int sessionId,\n          vector<vector<int>>& seen, vector<vector<int>>& match) {\n    const int m = seats.size();\n    const int n = seats[0].size();\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == m || y < 0 || y == n)\n        continue;\n      if (seats[x][y] != '.' || seen[x][y] == sessionId)\n        continue;\n      seen[x][y] = sessionId;\n      if (match[x][y] == -1 || dfs(seats, match[x][y] / n, match[x][y] % n,\n                                   sessionId, seen, match)) {\n        match[x][y] = i * n + j;\n        match[i][j] = x * n + y;\n        return 1;\n      }\n    }\n\n    return 0;\n  }\n};\n", "135": "class Solution {\n public:\n  int candy(vector<int>& ratings) {\n    const int n = ratings.size();\n    int ans = 0;\n    vector<int> l(n, 1);\n    vector<int> r(n, 1);\n\n    for (int i = 1; i < n; ++i)\n      if (ratings[i] > ratings[i - 1])\n        l[i] = l[i - 1] + 1;\n\n    for (int i = n - 2; i >= 0; --i)\n      if (ratings[i] > ratings[i + 1])\n        r[i] = r[i + 1] + 1;\n\n    for (int i = 0; i < n; ++i)\n      ans += max(l[i], r[i]);\n\n    return ans;\n  }\n};\n", "1351": "class Solution {\n public:\n  int countNegatives(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    int i = m - 1;\n    int j = 0;\n\n    while (i >= 0 && j < n) {\n      if (grid[i][j] < 0) {\n        ans += n - j;\n        --i;\n      } else {\n        ++j;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1352": "class ProductOfNumbers {\n public:\n  ProductOfNumbers() : prefix{1} {}\n\n  void add(int num) {\n    if (num == 0)\n      prefix = {1};\n    else\n      prefix.push_back(prefix.back() * num);\n  }\n\n  int getProduct(int k) {\n    return k >= prefix.size() ? 0\n                              : prefix.back() / prefix[prefix.size() - k - 1];\n  }\n\n private:\n  vector<int> prefix;\n};\n", "1353": "class Solution {\n public:\n  int maxEvents(vector<vector<int>>& events) {\n    int ans = 0;\n    int d = 0;  // the current day\n    int i = 0;  // events' index\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    ranges::sort(events);\n\n    while (!minHeap.empty() || i < events.size()) {\n      // If no events are available to attend today, let time flies to the next\n      // available event.\n      if (minHeap.empty())\n        d = events[i][0];\n      // All the events starting from today are newly available.\n      while (i < events.size() && events[i][0] == d)\n        minHeap.push(events[i++][1]);\n      // Greedily attend the event that'll end the earliest since it has higher\n      // chance can't be attended in the future.\n      minHeap.pop();\n      ++ans;\n      ++d;\n      // Pop the events that can't be attended.\n      while (!minHeap.empty() && minHeap.top() < d)\n        minHeap.pop();\n    }\n\n    return ans;\n  }\n};\n", "1354": "class Solution {\n public:\n  bool isPossible(vector<int>& target) {\n    if (target.size() == 1)\n      return target[0] == 1;\n\n    long sum = accumulate(target.begin(), target.end(), 0L);\n    priority_queue<int> maxHeap;\n\n    for (const int num : target)\n      maxHeap.push(num);\n\n    while (maxHeap.top() > 1) {\n      const long mx = maxHeap.top();\n      maxHeap.pop();\n      const long restSum = sum - mx;\n      // Only occurs if n == 2.\n      if (restSum == 1)\n        return true;\n      const long updated = mx % restSum;\n      // updated == 0 (invalid) or didn't change.\n      if (updated == 0 || updated == mx)\n        return false;\n      maxHeap.push(updated);\n      sum = sum - mx + updated;\n    }\n\n    return true;\n  }\n};\n", "1356": "class Solution {\n public:\n  vector<int> sortByBits(vector<int>& arr) {\n    ranges::sort(arr, ranges::less{}, [](const int a) {\n      const int bitCount = bitset<32>(a).count();\n      return pair<int, int>{bitCount, a};\n    });\n    return arr;\n  }\n};\n", "1357": "class Cashier {\n public:\n  Cashier(int n, int discount, vector<int>& products, vector<int>& prices)\n      : n(n), discount(discount) {\n    for (int i = 0; i < products.size(); ++i)\n      productToPrice[products[i]] = prices[i];\n  }\n\n  double getBill(vector<int> product, vector<int> amount) {\n    ++count;\n    int total = 0;\n    for (int i = 0; i < product.size(); ++i)\n      total += productToPrice[product[i]] * amount[i];\n    return count % n == 0 ? total * (1 - discount / 100.0) : total;\n  }\n\n private:\n  const int n;\n  const int discount;\n  unordered_map<int, int> productToPrice;\n  int count = 0;\n};\n", "1358": "class Solution {\n public:\n  // Similar to 3. Longest Substring Without Repeating Characters\n  int numberOfSubstrings(string s) {\n    int ans = 0;\n    // lastSeen[c] := the index of the last time c appeared\n    vector<int> lastSeen(3, -1);\n\n    for (int i = 0; i < s.length(); ++i) {\n      lastSeen[s[i] - 'a'] = i;\n      // s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.\n      ans += 1 + ranges::min(lastSeen);\n    }\n\n    return ans;\n  }\n};\n", "1359": "class Solution {\n public:\n  int countOrders(int n) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 1;\n\n    for (int i = 1; i <= n; ++i)\n      ans = ans * i * (i * 2 - 1) % kMod;\n\n    return ans;\n  }\n};\n", "136": "class Solution {\n public:\n  int singleNumber(vector<int>& nums) {\n    int ans = 0;\n\n    for (const int num : nums)\n      ans ^= num;\n\n    return ans;\n  }\n};\n", "1360": "class Solution {\n public:\n  int daysBetweenDates(string date1, string date2) {\n    return abs(daysFrom1971(date1) - daysFrom1971(date2));\n  }\n\n private:\n  const vector<int> days{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n  int daysFrom1971(const string& date) {\n    const int year = stoi(date1.substr(0, 4));\n    const int month = stoi(date1.substr(5, 2));\n    const int day = stoi(date1.substr(8, 2));\n    int res = 0;\n    for (int i = 1971; i < year; ++i)\n      res += isLeapYear(i) ? 366 : 365;\n    for (int i = 0; i < month; ++i)\n      res += days[i];\n    if (month > 2 && isLeapYear(year))\n      ++res;\n    res += day;\n    return res;\n  }\n\n  bool isLeapYear(int year) {\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n  };\n};\n", "1361": "class Solution {\n public:\n  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,\n                               vector<int>& rightChild) {\n    vector<int> inDegrees(n);\n    int root = -1;\n\n    // If the in-degree of any node > 1, return false.\n    for (const int child : leftChild)\n      if (child != -1 && ++inDegrees[child] == 2)\n        return false;\n\n    for (const int child : rightChild)\n      if (child != -1 && ++inDegrees[child] == 2)\n        return false;\n\n    // Find the root (the node with in-degree == 0).\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        if (root == -1)\n          root = i;\n        else\n          return false;  // There're multiple roots.\n\n    // Didn't find the root.\n    if (root == -1)\n      return false;\n\n    return countNodes(root, leftChild, rightChild) == n;\n  }\n\n private:\n  int countNodes(int root, const vector<int>& leftChild,\n                 const vector<int>& rightChild) {\n    if (root == -1)\n      return 0;\n    return 1 +  //\n           countNodes(leftChild[root], leftChild, rightChild) +\n           countNodes(rightChild[root], leftChild, rightChild);\n  }\n};\n", "1362": "class Solution {\n public:\n  vector<int> closestDivisors(int num) {\n    for (int root = sqrt(num + 2); root > 0; --root)\n      for (int cand : {num + 1, num + 2})\n        if (cand % root == 0)\n          return {root, cand / root};\n\n    throw;\n  }\n};\n", "1363": "class Solution {\n public:\n  string largestMultipleOfThree(vector<int>& digits) {\n    string ans;\n    vector<int> mod1{1, 4, 7, 2, 5, 8};\n    vector<int> mod2{2, 5, 8, 1, 4, 7};\n    vector<int> count(10);\n    int sum = accumulate(digits.begin(), digits.end(), 0);\n\n    for (const int digit : digits)\n      ++count[digit];\n\n    while (sum % 3 != 0)\n      for (int i : sum % 3 == 1 ? mod1 : mod2)\n        if (count[i]) {\n          --count[i];\n          sum -= i;\n          break;\n        }\n\n    for (int digit = 9; digit >= 0; --digit)\n      ans += string(count[digit], '0' + digit);\n\n    return ans.size() && ans[0] == '0' ? \"0\" : ans;\n  }\n};\n", "1365": "class Solution {\n public:\n  vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n    constexpr int kMax = 100;\n    vector<int> ans;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = 1; i <= kMax; ++i)\n      count[i] += count[i - 1];\n\n    for (const int num : nums)\n      ans.push_back(num == 0 ? 0 : count[num - 1]);\n\n    return ans;\n  }\n};\n", "1366": "struct Team {\n  char name;\n  vector<int> rank;\n  Team(char name, int teamSize) : name(name), rank(teamSize) {}\n};\n\nclass Solution {\n public:\n  string rankTeams(vector<string>& votes) {\n    const int teamSize = votes[0].size();\n    string ans;\n    vector<Team> teams;\n\n    for (int i = 0; i < 26; ++i)\n      teams.push_back(Team('A' + i, teamSize));\n\n    for (const string& vote : votes)\n      for (int i = 0; i < teamSize; ++i)\n        ++teams[vote[i] - 'A'].rank[i];\n\n    ranges::sort(teams, ranges::greater{}, [](const Team& team) {\n      return pair<vector<int>, char>{team.rank, -team.name};\n    });\n\n    for (int i = 0; i < teamSize; ++i)\n      ans += teams[i].name;\n\n    return ans;\n  }\n};\n", "1367": "class Solution {\n public:\n  bool isSubPath(ListNode* head, TreeNode* root) {\n    if (root == nullptr)\n      return false;\n    return isContinuousSubPath(head, root) || isSubPath(head, root->left) ||\n           isSubPath(head, root->right);\n  }\n\n private:\n  bool isContinuousSubPath(ListNode* head, TreeNode* root) {\n    if (head == nullptr)\n      return true;\n    if (root == nullptr)\n      return false;\n    return head->val == root->val &&\n           (isContinuousSubPath(head->next, root->left) ||\n            isContinuousSubPath(head->next, root->right));\n  }\n};\n", "1368": "class Solution {\n public:\n  int minCost(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> mem(m, vector<int>(n, -1));\n    queue<pair<int, int>> q;\n\n    dfs(grid, 0, 0, /*cost=*/0, q, mem);\n\n    for (int cost = 1; !q.empty(); ++cost)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs)\n          dfs(grid, i + dx, j + dy, cost, q, mem);\n      }\n\n    return mem.back().back();\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n  void dfs(const vector<vector<int>>& grid, int i, int j, int cost,\n           queue<pair<int, int>>& q, vector<vector<int>>& mem) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (mem[i][j] != -1)\n      return;\n\n    mem[i][j] = cost;\n    q.emplace(i, j);\n    const auto& [dx, dy] = kDirs[grid[i][j] - 1];\n    dfs(grid, i + dx, j + dy, cost, q, mem);\n  }\n};\n", "137": "class Solution {\n public:\n  int singleNumber(vector<int>& nums) {\n    int ones = 0;\n    int twos = 0;\n\n    for (const int num : nums) {\n      ones ^= (num & ~twos);\n      twos ^= (num & ~ones);\n    }\n\n    return ones;\n  }\n};\n", "1370": "class Solution {\n public:\n  string sortString(string s) {\n    string ans;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    while (ans.length() < s.size()) {\n      for (int i = 0; i < 26; ++i) {\n        if (count[i] == 0)\n          continue;\n        ans += 'a' + i;\n        --count[i];\n      }\n      for (int i = 25; i >= 0; --i) {\n        if (count[i] == 0)\n          continue;\n        ans += 'a' + i;\n        --count[i];\n      }\n    }\n\n    return ans;\n  }\n};\n", "1371": "class Solution {\n public:\n  int findTheLongestSubstring(string s) {\n    constexpr string_view kVowels = \"aeiou\";\n    int ans = 0;\n    int prefix = 0;  // the binary prefix\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int index = kVowels.find(s[i]);\n      if (index != -1)\n        prefix ^= 1 << index;\n      if (!prefixToIndex.contains(prefix))\n        prefixToIndex[prefix] = i;\n      ans = max(ans, i - prefixToIndex[prefix]);\n    }\n\n    return ans;\n  }\n};\n", "1372": "struct T {\n  int leftMax;\n  int rightMax;\n  int subtreeMax;\n};\n\nclass Solution {\n public:\n  int longestZigZag(TreeNode* root) {\n    return dfs(root).subtreeMax;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {-1, -1, -1};\n    const T left = dfs(root->left);\n    const T right = dfs(root->right);\n    const int leftZigZag = left.rightMax + 1;\n    const int rightZigZag = right.leftMax + 1;\n    const int subtreeMax =\n        max({leftZigZag, rightZigZag, left.subtreeMax, right.subtreeMax});\n    return {leftZigZag, rightZigZag, subtreeMax};\n  }\n};\n", "1373": "struct T {\n  bool isBST = false;\n  int mx;\n  int mn;\n  int sum;\n};\n\nclass Solution {\n public:\n  int maxSumBST(TreeNode* root) {\n    int ans = 0;\n    traverse(root, ans);\n    return ans;\n  }\n\n private:\n  T traverse(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return T(true, INT_MIN, INT_MAX, 0);\n\n    const T left = traverse(root->left, ans);\n    const T right = traverse(root->right, ans);\n\n    if (!left.isBST || !right.isBST)\n      return T();\n    if (root->val <= left.mx || root->val >= right.mn)\n      return T();\n\n    // The `root` is a valid BST.\n    const int sum = root->val + left.sum + right.sum;\n    ans = max(ans, sum);\n    return T(true, max(root->val, right.mx), min(root->val, left.mn), sum);\n  }\n};\n", "1374": "class Solution {\n public:\n  string generateTheString(int n) {\n    string s(n, 'a');\n    if (n % 2 == 0)\n      s.back() = 'b';\n    return s;\n  }\n};\n", "1375": "class Solution {\n public:\n  int numTimesAllBlue(vector<int>& flips) {\n    int ans = 0;\n    int rightmost = 0;\n\n    for (int i = 0; i < flips.size(); ++i) {\n      rightmost = max(rightmost, flips[i]);\n      // max(flips[0..i]) = rightmost = i + 1,\n      // so flips[0..i] is a permutation of 1, 2, ..., i + 1.\n      if (rightmost == i + 1)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1376": "class Solution {\n public:\n  int numOfMinutes(int n, int headID, vector<int>& manager,\n                   vector<int>& informTime) {\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      ans = max(ans, dfs(i, headID, manager, informTime, {}));\n\n    return ans;\n  }\n\n private:\n  int dfs(int i, int headID, const vector<int>& manager,\n          const vector<int>& informTime, unordered_map<int, int>&& mem) {\n    if (const auto it = mem.find(i); it != mem.cend())\n      return it->second;\n    if (i == headID)\n      return 0;\n\n    const int parent = manager[i];\n    return mem[i] = informTime[parent] +\n                    dfs(parent, headID, manager, informTime, std::move(mem));\n  }\n};\n", "1377": "class Solution {\n public:\n  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n    vector<vector<int>> tree(n + 1);\n    queue<int> q{{1}};\n    vector<bool> seen(n + 1);\n    vector<double> prob(n + 1);\n\n    seen[1] = true;\n    prob[1] = 1.0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    while (!q.empty() && t-- > 0)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int a = q.front();\n        q.pop();\n        const int nChildren =\n            ranges::count_if(tree[a], [&seen](int b) { return !seen[b]; });\n        for (const int b : tree[a]) {\n          if (seen[b])\n            continue;\n          seen[b] = true;\n          prob[b] = prob[a] / nChildren;\n          q.push(b);\n        }\n        if (nChildren > 0)\n          prob[a] = 0.0;\n      }\n\n    return prob[target];\n  }\n};\n", "1379": "class Solution {\n public:\n  TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned,\n                          TreeNode* target) {\n    TreeNode* ans = nullptr;\n    dfs(original, cloned, target, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target,\n           TreeNode*& ans) {\n    if (ans != nullptr)\n      return;\n    if (original == nullptr)\n      return;\n    if (original == target) {\n      ans = cloned;\n      return;\n    }\n    dfs(original->left, cloned->left, target, ans);\n    dfs(original->right, cloned->right, target, ans);\n  }\n};\n", "138": "class Solution {\n public:\n  Node* copyRandomList(Node* head) {\n    if (head == nullptr)\n      return nullptr;\n    if (const auto it = map.find(head); it != map.cend())\n      return it->second;\n\n    Node* newNode = new Node(head->val);\n    map[head] = newNode;\n    newNode->next = copyRandomList(head->next);\n    newNode->random = copyRandomList(head->random);\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, Node*> map;\n};\n", "1380": "class Solution {\n public:\n  vector<int> luckyNumbers(vector<vector<int>>& matrix) {\n    for (const vector<int>& row : matrix) {\n      const int minIndex = distance(row.begin(), ranges::min_element(row));\n      if (row[minIndex] == maxNumOfColumn(matrix, minIndex))\n        return {row[minIndex]};\n    }\n    return {};\n  }\n\n private:\n  int maxNumOfColumn(const vector<vector<int>>& matrix, int j) {\n    int res = 0;\n    for (int i = 0; i < matrix.size(); ++i)\n      res = max(res, matrix[i][j]);\n    return res;\n  }\n};\n", "1381": "class CustomStack {\n public:\n  CustomStack(int maxSize) : maxSize(maxSize) {}\n\n  void push(int x) {\n    if (stack.size() == maxSize)\n      return;\n    stack.push(x);\n    pendingIncrements.push_back(0);\n  }\n\n  int pop() {\n    if (stack.empty())\n      return -1;\n    const int i = stack.size() - 1;\n    if (i > 0)\n      pendingIncrements[i - 1] += pendingIncrements[i];\n    const int val = stack.top() + pendingIncrements[i];\n    stack.pop();\n    pendingIncrements.pop_back();\n    return val;\n  }\n\n  void increment(int k, int val) {\n    if (stack.empty())\n      return;\n    const int i = min(k - 1, static_cast<int>(stack.size()) - 1);\n    pendingIncrements[i] += val;\n  }\n\n private:\n  const int maxSize;\n  stack<int> stack;\n  // pendingIncrements[i] := the pending increment for stack[0..i].\n  vector<int> pendingIncrements;\n};\n", "1382": "class Solution {\n public:\n  TreeNode* balanceBST(TreeNode* root) {\n    vector<int> nums;\n    inorder(root, nums);\n    return build(nums, 0, nums.size() - 1);\n  }\n\n private:\n  void inorder(TreeNode* root, vector<int>& nums) {\n    if (root == nullptr)\n      return;\n    inorder(root->left, nums);\n    nums.push_back(root->val);\n    inorder(root->right, nums);\n  }\n\n  // Same as 108. Convert Sorted Array to Binary Search Tree\n  TreeNode* build(const vector<int>& nums, int l, int r) {\n    if (l > r)\n      return nullptr;\n    const int m = (l + r) / 2;\n    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));\n  }\n};\n", "1383": "class Solution {\n public:\n  // Similar to 857. Minimum Cost to Hire K Workers\n  int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency,\n                     int k) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    long speedSum = 0;\n    // (efficiency[i], speed[i]) sorted by efficiency[i] in descending order\n    vector<pair<int, int>> A;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (int i = 0; i < n; ++i)\n      A.emplace_back(efficiency[i], speed[i]);\n\n    ranges::sort(A, greater<>());\n\n    for (const auto& [e, s] : A) {\n      minHeap.push(s);\n      speedSum += s;\n      if (minHeap.size() > k)\n        speedSum -= minHeap.top(), minHeap.pop();\n      ans = max(ans, speedSum * e);\n    }\n\n    return ans % kMod;\n  }\n};\n", "1385": "class Solution {\n public:\n  int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n    int ans = 0;\n\n    ranges::sort(arr2);\n\n    for (const int a : arr1)\n      if (ranges::upper_bound(arr2, a + d) == ranges::lower_bound(arr2, a - d))\n        ++ans;\n\n    return ans;\n  }\n};\n", "1386": "class Solution {\n public:\n  int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {\n    int ans = 0;\n    unordered_map<int, int> rowToSeats;\n\n    for (const vector<int>& reservedSeat : reservedSeats) {\n      const int row = reservedSeat[0];\n      const int seat = reservedSeat[1];\n      rowToSeats[row] |= 1 << (seat - 1);\n    }\n\n    for (const auto& [_, seats] : rowToSeats)\n      if ((seats & 0b0111111110) == 0)\n        // Can fit 2 four-person groups.\n        ans += 2;\n      else if ((seats & 0b0111100000) == 0 ||  // The left is not occupied.\n               (seats & 0b0001111000) == 0 ||  // The middle is not occupied.\n               (seats & 0b0000011110) == 0)    // The right is notoccupied.\n        // Can fit 1 four-person group.\n        ans += 1;\n\n    // Any empty row can fit 2 four-person groups.\n    return ans + (n - rowToSeats.size()) * 2;\n  }\n};\n", "1387": "class Solution {\n public:\n  int getKth(int lo, int hi, int k) {\n    vector<pair<int, int>> powAndVals;  // (pow, val)\n\n    for (int i = lo; i <= hi; ++i)\n      powAndVals.emplace_back(getPow(i), i);\n\n    nth_element(powAndVals.begin(), powAndVals.begin() + k - 1,\n                powAndVals.end());\n    return powAndVals[k - 1].second;\n  }\n\n private:\n  int getPow(int n) {\n    if (n == 1)\n      return 0;\n    return 1 + (n % 2 == 0 ? getPow(n / 2) : getPow(n * 3 + 1));\n  }\n};\n", "1389": "class Solution {\n public:\n  vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {\n    vector<int> ans;\n    for (int i = 0; i < nums.size(); ++i)\n      ans.insert(ans.begin() + index[i], nums[i]);\n    return ans;\n  }\n};\n", "139": "class Solution {\n public:\n  bool wordBreak(string s, vector<string>& wordDict) {\n    return wordBreak(s, 0, {wordDict.begin(), wordDict.end()},\n                     vector<int>(s.length(), -1));\n  }\n\n private:\n  // Returns true if s[i..n) can be segmented.\n  bool wordBreak(const string& s, int i, const unordered_set<string>&& wordSet,\n                 vector<int>&& mem) {\n    if (i == s.length())\n      return true;\n    if (mem[i] != -1)\n      return mem[i];\n\n    for (int j = i + 1; j <= s.length(); ++j)\n      if (wordSet.contains(s.substr(i, j - i)) &&\n          wordBreak(s, j, std::move(wordSet), std::move(mem)))\n        return mem[i] = 1;\n\n    return mem[i] = 0;\n  }\n};\n", "1390": "class Solution {\n public:\n  int sumFourDivisors(vector<int>& nums) {\n    int ans = 0;\n\n    for (int num : nums) {\n      int divisor = 0;\n      for (int i = 2; i * i <= num; ++i)\n        if (num % i == 0) {\n          if (divisor == 0)\n            divisor = i;\n          else {\n            divisor = 0;\n            break;\n          }\n        }\n      if (divisor > 0 && divisor * divisor < num)\n        ans += 1 + num + divisor + num / divisor;\n    }\n\n    return ans;\n  }\n};\n", "1391": "class Solution {\n public:\n  bool hasValidPath(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // g := upscaled grid\n    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        switch (grid[i][j]) {\n          case 1:\n            g[i * 3 + 1][j * 3 + 0] = true;\n            g[i * 3 + 1][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 2] = true;\n            break;\n          case 2:\n            g[i * 3 + 0][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 1] = true;\n            g[i * 3 + 2][j * 3 + 1] = true;\n            break;\n          case 3:\n            g[i * 3 + 1][j * 3 + 0] = true;\n            g[i * 3 + 1][j * 3 + 1] = true;\n            g[i * 3 + 2][j * 3 + 1] = true;\n            break;\n          case 4:\n            g[i * 3 + 1][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 2] = true;\n            g[i * 3 + 2][j * 3 + 1] = true;\n            break;\n          case 5:\n            g[i * 3 + 0][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 0] = true;\n            g[i * 3 + 1][j * 3 + 1] = true;\n            break;\n          case 6:\n            g[i * 3 + 0][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 1] = true;\n            g[i * 3 + 1][j * 3 + 2] = true;\n            break;\n        }\n\n    return dfs(g, 1, 1);\n  }\n\n private:\n  bool dfs(vector<vector<bool>>& g, int i, int j) {\n    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())\n      return false;\n    if (!g[i][j])  // There's no path here.\n      return false;\n    if (i == g.size() - 2 && j == g[0].size() - 2)\n      return true;\n\n    g[i][j] = false;  // Mark as visited.\n    return dfs(g, i + 1, j) || dfs(g, i - 1, j) || dfs(g, i, j + 1) ||\n           dfs(g, i, j - 1);\n  }\n};\n", "1392": "class Solution {\n public:\n  string longestPrefix(string s) {\n    constexpr int kBase = 26;\n    constexpr long kHash = 8'417'508'174'513;\n\n    const int n = s.length();\n    int maxLength = 0;\n    long pow = 1;\n    long prefixHash = 0;  // the hash of s[0..i]\n    long suffixHash = 0;  // the hash of s[j..n)\n\n    for (int i = 0, j = n - 1; i < n - 1; ++i, --j) {\n      prefixHash = (prefixHash * kBase + val(s[i])) % kHash;\n      suffixHash = (val(s[j]) * pow + suffixHash) % kHash;\n      pow = pow * kBase % kHash;\n      if (prefixHash == suffixHash)\n        maxLength = i + 1;\n    }\n\n    return s.substr(0, maxLength);\n  }\n\n private:\n  constexpr int val(char c) {\n    return c - 'a';\n  }\n};\n", "1394": "class Solution {\n public:\n  int findLucky(vector<int>& arr) {\n    vector<int> count(arr.size() + 1);\n\n    for (const int a : arr)\n      if (a <= arr.size())\n        ++count[a];\n\n    for (int i = arr.size(); i >= 1; --i)\n      if (count[i] == i)\n        return i;\n\n    return -1;\n  }\n};\n", "1395": "class Solution {\n public:\n  int numTeams(vector<int>& rating) {\n    int ans = 0;\n\n    for (int i = 1; i < rating.size() - 1; ++i) {\n      // Calculate soldiers on the left with less/greater ratings.\n      int leftLess = 0;\n      int leftGreater = 0;\n      for (int j = 0; j < i; ++j)\n        if (rating[j] < rating[i])\n          ++leftLess;\n        else if (rating[j] > rating[i])\n          ++leftGreater;\n      // Calculate soldiers on the right with less/greater ratings.\n      int rightLess = 0;\n      int rightGreater = 0;\n      for (int j = i + 1; j < rating.size(); ++j)\n        if (rating[j] < rating[i])\n          ++rightLess;\n        else if (rating[j] > rating[i])\n          ++rightGreater;\n      ans += leftLess * rightGreater + leftGreater * rightLess;\n    }\n\n    return ans;\n  }\n};\n", "1396": "struct CheckIn {\n  string stationName;\n  int time;\n};\n\nstruct CheckOut {\n  int numTrips;\n  int totalTime;\n};\n\nclass UndergroundSystem {\n public:\n  void checkIn(int id, string stationName, int t) {\n    checkIns[id] = {stationName, t};\n  }\n\n  void checkOut(int id, string stationName, int t) {\n    const auto [startStation, startTime] = checkIns[id];\n    checkIns.erase(id);\n    const string& route = startStation + \"->\" + stationName;\n    ++checkOuts[route].numTrips;\n    checkOuts[route].totalTime += t - startTime;\n  }\n\n  double getAverageTime(string startStation, string endStation) {\n    const auto& [numTrips, totalTime] =\n        checkOuts[startStation + \"->\" + endStation];\n    return totalTime / (double)numTrips;\n  }\n\n private:\n  unordered_map<int, CheckIn> checkIns;       // {id: (stationName, time)}\n  unordered_map<string, CheckOut> checkOuts;  // {route: (numTrips, totalTime)}\n};\n", "1397": "class Solution {\n public:\n  int findGoodStrings(int n, string s1, string s2, string evil) {\n    vector<vector<vector<vector<int>>>> mem(\n        n, vector<vector<vector<int>>>(\n               evil.length(), vector<vector<int>>(2, vector<int>(2, -1))));\n    // nextMatchedCount[i][j] := the number of next matched evil count, where\n    // there're i matches with `evil` and the current letter is ('a' + j)\n    vector<vector<int>> nextMatchedCount(evil.length(), vector<int>(26, -1));\n    return count(s1, s2, evil, 0, 0, true, true, getLPS(evil), nextMatchedCount,\n                 mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of good strings for s[i..n), where there're j matches\n  // with `evil`, `isS1Prefix` indicates if the current letter is tightly bound\n  // for `s1` and `isS2Prefix` indicates if the current letter is tightly bound\n  // for `s2`.\n  int count(const string& s1, const string& s2, const string& evil, int i,\n            int matchedEvilCount, bool isS1Prefix, bool isS2Prefix,\n            const vector<int>& evilLPS, vector<vector<int>>& nextMatchedCount,\n            vector<vector<vector<vector<int>>>>& mem) {\n    // s[0..i) contains `evil`, so don't consider any ongoing strings.\n    if (matchedEvilCount == evil.length())\n      return 0;\n    // Run out of strings, so contribute one.\n    if (i == s1.length())\n      return 1;\n    int& res = mem[i][matchedEvilCount][isS1Prefix][isS2Prefix];\n    if (res != -1)\n      return res;\n    res = 0;\n    const char minLetter = isS1Prefix ? s1[i] : 'a';\n    const char maxLetter = isS2Prefix ? s2[i] : 'z';\n    for (char c = minLetter; c <= maxLetter; ++c) {\n      const int nextMatchedEvilCount = getNextMatchedEvilCount(\n          nextMatchedCount, evil, matchedEvilCount, c, evilLPS);\n      res += count(s1, s2, evil, i + 1, nextMatchedEvilCount,\n                   isS1Prefix && c == s1[i], isS2Prefix && c == s2[i], evilLPS,\n                   nextMatchedCount, mem);\n      res %= kMod;\n    }\n    return res;\n  }\n\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n\n  // j := the next index we're trying to match with `currLetter`\n  int getNextMatchedEvilCount(vector<vector<int>>& nextMatchedCount,\n                              const string& evil, int j, char currLetter,\n                              const vector<int>& evilLPS) {\n    int& res = nextMatchedCount[j][currLetter - 'a'];\n    if (res != -1)\n      return res;\n    while (j > 0 && evil[j] != currLetter)\n      j = evilLPS[j - 1];\n    return res = (evil[j] == currLetter ? j + 1 : j);\n  }\n};\n", "1399": "class Solution {\n public:\n  int countLargestGroup(int n) {\n    vector<int> count(9 * 4 + 1);\n    for (int i = 1; i <= n; ++i)\n      ++count[getDigitSum(i)];\n    return ranges::count(count, ranges::max(count));\n  }\n\n private:\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "14": "class Solution {\n public:\n  string longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty())\n      return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i)\n      for (int j = 1; j < strs.size(); ++j)\n        if (i == strs[j].length() || strs[j][i] != strs[0][i])\n          return strs[0].substr(0, i);\n\n    return strs[0];\n  }\n};\n", "140": "class Solution {\n public:\n  vector<string> wordBreak(string s, vector<string>& wordDict) {\n    unordered_set<string> wordSet{wordDict.begin(), wordDict.end()};\n    unordered_map<string, vector<string>> mem;\n    return wordBreak(s, wordSet, mem);\n  }\n\n private:\n  vector<string> wordBreak(const string& s,\n                           const unordered_set<string>& wordSet,\n                           unordered_map<string, vector<string>>& mem) {\n    if (const auto it = mem.find(s); it != mem.cend())\n      return it->second;\n\n    vector<string> ans;\n\n    // 1 <= prefix.length() < s.length()\n    for (int i = 1; i < s.length(); ++i) {\n      const string& prefix = s.substr(0, i);\n      const string& suffix = s.substr(i);\n      if (wordSet.contains(prefix))\n        for (const string& word : wordBreak(suffix, wordSet, mem))\n          ans.push_back(prefix + \" \" + word);\n    }\n\n    // `wordSet` contains the whole string s, so don't add any space.\n    if (wordSet.contains(s))\n      ans.push_back(s);\n\n    return mem[s] = ans;\n  }\n};\n", "1400": "class Solution {\n public:\n  bool canConstruct(string s, int k) {\n    // If |s| < k, we cannot construct k strings from the s.\n    if (s.length() < k)\n      return false;\n\n    bitset<26> odd;\n\n    for (const char c : s)\n      odd.flip(c - 'a');\n\n    // If the number of letters that have odd counts > k, the minimum number of\n    // palindromic strings we can construct is > k.\n    return odd.contains() <= k;\n  }\n};\n", "1401": "class Solution {\n public:\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,\n                    int x2, int y2) {\n    auto clamp = [&](int center, int mn, int mx) {\n      return max(mn, min(mx, center));\n    };\n\n    // the closest point to the circle within the rectangle\n    int closestX = clamp(x_center, x1, x2);\n    int closestY = clamp(y_center, y1, y2);\n\n    // the distance between the circle's center and its closest point\n    int distanceX = x_center - closestX;\n    int distanceY = y_center - closestY;\n\n    // If the distance < the circle's radius, an intersection occurs.\n    return (distanceX * distanceX) + (distanceY * distanceY) <=\n           (radius * radius);\n  }\n};\n", "1402": "class Solution {\n public:\n  int maxSatisfaction(vector<int>& satisfaction) {\n    int ans = 0;\n    int sumSatisfaction = 0;\n\n    ranges::sort(satisfaction, greater<>());\n\n    for (const int s : satisfaction) {\n      sumSatisfaction += s;\n      if (sumSatisfaction <= 0)\n        return ans;\n      ans += sumSatisfaction;\n    }\n\n    return ans;\n  }\n};\n", "1403": "class Solution {\n public:\n  vector<int> minSubsequence(vector<int>& nums) {\n    vector<int> ans;\n    priority_queue<int> maxHeap(nums.begin(), nums.end());\n    int half = accumulate(nums.begin(), nums.end(), 0) / 2;\n\n    while (half >= 0) {\n      ans.push_back(maxHeap.top());\n      half -= maxHeap.top(), maxHeap.pop();\n    }\n\n    return ans;\n  }\n};\n", "1404": "class Solution {\n public:\n  int numSteps(string s) {\n    int ans = 0;\n\n    // All the trailing 0s can be popped by 1 step.\n    while (s.back() == '0') {\n      s.pop_back();\n      ++ans;\n    }\n\n    if (s == \"1\")\n      return ans;\n\n    // `s` is now odd, so add 1 to `s` and cost 1 step.\n    ++ans;\n\n    // All the 1s will become 0s and can be popped by 1 step.\n    // All the 0s will become 1s and can be popped by 2 steps (adding 1 then\n    // dividing by 2).\n    for (const char c : s)\n      ans += c == '1' ? 1 : 2;\n\n    return ans;\n  }\n};\n", "1405": "class Solution {\n public:\n  string longestDiverseString(int a, int b, int c, char A = 'a', char B = 'b',\n                              char C = 'c') {\n    if (a < b)\n      return longestDiverseString(b, a, c, B, A, C);\n    if (b < c)\n      return longestDiverseString(a, c, b, A, C, B);\n    if (b == 0)\n      return string(min(a, 2), A);\n\n    const int useA = min(a, 2);\n    const int useB = (a - useA >= b) ? 1 : 0;\n    return string(useA, A) + string(useB, B) +\n           longestDiverseString(a - useA, b - useB, c, A, B, C);\n  }\n};\n", "1406": "class Solution {\n public:\n  string stoneGameIII(vector<int>& stoneValue) {\n    const int n = stoneValue.size();\n    // dp[i] := the maximum relative score Alice can make with stoneValue[i..n)\n    vector<int> dp(n + 1, INT_MIN / 2);\n    dp.back() = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n      int sum = 0;\n      for (int j = i; j < i + 3 && j < n; ++j) {\n        sum += stoneValue[j];\n        dp[i] = max(dp[i], sum - dp[j + 1]);\n      }\n    }\n\n    const int score = dp[0];\n    return score > 0 ? \"Alice\" : score < 0 ? \"Bob\" : \"Tie\";\n  }\n};\n", "1408": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n  }\n\n  bool search(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return false;\n      node = node->children[i];\n    }\n    return true;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  vector<string> stringMatching(vector<string>& words) {\n    vector<string> ans;\n    Trie trie;\n\n    ranges::sort(words, ranges::greater{},\n                 [](const string& word) { return word.length(); });\n\n    for (const string& word : words) {\n      if (trie.search(word))\n        ans.push_back(word);\n      for (int i = 0; i < word.length(); ++i)\n        trie.insert(word.substr(i));\n    }\n\n    return ans;\n  }\n};\n", "1409": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> processQueries(vector<int>& queries, int m) {\n    vector<int> ans;\n    // Map [-m, m] to [0, 2 * m].\n    FenwickTree tree(2 * m + 1);\n    unordered_map<int, int> numToIndex;\n\n    for (int num = 1; num <= m; ++num) {\n      numToIndex[num] = num + m;\n      tree.add(num + m, 1);\n    }\n\n    int nextEmptyIndex = m;  // Map 0 to m.\n\n    for (const int query : queries) {\n      const int index = numToIndex[query];\n      ans.push_back(tree.get(index - 1));\n      // Move `query` from `index` to `nextEmptyIndex`.\n      tree.add(index, -1);\n      tree.add(nextEmptyIndex, 1);\n      numToIndex[query] = nextEmptyIndex--;\n    }\n\n    return ans;\n  }\n};\n", "141": "class Solution {\n public:\n  bool hasCycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n      if (slow == fast)\n        return true;\n    }\n\n    return false;\n  }\n};\n", "1410": "class Solution {\n public:\n  string entityParser(string text) {\n    const unordered_map<string, char> entityToChar{\n        {\"&quot;\", '\"'}, {\"&apos;\", '\\''}, {\"&amp;\", '&'},\n        {\"&gt;\", '>'},   {\"&lt;\", '<'},    {\"&frasl;\", '/'}};\n    string ans;\n    int j = 0;  // text[j..ampersandIndex - 1] is the pending substring.\n    int ampersandIndex = -1;\n\n    for (int i = 0; i < text.length(); ++i)\n      if (text[i] == '&') {\n        ampersandIndex = i;\n      } else if (text[i] == ';' && ampersandIndex >= j) {\n        const string sub = text.substr(ampersandIndex, i - ampersandIndex + 1);\n        ans += text.substr(j, ampersandIndex - j);\n        ans += getCharIfMatched(text, sub, entityToChar);\n        j = i + 1;\n      }\n\n    return ans + text.substr(j);\n  }\n\n private:\n  string getCharIfMatched(const string& text, const string& sub,\n                          const unordered_map<string, char>& entityToChar) {\n    for (const auto& [entity, c] : entityToChar)\n      if (entity == sub)\n        return string(1, c);\n    return sub;\n  }\n};\n", "1411": "class Solution {\n public:\n  int numOfWays(int n) {\n    constexpr int kMod = 1'000'000'007;\n    long color2 = 6;  // 121, 131, 212, 232, 313, 323\n    long color3 = 6;  // 123, 132, 213, 231, 312, 321\n\n    for (int i = 1; i < n; ++i) {\n      const long nextColor2 = color2 * 3 + color3 * 2;\n      const long nextColor3 = color2 * 2 + color3 * 2;\n      color2 = nextColor2 % kMod;\n      color3 = nextColor3 % kMod;\n    }\n\n    return (color2 + color3) % kMod;\n  }\n};\n", "1413": "class Solution {\n public:\n  int minStartValue(vector<int>& nums) {\n    int sum = 0;\n    int minSum = 0;\n\n    for (const int num : nums)\n      minSum = min(minSum, sum += num);\n\n    return 1 - minSum;\n  }\n};\n", "1414": "class Solution {\n public:\n  int findMinFibonacciNumbers(int k) {\n    int ans = 0;\n    int a = 1;  // F_1\n    int b = 1;  // F_2\n\n    while (b <= k) {\n      //    a, b = F_{i + 1}, F_{i + 2}\n      // -> a, b = F_{i + 2}, F_{i + 3}\n      const int temp = a;\n      a = b;\n      b = a + temp;\n    }\n\n    while (a > 0) {\n      if (a <= k) {\n        k -= a;\n        ++ans;\n      }\n      //    a, b = F_{i + 2}, F_{i + 3}\n      // -> a, b = F_{i + 1}, F_{i + 2}\n      const int temp = a;\n      a = b - a;\n      b = temp;\n    }\n\n    return ans;\n  }\n};\n", "1415": "class Solution {\n public:\n  string getHappyString(int n, int k) {\n    const unordered_map<char, string> nextLetters{\n        {'a', \"bc\"}, {'b', \"ac\"}, {'c', \"ab\"}};\n    queue<string> q{{{\"a\", \"b\", \"c\"}}};\n\n    while (q.front().length() != n) {\n      const string u = q.front();\n      q.pop();\n      for (const char nextLetter : nextLetters.at(u.back()))\n        q.push(u + nextLetter);\n    }\n\n    if (q.size() < k)\n      return \"\";\n\n    for (int i = 0; i < k - 1; ++i)\n      q.pop();\n    return q.front();\n  }\n};\n", "1416": "class Solution {\n public:\n  int numberOfArrays(string s, int k) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = s.length();\n    // dp[i] := the number of arrays to restore s[i..n) with k\n    vector<int> dp(n + 1);\n    dp.back() = 1;  // an empty string \"\"\n\n    for (int i = n - 1; i >= 0; --i) {\n      if (s[i] == '0')\n        continue;  // a leading zero\n      long num = 0;\n      for (int j = i; j < n; ++j) {\n        num = num * 10 + (s[j] - '0');\n        if (num > k)\n          break;\n        dp[i] = (dp[i] + dp[j + 1]) % kMod;\n      }\n    }\n\n    return dp[0];\n  }\n};\n", "1417": "class Solution {\n public:\n  string reformat(string s) {\n    const int countAlpha =\n        ranges::count_if(s, [](char c) { return isalpha(c); });\n    const int countDigit = s.size() - countAlpha;\n    if (abs(countAlpha - countDigit) >= 2)\n      return \"\";\n\n    // Initialize the starting index. e.g. \"a0a0a\" or \"0a0a0\".\n    const int alphaStartingIndex = countAlpha >= countDigit ? 0 : 1;\n\n    // Place all alphas in the indices 0, 2, 4, 6, ... or 1, 3, 5, 7, ....\n    for (int i = 0, j = alphaStartingIndex; i < s.length(); ++i) {\n      if (i < j && i % 2 == alphaStartingIndex)\n        continue;  // The `s[i]` has been set.\n      if (!isalpha(s[i]))\n        continue;\n      swap(s[i], s[j]);\n      j += 2;\n      --i;\n    }\n\n    return s;\n  }\n};\n", "1418": "class Solution {\n public:\n  vector<vector<string>> displayTable(vector<vector<string>>& orders) {\n    vector<vector<string>> ans{{\"Table\"}};\n    unordered_map<string, int> tableNumberToRowIndex;\n    unordered_map<string, int> foodItemToColIndex;\n\n    // Create the first row and column of ans.\n    for (const vector<string>& order : orders) {\n      const string& tableNumber = order[1];\n      const string& foodItem = order[2];\n      // Initialize indices with 0s.\n      tableNumberToRowIndex[tableNumber] = 0;\n      foodItemToColIndex[foodItem] = 0;\n    }\n    for (const auto& [tableNumber, _] : tableNumberToRowIndex)\n      ans.push_back({tableNumber});\n    for (const auto& [foodItem, _] : foodItemToColIndex)\n      ans[0].push_back(foodItem);\n\n    // Sort the first row and the column, except ans[0][0].\n    sort(ans[0].begin() + 1, ans[0].end());\n    ranges::sort(ans.begin() + 1, ans.end(), ranges::less{},\n                 [](const vector<string>& cols) { return stoi(cols[0]); });\n\n    // Set the indices after sorting.\n    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)\n      tableNumberToRowIndex[ans[i + 1][0]] = i;\n    for (int i = 0; i < foodItemToColIndex.size(); ++i)\n      foodItemToColIndex[ans[0][i + 1]] = i;\n\n    // Get all the counts of each food item in each table.\n    vector<vector<int>> count;\n    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)\n      count.push_back(vector<int>(foodItemToColIndex.size()));\n    for (const vector<string>& order : orders) {\n      const string& tableNumber = order[1];\n      const string& foodItem = order[2];\n      const int rowIndex = tableNumberToRowIndex[tableNumber];\n      const int colIndex = foodItemToColIndex[foodItem];\n      ++count[rowIndex][colIndex];\n    }\n\n    // Set the counts to `ans`.\n    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)\n      for (int j = 0; j < foodItemToColIndex.size(); ++j)\n        ans[i + 1].push_back(to_string(count[i][j]));\n\n    return ans;\n  }\n};\n", "1419": "class Solution {\n public:\n  int minNumberOfFrogs(string croakOfFrogs) {\n    const string kCroak = \"croak\";\n    int ans = 0;\n    int frogs = 0;\n    vector<int> count(5);\n\n    for (const char c : croakOfFrogs) {\n      ++count[kCroak.find(c)];\n      for (int i = 1; i < 5; ++i)\n        if (count[i] > count[i - 1])\n          return -1;\n      if (c == 'c')\n        ++frogs;\n      else if (c == 'k')\n        --frogs;\n      ans = max(ans, frogs);\n    }\n\n    return frogs == 0 ? ans : -1;\n  }\n};\n", "142": "class Solution {\n public:\n  ListNode* detectCycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n      if (slow == fast) {\n        slow = head;\n        while (slow != fast) {\n          slow = slow->next;\n          fast = fast->next;\n        }\n        return slow;\n      }\n    }\n\n    return nullptr;\n  }\n};\n", "1420": "class Solution {\n public:\n  int numOfArrays(int n, int m, int k) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j][k] := the number of ways to build an array of length i, where j\n    // is the maximum number and k is the `search_cost`\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1)));\n    // prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j\n    vector<vector<vector<int>>> prefix(\n        n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1)));\n\n    for (int j = 1; j <= m; ++j) {\n      dp[1][j][1] = 1;\n      prefix[1][j][1] = j;\n    }\n\n    for (int i = 2; i <= n; ++i)                 // for each length\n      for (int j = 1; j <= m; ++j)               // for each max value\n        for (int cost = 1; cost <= k; ++cost) {  // for each cost\n          // 1. Appending any of [1, j] in the i-th position doesn't change the\n          //    maximum and cost.\n          // 2. Appending j in the i-th position makes j the new max and\n          //    cost 1.\n          dp[i][j][cost] = (static_cast<long>(j) * dp[i - 1][j][cost] +\n                            prefix[i - 1][j - 1][cost - 1]) %\n                           kMod;\n          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % kMod;\n        }\n\n    int ans = 0;\n    for (int j = 1; j <= m; ++j) {\n      ans += dp[n][j][k];\n      ans %= kMod;\n    }\n    return ans;\n  }\n};\n", "1422": "class Solution {\n public:\n  int maxScore(string s) {\n    int ans = 0;\n    int zeros = 0;\n    int ones = ranges::count(s, '1');\n\n    for (int i = 0; i + 1 < s.size(); ++i) {\n      if (s[i] == '0')\n        ++zeros;\n      else\n        --ones;\n      ans = max(ans, zeros + ones);\n    }\n\n    return ans;\n  }\n};\n", "1423": "class Solution {\n public:\n  int maxScore(vector<int>& cardPoints, int k) {\n    const int n = cardPoints.size();\n    const int sum = accumulate(cardPoints.begin(), cardPoints.end(), 0);\n    int windowSum =\n        accumulate(cardPoints.begin(), cardPoints.begin() + n - k, 0);\n    int ans = sum - windowSum;\n\n    for (int i = 0; i < k; ++i) {\n      windowSum -= cardPoints[i];\n      windowSum += cardPoints[i + n - k];\n      ans = max(ans, sum - windowSum);\n    }\n\n    return ans;\n  }\n};\n", "1424": "class Solution {\n public:\n  vector<int> findDiagonalOrder(vector<vector<int>>& nums) {\n    vector<int> ans;\n    unordered_map<int, vector<int>> keyToNums;  // key := row + column\n    int maxKey = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = 0; j < nums[i].size(); ++j) {\n        const int key = i + j;\n        keyToNums[key].push_back(nums[i][j]);\n        maxKey = max(maxKey, key);\n      }\n\n    for (int i = 0; i <= maxKey; ++i)\n      for (auto it = keyToNums[i].rbegin(); it != keyToNums[i].rend(); ++it)\n        ans.push_back(*it);\n\n    return ans;\n  }\n};\n", "1425": "class Solution {\n public:\n  int constrainedSubsetSum(vector<int>& nums, int k) {\n    // dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]\n    vector<int> dp(nums.size());\n    // dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0\n    // in decreasing order.\n    deque<int> dq;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (dq.empty())\n        dp[i] = nums[i];\n      else\n        dp[i] = max(dq.front(), 0) + nums[i];\n      while (!dq.empty() && dq.back() < dp[i])\n        dq.pop_back();\n      dq.push_back(dp[i]);\n      if (i >= k && dp[i - k] == dq.front())\n        dq.pop_front();\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "1426": "class Solution {\n public:\n  int countElements(vector<int>& arr) {\n    unordered_set<int> arrSet{arr.begin(), arr.end()};\n    return ranges::count_if(\n        arr, [&arrSet](int a) { return arrSet.contains(a + 1); });\n  }\n};\n", "1427": "class Solution {\n public:\n  string stringShift(string s, vector<vector<int>>& shift) {\n    const int n = s.length();\n    int move = 0;\n\n    for (const vector<int>& pair : shift) {\n      const int direction = pair[0];\n      const int amount = pair[1];\n      if (direction == 0)\n        move -= amount;\n      else\n        move += amount;\n    }\n\n    move = ((move % n) + n) % n;\n    return s.substr(n - move) + s.substr(0, n - move);\n  }\n};\n", "1428": "/**\n * // This is the BinaryMatrix's API interface.\n * // You should not implement it, or speculate about its implementation\n * class BinaryMatrix {\n *  public:\n *   int get(int row, int col);\n *   vector<int> dimensions();\n * };\n */\n\nclass Solution {\n public:\n  int leftMostColumnWithOne(BinaryMatrix& binaryMatrix) {\n    const vector<int> dimensions = binaryMatrix.dimensions();\n    const int m = dimensions[0];\n    const int n = dimensions[1];\n    int ans = -1;\n    int i = 0;\n    int j = n - 1;\n\n    while (i < m && j >= 0)\n      if (binaryMatrix.get(i, j) == 1)\n        ans = j--;\n      else\n        ++i;\n\n    return ans;\n  }\n};\n", "1429": "class FirstUnique {\n public:\n  FirstUnique(vector<int>& nums) {\n    for (const int num : nums)\n      add(num);\n  }\n\n  int showFirstUnique() {\n    return unique.empty() ? -1 : unique.front();\n  }\n\n  void add(int value) {\n    const auto it = valueToIterator.find(value);\n    if (it == valueToIterator.cend()) {\n      unique.push_back(value);\n      valueToIterator[value] = prev(unique.end());\n    } else if (it->second != unique.end()) {\n      // We have added this value before, and this is the second time we're\n      // adding it. So, erase the value from `unique` and mark it as erased.\n      unique.erase(it->second);\n      valueToIterator[value] = unique.end();\n    }\n  }\n\n private:\n  list<int> unique;\n  unordered_map<int, list<int>::iterator> valueToIterator;\n};\n", "143": "class Solution {\n public:\n  void reorderList(ListNode* head) {\n    if (!head || !head->next)\n      return;\n\n    ListNode* mid = findMid(head);\n    ListNode* reversed = reverse(mid);\n    merge(head, reversed);\n  }\n\n private:\n  ListNode* findMid(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n      prev = slow;\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n    prev->next = nullptr;\n\n    return slow;\n  }\n\n  ListNode* reverse(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* curr = head;\n\n    while (curr != nullptr) {\n      ListNode* next = curr->next;\n      curr->next = prev;\n      prev = curr;\n      curr = next;\n    }\n\n    return prev;\n  }\n\n  void merge(ListNode* l1, ListNode* l2) {\n    while (l2) {\n      ListNode* next = l1->next;\n      l1->next = l2;\n      l1 = l2;\n      l2 = next;\n    }\n  }\n};\n", "1430": "class Solution {\n public:\n  bool isValidSequence(TreeNode* root, vector<int>& arr) {\n    return isValidSequence(root, arr, 0);\n  }\n\n private:\n  bool isValidSequence(TreeNode* root, const vector<int>& arr, int i) {\n    if (root == nullptr)\n      return false;\n    if (i == arr.size() - 1)\n      return root->val == arr[i] && root->left == nullptr &&\n             root->right == nullptr;\n    return root->val == arr[i] && (isValidSequence(root->left, arr, i + 1) ||\n                                   isValidSequence(root->right, arr, i + 1));\n  }\n};\n", "1431": "class Solution {\n public:\n  vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n    vector<bool> ans;\n    const int maxCandy = ranges::max(candies);\n\n    for (const int candy : candies)\n      ans.push_back(candy + extraCandies >= maxCandy);\n\n    return ans;\n  }\n};\n", "1432": "class Solution {\n public:\n  int maxDiff(int num) {\n    const string s = to_string(num);\n    int firstNot9 = s.find_first_not_of('9');\n    int firstNot01 = s.find_first_not_of(\"01\");\n    if (firstNot9 == string::npos)\n      firstNot9 = 0;\n    if (firstNot01 == string::npos)\n      firstNot01 = 0;\n\n    string a = s;\n    string b = s;\n    replace(a.begin(), a.end(), s[firstNot9], '9');\n    replace(b.begin(), b.end(), s[firstNot01], firstNot01 == 0 ? '1' : '0');\n    return stoi(a) - stoi(b);\n  }\n};\n", "1433": "class Solution {\n public:\n  bool checkIfCanBreak(string s1, string s2) {\n    vector<int> count(26);\n\n    for (const char c : s1)\n      ++count[c - 'a'];\n\n    for (const char c : s2)\n      --count[c - 'a'];\n\n    for (int i = 1; i < 26; ++i)\n      count[i] += count[i - 1];\n\n    return ranges::all_of(count, [](int c) { return c <= 0; }) ||\n           ranges::all_of(count, [](int c) { return c >= 0; });\n  }\n};\n", "1434": "class Solution {\n public:\n  int numberWays(vector<vector<int>>& hats) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int nHats = 40;\n    const int nPeople = hats.size();\n    const int nAssignments = 1 << nPeople;\n    vector<vector<int>> hatToPeople(nHats + 1);\n    // dp[i][j] := the number of ways to assign hats 1, 2, ..., i to people,\n    // where j is the bitmask of the current assignment\n    vector<vector<int>> dp(nHats + 1, vector<int>(nAssignments));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < nPeople; ++i)\n      for (const int hat : hats[i])\n        hatToPeople[hat].push_back(i);\n\n    for (int h = 1; h <= nHats; ++h)\n      for (int j = 0; j < nAssignments; ++j) {\n        // We can cover the assignment j in 2 ways:\n        // 1. Assign the first h - 1 hats to people without using the hat `h`.\n        dp[h][j] += dp[h - 1][j];\n        dp[h][j] %= kMod;\n        for (const int p : hatToPeople[h])\n          if (j >> p & 1) {\n            // 2. Assign the first h - 1 hats to people without the person `p`\n            //    and assign the hat `h` to the person `p`.\n            dp[h][j] += dp[h - 1][j ^ 1 << p];\n            dp[h][j] %= kMod;\n          }\n      }\n\n    return dp[nHats][nAssignments - 1];\n  }\n};\n", "1438": "class Solution {\n public:\n  int longestSubarray(vector<int>& nums, int limit) {\n    int ans = 1;\n    deque<int> minQ;\n    deque<int> maxQ;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      while (!minQ.empty() && minQ.back() > nums[r])\n        minQ.pop_back();\n      minQ.push_back(nums[r]);\n      while (!maxQ.empty() && maxQ.back() < nums[r])\n        maxQ.pop_back();\n      maxQ.push_back(nums[r]);\n      while (maxQ.front() - minQ.front() > limit) {\n        if (minQ.front() == nums[l])\n          minQ.pop_front();\n        if (maxQ.front() == nums[l])\n          maxQ.pop_front();\n        ++l;\n      }\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "1439": "struct T {\n  int i;\n  int j;\n  int sum;  // nums1[i] + nums2[j]\n};\n\nclass Solution {\n public:\n  int kthSmallest(vector<vector<int>>& mat, int k) {\n    vector<int> row = mat[0];\n\n    for (int i = 1; i < mat.size(); ++i)\n      row = kSmallestPairSums(row, mat[i], k);\n\n    return row.back();\n  }\n\n private:\n  // Similar to 373. Find K Pairs with Smallest Sums\n  vector<int> kSmallestPairSums(vector<int>& nums1, vector<int>& nums2, int k) {\n    vector<int> ans;\n    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (int i = 0; i < k && i < nums1.size(); ++i)\n      minHeap.emplace(i, 0, nums1[i] + nums2[0]);\n\n    while (!minHeap.empty() && ans.size() < k) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      ans.push_back(nums1[i] + nums2[j]);\n      if (j + 1 < nums2.size())\n        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);\n    }\n\n    return ans;\n  }\n};\n", "144": "class Solution {\n public:\n  vector<int> preorderTraversal(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> ans;\n    stack<TreeNode*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      if (root->right)\n        stack.push(root->right);\n      if (root->left)\n        stack.push(root->left);\n    }\n\n    return ans;\n  }\n};\n", "1443": "class Solution {\n public:\n  int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    return dfs(graph, 0, vector<bool>(n), hasApple);\n  }\n\n private:\n  int dfs(const vector<vector<int>>& graph, int u, vector<bool>&& seen,\n          const vector<bool>& hasApple) {\n    seen[u] = true;\n    int totalCost = 0;\n\n    for (const int v : graph[u]) {\n      if (seen[v])\n        continue;\n      const int cost = dfs(graph, v, std::move(seen), hasApple);\n      if (cost > 0 || hasApple[v])\n        totalCost += cost + 2;\n    }\n\n    return totalCost;\n  }\n};\n", "1444": "class Solution {\n public:\n  int ways(vector<string>& pizza, int k) {\n    const int M = pizza.size();\n    const int N = pizza[0].size();\n    vector<vector<vector<int>>> mem(M,\n                                    vector<vector<int>>(N, vector<int>(k, -1)));\n    vector<vector<int>> prefix(M + 1, vector<int>(N + 1));\n\n    for (int i = 0; i < M; ++i)\n      for (int j = 0; j < N; ++j)\n        prefix[i + 1][j + 1] = (pizza[i][j] == 'A') + prefix[i][j + 1] +\n                               prefix[i + 1][j] - prefix[i][j];\n\n    return ways(0, 0, k - 1, M, N, prefix, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.\n  int ways(int m, int n, int k, const int M, const int N,\n           const vector<vector<int>>& prefix,\n           vector<vector<vector<int>>>& mem) {\n    if (k == 0)\n      return hasApple(prefix, m, M, n, N) ? 1 : 0;\n    if (mem[m][n][k] != -1)\n      return mem[m][n][k];\n\n    mem[m][n][k] = 0;\n\n    for (int i = m + 1; i < M; ++i)  // Cut horizontally.\n      if (hasApple(prefix, m, i, n, N) && hasApple(prefix, i, M, n, N)) {\n        mem[m][n][k] += ways(i, n, k - 1, M, N, prefix, mem);\n        mem[m][n][k] %= kMod;\n      }\n\n    for (int j = n + 1; j < N; ++j)  // Cut vertically.\n      if (hasApple(prefix, m, M, n, j) && hasApple(prefix, m, M, j, N)) {\n        mem[m][n][k] += ways(m, j, k - 1, M, N, prefix, mem);\n        mem[m][n][k] %= kMod;\n      }\n\n    return mem[m][n][k];\n  }\n\n  // Returns true if pizza[row1..row2)[col1..col2) has apple.\n  bool hasApple(const vector<vector<int>>& prefix, int row1, int row2, int col1,\n                int col2) {\n    return (prefix[row2][col2] - prefix[row1][col2] -  //\n            prefix[row2][col1] + prefix[row1][col1]) > 0;\n  };\n};\n", "1446": "class Solution {\n public:\n  int maxPower(string s) {\n    int ans = 1;\n    int count = 1;\n\n    for (int i = 1; i < s.length(); ++i) {\n      count = s[i] == s[i - 1] ? count + 1 : 1;\n      ans = max(ans, count);\n    }\n\n    return ans;\n  }\n};\n", "1447": "class Solution {\n public:\n  vector<string> simplifiedFractions(int n) {\n    vector<string> ans;\n    for (int denominator = 2; denominator <= n; ++denominator)\n      for (int numerator = 1; numerator < denominator; ++numerator)\n        if (__gcd(denominator, numerator) == 1)\n          ans.push_back(to_string(numerator) + \"/\" + to_string(denominator));\n    return ans;\n  }\n};\n", "1448": "class Solution {\n public:\n  int goodNodes(TreeNode* root, int mx = INT_MIN) {\n    if (root == nullptr)\n      return 0;\n    const int newMax = max(mx, root->val);\n    return (root->val >= mx) +              //\n           goodNodes(root->left, newMax) +  //\n           goodNodes(root->right, newMax);\n  }\n};\n", "1449": "class Solution {\n public:\n  string largestNumber(vector<int>& cost, int target) {\n    // dp[i] := the maximum length that cost i can achieve\n    vector<int> dp(target + 1, INT_MIN);\n    dp[0] = 0;  // If cost = 0, the best choice is the empty string \"\".\n\n    for (int i = 1; i <= target; ++i)\n      for (int d = 0; d < 9; ++d)\n        if (i >= cost[d])\n          dp[i] = max(dp[i], dp[i - cost[d]] + 1);\n\n    if (dp[target] < 0)\n      return \"0\";\n\n    string ans;\n\n    // Greedily build the ans string.\n    for (int d = 8; d >= 0; --d)\n      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {\n        target -= cost[d];\n        ans += '1' + d;\n      }\n\n    return ans;\n  }\n};\n", "145": "class Solution {\n public:\n  vector<int> postorderTraversal(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> ans;\n    stack<TreeNode*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      if (root->left)\n        stack.push(root->left);\n      if (root->right)\n        stack.push(root->right);\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "1450": "class Solution {\n public:\n  int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n    const int n = startTime.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (startTime[i] <= queryTime && queryTime <= endTime[i])\n        ++ans;\n\n    return ans;\n  }\n};\n", "1453": "struct Point {\n  double x;\n  double y;\n  Point(double x, double y) : x(x), y(y) {}\n};\n\nclass Solution {\n public:\n  int numPoints(vector<vector<int>>& darts, int r) {\n    int ans = 1;\n    vector<Point> points = convertToPoints(darts);\n\n    for (int i = 0; i < points.size(); ++i)\n      for (int j = i + 1; j < points.size(); ++j)\n        for (const Point& c : getCircles(points[i], points[j], r)) {\n          int count = 0;\n          for (const Point& point : points)\n            if (dist(c, point) - r <= kErr)\n              ++count;\n          ans = max(ans, count);\n        }\n\n    return ans;\n  }\n\n private:\n  static constexpr double kErr = 1e-6;\n\n  vector<Point> convertToPoints(const vector<vector<int>>& darts) {\n    vector<Point> points;\n    for (const vector<int>& dart : darts)\n      points.emplace_back(dart[0], dart[1]);\n    return points;\n  }\n\n  vector<Point> getCircles(const Point& p, const Point& q, int r) {\n    if (dist(p, q) - 2.0 * r > kErr)\n      return {};\n    const Point m{(p.x + q.x) / 2, (p.y + q.y) / 2};\n    const double distCM = sqrt(pow(r, 2) - pow(dist(p, q) / 2, 2));\n    const double alpha = atan2(p.y - q.y, q.x - p.x);\n    return {Point{m.x - distCM * sin(alpha), m.y - distCM * cos(alpha)},\n            Point{m.x + distCM * sin(alpha), m.y + distCM * cos(alpha)}};\n  }\n\n  double dist(const Point& p, const Point& q) {\n    return sqrt(pow(p.x - q.x, 2) + pow(p.y - q.y, 2));\n  }\n};\n", "1457": "class Solution {\n public:\n  int pseudoPalindromicPaths(TreeNode* root) {\n    int ans = 0;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int path, int& ans) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      path ^= 1 << root->val;\n      if ((path & (path - 1)) == 0)\n        ++ans;\n      return;\n    }\n\n    dfs(root->left, path ^ 1 << root->val, ans);\n    dfs(root->right, path ^ 1 << root->val, ans);\n  }\n};\n", "1458": "class Solution {\n public:\n  int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n    const int m = nums1.size();\n    const int n = nums2.size();\n    // dp[i][j] := the maximum dot product of the two subsequences nums[0..i)\n    // and nums2[0..j)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        dp[i + 1][j + 1] = max({dp[i][j + 1], dp[i + 1][j],\n                                max(0, dp[i][j]) + nums1[i] * nums2[j]});\n\n    return dp[m][n];\n  }\n};\n", "146": "struct Node {\n  int key;\n  int value;\n};\n\nclass LRUCache {\n public:\n  LRUCache(int capacity) : capacity(capacity) {}\n\n  int get(int key) {\n    const auto it = keyToIterator.find(key);\n    if (it == keyToIterator.cend())\n      return -1;\n\n    const auto& listIt = it->second;\n    // Move it to the front.\n    cache.splice(cache.begin(), cache, listIt);\n    return listIt->value;\n  }\n\n  void put(int key, int value) {\n    // There's no capacity issue, so just update the value.\n    if (const auto it = keyToIterator.find(key); it != keyToIterator.cend()) {\n      const auto& listIt = it->second;\n      // Move it to the front.\n      cache.splice(cache.begin(), cache, listIt);\n      listIt->value = value;\n      return;\n    }\n\n    // Check the capacity.\n    if (cache.size() == capacity) {\n      const Node& lastNode = cache.back();\n      // That's why we store `key` in `Node`.\n      keyToIterator.erase(lastNode.key);\n      cache.pop_back();\n    }\n\n    cache.emplace_front(key, value);\n    keyToIterator[key] = cache.begin();\n  }\n\n private:\n  const int capacity;\n  list<Node> cache;\n  unordered_map<int, list<Node>::iterator> keyToIterator;\n};\n", "1460": "class Solution {\n public:\n  bool canBeEqual(vector<int>& target, vector<int>& arr) {\n    return unordered_multiset<int>(arr.begin(), arr.end()) ==\n           unordered_multiset<int>(target.begin(), target.end());\n  }\n};\n", "1461": "class Solution {\n public:\n  bool hasAllCodes(string s, int k) {\n    const int n = 1 << k;\n    if (s.length() < n)\n      return false;\n\n    // used[i] := true if i is a substring of `s`\n    vector<bool> used(n);\n\n    int window = k == 1 ? 0 : stoi(s.substr(0, k - 1), nullptr, 2);\n    for (int i = k - 1; i < s.length(); ++i) {\n      // Include the s[i].\n      window = (window << 1) + (s[i] - '0');\n      // Discard the s[i - k].\n      window &= n - 1;\n      used[window] = true;\n    }\n\n    return ranges::all_of(used, [](bool u) { return u; });\n  }\n};\n", "1462": "class Solution {\n public:\n  vector<bool> checkIfPrerequisite(int numCourses,\n                                   vector<vector<int>>& prerequisites,\n                                   vector<vector<int>>& queries) {\n    vector<bool> ans;\n    // isPrerequisite[i][j] := true if course i is a prerequisite of course j\n    vector<vector<bool>> isPrerequisite(numCourses, vector<bool>(numCourses));\n\n    for (const vector<int>& prerequisite : prerequisites) {\n      const int u = prerequisite[0];\n      const int v = prerequisite[1];\n      isPrerequisite[u][v] = true;\n    }\n\n    for (int k = 0; k < numCourses; ++k)\n      for (int i = 0; i < numCourses; ++i)\n        for (int j = 0; j < numCourses; ++j)\n          isPrerequisite[i][j] = isPrerequisite[i][j] ||\n                                 (isPrerequisite[i][k] && isPrerequisite[k][j]);\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      ans.push_back(isPrerequisite[u][v]);\n    }\n\n    return ans;\n  }\n};\n", "1463": "class Solution {\n public:\n  int cherryPickup(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dp[x][y1][y2] := the maximum cherries we can collect, where the robot #1\n    // is on (x, y1) and the robot #2 is on (x, y2)\n    vector<vector<vector<int>>> dp(m + 1,\n                                   vector<vector<int>>(n, vector<int>(n)));\n\n    for (int x = m - 1; x >= 0; --x)\n      for (int y1 = 0; y1 < n; ++y1)\n        for (int y2 = 0; y2 < n; ++y2) {\n          const int currRow = grid[x][y1] + (y1 != y2) * grid[x][y2];\n          for (int d1 = max(0, y1 - 1); d1 < min(n, y1 + 2); ++d1)\n            for (int d2 = max(0, y2 - 1); d2 < min(n, y2 + 2); ++d2)\n              dp[x][y1][y2] = max(dp[x][y1][y2], currRow + dp[x + 1][d1][d2]);\n        }\n\n    return dp[0][0][n - 1];\n  }\n};\n", "1464": "class Solution {\n public:\n  int maxProduct(vector<int>& nums) {\n    const auto maxIt1 = ranges::max_element(nums);\n    *maxIt1 *= -1;\n    const int max2 = ranges::max(nums);\n    *maxIt1 *= -1;\n    return (*maxIt1 - 1) * (max2 - 1);\n  }\n};\n", "1465": "class Solution {\n public:\n  int maxArea(int h, int w, vector<int>& horizontalCuts,\n              vector<int>& verticalCuts) {\n    constexpr int kMod = 1'000'000'007;\n    ranges::sort(horizontalCuts);\n    ranges::sort(verticalCuts);\n\n    // the maximum gap of each direction\n    int maxGapX = max(verticalCuts[0], w - verticalCuts.back());\n    int maxGapY = max(horizontalCuts[0], h - horizontalCuts.back());\n\n    for (int i = 1; i < verticalCuts.size(); ++i)\n      maxGapX = max(maxGapX, verticalCuts[i] - verticalCuts[i - 1]);\n\n    for (int i = 1; i < horizontalCuts.size(); ++i)\n      maxGapY = max(maxGapY, horizontalCuts[i] - horizontalCuts[i - 1]);\n\n    return static_cast<long>(maxGapX) * maxGapY % kMod;\n  }\n};\n", "1466": "class Solution {\n public:\n  int minReorder(int n, vector<vector<int>>& connections) {\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      graph[u].push_back(v);\n      graph[v].push_back(-u);  // - := u -> v\n    }\n\n    return dfs(graph, 0, -1);\n  }\n\n private:\n  int dfs(const vector<vector<int>>& graph, int u, int prev) {\n    int change = 0;\n\n    for (const int v : graph[u]) {\n      if (abs(v) == prev)\n        continue;\n      if (v > 0)\n        ++change;\n      change += dfs(graph, abs(v), u);\n    }\n\n    return change;\n  }\n};\n", "1467": "enum class BoxCase { kEqualBalls, kEqualDistantBalls };\n\nclass Solution {\n public:\n  double getProbability(vector<int>& balls) {\n    const int n = accumulate(balls.begin(), balls.end(), 0) / 2;\n    return cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualDistantBalls) /\n           cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualBalls);\n  }\n\n private:\n  const vector<int> fact{1, 1, 2, 6, 24, 120, 720};\n\n  // Assume we have two boxes A and B.\n  double cases(const vector<int>& balls, int i, int ballsCountA,\n               int ballsCountB, int colorsCountA, int colorsCountB, int n,\n               BoxCase boxCase) {\n    if (ballsCountA > n || ballsCountB > n)\n      return 0;\n    if (i == balls.size())\n      return boxCase == BoxCase::kEqualBalls ? 1 : colorsCountA == colorsCountB;\n\n    double ans = 0;\n\n    // balls taken from A for `balls[i]`\n    for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {\n      const int ballsTakenB = balls[i] - ballsTakenA;\n      const int newcolorsCountA = colorsCountA + (ballsTakenA > 0);\n      const int newcolorsCountB = colorsCountB + (ballsTakenB > 0);\n      ans += cases(balls, i + 1, ballsCountA + ballsTakenA,\n                   ballsCountB + ballsTakenB, newcolorsCountA, newcolorsCountB,\n                   n, boxCase) /\n             (fact[ballsTakenA] * fact[ballsTakenB]);\n    }\n\n    return ans;\n  }\n};\n", "1469": "class Solution {\n public:\n  vector<int> getLonelyNodes(TreeNode* root) {\n    vector<int> ans;\n\n    dfs(root, false, ans);\n\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, bool isLonely, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n    if (isLonely)\n      ans.push_back(root->val);\n\n    dfs(root->left, root->right == nullptr, ans);\n    dfs(root->right, root->left == nullptr, ans);\n  }\n};\n", "147": "class Solution {\n public:\n  ListNode* insertionSortList(ListNode* head) {\n    ListNode dummy(0);\n    ListNode* prev = &dummy;  // the last and thus largest of the sorted list\n\n    while (head != nullptr) {       // the current inserting node\n      ListNode* next = head->next;  // Cache the next inserting node.\n      if (prev->val >= head->val)\n        prev = &dummy;  // Move `prev` to the front.\n      while (prev->next && prev->next->val < head->val)\n        prev = prev->next;\n      head->next = prev->next;\n      prev->next = head;\n      head = next;  // Update the current inserting node.\n    }\n\n    return dummy.next;\n  }\n};\n", "1470": "class Solution {\n public:\n  vector<int> shuffle(vector<int>& nums, int n) {\n    vector<int> ans;\n    for (int i = 0; i < n; ++i) {\n      ans.push_back(nums[i]);\n      ans.push_back(nums[i + n]);\n    }\n    return ans;\n  }\n};\n", "1471": "class Solution {\n public:\n  vector<int> getStrongest(vector<int>& arr, int k) {\n    const int midIndex = (arr.size() - 1) / 2;\n    nth_element(arr.begin(), arr.begin() + midIndex, arr.end());\n    const int median = arr[midIndex];\n\n    nth_element(arr.begin(), arr.begin() + k, arr.end(), [&](int a, int b) {\n      const int da = abs(a - median);\n      const int db = abs(b - median);\n      return da == db ? a > b : da > db;\n    });\n\n    arr.resize(k);\n    return arr;\n  }\n};\n", "1472": "class BrowserHistory {\n public:\n  BrowserHistory(string homepage) {\n    visit(homepage);\n  }\n\n  void visit(string url) {\n    history.push(url);\n    future = stack<string>();\n  }\n\n  string back(int steps) {\n    while (history.size() > 1 && steps-- > 0)\n      future.push(history.top()), history.pop();\n    return history.top();\n  }\n\n  string forward(int steps) {\n    while (!future.empty() && steps-- > 0)\n      history.push(future.top()), future.pop();\n    return history.top();\n  }\n\n private:\n  stack<string> history;\n  stack<string> future;\n};\n", "1473": "class Solution {\n public:\n  int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n,\n              int target) {\n    vector<vector<vector<int>>> mem(target + 1,\n                                    vector<vector<int>>(m, vector<int>(n + 1)));\n    // Initialize `prevColor` to 0 (the virtual neighbor).\n    const int c = minCost(houses, cost, m, n, target, 0, 0, mem);\n    return c == kMax ? -1 : c;\n  }\n\n private:\n  static constexpr int kMax = 1'000'001;\n\n  // Returns the minimum cost to paint houses[i..m) into k neighborhoods, where\n  // there are houses[i - 1] colors = prevColor.\n  int minCost(const vector<int>& houses, const vector<vector<int>>& cost,\n              const int& m, const int& n, int k, int i, int prevColor,\n              vector<vector<vector<int>>>& mem) {\n    if (i == m || k < 0)\n      return k == 0 ? 0 : kMax;\n    if (mem[k][i][prevColor] > 0)\n      return mem[k][i][prevColor];\n    if (houses[i] > 0)  // The house was painted last year.\n      return minCost(houses, cost, m, n, k - (prevColor != houses[i]), i + 1,\n                     houses[i], mem);\n\n    int res = kMax;\n\n    // Try to paint the houses[i] with each color in 1..n.\n    for (int color = 1; color <= n; ++color)\n      res = min(res, cost[i][color - 1] + minCost(houses, cost, m, n,\n                                                  k - (prevColor != color),\n                                                  i + 1, color, mem));\n\n    return mem[k][i][prevColor] = res;\n  }\n};\n", "1474": "class Solution {\n public:\n  ListNode* deleteNodes(ListNode* head, int m, int n) {\n    ListNode* curr = head;\n    ListNode* prev = nullptr;  // prev.next == curr\n\n    while (curr != nullptr) {\n      // Set the m-th node as `prev`.\n      for (int i = 0; i < m & curr != nullptr; ++i) {\n        prev = curr;\n        curr = curr->next;\n      }\n      // Set the (m + n + 1)-th node as `curr`.\n      for (int i = 0; i < n && curr != nullptr; ++i)\n        curr = curr->next;\n      // Delete the nodes [m + 1..n - 1].\n      prev->next = curr;\n    }\n\n    return head;\n  }\n};\n", "1475": "class Solution {\n public:\n  vector<int> finalPrices(vector<int>& prices) {\n    vector<int> ans{prices};\n    stack<int> stack;\n\n    for (int j = 0; j < prices.size(); ++j) {\n      // stack[-1] : = i in the problem description.\n      while (!stack.empty() && prices[j] <= prices[stack.top()])\n        ans[stack.top()] -= prices[j], stack.pop();\n      stack.push(j);\n    }\n\n    return ans;\n  }\n};\n", "1476": "class SubrectangleQueries {\n public:\n  SubrectangleQueries(vector<vector<int>>& rectangle) : rectangle(rectangle) {}\n\n  void updateSubrectangle(int row1, int col1, int row2, int col2,\n                          int newValue) {\n    updates.push_back({row1, col1, row2, col2, newValue});\n  }\n\n  int getValue(int row, int col) {\n    for (int i = updates.size() - 1; i >= 0; --i) {\n      auto [r1, c1, r2, c2, v] = updates[i];\n      if (r1 <= row && row <= r2 && c1 <= col && col <= c2)\n        return v;\n    }\n    return rectangle[row][col];\n  }\n\n private:\n  const vector<vector<int>>& rectangle;\n  vector<array<int, 5>> updates;  // [r1, c1, r2, c2, v]\n};\n", "1477": "class Solution {\n public:\n  int minSumOfLengths(vector<int>& arr, int target) {\n    int ans = INT_MAX;\n    int sum = 0;  // the window sum\n    // best[i] := the minimum length of subarrays in arr[0..i] that have\n    // sum = target\n    vector<int> best(arr.size(), INT_MAX);\n\n    for (int l = 0, r = 0; r < arr.size(); ++r) {\n      sum += arr[r];  // Expand the window.\n      while (sum > target)\n        sum -= arr[l++];  // Shrink the window.\n      if (sum == target) {\n        if (l > 0 && best[l - 1] != INT_MAX)\n          ans = min(ans, best[l - 1] + r - l + 1);\n        best[r] = min(best[r], r - l + 1);\n      }\n      if (r > 0)\n        best[r] = min(best[r], best[r - 1]);\n    }\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "1478": "class Solution {\n public:\n  int minDistance(vector<int>& houses, int k) {\n    const int n = houses.size();\n    vector<vector<int>> mem(n, vector<int>(k + 1, INT_MAX));\n    // cost[i][j] := the minimum cost to allocate mailboxes between houses[i]\n    // and houses[j]\n    vector<vector<int>> cost(n, vector<int>(n));\n\n    ranges::sort(houses);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        const int median = houses[(i + j) / 2];\n        for (int x = i; x <= j; ++x)\n          cost[i][j] += abs(houses[x] - median);\n      }\n\n    return minDistance(houses, 0, k, cost, mem);\n  }\n\n private:\n  static constexpr int kMax = 1'000'000;\n\n  // Returns the minimum distance to allocate k mailboxes for houses[i..n).\n  int minDistance(const vector<int>& houses, int i, int k,\n                  const vector<vector<int>>& cost, vector<vector<int>>& mem) {\n    if (i == houses.size() && k == 0)\n      return 0;\n    if (i == houses.size() || k == 0)\n      return kMax;\n    if (mem[i][k] != INT_MAX)\n      return mem[i][k];\n\n    for (int j = i; j < houses.size(); ++j)\n      mem[i][k] = min(\n          mem[i][k], cost[i][j] + minDistance(houses, j + 1, k - 1, cost, mem));\n\n    return mem[i][k];\n  }\n};\n", "148": "class Solution {\n public:\n  ListNode* sortList(ListNode* head) {\n    const int length = getLength(head);\n    ListNode dummy(0, head);\n\n    for (int k = 1; k < length; k *= 2) {\n      ListNode* curr = dummy.next;\n      ListNode* tail = &dummy;\n      while (curr != nullptr) {\n        ListNode* l = curr;\n        ListNode* r = split(l, k);\n        curr = split(r, k);\n        auto [mergedHead, mergedTail] = merge(l, r);\n        tail->next = mergedHead;\n        tail = mergedTail;\n      }\n    }\n\n    return dummy.next;\n  }\n\n private:\n  int getLength(ListNode* head) {\n    int length = 0;\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n\n  ListNode* split(ListNode* head, int k) {\n    while (--k && head)\n      head = head->next;\n    ListNode* rest = head ? head->next : nullptr;\n    if (head != nullptr)\n      head->next = nullptr;\n    return rest;\n  }\n\n  pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {\n    ListNode dummy(0);\n    ListNode* tail = &dummy;\n\n    while (l1 && l2) {\n      if (l1->val > l2->val)\n        swap(l1, l2);\n      tail->next = l1;\n      l1 = l1->next;\n      tail = tail->next;\n    }\n    tail->next = l1 ? l1 : l2;\n    while (tail->next != nullptr)\n      tail = tail->next;\n\n    return {dummy.next, tail};\n  }\n};\n", "1480": "class Solution {\n public:\n  vector<int> runningSum(vector<int>& nums) {\n    vector<int> ans;\n    int sum = 0;\n    for (const int num : nums)\n      ans.push_back(sum += num);\n    return ans;\n  }\n};\n", "1481": "class Solution {\n public:\n  int findLeastNumOfUniqueInts(vector<int>& arr, int k) {\n    unordered_map<int, int> count;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int a : arr)\n      ++count[a];\n\n    for (const auto& [_, freq] : count)\n      minHeap.push(freq);\n\n    // Greedily remove the k least frequent numbers to have the least number of\n    // unique integers.\n    while (k > 0)\n      k -= minHeap.top(), minHeap.pop();\n\n    return minHeap.size() + (k < 0 ? 1 : 0);\n  }\n};\n", "1482": "class Solution {\n public:\n  int minDays(vector<int>& bloomDay, int m, int k) {\n    if (bloomDay.size() < static_cast<long>(m) * k)\n      return -1;\n\n    int l = ranges::min(bloomDay);\n    int r = ranges::max(bloomDay);\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      if (getBouquetCount(bloomDay, k, mid) >= m)\n        r = mid;\n      else\n        l = mid + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the number of bouquets (k flowers needed) can be made after the\n  // `waitingDays`..\n  int getBouquetCount(const vector<int>& bloomDay, int k, int waitingDays) {\n    int bouquetCount = 0;\n    int requiredFlowers = k;\n    for (const int day : bloomDay)\n      if (day > waitingDays) {\n        // Reset `requiredFlowers` since there was not enough adjacent flowers.\n        requiredFlowers = k;\n      } else if (--requiredFlowers == 0) {\n        // Use k adjacent flowers to make a bouquet.\n        ++bouquetCount;\n        requiredFlowers = k;\n      }\n    return bouquetCount;\n  }\n};\n", "1483": "class TreeAncestor {\n public:\n  TreeAncestor(int n, vector<int>& parent)\n      : maxLevel(32 - __builtin_clz(n)), dp(n, vector<int>(maxLevel)) {\n    // Node i's 2^0 ancestor is its direct parent.\n    for (int i = 0; i < n; ++i)\n      dp[i][0] = parent[i];\n\n    for (int j = 1; j < maxLevel; ++j)\n      for (int i = 0; i < n; ++i)\n        if (dp[i][j - 1] == -1)  // There's no such ancestor.\n          dp[i][j] = -1;\n        else  // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})\n          dp[i][j] = dp[dp[i][j - 1]][j - 1];\n  }\n\n  int getKthAncestor(int node, int k) {\n    for (int j = 0; j < maxLevel && node != -1; ++j)\n      if (k >> j & 1)\n        node = dp[node][j];\n    return node;\n  }\n\n private:\n  const int maxLevel;\n  vector<vector<int>> dp;  // dp[i][j] := node i's 2^j-th ancestor\n};\n", "1485": "class Solution {\n public:\n  NodeCopy* copyRandomBinaryTree(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n    if (const auto it = map.find(root); it != map.cend())\n      return it->second;\n\n    NodeCopy* newNode = new NodeCopy(root->val);\n    map[root] = newNode;\n\n    newNode->left = copyRandomBinaryTree(root->left);\n    newNode->right = copyRandomBinaryTree(root->right);\n    newNode->random = copyRandomBinaryTree(root->random);\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, NodeCopy*> map;\n};\n", "1486": "class Solution {\n public:\n  int xorOperation(int n, int start) {\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n      ans ^= start + 2 * i;\n    return ans;\n  }\n};\n", "1487": "class Solution {\n public:\n  vector<string> getFolderNames(vector<string>& names) {\n    vector<string> ans;\n    unordered_map<string, int> nameToSuffix;\n\n    for (const string& name : names)\n      if (const auto it = nameToSuffix.find(name); it != nameToSuffix.cend()) {\n        int suffix = it->second;\n        string newName = getName(name, ++suffix);\n        while (nameToSuffix.contains(newName))\n          newName = getName(name, ++suffix);\n        nameToSuffix[name] = suffix;\n        nameToSuffix[newName] = 0;\n        ans.push_back(newName);\n      } else {\n        nameToSuffix[name] = 0;\n        ans.push_back(name);\n      }\n\n    return ans;\n  }\n\n private:\n  string getName(const string& name, int suffix) {\n    return name + \"(\" + to_string(suffix) + \")\";\n  }\n};\n", "1488": "class Solution {\n public:\n  vector<int> avoidFlood(vector<int>& rains) {\n    vector<int> ans(rains.size(), -1);\n    unordered_map<int, int> lakeIdToFullDay;\n    set<int> emptyDays;  // indices of rains[i] == 0\n\n    for (int i = 0; i < rains.size(); ++i) {\n      const int lakeId = rains[i];\n      if (lakeId == 0) {\n        emptyDays.insert(i);\n        continue;\n      }\n      if (const auto itFullDay = lakeIdToFullDay.find(lakeId);\n          itFullDay != lakeIdToFullDay.cend()) {\n        // The lake was full in a previous day. Greedily find the closest day\n        // to make the lake empty.\n        const auto itEmptyDay = emptyDays.upper_bound(itFullDay->second);\n        if (itEmptyDay == emptyDays.cend())  // Not found.\n          return {};\n        // Empty the lake at this day.\n        ans[*itEmptyDay] = lakeId;\n        emptyDays.erase(itEmptyDay);\n      }\n      // The lake with `lakeId` becomes full at the day `i`.\n      lakeIdToFullDay[lakeId] = i;\n    }\n\n    // Empty an arbitrary lake if there are remaining empty days.\n    for (const int emptyDay : emptyDays)\n      ans[emptyDay] = 1;\n\n    return ans;\n  }\n};\n", "1489": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<vector<int>> findCriticalAndPseudoCriticalEdges(\n      int n, vector<vector<int>>& edges) {\n    vector<int> criticalEdges;\n    vector<int> pseudoCriticalEdges;\n\n    // Record the index information, so edges[i] := (u, v, weight, index).\n    for (int i = 0; i < edges.size(); ++i)\n      edges[i].push_back(i);\n\n    // Sort by the weight.\n    ranges::sort(edges, ranges::less{},\n                 [](const vector<int>& edge) { return edge[2]; });\n\n    const int mstWeight = getMSTWeight(n, edges, {}, -1);\n\n    for (const vector<int>& edge : edges) {\n      const int index = edge[3];\n      // Deleting the `edge` increases the MST's weight or makes the MST\n      // invalid.\n      if (getMSTWeight(n, edges, {}, index) > mstWeight)\n        criticalEdges.push_back(index);\n      // If an edge can be in any MST, we can always add `edge` to the edge set.\n      else if (getMSTWeight(n, edges, edge, -1) == mstWeight)\n        pseudoCriticalEdges.push_back(index);\n    }\n\n    return {criticalEdges, pseudoCriticalEdges};\n  }\n\n private:\n  int getMSTWeight(int n, const vector<vector<int>>& edges,\n                   const vector<int>& firstEdge, int deletedEdgeIndex) {\n    int mstWeight = 0;\n    UnionFind uf(n);\n\n    if (!firstEdge.empty()) {\n      uf.unionByRank(firstEdge[0], firstEdge[1]);\n      mstWeight += firstEdge[2];\n    }\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int weight = edge[2];\n      const int index = edge[3];\n      if (index == deletedEdgeIndex)\n        continue;\n      if (uf.find(u) == uf.find(v))\n        continue;\n      uf.unionByRank(u, v);\n      mstWeight += weight;\n    }\n\n    const int root = uf.find(0);\n    for (int i = 0; i < n; ++i)\n      if (uf.find(i) != root)\n        return INT_MAX;\n\n    return mstWeight;\n  }\n};\n", "149": "class Solution {\n public:\n  int maxPoints(vector<vector<int>>& points) {\n    int ans = 0;\n\n    for (int i = 0; i < points.size(); ++i) {\n      unordered_map<pair<int, int>, int, PairHash> slopeCount;\n      const vector<int> p1{points[i]};\n      int samePoints = 1;\n      int maxPoints = 0;  // the maximum number of points with the same slope\n      for (int j = i + 1; j < points.size(); ++j) {\n        const vector<int> p2{points[j]};\n        if (p1 == p2)\n          ++samePoints;\n        else\n          maxPoints = max(maxPoints, ++slopeCount[getSlope(p1, p2)]);\n      }\n      ans = max(ans, samePoints + maxPoints);\n    }\n\n    return ans;\n  }\n\n private:\n  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {\n    const int dx = p[0] - q[0];\n    const int dy = p[1] - q[1];\n    if (dx == 0)\n      return {0, p[0]};\n    if (dy == 0)\n      return {p[1], 0};\n    const int d = __gcd(dx, dy);\n    return {dx / d, dy / d};\n  }\n\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "1490": "class Solution {\n public:\n  Node* cloneTree(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n    if (const auto it = map.find(root); it != map.cend())\n      return it->second;\n\n    Node* newNode = new Node(root->val);\n    map[root] = newNode;\n\n    for (Node* child : root->children)\n      newNode->children.push_back(cloneTree(child));\n\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, Node*> map;\n};\n", "1491": "class Solution {\n public:\n  double average(vector<int>& salary) {\n    const double sum = accumulate(salary.begin(), salary.end(), 0.0);\n    const int mx = ranges::max(salary);\n    const int mn = ranges::min(salary);\n    return (sum - mx - mn) / (salary.size() - 2);\n  }\n};\n", "1492": "class Solution {\n public:\n  int kthFactor(int n, int k) {\n    // If i is a divisor of n, then n / i is also a divisor of n. So, we can\n    // find all the divisors of n by processing the numbers <= sqrt(n).\n    int factor = 1;\n    int i = 0;  // the i-th factor\n\n    for (; factor * factor < n; ++factor)\n      if (n % factor == 0 && ++i == k)\n        return factor;\n\n    for (factor = n / factor; factor >= 1; --factor)\n      if (n % factor == 0 && ++i == k)\n        return n / factor;\n\n    return -1;\n  }\n};\n", "1493": "class Solution {\n public:\n  int longestSubarray(vector<int>& nums) {\n    int l = 0;\n    int zeros = 0;\n\n    for (const int num : nums) {\n      if (num == 0)\n        ++zeros;\n      if (zeros > 1 && nums[l++] == 0)\n        --zeros;\n    }\n\n    return nums.size() - l - 1;\n  }\n};\n", "1494": "class Solution {\n public:\n  int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\n    // dp[i] := the minimum number of semesters to take the courses, where i is\n    // the bitmask of the taken courses\n    vector<int> dp(1 << n, n);\n    // prereq[i] := the bitmask of all the dependencies of the i-th course\n    vector<int> prereq(n);\n\n    for (const vector<int>& relation : relations) {\n      const int prevCourse = relation[0] - 1;\n      const int nextCourse = relation[1] - 1;\n      prereq[nextCourse] |= 1 << prevCourse;\n    }\n\n    dp[0] = 0;  // Don't need time to finish 0 course.\n\n    for (int i = 0; i < dp.size(); ++i) {\n      // the bitmask of all the courses can be taken\n      int coursesCanBeTaken = 0;\n      // Can take the j-th course if i contains all of j's prerequisites.\n      for (int j = 0; j < n; ++j)\n        if ((i & prereq[j]) == prereq[j])\n          coursesCanBeTaken |= 1 << j;\n      // Don't take any course which is already taken.\n      // (i represents set of courses that are already taken)\n      coursesCanBeTaken &= ~i;\n      // Enumerate every bitmask subset of `coursesCanBeTaken`.\n      for (unsigned s = coursesCanBeTaken; s > 0;\n           s = (s - 1) & coursesCanBeTaken)\n        if (popcount(s) <= k)\n          // Any combination of courses (if <= k) can be taken now.\n          // i | s := combining courses taken with courses can be taken.\n          dp[i | s] = min(dp[i | s], dp[i] + 1);\n    }\n\n    return dp.back();\n  }\n};\n", "1496": "class Solution {\n public:\n  bool isPathCrossing(string path) {\n    set<int> seen;\n\n    seen.insert(0);\n\n    int x = 0;\n    int y = 0;\n\n    for (const char c : path) {\n      switch (c) {\n        case 'N':\n          ++y;\n          break;\n        case 'S':\n          --y;\n          break;\n        case 'E':\n          ++x;\n          break;\n        case 'W':\n          --x;\n          break;\n      }\n      const int key = x * 20001 + y;\n      if (seen.contains(key))\n        return true;\n      seen.insert(key);\n    }\n\n    return false;\n  }\n};\n", "1497": "class Solution {\n public:\n  bool canArrange(vector<int>& arr, int k) {\n    vector<int> count(k);\n\n    for (int a : arr) {\n      a %= k;\n      ++count[a < 0 ? a + k : a];\n    }\n\n    if (count[0] % 2 != 0)\n      return false;\n\n    for (int i = 1; i <= k / 2; ++i)\n      if (count[i] != count[k - i])\n        return false;\n\n    return true;\n  }\n};\n", "1498": "class Solution {\n public:\n  int numSubseq(vector<int>& nums, int target) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    vector<int> pows(n, 1);  // pows[i] = 2^i % kMod\n\n    for (int i = 1; i < n; ++i)\n      pows[i] = pows[i - 1] * 2 % kMod;\n\n    ranges::sort(nums);\n\n    for (int l = 0, r = n - 1; l <= r;)\n      if (nums[l] + nums[r] <= target) {\n        ans += pows[r - l];\n        ans %= kMod;\n        ++l;\n      } else {\n        --r;\n      }\n\n    return ans;\n  }\n};\n", "1499": "class Solution {\n public:\n  int findMaxValueOfEquation(vector<vector<int>>& points, int k) {\n    int ans = INT_MIN;\n    deque<pair<int, int>> maxQ;  // (y - x, x) max queue\n\n    for (const vector<int>& point : points) {\n      const int x = point[0];\n      const int y = point[1];\n      // Remove the invalid points, xj - xi > k.\n      while (!maxQ.empty() && x - maxQ.front().second > k)\n        maxQ.pop_front();\n      if (!maxQ.empty())\n        ans = max(ans, x + y + maxQ.front().first);\n      // Remove the points that contribute less value and have a bigger x.\n      while (!maxQ.empty() && y - x >= maxQ.back().first)\n        maxQ.pop_back();\n      maxQ.emplace_back(y - x, x);\n    }\n\n    return ans;\n  }\n};\n", "15": "class Solution {\n public:\n  vector<vector<int>> threeSum(vector<int>& nums) {\n    if (nums.size() < 3)\n      return {};\n\n    vector<vector<int>> ans;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first number in the triplet, then search the\n      // remaining numbers in [i + 1, n - 1].\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r) {\n        const int sum = nums[i] + nums[l] + nums[r];\n        if (sum == 0) {\n          ans.push_back({nums[i], nums[l++], nums[r--]});\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < 0) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n    }\n\n    return ans;\n  }\n};\n", "150": "class Solution {\n public:\n  int evalRPN(vector<string>& tokens) {\n    stack<long> stack;\n    const unordered_map<string, function<long(long, long)>> op{\n        {\"+\", std::plus<long>()},\n        {\"-\", std::minus<long>()},\n        {\"*\", std::multiplies<long>()},\n        {\"/\", std::divides<long>()}};\n\n    for (const string& token : tokens)\n      if (op.contains(token)) {\n        const long b = stack.top();\n        stack.pop();\n        const long a = stack.top();\n        stack.pop();\n        stack.push(op.at(token)(a, b));\n      } else {\n        stack.push(stoi(token));\n      }\n\n    return stack.top();\n  }\n};\n", "1500": "class FileSharing {\n public:\n  FileSharing(int m) {}\n\n  int join(vector<int> ownedChunks) {\n    const int userId = getMinUserId();\n    userToChunks[userId] = {ownedChunks.begin(), ownedChunks.end()};\n    for (const int chunk : ownedChunks)\n      chunkToUsers[chunk].insert(userId);\n    return userId;\n  }\n\n  void leave(int userID) {\n    for (const int chunk : userToChunks[userID]) {\n      chunkToUsers[chunk].erase(userID);\n      if (chunkToUsers[chunk].empty())\n        chunkToUsers.erase(chunk);\n    }\n    userToChunks.erase(userID);\n    availableUserIds.push(userID);\n  }\n\n  vector<int> request(int userID, int chunkID) {\n    const auto it = chunkToUsers.find(chunkID);\n    if (it == chunkToUsers.end())\n      return {};\n    vector<int> userIds{it->second.begin(), it->second.end()};\n    userToChunks[userID].insert(chunkID);\n    chunkToUsers[chunkID].insert(userID);\n    return userIds;\n  }\n\n private:\n  unordered_map<int, set<int>> userToChunks;\n  unordered_map<int, set<int>> chunkToUsers;\n  priority_queue<int, vector<int>, greater<>> availableUserIds;\n\n  int getMinUserId() {\n    if (availableUserIds.empty())\n      return userToChunks.size() + 1;\n    const int minUserId = availableUserIds.top();\n    availableUserIds.pop();\n    return minUserId;\n  }\n};\n", "1502": "class Solution {\n public:\n  bool canMakeArithmeticProgression(vector<int>& arr) {\n    const int n = arr.size();\n    const int mx = ranges::max(arr);\n    const int mn = ranges::min(arr);\n    const int range = mx - mn;\n    if (range % (n - 1) != 0)\n      return false;\n    const int diff = range / (n - 1);\n    if (diff == 0)\n      return true;\n\n    for (int i = 0; i < n;) {\n      const int gap = arr[i] - mn;\n      if (gap % diff != 0)\n        return false;\n      if (gap == i * diff) {\n        ++i;\n      } else {\n        const int rightIndex = gap / diff;\n        swap(arr[i], arr[rightIndex]);\n      }\n    }\n\n    return true;\n  }\n};\n", "1503": "class Solution {\n public:\n  int getLastMoment(int n, vector<int>& left, vector<int>& right) {\n    const int maxLeft = left.empty() ? 0 : ranges::max(left);\n    const int minRight = right.empty() ? n : ranges::min(right);\n    return max(maxLeft, n - minRight);\n  }\n};\n", "1504": "class Solution {\n public:\n  int numSubmat(vector<vector<int>>& mat) {\n    int ans = 0;\n    vector<int> hist(mat[0].size());\n\n    for (const vector<int>& row : mat) {\n      for (int i = 0; i < row.size(); ++i)\n        hist[i] = row[i] == 0 ? 0 : hist[i] + 1;\n      ans += count(hist);\n    }\n\n    return ans;\n  }\n\n private:\n  int count(const vector<int>& hist) {\n    // submatrices[i] := the number of submatrices, where the i-th column is the\n    // right border\n    vector<int> submatrices(hist.size());\n    stack<int> stack;\n\n    for (int i = 0; i < hist.size(); ++i) {\n      while (!stack.empty() && hist[stack.top()] >= hist[i])\n        stack.pop();\n      if (!stack.empty()) {\n        const int prevIndex = stack.top();\n        submatrices[i] = submatrices[prevIndex] + hist[i] * (i - prevIndex);\n      } else {\n        submatrices[i] = hist[i] * (i + 1);\n      }\n      stack.push(i);\n    }\n\n    return accumulate(submatrices.begin(), submatrices.end(), 0);\n  }\n};\n", "1505": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  string minInteger(string num, int k) {\n    const int n = num.length();\n    string ans;\n    FenwickTree tree(n);\n    vector<bool> used(n);\n    vector<queue<int>> numToIndices(10);\n\n    for (int i = 0; i < n; ++i)\n      numToIndices[num[i] - '0'].push(i);\n\n    while (k > 0 && ans.length() < n)\n      for (int d = 0; d < 10; ++d) {\n        if (numToIndices[d].empty())\n          continue;\n        const int i = numToIndices[d].front();\n        const int cost = i - tree.get(i);\n        if (cost > k)\n          continue;\n        k -= cost;\n        ans += '0' + d;\n        used[i] = true;\n        tree.add(i + 1, 1);\n        numToIndices[d].pop();\n        break;  // Scan from 0 -> 9 again.\n      }\n\n    for (int i = 0; i < n; ++i)\n      if (!used[i])\n        ans += num[i];\n\n    return ans;\n  }\n};\n", "1506": "class Solution {\n public:\n  Node* findRoot(vector<Node*> tree) {\n    int sum = 0;\n\n    for (Node* node : tree) {\n      sum ^= node->val;\n      for (Node* child : node->children)\n        sum ^= child->val;\n    }\n\n    for (Node* node : tree)\n      if (node->val == sum)\n        return node;\n\n    throw;\n  }\n};\n", "1507": "class Solution {\n public:\n  string reformatDate(string date) {\n    const unordered_map<string, string> monthToNumString{\n        {\"Jan\", \"01\"}, {\"Feb\", \"02\"}, {\"Mar\", \"03\"}, {\"Apr\", \"04\"},\n        {\"May\", \"05\"}, {\"Jun\", \"06\"}, {\"Jul\", \"07\"}, {\"Aug\", \"08\"},\n        {\"Sep\", \"09\"}, {\"Oct\", \"10\"}, {\"Nov\", \"11\"}, {\"Dec\", \"12\"},\n    };\n    const int index1 = date.find_first_of(' ');\n    const int index2 = date.find_first_of(' ', index1 + 1);\n    const string day = index1 == 4 ? date.substr(0, 2) : string(\"0\") + date[0];\n    const string month =\n        monthToNumString.at(date.substr(index1 + 1, index2 - (index1 + 1)));\n    const string year = date.substr(index2 + 1);\n    return year + \"-\" + month + \"-\" + day;\n  }\n};\n", "1508": "class Solution {\n public:\n  int rangeSum(vector<int>& nums, int n, int left, int right) {\n    constexpr int kMod = 1'000'000'007;\n\n    auto subarraysAndSumNoGreaterThan = [&](int m) -> pair<int, long> {\n      int count = 0;   // the number of subarrays <= m\n      long total = 0;  // sum(subarrays)\n      int sum = 0;     // the current sum\n      int window = 0;  // the window sum\n\n      for (int i = 0, j = 0; j < n; ++j) {\n        sum += nums[j] * (j - i + 1);\n        window += nums[j];  // Extend each subarray that ends in j.\n        while (window > m) {\n          sum -= window;\n          window -= nums[i++];  // Shrink the window.\n        }\n        count += j - i + 1;\n        total += sum;\n      }\n\n      return {count, total};\n    };\n\n    // [L, R] is the possible range of the sum of any subarray.\n    const int L = ranges::min(nums);\n    const int R = accumulate(nums.begin(), nums.end(), 0);\n\n    auto firstKSubarraysSum = [&](int k) -> long {\n      int l = L;\n      int r = R;\n\n      while (l < r) {\n        const int m = l + (r - l) / 2;\n        if (subarraysAndSumNoGreaterThan(m).first < k)\n          l = m + 1;\n        else\n          r = m;\n      }\n\n      const auto& [count, total] = subarraysAndSumNoGreaterThan(l);\n      // If count != k, there're subarray(s) have the same sum as l.\n      return total - l * (count - k);\n    };\n\n    return (firstKSubarraysSum(right) - firstKSubarraysSum(left - 1)) % kMod;\n  }\n};\n", "1509": "class Solution {\n public:\n  int minDifference(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 5)\n      return 0;\n\n    int ans = INT_MAX;\n\n    ranges::sort(nums);\n\n    // 1. Change nums[0..i) to nums[i].\n    // 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].\n    for (int i = 0; i <= 3; ++i)\n      ans = min(ans, nums[n - 4 + i] - nums[i]);\n\n    return ans;\n  }\n};\n", "151": "class Solution {\n public:\n  string reverseWords(string s) {\n    ranges::reverse(s);                 // Reverse the whole string.\n    reverseWords(s, s.length());        // Reverse each word.\n    return cleanSpaces(s, s.length());  // Clean up the spaces.\n  }\n\n private:\n  void reverseWords(string& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && s[i] == ' ')  // Skip the spaces.\n        ++i;\n      while (j < i || j < n && s[j] != ' ')  // Skip the spaces.\n        ++j;\n      reverse(s.begin() + i, s.begin() + j);  // Reverse the word.\n    }\n  }\n\n  // Trim leading, trailing, and middle spaces\n  string cleanSpaces(string& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (j < n) {\n      while (j < n && s[j] == ' ')  // Skip the spaces.\n        ++j;\n      while (j < n && s[j] != ' ')  // Keep non spaces\n        s[i++] = s[j++];\n      while (j < n && s[j] == ' ')  // Skip the spaces.\n        ++j;\n      if (j < n)  // Keep only one space.\n        s[i++] = ' ';\n    }\n\n    return s.substr(0, i);\n  }\n};\n", "1510": "class Solution {\n public:\n  bool winnerSquareGame(int n) {\n    // dp[i] := the winning result for n = i\n    vector<bool> dp(n + 1);\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j * j <= i; ++j)\n        if (!dp[i - j * j]) {  // Removing j^2 stones make the opponent lose.\n          dp[i] = true;        // So, we win.\n          break;\n        }\n\n    return dp[n];\n  }\n};\n", "1512": "class Solution {\n public:\n  int numIdenticalPairs(vector<int>& nums) {\n    int ans = 0;\n    vector<int> count(101);\n\n    for (const int num : nums)\n      ans += count[num]++;\n\n    return ans;\n  }\n};\n", "1513": "class Solution {\n public:\n  int numSub(string s) {\n    constexpr int kMod = 1'000'000'007;\n\n    int ans = 0;\n    int l = -1;\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (s[i] == '0')\n        l = i;  // Handle the reset value.\n      ans = (ans + i - l) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "1514": "class Solution {\n public:\n  double maxProbability(int n, vector<vector<int>>& edges,\n                        vector<double>& succProb, int start, int end) {\n    // {a: [(b, probability_ab)]}\n    vector<vector<pair<int, double>>> graph(n);\n    // (the probability to reach u, u)\n    priority_queue<pair<double, int>> maxHeap;\n    maxHeap.emplace(1.0, start);\n    vector<bool> seen(n);\n\n    for (int i = 0; i < edges.size(); ++i) {\n      const int u = edges[i][0];\n      const int v = edges[i][1];\n      const double prob = succProb[i];\n      graph[u].emplace_back(v, prob);\n      graph[v].emplace_back(u, prob);\n    }\n\n    while (!maxHeap.empty()) {\n      const auto [prob, u] = maxHeap.top();\n      maxHeap.pop();\n      if (u == end)\n        return prob;\n      if (seen[u])\n        continue;\n      seen[u] = true;\n      for (const auto& [nextNode, edgeProb] : graph[u]) {\n        if (seen[nextNode])\n          continue;\n        maxHeap.emplace(prob * edgeProb, nextNode);\n      }\n    }\n\n    return 0;\n  }\n};\n", "1515": "class Solution {\n public:\n  double getMinDistSum(vector<vector<int>>& positions) {\n    constexpr double kErr = 1e-6;\n    double currX = 50;\n    double currY = 50;\n    double ans = distSum(positions, currX, currY);\n    double step = 1;\n\n    while (step > kErr) {\n      bool shouldDecreaseStep = true;\n      for (const auto& [dx, dy] : vector<pair<double, double>>{\n               {0, step}, {0, -step}, {step, 0}, {-step, 0}}) {\n        const double x = currX + dx;\n        const double y = currY + dy;\n        const double newDistSum = distSum(positions, x, y);\n        if (newDistSum < ans) {\n          ans = newDistSum;\n          currX = x;\n          currY = y;\n          shouldDecreaseStep = false;\n        }\n      }\n      if (shouldDecreaseStep)\n        step /= 10;\n    }\n\n    return ans;\n  }\n\n private:\n  double distSum(const vector<vector<int>>& positions, double a, double b) {\n    double sum = 0;\n    for (const vector<int>& p : positions)\n      sum += sqrt(pow(a - p[0], 2) + pow(b - p[1], 2));\n    return sum;\n  }\n};\n", "1516": "class Solution {\n public:\n  Node* moveSubTree(Node* root, Node* p, Node* q) {\n    if (find(q->children.begin(), q->children.end(), p) != q->children.end())\n      return root;\n\n    // Create a dummy node for the case when root == p.\n    Node* dummy = new Node(0, {root});\n\n    // Get each parent of p and q.\n    Node* pParent = getParent(dummy, p);\n    Node* qParent = getParent(p, q);\n\n    // Get p's original index in p's parent.\n    vector<Node*>& pSiblings = pParent->children;\n    const int pIndex =\n        find(pSiblings.begin(), pSiblings.end(), p) - pSiblings.begin();\n    pSiblings.erase(pSiblings.begin() + pIndex);\n\n    q->children.push_back(p);\n\n    // If q is in p's subtree, qParent != nullptr.\n    if (qParent != nullptr) {\n      vector<Node*>& qSiblings = qParent->children;\n      std::erase(qSiblings, q);\n      pSiblings.insert(pSiblings.begin() + pIndex, q);\n    }\n\n    return dummy->children[0];\n  }\n\n private:\n  Node* getParent(Node* root, Node* target) {\n    for (Node* child : root->children) {\n      if (child == target)\n        return root;\n      Node* res = getParent(child, target);\n      if (res != nullptr)\n        return res;\n    }\n    return nullptr;\n  }\n};\n", "1518": "class Solution {\n public:\n  int numWaterBottles(int numBottles, int numExchange) {\n    return numBottles + (numBottles - 1) / (numExchange - 1);\n  }\n};\n", "1519": "class Solution {\n public:\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n    vector<int> ans(n);\n    vector<vector<int>> tree(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, -1, labels, ans);\n    return ans;\n  }\n\n private:\n  vector<int> dfs(const vector<vector<int>>& tree, int u, int prev,\n                  const string& labels, vector<int>& ans) {\n    // count[i] := the number of letters down from ('a' + i)\n    vector<int> count(26);\n\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      vector<int> childCount = dfs(tree, v, u, labels, ans);\n      for (int i = 0; i < 26; ++i)\n        count[i] += childCount[i];\n    }\n\n    ans[u] = ++count[labels[u] - 'a'];  // the u itself\n    return count;\n  }\n};\n", "152": "class Solution {\n public:\n  int maxProduct(vector<int>& nums) {\n    int ans = nums[0];\n    int dpMin = nums[0];  // the minimum so far\n    int dpMax = nums[0];  // the maximum so far\n\n    for (int i = 1; i < nums.size(); ++i) {\n      const int num = nums[i];\n      const int prevMin = dpMin;  // dpMin[i - 1]\n      const int prevMax = dpMax;  // dpMax[i - 1]\n      if (num < 0) {\n        dpMin = min(prevMax * num, num);\n        dpMax = max(prevMin * num, num);\n      } else {\n        dpMin = min(prevMin * num, num);\n        dpMax = max(prevMax * num, num);\n      }\n      ans = max(ans, dpMax);\n    }\n\n    return ans;\n  }\n};\n", "1520": "class Solution {\n public:\n  vector<string> maxNumOfSubstrings(string s) {\n    const int n = s.length();\n    vector<string> ans;\n    // leftmost[i] := the leftmost index of ('a' + i)\n    vector<int> leftmost(26, n);\n    // rightmost[i] := the rightmost index of ('a' + i)\n    vector<int> rightmost(26, -1);\n\n    for (int i = 0; i < n; ++i) {\n      leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);\n      rightmost[s[i] - 'a'] = i;\n    }\n\n    auto getNewRight = [&](int i) {\n      int right = rightmost[s[i] - 'a'];\n      for (int j = i; j <= right; ++j) {\n        if (leftmost[s[j] - 'a'] < i)  // Find a letter's leftmost index < i.\n          return -1;\n        // Expand the right dynamically.\n        right = max(right, rightmost[s[j] - 'a']);\n      }\n      return right;\n    };\n\n    int right = -1;  // the rightmost index of the last substring\n    for (int i = 0; i < n; ++i) {\n      // the current index is the first appearance\n      if (i == leftmost[s[i] - 'a']) {\n        const int newRight = getNewRight(i);\n        if (newRight == -1)\n          continue;  // Find a letter's leftmost index < i.\n        if (i <= right && !ans.empty())\n          ans.back() = s.substr(i, newRight - i + 1);\n        else\n          ans.push_back(s.substr(i, newRight - i + 1));\n        right = newRight;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1521": "class Solution {\n public:\n  int closestToTarget(vector<int>& arr, int target) {\n    int ans = INT_MAX;\n    // all the values of subarrays that end in the previous number\n    unordered_set<int> prev;\n\n    for (const int num : arr) {\n      unordered_set<int> curr{num};\n      // Extend each subarray that ends in the previous number. Due to\n      // monotonicity of the AND operation, the size of `curr` will be at most\n      // num.bit_count() + 1.\n      for (const int val : prev)\n        curr.insert(val & num);\n      for (const int val : curr)\n        ans = min(ans, abs(target - val));\n      prev = std::move(curr);\n    }\n\n    return ans;\n  }\n};\n", "1522": "class Solution {\n public:\n  int diameter(Node* root) {\n    int ans = 0;\n    maxDepth(root, ans);\n    return ans;\n  }\n\n private:\n  // Returns the maximum depth of the subtree rooted at `root`.\n  int maxDepth(Node* root, int& ans) {\n    int maxSubDepth1 = 0;\n    int maxSubDepth2 = 0;\n    for (Node* child : root->children) {\n      const int maxSubDepth = maxDepth(child, ans);\n      if (maxSubDepth > maxSubDepth1) {\n        maxSubDepth2 = maxSubDepth1;\n        maxSubDepth1 = maxSubDepth;\n      } else if (maxSubDepth > maxSubDepth2) {\n        maxSubDepth2 = maxSubDepth;\n      }\n    }\n    ans = max(ans, maxSubDepth1 + maxSubDepth2);\n    return 1 + maxSubDepth1;\n  }\n};\n", "1523": "class Solution {\n public:\n  int countOdds(int low, int high) {\n    return (high + 1) / 2 - low / 2;\n  }\n};\n", "1524": "class Solution {\n public:\n  int numOfSubarrays(vector<int>& arr) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    long dp0 = 0;\n    long dp1 = 0;\n\n    for (const int a : arr) {\n      if (a % 2 == 1) {\n        const int cache = dp0;\n        dp0 = dp1;\n        dp1 = cache + 1;\n      } else {\n        ++dp0;\n      }\n      ans = (ans + dp1) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "1525": "class Solution {\n public:\n  int numSplits(string s) {\n    const int n = s.length();\n    int ans = 0;\n    // prefix[i] := the number of unique letters in s[0..i]\n    vector<int> prefix(n);\n    // suffix[i] := of unique letters in s[i..n)\n    vector<int> suffix(n);\n    unordered_set<int> seen;\n\n    for (int i = 0; i < n; ++i) {\n      seen.insert(s[i]);\n      prefix[i] = seen.size();\n    }\n\n    seen.clear();\n\n    for (int i = n - 1; i >= 0; --i) {\n      seen.insert(s[i]);\n      suffix[i] = seen.size();\n    }\n\n    for (int i = 0; i + 1 < n; ++i)\n      if (prefix[i] == suffix[i + 1])\n        ++ans;\n\n    return ans;\n  }\n};\n", "1526": "class Solution {\n public:\n  int minNumberOperations(vector<int>& target) {\n    int ans = target.front();\n\n    for (int i = 1; i < target.size(); ++i)\n      if (target[i] > target[i - 1])\n        ans += target[i] - target[i - 1];\n\n    return ans;\n  }\n};\n", "1528": "class Solution {\n public:\n  string restoreString(string s, vector<int>& indices) {\n    string ans(s.length(), '.');\n\n    for (int i = 0; i < indices.size(); ++i)\n      ans[indices[i]] = s[i];\n\n    return ans;\n  }\n};\n", "1529": "class Solution {\n public:\n  int minFlips(string target) {\n    int ans = 0;\n    int state = 0;\n\n    for (const char c : target)\n      if (c - '0' != state) {\n        state = c - '0';\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "153": "class Solution {\n public:\n  int findMin(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return nums[l];\n  }\n};\n", "1530": "class Solution {\n public:\n  int countPairs(TreeNode* root, int distance) {\n    int ans = 0;\n\n    dfs(root, distance, ans);\n\n    return ans;\n  }\n\n private:\n  vector<int> dfs(TreeNode* root, int distance, int& ans) {\n    vector<int> d(distance + 1);  // {distance: the number of leaf nodes}\n    if (root == nullptr)\n      return d;\n    if (root->left == nullptr && root->right == nullptr) {\n      d[0] = 1;\n      return d;\n    }\n\n    const vector<int> dl = dfs(root->left, distance, ans);\n    const vector<int> dr = dfs(root->right, distance, ans);\n\n    for (int i = 0; i < distance; ++i)\n      for (int j = 0; j < distance; ++j)\n        if (i + j + 2 <= distance)\n          ans += dl[i] * dr[j];\n\n    for (int i = 0; i < distance; ++i)\n      d[i + 1] = dl[i] + dr[i];\n\n    return d;\n  }\n};\n", "1531": "class Solution {\n public:\n  int getLengthOfOptimalCompression(string s, int k) {\n    vector<vector<int>> mem(s.length(), vector<int>(k + 1, kMax));\n    return compression(s, 0, k, mem);\n  }\n\n private:\n  static constexpr int kMax = 101;\n\n  // Returns the length of the optimal compression of s[i..n) with at most k\n  // deletion.\n  int compression(const string& s, int i, int k, vector<vector<int>>& mem) {\n    if (k < 0)\n      return kMax;\n    if (i == s.length() || s.length() - i <= k)\n      return 0;\n    if (mem[i][k] != kMax)\n      return mem[i][k];\n\n    int maxFreq = 0;  // the maximum frequency in s[i..j]\n    vector<int> count(128);\n\n    // Make letters in s[i..j] be the same.\n    // Keep the letter that has the maximum frequency in this range and remove\n    // the other letters.\n    for (int j = i; j < s.length(); ++j) {\n      maxFreq = max(maxFreq, ++count[s[j]]);\n      mem[i][k] = min(  //\n          mem[i][k],    //\n          getLength(maxFreq) +\n              compression(s, j + 1, k - (j - i + 1 - maxFreq), mem));\n    }\n\n    return mem[i][k];\n  }\n\n  // Returns the length to compress `maxFreq`.\n  int getLength(int maxFreq) {\n    if (maxFreq == 1)\n      return 1;  // c\n    if (maxFreq < 10)\n      return 2;  // [1-9]c\n    if (maxFreq < 100)\n      return 3;  // [1-9][0-9]c\n    return 4;    // [1-9][0-9][0-9]c\n  }\n};\n", "1533": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *  public:\n *   // Compares the sum of arr[l..r] with the sum of arr[x..y]\n *   // return 1 if sum(arr[l..r]) > sum(arr[x..y])\n *   // return 0 if sum(arr[l..r]) == sum(arr[x..y])\n *   // return -1 if sum(arr[l..r]) < sum(arr[x..y])\n *   int compareSub(int l, int r, int x, int y);\n *\n *   // Returns the length of the array\n *   int length();\n * };\n */\n\nclass Solution {\n public:\n  int getIndex(ArrayReader& reader) {\n    int l = 0;\n    int r = reader.length() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const int res = (r - l + 1) % 2 == 0 ? reader.compareSub(l, m, m + 1, r)\n                                           : reader.compareSub(l, m, m, r);\n      if (res == -1)\n        l = m + 1;\n      else  // res == 1 || res == 0\n        r = m;\n    }\n\n    return l;\n  }\n};\n", "1534": "class Solution {\n public:\n  int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\n    int ans = 0;\n    for (int i = 0; i < arr.size(); ++i)\n      for (int j = i + 1; j < arr.size(); ++j)\n        for (int k = j + 1; k < arr.size(); ++k)\n          if (abs(arr[i] - arr[j]) <= a &&  //\n              abs(arr[j] - arr[k]) <= b &&  //\n              abs(arr[i] - arr[k]) <= c)\n            ++ans;\n    return ans;\n  }\n};\n", "1535": "class Solution {\n public:\n  int getWinner(vector<int>& arr, int k) {\n    int ans = arr[0];\n    int wins = 0;\n\n    for (int i = 1; i < arr.size() && wins < k; ++i)\n      if (arr[i] > ans) {\n        ans = arr[i];\n        wins = 1;\n      } else {\n        ++wins;\n      }\n\n    return ans;\n  }\n};\n", "1536": "class Solution {\n public:\n  int minSwaps(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    int ans = 0;\n    // suffixZeros[i] := the number of suffix zeros in the i-th row\n    vector<int> suffixZeros;\n\n    for (const vector<int> row : grid) {\n      const auto itLastOne = find(row.rbegin(), row.rend(), 1);\n      const int suffixZeroCount = distance(row.rbegin(), itLastOne);\n      suffixZeros.push_back(suffixZeroCount);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      const int neededZeros = n - 1 - i;\n      // Get the first row with suffix zeros >= `neededZeros` in\n      // suffixZeros[i:..n).\n      const auto it = find_if(suffixZeros.begin() + i, suffixZeros.end(),\n                              [&](int count) { return count >= neededZeros; });\n      if (it == suffixZeros.end())\n        return -1;\n      const int j = distance(suffixZeros.begin(), it);\n      // Move the rows[j] to the rows[i].\n      for (int k = j; k > i; --k)\n        suffixZeros[k] = suffixZeros[k - 1];\n      ans += j - i;\n    }\n\n    return ans;\n  }\n};\n", "1537": "class Solution {\n public:\n  int maxSum(vector<int>& nums1, vector<int>& nums2) {\n    constexpr int kMod = 1'000'000'007;\n    // Keep the running the sum of `nums1` and `nums2` before the next\n    // rendezvous. Since `nums1` and `nums2` are increasing, move forward on the\n    // smaller one to ensure we don't miss any rendezvous. When meet rendezvous,\n    // choose the better path.\n    long ans = 0;\n    // sum(nums1) in (the prevoious rendezvous, the next rendezvous)\n    long sum1 = 0;\n    // sum(nums2) in (the prevoious rendezvous, the next rendezvous)\n    long sum2 = 0;\n    int i = 0;  // nums1's index\n    int j = 0;  // nums2's index\n\n    while (i < nums1.size() && j < nums2.size())\n      if (nums1[i] < nums2[j]) {\n        sum1 += nums1[i++];\n      } else if (nums1[i] > nums2[j]) {\n        sum2 += nums2[j++];\n      } else {  // An rendezvous happens.\n        ans += max(sum1, sum2) + nums1[i];\n        sum1 = 0;\n        sum2 = 0;\n        ++i;\n        ++j;\n      }\n\n    while (i < nums1.size())\n      sum1 += nums1[i++];\n\n    while (j < nums2.size())\n      sum2 += nums2[j++];\n\n    return (ans + max(sum1, sum2)) % kMod;\n  }\n};\n", "1538": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *  public:\n *   // Compares 4 different elements in the array\n *   // Returns 4 if the values of the 4 elements are the same (0 or 1).\n *   // Returns 2 if three\u00a0elements have a value\u00a0equal to 0\u00a0and one\u00a0element has\n *   //           value equal to 1\u00a0or vice versa.\n *   // Returns 0 if two element have a value equal to 0 and two elements have\n *   //           a value equal to 1.\n *   int query(int a, int b, int c, int d);\n *\n *   // Returns the length of the array\n *   int length();\n * };\n */\n\nclass Solution {\n public:\n  int guessMajority(ArrayReader& reader) {\n    const int n = reader.length();\n    const int query0123 = reader.query(0, 1, 2, 3);\n    const int query1234 = reader.query(1, 2, 3, 4);\n    // the number of numbers that are same as `nums[0]`\n    int zeros = 1;\n    // the number of numbers that are different from `nums[0]`\n    int nonZeros = 0;\n    // any index i s.t. nums[i] != nums[0]\n    int indexNot0 = -1;\n\n    // Find which group nums[1..3] belong to.\n    for (int i = 1; i <= 3; ++i) {\n      vector<int> abcd = getABCD(i);\n      if (reader.query(abcd[0], abcd[1], abcd[2], abcd[3]) == query1234) {\n        ++zeros;\n      } else {\n        ++nonZeros;\n        indexNot0 = i;\n      }\n    }\n\n    // Find which group nums[4..n) belong to.\n    for (int i = 4; i < n; ++i)\n      if (reader.query(1, 2, 3, i) == query0123) {\n        ++zeros;\n      } else {\n        ++nonZeros;\n        indexNot0 = i;\n      }\n\n    if (zeros == nonZeros)\n      return -1;\n    if (zeros > nonZeros)\n      return 0;\n    return indexNot0;\n  }\n\n private:\n  // Returns [0..4] except i.\n  vector<int> getABCD(int i) {\n    vector<int> abcd{0};\n    for (int j = 1; j <= 3; ++j)\n      if (j != i)\n        abcd.push_back(j);\n    abcd.push_back(4);\n    return abcd;\n  }\n};\n", "1539": "class Solution {\n public:\n  int findKthPositive(vector<int>& arr, int k) {\n    int l = 0;\n    int r = arr.size();\n\n    // Find the first index l s.t. nMissing(l) = A[l] - l - 1 >= k.\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (arr[m] - m - 1 >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    // The k-th missing positive\n    // = A[l - 1] + k - nMissing(l - 1)\n    // = A[l - 1] + k - (A[l - 1] - (l - 1) - 1)\n    // = A[l - 1] + k - (A[l - 1] - l)\n    // = l + k\n    return l + k;\n  }\n};\n", "154": "class Solution {\n public:\n  int findMin(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == nums[r])\n        --r;\n      else if (nums[m] < nums[r])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return nums[l];\n  }\n};\n", "1540": "class Solution {\n public:\n  bool canConvertString(string s, string t, int k) {\n    if (s.length() != t.length())\n      return false;\n\n    // e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3.\n    // 1. a -> b, need 1 move.\n    // 2. a -> b, need 1 + 26 moves.\n    // 3. b -> c, need 1 + 26 * 2 moves.\n    vector<int> shiftCount(26);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int shift = (t[i] - s[i] + 26) % 26;\n      if (shift == 0)\n        continue;\n      if (shift + 26 * shiftCount[shift] > k)\n        return false;\n      ++shiftCount[shift];\n    }\n\n    return true;\n  }\n};\n", "1541": "class Solution {\n public:\n  int minInsertions(string s) {\n    int neededRight = 0;   // Increment by 2 for each '('.\n    int missingLeft = 0;   // Increment by 1 for each missing '('.\n    int missingRight = 0;  // Increment by 1 for each missing ')'.\n\n    for (const char c : s)\n      if (c == '(') {\n        if (neededRight % 2 == 1) {\n          // e.g. \"()(...\"\n          ++missingRight;\n          --neededRight;\n        }\n        neededRight += 2;\n      } else if (--neededRight < 0) {  // c == ')'\n        // e.g. \"()))...\"\n        ++missingLeft;\n        neededRight += 2;\n      }\n\n    return neededRight + missingLeft + missingRight;\n  }\n};\n", "1542": "class Solution {\n public:\n  int longestAwesome(string s) {\n    int ans = 0;\n    int prefix = 0;  // the binary prefix\n    vector<int> prefixToIndex(1024, s.length());\n    prefixToIndex[0] = -1;\n\n    for (int i = 0; i < s.length(); ++i) {\n      prefix ^= 1 << s[i] - '0';\n      ans = max(ans, i - prefixToIndex[prefix]);\n      for (int j = 0; j < 10; ++j)\n        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j]);\n      prefixToIndex[prefix] = min(prefixToIndex[prefix], i);\n    }\n\n    return ans;\n  }\n};\n", "1544": "class Solution {\n public:\n  string makeGood(string s) {\n    string ans;\n    for (const char c : s)\n      if (!ans.empty() && isBadPair(ans.back(), c))\n        ans.pop_back();\n      else\n        ans.push_back(c);\n    return ans;\n  }\n\n  bool isBadPair(char a, char b) {\n    return a != b && tolower(a) == tolower(b);\n  }\n};\n", "1545": "class Solution {\n public:\n  char findKthBit(int n, int k) {\n    if (n == 1)\n      return '0';\n    const int midIndex = pow(2, n - 1);  // 1-indexed\n    if (k == midIndex)\n      return '1';\n    if (k < midIndex)\n      return findKthBit(n - 1, k);\n    return findKthBit(n - 1, midIndex * 2 - k) == '0' ? '1' : '0';\n  }\n};\n", "1546": "class Solution {\n public:\n  int maxNonOverlapping(vector<int>& nums, int target) {\n    // Ending the subarray ASAP always has a better result.\n    int ans = 0;\n    int prefix = 0;\n    unordered_set<int> prefixes{0};\n\n    // Greedily find the subarrays that equal to the target.\n    for (const int num : nums) {\n      // Check if there is a subarray ends in here and equals to the target.\n      prefix += num;\n      if (prefixes.contains(prefix - target)) {\n        // Find one and discard all the prefixes that have been used.\n        ++ans;\n        prefix = 0;\n        prefixes = {0};\n      } else {\n        prefixes.insert(prefix);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1547": "class Solution {\n public:\n  int minCost(int n, vector<int>& cuts) {\n    cuts.push_back(0);\n    cuts.push_back(n);\n    ranges::sort(cuts);\n\n    // dp[i][j] := minCost(cuts[i..j])\n    vector<vector<int>> dp(cuts.size(), vector<int>(cuts.size()));\n\n    for (int d = 2; d < cuts.size(); ++d)\n      for (int i = 0; i + d < cuts.size(); ++i) {\n        const int j = i + d;\n        dp[i][j] = INT_MAX;\n        for (int k = i + 1; k < j; ++k)\n          dp[i][j] = min(dp[i][j], cuts[j] - cuts[i] + dp[i][k] + dp[k][j]);\n      }\n\n    return dp[0][cuts.size() - 1];\n  }\n};\n", "1548": "class Solution {\n public:\n  vector<int> mostSimilar(int n, vector<vector<int>>& roads,\n                          vector<string>& names, vector<string>& targetPath) {\n    this->names = names;\n    this->targetPath = targetPath;\n    // cost[i][j] := the minimum cost to start from names[i] in path[j]\n    this->cost.resize(names.size(), vector<int>(targetPath.size(), -1));\n    // next[i][j] := the best next of names[i] in path[j]\n    this->next.resize(names.size(), vector<int>(targetPath.size()));\n    this->graph.resize(n);\n\n    for (const vector<int>& road : roads) {\n      graph[road[0]].push_back(road[1]);\n      graph[road[1]].push_back(road[0]);\n    }\n\n    int minDist = INT_MAX;\n    int start = 0;\n\n    for (int i = 0; i < n; ++i) {\n      const int dist = dfs(i, 0);\n      if (dist < minDist) {\n        minDist = dist;\n        start = i;\n      }\n    }\n\n    vector<int> ans;\n\n    while (ans.size() < targetPath.size()) {\n      ans.push_back(start);\n      start = next[start][ans.size() - 1];\n    }\n\n    return ans;\n  }\n\n private:\n  vector<string> names;\n  vector<string> targetPath;\n  vector<vector<int>> cost;\n  vector<vector<int>> next;\n  vector<vector<int>> graph;\n\n  int dfs(int nameIndex, int pathIndex) {\n    if (cost[nameIndex][pathIndex] != -1)\n      return cost[nameIndex][pathIndex];\n\n    const int editDist = names[nameIndex] != targetPath[pathIndex];\n    if (pathIndex == targetPath.size() - 1)\n      return editDist;\n\n    int minDist = INT_MAX;\n\n    for (const int v : graph[nameIndex]) {\n      const int dist = dfs(v, pathIndex + 1);\n      if (dist < minDist) {\n        minDist = dist;\n        next[nameIndex][pathIndex] = v;\n      }\n    }\n\n    return cost[nameIndex][pathIndex] = editDist + minDist;\n  }\n};\n", "155": "class MinStack {\n public:\n  void push(int x) {\n    if (stack.empty())\n      stack.emplace(x, x);\n    else\n      stack.emplace(x, min(x, stack.top().second));\n  }\n\n  void pop() {\n    stack.pop();\n  }\n\n  int top() {\n    return stack.top().first;\n  }\n\n  int getMin() {\n    return stack.top().second;\n  }\n\n private:\n  stack<pair<int, int>> stack;  // {x, min}\n};\n", "1550": "\nclass Solution {\n public:\n  bool threeConsecutiveOdds(vector<int>& arr) {\n    int count = 0;\n    for (const int a : arr) {\n      count = a % 2 == 0 ? 0 : count + 1;\n      if (count == 3)\n        return true;\n    }\n    return false;\n  }\n};\n", "1551": "class Solution {\n public:\n  int minOperations(int n) {\n    //     median := median of arr\n    //   diffs[i] := median - arr[i] where i <= i <= n / 2\n    //        ans := sum(diffs)\n    // e.g.\n    // n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n    //        ans = (4 + 2) * 2 / 2 = 6\n    // n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n    //        ans = (5 + 1) * 3 / 2 = 9\n    const int halfSize = n / 2;\n    const int median = (arr(n) + arr(1)) / 2;\n    const int firstDiff = median - arr(1);\n    const int lastDiff = median - arr(halfSize);\n    return (firstDiff + lastDiff) * halfSize / 2;\n  }\n\n private:\n  // Returns the i-th element of `arr`, where 1 <= i <= n.\n  int arr(int i) {\n    return (i - 1) * 2 + 1;\n  }\n};\n", "1552": "class Solution {\n public:\n  int maxDistance(vector<int>& position, int m) {\n    ranges::sort(position);\n\n    int l = 1;\n    int r = position.back() - position.front();\n\n    while (l < r) {\n      const int mid = r - (r - l) / 2;\n      if (numBalls(position, mid) >= m)  // There're too many balls.\n        l = mid;\n      else  // There're too few balls.\n        r = mid - 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numBalls(const vector<int>& position, int force) {\n    int balls = 0;\n    int prevPosition = -force;\n    for (const int pos : position)\n      if (pos - prevPosition >= force) {\n        ++balls;\n        prevPosition = pos;\n      }\n    return balls;\n  }\n};\n", "1553": "class Solution {\n public:\n  int minDays(int n) {\n    if (n <= 1)\n      return n;\n    if (const auto it = mem.find(n); it != mem.cend())\n      return it->second;\n    return mem[n] = 1 + min(minDays(n / 3) + n % 3,  //\n                            minDays(n / 2) + n % 2);\n  }\n\n private:\n  unordered_map<int, int> mem;\n};\n", "1554": "class Solution {\n public:\n  bool differByOne(vector<string>& dict) {\n    const int m = dict[0].length();\n    vector<int> wordToHash;\n\n    for (const string& word : dict)\n      wordToHash.push_back(getHash(word));\n\n    // Compute the hash without each letter.\n    // e.g. hash of \"abc\" = 26^2 * 'a' + 26 * 'b' + 'c'\n    //   newHash of \"a*c\" = hash - 26 * 'b'\n    int coefficient = 1;\n    for (int j = m - 1; j >= 0; --j) {\n      unordered_map<int, vector<int>> newHashToIndices;\n      for (int i = 0; i < dict.size(); ++i) {\n        const string& word = dict[i];\n        const int newHash =\n            (wordToHash[i] -\n             static_cast<long>(coefficient) * val(word[j]) % kHash + kHash) %\n            kHash;\n        if (const auto it = newHashToIndices.find(newHash);\n            it != newHashToIndices.cend())\n          for (const int index : it->second)\n            // word[0..j) == dict[index][0..j) &&\n            // word[j + 1..n) == dict[index][j + 1..n)\n            if (equal(word.begin(), word.begin() + j, dict[index].begin()) &&\n                equal(word.begin() + j + 1, word.end(),\n                      dict[index].begin() + j + 1))\n              return true;\n        newHashToIndices[newHash].push_back(i);\n      }\n      coefficient = coefficient * kBase % kHash;\n    }\n\n    return false;\n  }\n\n private:\n  static constexpr long kBase = 26;\n  static constexpr int kHash = 1'000'000'007;\n\n  static constexpr int val(char c) {\n    return c - 'a';\n  }\n\n  // Returns the hash of `s`. Assume the length of `s` is m.\n  // e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].\n  int getHash(const string& s) {\n    int hash = 0;\n    for (const char c : s)\n      hash = (hash * kBase + val(c)) % kHash;\n    return hash;\n  }\n};\n", "1556": "class Solution {\n public:\n  string thousandSeparator(int n) {\n    const string s = to_string(n);\n    string ans;\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (i > 0 && (s.length() - i) % 3 == 0)\n        ans += '.';\n      ans += s[i];\n    }\n\n    return ans;\n  }\n};\n", "1557": "class Solution {\n public:\n  vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {\n    vector<int> ans;\n    vector<int> inDegrees(n);\n\n    for (const vector<int>& edge : edges)\n      ++inDegrees[edge[1]];\n\n    for (int i = 0; i < inDegrees.size(); ++i)\n      if (inDegrees[i] == 0)\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "1558": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    const int mx = ranges::max(nums);\n    return accumulate(nums.begin(), nums.end(), 0, [](int acc, unsigned num) {\n      return acc + popcount(num);\n    }) + (mx == 0 ? 0 : static_cast<int>(log2(mx)));\n  }\n};\n", "1559": "class Solution {\n public:\n  bool containsCycle(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (seen[i][j])\n          continue;\n        if (dfs(grid, i, j, -1, -1, grid[i][j], seen))\n          return true;\n      }\n\n    return false;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  bool dfs(const vector<vector<char>>& grid, int i, int j, int prevI, int prevJ,\n           char c, vector<vector<bool>>& seen) {\n    seen[i][j] = true;\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())\n        continue;\n      if (x == prevI && y == prevJ)\n        continue;\n      if (grid[x][y] != c)\n        continue;\n      if (seen[x][y])\n        return true;\n      if (dfs(grid, x, y, i, j, c, seen))\n        return true;\n    }\n\n    return false;\n  }\n};\n", "156": "class Solution {\n public:\n  TreeNode* upsideDownBinaryTree(TreeNode* root) {\n    TreeNode* prevRoot = nullptr;\n    TreeNode* prevRightChild = nullptr;\n\n    while (root != nullptr) {\n      TreeNode* nextRoot = root->left;  // Cache the next root.\n      root->left = prevRightChild;\n      prevRightChild = root->right;\n      root->right = prevRoot;\n      prevRoot = root;  // Record the previous root.\n      root = nextRoot;  // Update the root.\n    }\n\n    return prevRoot;\n  }\n};\n", "1560": "class Solution {\n public:\n  vector<int> mostVisited(int n, vector<int>& rounds) {\n    // 1. If start <= end, [start, end] is the most visited.\n    //\n    //      s --------- n\n    // 1 -------------- n\n    // 1 ------ e\n    //\n    // 2. If start > end, [1, end] and [start, n] are the most visited.\n    //\n    //             s -- n\n    // 1 -------------- n\n    // 1 ------ e\n    const int start = rounds.front();\n    const int end = rounds.back();\n    vector<int> ans;\n    for (int i = 1; i <= n; ++i)\n      if (start <= end) {\n        if (start <= i && i <= end)\n          ans.push_back(i);\n      } else {  // start > end\n        if (i >= start || i <= end)\n          ans.push_back(i);\n      }\n    return ans;\n  }\n};\n", "1561": "class Solution {\n public:\n  int maxCoins(vector<int>& piles) {\n    ranges::sort(piles);\n\n    int ans = 0;\n\n    // piles = [S S M L M L], pick all the M.\n    for (int i = piles.size() / 3; i < piles.size(); i += 2)\n      ans += piles[i];\n\n    return ans;\n  }\n};\n", "1562": "class Solution {\n public:\n  int findLatestStep(vector<int>& arr, int m) {\n    if (arr.size() == m)\n      return arr.size();\n\n    int ans = -1;\n    int step = 0;\n    // sizes[i] := the size of the group starting from i or ending in i\n    // (1-indexed)\n    vector<int> sizes(arr.size() + 2);\n\n    for (const int i : arr) {\n      ++step;\n      // In the previous step, there exists a group with a size of m.\n      if (sizes[i - 1] == m || sizes[i + 1] == m)\n        ans = step - 1;\n      const int head = i - sizes[i - 1];\n      const int tail = i + sizes[i + 1];\n      sizes[head] = tail - head + 1;\n      sizes[tail] = tail - head + 1;\n    }\n\n    return ans;\n  }\n};\n", "1563": "class Solution {\n public:\n  int stoneGameV(vector<int>& stoneValue) {\n    const int n = stoneValue.size();\n    vector<vector<int>> mem(n, vector<int>(n, INT_MIN));\n    vector<int> prefix(n + 1);\n    partial_sum(stoneValue.begin(), stoneValue.end(), prefix.begin() + 1);\n    return stoneGameV(stoneValue, 0, n - 1, prefix, mem);\n  }\n\n private:\n  // Returns the maximum score that Alice can obtain from stoneValue[i..j].\n  int stoneGameV(const vector<int>& stoneValue, int i, int j,\n                 const vector<int>& prefix, vector<vector<int>>& mem) {\n    if (i == j)\n      return 0;\n    if (mem[i][j] > 0)\n      return mem[i][j];\n\n    // Try all the possible partitions.\n    for (int p = i; p < j; ++p) {\n      // sum(stoneValue[i..p])\n      const int leftSum = prefix[p + 1] - prefix[i];\n      const int throwRight =\n          leftSum + stoneGameV(stoneValue, i, p, prefix, mem);\n      // sum(stoneValue[p + 1..j])\n      const int rightSum = prefix[j + 1] - prefix[p + 1];\n      const int throwLeft =\n          rightSum + stoneGameV(stoneValue, p + 1, j, prefix, mem);\n      if (leftSum < rightSum)  // Bob throws the right row.\n        mem[i][j] = max(mem[i][j], throwRight);\n      else if (leftSum > rightSum)  // Bob throws the left row.\n        mem[i][j] = max(mem[i][j], throwLeft);\n      else  // Alice decides which row to throw.\n        mem[i][j] = max({mem[i][j], throwLeft, throwRight});\n    }\n\n    return mem[i][j];\n  }\n};\n", "1564": "class Solution {\n public:\n  int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {\n    int i = 0;  // warehouse's index\n\n    ranges::sort(boxes, greater<>());\n\n    for (const int box : boxes)\n      if (i < warehouse.size() && warehouse[i] >= box)\n        ++i;\n\n    return i;\n  }\n};\n", "1566": "class Solution {\n public:\n  bool containsPattern(vector<int>& arr, int m, int k) {\n    int count = 0;\n    for (int i = m; i < arr.size(); ++i) {\n      count = arr[i] == arr[i - m] ? count + 1 : 0;\n      if (count == m * k - m)\n        return true;\n    }\n    return false;\n  }\n};\n", "1567": "class Solution {\n public:\n  int getMaxLen(vector<int>& nums) {\n    int ans = 0;\n    // the maximum length of subarrays ending in `num` with a negative product\n    int neg = 0;\n    // the maximum length of subarrays ending in `num` with a positive product\n    int pos = 0;\n\n    for (const int num : nums) {\n      pos = num == 0 ? 0 : pos + 1;\n      neg = num == 0 || neg == 0 ? 0 : neg + 1;\n      if (num < 0)\n        swap(pos, neg);\n      ans = max(ans, pos);\n    }\n\n    return ans;\n  }\n};\n", "1568": "class Solution {\n public:\n  int minDays(vector<vector<int>>& grid) {\n    if (disconnected(grid))\n      return 0;\n\n    // Try to remove 1 land.\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == 1) {\n          grid[i][j] = 0;\n          if (disconnected(grid))\n            return 1;\n          grid[i][j] = 1;\n        }\n\n    // Remove 2 lands.\n    return 2;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  bool disconnected(const vector<vector<int>>& grid) {\n    int islandsCount = 0;\n    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j) {\n        if (grid[i][j] == 0 || seen[i][j])\n          continue;\n        if (++islandsCount > 1)\n          return true;\n        dfs(grid, i, j, seen);\n      }\n    return islandsCount != 1;\n  }\n\n  void dfs(const vector<vector<int>>& grid, int i, int j,\n           vector<vector<bool>>& seen) {\n    seen[i][j] = true;\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())\n        continue;\n      if (grid[x][y] == 0 || seen[x][y])\n        continue;\n      dfs(grid, x, y, seen);\n    }\n  }\n};\n", "1569": "class Solution {\n public:\n  int numOfWays(vector<int>& nums) {\n    comb = generate(nums.size() + 1);\n    return ways(nums) - 1;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  // comb[n][k] := C(n, k)\n  vector<vector<int>> comb;\n\n  int ways(const vector<int>& nums) {\n    if (nums.size() <= 2)\n      return 1;\n\n    vector<int> left;\n    vector<int> right;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] < nums[0])\n        left.push_back(nums[i]);\n      else\n        right.push_back(nums[i]);\n\n    long ans = comb[nums.size() - 1][left.size()];\n    ans = (ans * ways(left)) % kMod;\n    ans = (ans * ways(right)) % kMod;\n    return ans;\n  }\n\n  // Same as 118. Pascal's Triangle\n  vector<vector<int>> generate(int numRows) {\n    vector<vector<int>> comb;\n\n    for (int i = 0; i < numRows; ++i)\n      comb.push_back(vector<int>(i + 1, 1));\n\n    for (int i = 2; i < numRows; ++i)\n      for (int j = 1; j < comb[i].size() - 1; ++j)\n        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;\n\n    return comb;\n  }\n};\n", "157": "/**\n * The read4 API is defined in the parent class Reader4.\n *     int read4(char *buf4);\n */\n\nclass Solution {\n public:\n  /**\n   * @param buf Destination buffer\n   * @param n   Number of characters to read\n   * @return    The number of actual characters read\n   */\n  int read(char* buf, int n) {\n    char* buf4 = new char[4];\n    int i4 = 0;  // buf4's index\n    int n4 = 0;  // buf4's size\n    int i = 0;   // buf's index\n\n    // While we're not reaching the tail (< 4 characters).\n    while (i + 4 < n) {\n      const int k = read4(buf + i);  // Directly write to the buf.\n      if (k == 0)                    // Reach the EOF.\n        return i;\n      i += k;\n    }\n\n    while (i < n) {\n      if (i4 == n4) {      // All the characters in the buf4 are consumed.\n        i4 = 0;            // Reset the buf4's index.\n        n4 = read4(buf4);  // Read <= 4 characters from the file to the buf4.\n        if (n4 == 0)       // Reach the EOF.\n          return i;\n      }\n      buf[i++] = buf4[i4++];\n    }\n\n    return i;\n  }\n};\n", "1570": "class SparseVector {\n public:\n  SparseVector(vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i])\n        v.push_back({i, nums[i]});\n  }\n\n  // Returns the dot product of the two sparse vectors.\n  int dotProduct(SparseVector& vec) {\n    int ans = 0;\n\n    for (int i = 0, j = 0; i < v.size() && j < vec.v.size();)\n      if (v[i].first == vec.v[j].first)\n        ans += v[i++].second * vec.v[j++].second;\n      else if (v[i].first < vec.v[j].first)\n        ++i;\n      else\n        ++j;\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> v;  //  [(index, num)]\n};\n", "1572": "class Solution {\n public:\n  int diagonalSum(vector<vector<int>>& mat) {\n    const int n = mat.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n      ans += mat[i][i];\n      ans += mat[n - 1 - i][i];\n    }\n\n    return n % 2 == 0 ? ans : ans - mat[n / 2][n / 2];\n  }\n};\n", "1573": "class Solution {\n public:\n  int numWays(string s) {\n    constexpr int kMod = 1'000'000'007;\n    const int ones = ranges::count(s, '1');\n    if (ones % 3 != 0)\n      return 0;\n    if (ones == 0) {\n      const long n = s.size();\n      return (n - 1) * (n - 2) / 2 % kMod;\n    }\n\n    int s1End = -1;\n    int s2Start = -1;\n    int s2End = -1;\n    int s3Start = -1;\n    int onesSoFar = 0;\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (s[i] == '1')\n        ++onesSoFar;\n      if (s1End == -1 && onesSoFar == ones / 3)\n        s1End = i;\n      else if (s2Start == -1 && onesSoFar == ones / 3 + 1)\n        s2Start = i;\n      if (s2End == -1 && onesSoFar == ones / 3 * 2)\n        s2End = i;\n      else if (s3Start == -1 && onesSoFar == ones / 3 * 2 + 1)\n        s3Start = i;\n    }\n\n    return static_cast<long>(s2Start - s1End) * (s3Start - s2End) % kMod;\n  }\n};\n", "1574": "class Solution {\n public:\n  int findLengthOfShortestSubarray(vector<int>& arr) {\n    const int n = arr.size();\n    int l = 0;\n    int r = n - 1;\n\n    // arr[0..l] is non-decreasing.\n    while (l < n - 1 && arr[l + 1] >= arr[l])\n      ++l;\n    // arr[r..n - 1] is non-decreasing.\n    while (r > 0 && arr[r - 1] <= arr[r])\n      --r;\n    // Remove arr[l + 1..n - 1] or arr[0..r - 1].\n    int ans = min(n - 1 - l, r);\n\n    // Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers\n    // at the rightmost indices, l and n - 1, and greedily shrink them toward\n    // the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],\n    // we ensure that `arr` becomes non-decreasing.\n    int i = l;\n    int j = n - 1;\n    while (i >= 0 && j >= r && j > i) {\n      if (arr[i] <= arr[j])\n        --j;\n      else\n        --i;\n      ans = min(ans, j - i);\n    }\n\n    return ans;\n  }\n};\n", "1575": "class Solution {\n public:\n  int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = locations.size();\n    // dp[i][j] := the number of ways to reach the `finish` city from the i-th\n    // city with `j` fuel\n    vector<vector<int>> dp(n, vector<int>(fuel + 1));\n\n    for (int f = 0; f <= fuel; ++f)\n      dp[finish][f] = 1;\n\n    for (int f = 0; f <= fuel; ++f)\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j) {\n          if (i == j)\n            continue;\n          const int requiredFuel = abs(locations[i] - locations[j]);\n          if (requiredFuel <= f) {\n            dp[i][f] += dp[j][f - requiredFuel];\n            dp[i][f] %= kMod;\n          }\n        }\n\n    return dp[start][fuel];\n  }\n};\n", "1577": "class Solution {\n public:\n  int numTriplets(vector<int>& nums1, vector<int>& nums2) {\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1);\n  }\n\n private:\n  // Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].\n  int countTriplets(const vector<int>& A, const vector<int>& B) {\n    int res = 0;\n    unordered_map<int, int> count;\n\n    for (const int b : B)\n      ++count[b];\n\n    for (const int a : A) {\n      const long target = static_cast<long>(a) * a;\n      for (const auto& [b, freq] : count) {\n        if (target % b > 0 || !count.contains(target / b))\n          continue;\n        if (target / b == b)\n          res += freq * (freq - 1);\n        else\n          res += freq * count[target / b];\n      }\n    }\n\n    return res / 2;\n  }\n};\n", "1578": "class Solution {\n public:\n  int minCost(string colors, vector<int>& neededTime) {\n    int ans = 0;\n    int maxNeededTime = neededTime[0];\n\n    for (int i = 1; i < colors.length(); ++i)\n      if (colors[i] == colors[i - 1]) {\n        ans += min(maxNeededTime, neededTime[i]);\n        // For each continuous group, Bob needs to remove every balloon except\n        // the one with the maximum `neededTime`. So, he should hold the balloon\n        // with the highest `neededTime` in his hand.\n        maxNeededTime = max(maxNeededTime, neededTime[i]);\n      } else {\n        // If the current balloon is different from the previous one, discard\n        // the balloon from the previous group and hold the new one in hand.\n        maxNeededTime = neededTime[i];\n      }\n\n    return ans;\n  }\n};\n", "1579": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  bool unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return false;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n    return true;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\n    UnionFind alice(n);\n    UnionFind bob(n);\n    int requiredEdges = 0;\n\n    // Greedily put type 3 edges in the front.\n    ranges::sort(edges, ranges::greater{},\n                 [](const vector<int>& edge) { return edge[0]; });\n\n    for (const vector<int>& edge : edges) {\n      const int type = edge[0];\n      const int u = edge[1] - 1;\n      const int v = edge[2] - 1;\n      switch (type) {\n        case 3:  // Can be traversed by Alice and Bob.\n          // Note that we should use | instead of || because if the first\n          // expression is true, short-circuiting will skip the second\n          // expression.\n          if (alice.unionByRank(u, v) | bob.unionByRank(u, v))\n            ++requiredEdges;\n          break;\n        case 2:  // Can be traversed by Bob.\n          if (bob.unionByRank(u, v))\n            ++requiredEdges;\n          break;\n        case 1:  // Can be traversed by Alice.\n          if (alice.unionByRank(u, v))\n            ++requiredEdges;\n          break;\n      }\n    }\n\n    return alice.getCount() == 1 && bob.getCount() == 1\n               ? edges.size() - requiredEdges\n               : -1;\n  }\n};\n", "158": "/**\n * The read4 API is defined in the parent class Reader4.\n *     int read4(char *buf4);\n */\n\nclass Solution {\n public:\n  /**\n   * @param buf Destination buffer\n   * @param n   Number of characters to read\n   * @return    The number of actual characters read\n   */\n  int read(char* buf, int n) {\n    int i = 0;  // buf's index\n\n    // Put the remaining characteres in the buf4 to the buf.\n    while (i4 < n4 && i < n)\n      buf[i++] = buf4[i4++];\n\n    // While we're not reaching the tail (< 4 characters).\n    while (i + 4 < n) {\n      const int k = read4(buf + i);  // Directly write to the buf.\n      if (k == 0)                    // Reach the EOF.\n        return i;\n      i += k;\n    }\n\n    // Reach the tail.\n    while (i < n) {\n      if (i4 == n4) {      // All the characters in the buf4 are consumed.\n        i4 = 0;            // Reset the buf4's index.\n        n4 = read4(buf4);  // Read <= 4 characters from the file to the buf4.\n        if (n4 == 0)       // Reach the EOF.\n          return i;\n      }\n      buf[i++] = buf4[i4++];\n    }\n\n    return i;\n  }\n\n private:\n  char* buf4 = new char[4];\n  int i4 = 0;  // buf4's index\n  int n4 = 0;  // buf4's size\n};\n", "1580": "class Solution {\n public:\n  int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {\n    int l = 0;\n    int r = warehouse.size() - 1;\n\n    ranges::sort(boxes, greater<>());\n\n    for (const int box : boxes) {\n      if (l > r)\n        return warehouse.size();\n      if (box <= warehouse[l])\n        ++l;\n      else if (box <= warehouse[r])\n        --r;\n    }\n\n    return l + (warehouse.size() - r - 1);\n  }\n};\n", "1582": "class Solution {\n public:\n  int numSpecial(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    int ans = 0;\n    vector<int> rowOnes(m);\n    vector<int> colOnes(n);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 1) {\n          ++rowOnes[i];\n          ++colOnes[j];\n        }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 1 && rowOnes[i] == 1 && colOnes[j] == 1)\n          ++ans;\n\n    return ans;\n  }\n};\n", "1583": "class Solution {\n public:\n  int unhappyFriends(int n, vector<vector<int>>& preferences,\n                     vector<vector<int>>& pairs) {\n    int ans = 0;\n    vector<int> matches(n);\n    vector<unordered_map<int, int>> prefer(n);\n\n    for (const vector<int>& pair : pairs) {\n      const int x = pair[0];\n      const int y = pair[1];\n      matches[x] = y;\n      matches[y] = x;\n    }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n - 1; ++j)\n        prefer[i][preferences[i][j]] = j;\n\n    for (int x = 0; x < n; ++x)\n      for (const auto& [u, _] : prefer[x]) {\n        const int y = matches[x];\n        const int v = matches[u];\n        if (prefer[x][u] < prefer[x][y] && prefer[u][x] < prefer[u][v]) {\n          ++ans;\n          break;\n        }\n      }\n\n    return ans;\n  }\n};\n", "1584": "class Solution {\n public:\n  int minCostConnectPoints(vector<vector<int>>& points) {\n    // dist[i] := the minimum distance to connect the points[i]\n    vector<int> dist(points.size(), INT_MAX);\n    int ans = 0;\n\n    for (int i = 0; i < points.size() - 1; ++i) {\n      for (int j = i + 1; j < points.size(); ++j) {\n        // Try to connect the points[i] with the points[j].\n        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +\n                                   abs(points[i][1] - points[j][1]));\n        // Swap the points[j] (the point with the mnimum distance) with the\n        // points[i + 1].\n        if (dist[j] < dist[i + 1]) {\n          swap(points[j], points[i + 1]);\n          swap(dist[j], dist[i + 1]);\n        }\n      }\n      ans += dist[i + 1];\n    }\n\n    return ans;\n  }\n};\n", "1585": "class Solution {\n public:\n  bool isTransformable(string s, string t) {\n    if (getCount(s) != getCount(t))\n      return false;\n\n    vector<queue<int>> positions(10);\n\n    for (int i = 0; i < s.length(); ++i)\n      positions[s[i] - '0'].push(i);\n\n    // For each digit in `t`, check if we can put this digit in `s` at the same\n    // position as `t`. Ensure that all the left digits are equal to or greater\n    // than it. This is because the only operation we can perform is sorting in\n    // ascending order. If there is a digit to the left that is smaller than it,\n    // we can never move it to the same position as in `t`. However, if all the\n    // digits to its left are equal to or greater than it, we can move it one\n    // position to the left until it reaches the same position as in `t`.\n    for (const char c : t) {\n      const int d = c - '0';\n      const int front = positions[d].front();\n      positions[d].pop();\n      for (int smaller = 0; smaller < d; ++smaller)\n        if (!positions[smaller].empty() && positions[smaller].front() < front)\n          return false;\n    }\n    return true;\n  }\n\n private:\n  vector<int> getCount(const string& s) {\n    vector<int> count(10);\n    for (const char c : s)\n      ++count[c - '0'];\n    return count;\n  }\n};\n", "1586": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root) {\n    pushLeftsUntilNull(root);\n  }\n\n  bool hasNext() {\n    return !nexts.empty();\n  }\n\n  int next() {\n    auto [root, fromNext] = nexts.top();\n    nexts.pop();\n    if (fromNext)\n      pushLeftsUntilNull(root->right);\n    prevsAndCurr.push(root);\n    return root->val;\n  }\n\n  bool hasPrev() {\n    return prevsAndCurr.size() > 1;\n  }\n\n  int prev() {\n    nexts.push({prevsAndCurr.top(), /*fromNext=*/false});\n    prevsAndCurr.pop();\n    return prevsAndCurr.top()->val;\n  }\n\n private:\n  stack<TreeNode*> prevsAndCurr;\n  stack<pair<TreeNode*, /*fromNext=*/bool>> nexts;\n\n  void pushLeftsUntilNull(TreeNode* root) {\n    while (root != nullptr) {\n      nexts.push({root, /*fromtNext=*/true});\n      root = root->left;\n    }\n  }\n};\n", "1588": "class Solution {\n public:\n  int sumOddLengthSubarrays(vector<int>& arr) {\n    int ans = 0;\n    // Maintain two sums of subarrays ending in the previous index.\n    // Each time we meet a new number, we'll consider \"how many times\" it should\n    // contribute to the newly built subarrays by calculating the number of\n    // previous even/odd-length subarrays.\n    int prevEvenSum = 0;  // the sum of even-length subarrays\n    int prevOddSum = 0;   // the sum of odd-length subarrays\n\n    for (int i = 0; i < arr.size(); ++i) {\n      // (i + 1) / 2 := the number of previous odd-length subarrays.\n      const int currEvenSum = prevOddSum + ((i + 1) / 2) * arr[i];\n      // i / 2 + 1 := the number of previous even-length subarrays\n      // (including 0).\n      const int currOddSum = prevEvenSum + (i / 2 + 1) * arr[i];\n      ans += currOddSum;\n      prevEvenSum = currEvenSum;\n      prevOddSum = currOddSum;\n    }\n\n    return ans;\n  }\n};\n", "1589": "class Solution {\n public:\n  int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    // count[i] := the number of times nums[i] has been requested\n    vector<int> count(nums.size());\n\n    for (const vector<int>& request : requests) {\n      const int start = request[0];\n      const int end = request[1];\n      ++count[start];\n      if (end + 1 < nums.size())\n        --count[end + 1];\n    }\n\n    for (int i = 1; i < nums.size(); ++i)\n      count[i] += count[i - 1];\n\n    ranges::sort(count);\n    ranges::sort(nums);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      ans += static_cast<long>(nums[i]) * count[i];\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "159": "class Solution {\n public:\n  int lengthOfLongestSubstringTwoDistinct(string s) {\n    int ans = 0;\n    int distinct = 0;\n    vector<int> count(128);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r]] == 1)\n        ++distinct;\n      while (distinct == 3)\n        if (--count[s[l++]] == 0)\n          --distinct;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "1590": "class Solution {\n public:\n  int minSubarray(vector<int>& nums, int p) {\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    const int remainder = sum % p;\n    if (remainder == 0)\n      return 0;\n\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n    int ans = nums.size();\n    int prefix = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      prefix %= p;\n      const int target = (prefix - remainder + p) % p;\n      if (const auto it = prefixToIndex.find(target);\n          it != prefixToIndex.cend())\n        ans = min(ans, i - it->second);\n      prefixToIndex[prefix] = i;\n    }\n\n    return ans == nums.size() ? -1 : ans;\n  }\n};\n", "1591": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  bool isPrintable(vector<vector<int>>& targetGrid) {\n    constexpr int kMaxColor = 60;\n    const int m = targetGrid.size();\n    const int n = targetGrid[0].size();\n    // graph[u] := {v1, v2} means v1 and v2 cover u\n    vector<unordered_set<int>> graph(kMaxColor + 1);\n\n    for (int color = 1; color <= kMaxColor; ++color) {\n      // Get the rectangle of the current color.\n      int minI = m;\n      int minJ = n;\n      int maxI = -1;\n      int maxJ = -1;\n      for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n          if (targetGrid[i][j] == color) {\n            minI = min(minI, i);\n            minJ = min(minJ, j);\n            maxI = max(maxI, i);\n            maxJ = max(maxJ, j);\n          }\n      // Add any color covering the current as the children.\n      for (int i = minI; i <= maxI; ++i)\n        for (int j = minJ; j <= maxJ; ++j)\n          if (targetGrid[i][j] != color)\n            graph[color].insert(targetGrid[i][j]);\n    }\n\n    vector<State> states(kMaxColor + 1);\n\n    for (int color = 1; color <= kMaxColor; ++color)\n      if (hasCycle(graph, color, states))\n        return false;\n\n    return true;\n  }\n\n private:\n  bool hasCycle(const vector<unordered_set<int>>& graph, int u,\n                vector<State>& states) {\n    if (states[u] == State::kVisiting)\n      return true;\n    if (states[u] == State::kVisited)\n      return false;\n    states[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (hasCycle(graph, v, states))\n        return true;\n    states[u] = State::kVisited;\n    return false;\n  }\n};\n", "1592": "class Solution {\n public:\n  string reorderSpaces(string text) {\n    const int spaces = ranges::count(text, ' ');\n    string ans;\n    vector<string> words;\n\n    istringstream iss(text);\n    string word;\n\n    while (iss >> word)\n      words.push_back(word);\n\n    if (words.size() == 1)\n      return word + string(spaces, ' ');\n\n    const int gapSize = spaces / (words.size() - 1);\n    const int remains = spaces % (words.size() - 1);\n\n    for (int i = 0; i < words.size() - 1; ++i)\n      ans += words[i] + string(gapSize, ' ');\n    ans += words.back() + string(remains, ' ');\n\n    return ans;\n  }\n};\n", "1593": "class Solution {\n public:\n  int maxUniqueSplit(string s) {\n    size_t ans = 0;\n    dfs(s, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int start, unordered_set<string>&& seen,\n           size_t& ans) {\n    if (start == s.length()) {\n      ans = max(ans, seen.size());\n      return;\n    }\n\n    for (int i = 1; start + i <= s.length(); ++i) {\n      const string cand = s.substr(start, i);\n      if (seen.contains(cand))\n        continue;\n      seen.insert(cand);\n      dfs(s, start + i, std::move(seen), ans);\n      seen.erase(cand);\n    }\n  }\n};\n", "1594": "class Solution {\n public:\n  int maxProductPath(vector<vector<int>>& grid) {\n    constexpr int kMod = 1'000'000'007;\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dpMin[i][j] := the minimum product from (0, 0) to (i, j)\n    // dpMax[i][j] := the maximum product from (0, 0) to (i, j)\n    vector<vector<long>> dpMin(m, vector<long>(n));\n    vector<vector<long>> dpMax(m, vector<long>(n));\n\n    dpMin[0][0] = dpMax[0][0] = grid[0][0];\n\n    for (int i = 1; i < m; ++i)\n      dpMin[i][0] = dpMax[i][0] = dpMin[i - 1][0] * grid[i][0];\n\n    for (int j = 1; j < n; ++j)\n      dpMin[0][j] = dpMax[0][j] = dpMin[0][j - 1] * grid[0][j];\n\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (grid[i][j] < 0) {\n          dpMin[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];\n          dpMax[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];\n        } else {\n          dpMin[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];\n          dpMax[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];\n        }\n\n    const long mx = max(dpMin.back().back(), dpMax.back().back());\n    return mx < 0 ? -1 : mx % kMod;\n  }\n};\n", "1595": "class Solution {\n public:\n  int connectTwoGroups(vector<vector<int>>& cost) {\n    const int m = cost.size();\n    const int n = cost[0].size();\n    vector<vector<int>> mem(m, vector<int>(1 << n, INT_MAX));\n    // minCosts[j] := the minimum cost of connecting group2's point j\n    vector<int> minCosts(n);\n\n    for (int j = 0; j < n; ++j) {\n      int minCostIndex = 0;\n      for (int i = 1; i < m; ++i)\n        if (cost[i][j] < cost[minCostIndex][j])\n          minCostIndex = i;\n      minCosts[j] = cost[minCostIndex][j];\n    }\n\n    return connectTwoGroups(cost, 0, 0, minCosts, mem);\n  }\n\n private:\n  // Returns the minimum cost to connect group1's points[i..n) with group2's\n  // points, where `mask` is the bitmask of the connected points in group2.\n  int connectTwoGroups(const vector<vector<int>>& cost, int i, int mask,\n                       const vector<int>& minCosts, vector<vector<int>>& mem) {\n    if (i == cost.size()) {\n      // All the points in group 1 are connected, so greedily assign the\n      // minimum cost for the unconnected points of group2.\n      int res = 0;\n      for (int j = 0; j < cost[0].size(); ++j)\n        if ((mask >> j & 1) == 0)\n          res += minCosts[j];\n      return res;\n    }\n    if (mem[i][mask] != INT_MAX)\n      return mem[i][mask];\n\n    for (int j = 0; j < cost[0].size(); ++j)\n      mem[i][mask] =\n          min(mem[i][mask],\n              cost[i][j] +\n                  connectTwoGroups(cost, i + 1, mask | 1 << j, minCosts, mem));\n\n    return mem[i][mask];\n  }\n};\n", "1597": "class Solution {\n public:\n  Node* expTree(string s) {\n    stack<Node*> nodes;\n    stack<char> ops;  // [operators | parentheses]\n\n    for (const char c : s)\n      if (isdigit(c)) {\n        nodes.push(new Node(c));\n      } else if (c == '(') {\n        ops.push(c);\n      } else if (c == ')') {\n        while (ops.top() != '(')\n          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));\n        ops.pop();  // Remove '('.\n      } else if (c == '+' || c == '-' || c == '*' || c == '/') {\n        while (!ops.empty() && compare(ops.top(), c))\n          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));\n        ops.push(c);\n      }\n\n    while (!ops.empty())\n      nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));\n\n    return nodes.top();\n  }\n\n private:\n  Node* buildNode(char op, Node* right, Node* left) {\n    return new Node(op, left, right);\n  }\n\n  // Returns true if op1 is a operator and priority(op1) >= priority(op2).\n  bool compare(char op1, char op2) {\n    if (op1 == '(' || op1 == ')')\n      return false;\n    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';\n  }\n\n  char pop(stack<char>& ops) {\n    const char op = ops.top();\n    ops.pop();\n    return op;\n  }\n\n  Node* pop(stack<Node*>& nodes) {\n    Node* node = nodes.top();\n    nodes.pop();\n    return node;\n  }\n};\n", "1598": "class Solution {\n public:\n  int minOperations(vector<string>& logs) {\n    int ans = 0;\n\n    for (const string& log : logs) {\n      if (log == \"./\")\n        continue;\n      if (log == \"../\")\n        ans = max(0, ans - 1);\n      else\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1599": "class Solution {\n public:\n  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,\n                             int runningCost) {\n    int waiting = 0;\n    int profit = 0;\n    int maxProfit = 0;\n    int rotate = 0;\n    int maxRotate = -1;\n    int i = 0;\n\n    while (waiting > 0 || i < customers.size()) {\n      if (i < customers.size())\n        waiting += customers[i++];\n      // Onboard new customers.\n      const int newOnboard = min(waiting, 4);\n      waiting -= newOnboard;\n      profit += newOnboard * boardingCost - runningCost;\n      ++rotate;\n      if (profit > maxProfit) {\n        maxProfit = profit;\n        maxRotate = rotate;\n      }\n    }\n\n    return maxRotate;\n  }\n};\n", "16": "class Solution {\n public:\n  int threeSumClosest(vector<int>& nums, int target) {\n    int ans = nums[0] + nums[1] + nums[2];\n\n    ranges::sort(nums);\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      // Choose nums[i] as the first number in the triplet, then search the\n      // remaining numbers in [i + 1, n - 1].\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r) {\n        const int sum = nums[i] + nums[l] + nums[r];\n        if (sum == target)\n          return sum;\n        if (abs(sum - target) < abs(ans - target))\n          ans = sum;\n        if (sum < target)\n          ++l;\n        else\n          --r;\n      }\n    }\n\n    return ans;\n  }\n};\n", "160": "class Solution {\n public:\n  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n    ListNode* a = headA;\n    ListNode* b = headB;\n\n    while (a != b) {\n      a = a == nullptr ? headB : a->next;\n      b = b == nullptr ? headA : b->next;\n    }\n\n    return a;\n  }\n};\n", "1600": "class ThroneInheritance {\n public:\n  ThroneInheritance(string kingName) : kingName(kingName) {}\n\n  void birth(string parentName, string childName) {\n    family[parentName].push_back(childName);\n  }\n\n  void death(string name) {\n    dead.insert(name);\n  }\n\n  vector<string> getInheritanceOrder() {\n    vector<string> ans;\n    dfs(kingName, ans);\n    return ans;\n  }\n\n private:\n  unordered_set<string> dead;\n  unordered_map<string, vector<string>> family;\n  string kingName;\n\n  void dfs(const string& name, vector<string>& ans) {\n    if (!dead.contains(name))\n      ans.push_back(name);\n    if (!family.contains(name))\n      return;\n\n    for (const string& child : family[name])\n      dfs(child, ans);\n  }\n};\n", "1601": "class Solution {\n public:\n  int maximumRequests(int n, vector<vector<int>>& requests) {\n    int ans = 0;\n    vector<int> degrees(n);  // degrees[i] := degrees of the i-th building\n\n    function<void(int, int)> dfs = [&](int i, int processedReqs) {\n      if (i == requests.size()) {\n        if (ranges::all_of(degrees, [](int d) { return d == 0; }))\n          ans = max(ans, processedReqs);\n        return;\n      }\n\n      // Skip the requests[i].\n      dfs(i + 1, processedReqs);\n\n      // Process the requests[i].\n      --degrees[requests[i][0]];\n      ++degrees[requests[i][1]];\n      dfs(i + 1, processedReqs + 1);\n      --degrees[requests[i][1]];\n      ++degrees[requests[i][0]];\n    };\n\n    dfs(0, 0);\n\n    return ans;\n  }\n};\n", "1602": "class Solution {\n public:\n  TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\n    TreeNode* ans = nullptr;\n    int targetDepth = -1;\n    dfs(root, u, 0, targetDepth, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, TreeNode* u, int depth, int& targetDepth,\n           TreeNode*& ans) {\n    if (root == nullptr)\n      return;\n    if (root == u) {\n      targetDepth = depth;\n      return;\n    }\n    if (depth == targetDepth && ans == nullptr) {\n      ans = root;\n      return;\n    }\n    dfs(root->left, u, depth + 1, targetDepth, ans);\n    dfs(root->right, u, depth + 1, targetDepth, ans);\n  }\n};\n", "1603": "class ParkingSystem {\n public:\n  ParkingSystem(int big, int medium, int small) {\n    count = {big, medium, small};\n  }\n\n  bool addCar(int carType) {\n    return count[carType - 1]-- > 0;\n  }\n\n private:\n  vector<int> count;\n};\n", "1604": "class Solution {\n public:\n  vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {\n    vector<string> ans;\n    unordered_map<string, vector<int>> nameToMinutes;\n\n    for (int i = 0; i < keyName.size(); ++i) {\n      const int minutes = getMinutes(keyTime[i]);\n      nameToMinutes[keyName[i]].push_back(minutes);\n    }\n\n    for (auto& [name, minutes] : nameToMinutes)\n      if (hasAlert(minutes))\n        ans.push_back(name);\n\n    ranges::sort(ans);\n    return ans;\n  }\n\n private:\n  // Returns true if any worker uses the key-card three or more times in an\n  // one-hour period.\n  bool hasAlert(vector<int>& minutes) {\n    if (minutes.size() > 70)\n      return true;\n    ranges::sort(minutes);\n    for (int i = 2; i < minutes.size(); ++i)\n      if (minutes[i - 2] + 60 >= minutes[i])\n        return true;\n    return false;\n  }\n\n  int getMinutes(const string& time) {\n    const int h = stoi(time.substr(0, 2));\n    const int m = stoi(time.substr(3));\n    return 60 * h + m;\n  }\n};\n", "1605": "class Solution {\n public:\n  vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {\n    const int m = rowSum.size();\n    const int n = colSum.size();\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        ans[i][j] = min(rowSum[i], colSum[j]);\n        rowSum[i] -= ans[i][j];\n        colSum[j] -= ans[i][j];\n      }\n\n    return ans;\n  }\n};\n", "1606": "class Solution {\n public:\n  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\n    vector<int> ans;\n    vector<int> times(k);\n    set<int> idleServers;\n    // (endTime, server)\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\n\n    for (int i = 0; i < k; ++i)\n      idleServers.insert(i);\n\n    for (int i = 0; i < arrival.size(); ++i) {\n      // Pop all the servers that are available now.\n      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {\n        idleServers.insert(minHeap.top().second);\n        minHeap.pop();\n      }\n      // Get the next available server.\n      const int server = getNextAvailableServer(idleServers, i, k);\n      if (server == -1)\n        continue;\n      ++times[server];\n      minHeap.emplace(arrival[i] + load[i], server);\n      idleServers.erase(server);\n    }\n\n    const int busiest = ranges::max(times);\n    for (int i = 0; i < k; ++i)\n      if (times[i] == busiest)\n        ans.push_back(i);\n    return ans;\n  }\n\n private:\n  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,\n                             int k) {\n    if (idleServers.empty())\n      return -1;\n    const auto it = idleServers.lower_bound(ithRequest % k);\n    return it == idleServers.cend() ? *idleServers.begin() : *it;\n  }\n};\n", "1608": "class Solution {\n public:\n  int specialArray(vector<int>& nums) {\n    ranges::sort(nums);\n\n    if (nums[0] >= nums.size())\n      return nums.size();\n\n    for (int i = 1; i < nums.size(); ++i) {\n      const int count = nums.size() - i;\n      if (nums[i - 1] < count && nums[i] >= count)\n        return count;\n    }\n\n    return -1;\n  }\n};\n", "1609": "class Solution {\n public:\n  bool isEvenOddTree(TreeNode* root) {\n    queue<TreeNode*> q{{root}};\n    bool isEven = true;\n\n    for (; !q.empty(); isEven = !isEven) {\n      int prevVal = isEven ? INT_MIN : INT_MAX;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        if (isEven && (node->val % 2 == 0 || node->val <= prevVal))\n          return false;  // invalid case on even level\n        if (!isEven && (node->val % 2 == 1 || node->val >= prevVal))\n          return false;  // invalid case on odd level\n        prevVal = node->val;\n        if (node->left != nullptr)\n          q.push(node->left);\n        if (node->right != nullptr)\n          q.push(node->right);\n      }\n    }\n\n    return true;\n  }\n};\n", "161": "class Solution {\n public:\n  bool isOneEditDistance(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    if (m > n)  // Make sure that |s| <= |t|.\n      return isOneEditDistance(t, s);\n\n    for (int i = 0; i < m; ++i)\n      if (s[i] != t[i]) {\n        if (m == n)\n          return s.substr(i + 1) == t.substr(i + 1);  // Replace s[i] with t[i].\n        return s.substr(i) == t.substr(i + 1);        // Delete t[i].\n      }\n\n    return m + 1 == n;  // Delete t[-1].\n  }\n};\n", "1610": "class Solution {\n public:\n  int visiblePoints(vector<vector<int>>& points, int angle,\n                    vector<int>& location) {\n    const int posX = location[0];\n    const int posY = location[1];\n    int maxVisible = 0;\n    int same = 0;\n    vector<double> pointAngles;\n\n    for (const vector<int>& p : points) {\n      const int x = p[0];\n      const int y = p[1];\n      if (x == posX && y == posY)\n        ++same;\n      else\n        pointAngles.push_back(getAngle(y - posY, x - posX));\n    }\n\n    ranges::sort(pointAngles);\n\n    const int n = pointAngles.size();\n    for (int i = 0; i < n; ++i)\n      pointAngles.push_back(pointAngles[i] + 360);\n\n    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {\n      while (pointAngles[r] - pointAngles[l] > angle)\n        ++l;\n      maxVisible = max(maxVisible, r - l + 1);\n    }\n\n    return maxVisible + same;\n  }\n\n private:\n  double getAngle(int dy, int dx) {\n    return atan2(dy, dx) * 180 / M_PI;\n  }\n};\n", "1611": "class Solution {\n public:\n  int minimumOneBitOperations(int n) {\n    // Observation: e.g. n = 2^2\n    //        100 (2^2 needs 2^3 - 1 ops)\n    // op1 -> 101\n    // op2 -> 111\n    // op1 -> 110\n    // op2 -> 010 (2^1 needs 2^2 - 1 ops)\n    // op1 -> 011\n    // op2 -> 001 (2^0 needs 2^1 - 1 ops)\n    // op1 -> 000\n    //\n    // So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\n    // also takes 2^(k + 1) - 1 ops.\n\n    // e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\n    //   - If the second bit is 1, you only need to consider the cost of turning\n    //     the last 2 bits to 0.\n    //   - If the second bit is 0, you need to add up the cost of flipping the\n    //     second bit from 0 to 1.\n    // XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\n    // Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\n    if (n == 0)\n      return 0;\n    // x is the largest 2^k <= n.\n    // x | x >> 1 -> x >> 1 needs 1 op.\n    //     x >> 1 -> 0      needs x = 2^k - 1 ops.\n    int x = 1;\n    while (x * 2 <= n)\n      x <<= 1;\n    return minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1;\n  }\n};\n", "1612": "class Solution {\n public:\n  bool checkEquivalence(Node* root1, Node* root2) {\n    vector<int> count(26);\n    dfs(root1, count, 1);\n    dfs(root2, count, -1);\n    return ranges::count_if(count, [](int c) { return c != 0; }) == 0;\n  }\n\n private:\n  void dfs(Node* root, vector<int>& count, int add) {\n    if (root == nullptr)\n      return;\n    if ('a' <= root->val && root->val <= 'z')\n      count[root->val - 'a'] += add;\n    dfs(root->left, count, add);\n    dfs(root->right, count, add);\n  }\n};\n", "1614": "class Solution {\n public:\n  int maxDepth(string s) {\n    int ans = 0;\n    int opened = 0;\n\n    for (const char c : s)\n      if (c == '(')\n        ans = max(ans, ++opened);\n      else if (c == ')')\n        --opened;\n\n    return ans;\n  }\n};\n", "1615": "class Solution {\n public:\n  int maximalNetworkRank(int n, vector<vector<int>>& roads) {\n    vector<int> degrees(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      ++degrees[u];\n      ++degrees[v];\n    }\n\n    // Find the first maximum and the second maximum degrees.\n    int maxDegree1 = 0;\n    int maxDegree2 = 0;\n    for (const int degree : degrees) {\n      if (degree > maxDegree1) {\n        maxDegree2 = maxDegree1;\n        maxDegree1 = degree;\n      } else if (degree > maxDegree2) {\n        maxDegree2 = degree;\n      }\n    }\n\n    // There can be multiple nodes with `maxDegree1` or `maxDegree2`.\n    // Find the counts of such nodes.\n    int countMaxDegree1 = 0;\n    int countMaxDegree2 = 0;\n    for (const int degree : degrees)\n      if (degree == maxDegree1)\n        ++countMaxDegree1;\n      else if (degree == maxDegree2)\n        ++countMaxDegree2;\n\n    if (countMaxDegree1 == 1) {\n      // 1. If there is only one node with degree = `maxDegree1`, then we'll\n      // need to use the node with degree = `maxDegree2`. The answer in general\n      // will be (maxDegree1 + maxDegree2), but if the two nodes that we're\n      // considering are connected, then we'll have to subtract 1.\n      const int edgeCount =\n          getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +\n          getEdgeCount(roads, degrees, maxDegree2, maxDegree1);\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount ? 1 : 0);\n    } else {\n      // 2. If there are more than one node with degree = `maxDegree1`, then we\n      // can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.\n      // The answer in general will be 2 * maxDegree1, but if the two nodes that\n      // we're considering are connected, then we'll have to subtract 1.\n      const int edgeCount =\n          getEdgeCount(roads, degrees, maxDegree1, maxDegree1);\n      const int maxPossibleEdgeCount =\n          countMaxDegree1 * (countMaxDegree1 - 1) / 2;\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount ? 1 : 0);\n    }\n  }\n\n private:\n  // Returns the number of edges (u, v) where degress[u] == degreeU and\n  // degrees[v] == degreeV.\n  int getEdgeCount(const vector<vector<int>>& roads, const vector<int>& degrees,\n                   int degreeU, int degreeV) {\n    int edgeCount = 0;\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      if (degrees[u] == degreeU && degrees[v] == degreeV)\n        ++edgeCount;\n    }\n    return edgeCount;\n  }\n};\n", "1616": "class Solution {\n public:\n  bool checkPalindromeFormation(string a, string b) {\n    return check(a, b) || check(b, a);\n  }\n\n private:\n  bool check(const string& a, const string& b) {\n    for (int i = 0, j = a.length() - 1; i < j; ++i, --j)\n      if (a[i] != b[j])\n        // a[0:i] + a[i..j] + b[j + 1:] or\n        // a[0:i] + b[i..j] + b[j + 1:]\n        return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n    return true;\n  }\n\n  bool isPalindrome(const string& s, int i, int j) {\n    while (i < j)\n      if (s[i++] != s[j--])\n        return false;\n    return true;\n  }\n};\n", "1617": "class Solution {\n public:\n  vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {\n    const int maxMask = 1 << n;\n    const vector<vector<int>> dist = floydWarshall(n, edges);\n    vector<int> ans(n - 1);\n\n    // mask := the subset of the cities\n    for (int mask = 0; mask < maxMask; ++mask) {\n      const int maxDist = getMaxDist(mask, dist, n);\n      if (maxDist > 0)\n        ++ans[maxDist - 1];\n    }\n\n    return ans;\n  }\n\n private:\n  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges) {\n    vector<vector<int>> dist(n, vector<int>(n, n));\n\n    for (int i = 0; i < n; ++i)\n      dist[i][i] = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0] - 1;\n      const int v = edge[1] - 1;\n      dist[u][v] = 1;\n      dist[v][u] = 1;\n    }\n\n    for (int k = 0; k < n; ++k)\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    return dist;\n  }\n\n  int getMaxDist(int mask, const vector<vector<int>>& dist, int n) {\n    int maxDist = 0;\n    int edgeCount = 0;\n    int cityCount = 0;\n    for (int u = 0; u < n; ++u) {\n      if ((mask >> u & 1) == 0)  // u is not in the subset.\n        continue;\n      ++cityCount;\n      for (int v = u + 1; v < n; ++v) {\n        if ((mask >> v & 1) == 0)  // v is not in the subset.\n          continue;\n        if (dist[u][v] == 1)  // u and v are connected.\n          ++edgeCount;\n        maxDist = max(maxDist, dist[u][v]);\n      }\n    }\n    return edgeCount == cityCount - 1 ? maxDist : 0;\n  }\n};\n", "1618": "/**\n * // This is the FontInfo's API interface.\n * // You should not implement it, or speculate about its implementation\n * class FontInfo {\n *  public:\n *   // Return the width of char ch when fontSize is used.\n *   int getWidth(int fontSize, char ch);\n *\n *   // Return Height of any char when fontSize is used.\n *   int getHeight(int fontSize)\n * };\n */\nclass Solution {\n public:\n  int maxFont(string text, int w, int h, vector<int>& fonts,\n              FontInfo fontInfo) {\n    vector<int> count(26);\n\n    for (const char c : text)\n      ++count[c - 'a'];\n\n    int l = 0;\n    int r = fonts.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r + 1) / 2;\n      if (fontInfo.getHeight(fonts[m]) <= h &&\n          getWidthSum(count, fonts[m], fontInfo) <= w)\n        l = m;\n      else\n        r = m - 1;\n    }\n\n    return getWidthSum(count, fonts[l], fontInfo) <= w ? fonts[l] : -1;\n  }\n\n private:\n  int getWidthSum(const vector<int>& count, int font, FontInfo& fontInfo) {\n    int width = 0;\n    for (int i = 0; i < 26; ++i)\n      width += count[i] * fontInfo.getWidth(font, (char)('a' + i));\n    return width;\n  }\n};\n", "1619": "class Solution {\n public:\n  double trimMean(vector<int>& arr) {\n    int offset = arr.size() / 20;\n    nth_element(arr.begin(), arr.begin() + offset, arr.end());\n    nth_element(arr.begin() + offset, arr.end() - offset, arr.end());\n    double sum = accumulate(arr.begin() + offset, arr.end() - offset, 0.0);\n    return sum / (arr.size() - offset * 2);\n  }\n};\n", "162": "class Solution {\n public:\n  int findPeakElement(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] >= nums[m + 1])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n};\n", "1620": "class Solution {\n public:\n  vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {\n    constexpr int kMax = 50;\n    const int n = towers.size();\n    vector<int> ans(2);\n    int maxQuality = 0;\n\n    for (int i = 0; i <= kMax; ++i)\n      for (int j = 0; j <= kMax; ++j) {\n        int qualitySum = 0;\n        for (const vector<int>& tower : towers) {\n          const double d = dist(tower, i, j);\n          if (d <= radius) {\n            const int q = tower[2];\n            qualitySum += static_cast<int>(q / (1 + d));\n          }\n        }\n        if (qualitySum > maxQuality) {\n          maxQuality = qualitySum;\n          ans = {i, j};\n        }\n      }\n\n    return ans;\n  }\n\n private:\n  // Returns the distance between the tower and the coordinate.\n  double dist(const vector<int>& tower, int i, int j) {\n    return sqrt(pow(tower[0] - i, 2) + pow(tower[1] - j, 2));\n  }\n};\n", "1621": "class Solution {\n public:\n  int numberOfSets(int n, int k) {\n    vector<vector<vector<int>>> mem(\n        n, vector<vector<int>>(k + 1, vector<int>(2, -1)));\n    return numberOfSets(0, k, /*drawing=*/false, n, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  int numberOfSets(int i, int k, bool drawing, int n,\n                   vector<vector<vector<int>>>& mem) {\n    if (k == 0)  // Find a way to draw k segments.\n      return 1;\n    if (i == n)  // Reach the end.\n      return 0;\n    if (mem[i][k][drawing] != -1)\n      return mem[i][k][drawing];\n    if (drawing)\n      // 1. Keep drawing at i and move to i + 1.\n      // 2. Stop at i so decrease k. We can start from i for the next segment.\n      return mem[i][k][drawing] = (numberOfSets(i + 1, k, true, n, mem) +\n                                   numberOfSets(i, k - 1, false, n, mem)) %\n                                  kMod;\n    // 1. Skip i and move to i + 1.\n    // 2. Start at i and move to i + 1.\n    return mem[i][k][drawing] = (numberOfSets(i + 1, k, false, n, mem) +\n                                 numberOfSets(i + 1, k, true, n, mem)) %\n                                kMod;\n  }\n};\n", "1622": "class Fancy {\n public:\n  // To undo a * val + b and get the original value, we append (val - b) / a.\n  // By Fermat's little theorem:\n  //   a^(p - 1) \u2261 1 (mod p)\n  //   a^(p - 2) \u2261 a^(-1) (mod p)\n  // So, (val - b) / a \u2261 (val - b) * a^(p - 2) (mod p)\n  void append(int val) {\n    const long x = (val - b + kMod) % kMod;\n    vals.push_back(x * modPow(a, kMod - 2) % kMod);\n  }\n\n  // If the value is a * val + b, then the value after adding by `inc` will be\n  // a * val + b + inc. So, we adjust b to b + inc.\n  void addAll(int inc) {\n    b = (b + inc) % kMod;\n  }\n\n  // If the value is a * val + b, then the value after multiplying by `m` will\n  // be a * m * val + b * m. So, we adjust a to a * m and b to b * m.\n  void multAll(int m) {\n    a = (a * m) % kMod;\n    b = (b * m) % kMod;\n  }\n\n  int getIndex(int idx) {\n    return idx >= vals.size() ? -1 : (a * vals[idx] + b) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  // For each `val` in `vals`, it actually represents a * val + b.\n  vector<unsigned long> vals;\n  unsigned long a = 1;\n  unsigned long b = 0;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "1624": "class Solution {\n public:\n  int maxLengthBetweenEqualCharacters(string s) {\n    int ans = -1;\n    vector<int> lastSeen(26, -1);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int c = s[i] - 'a';\n      if (lastSeen[c] == -1)\n        lastSeen[c] = i;\n      else\n        ans = max(ans, i - lastSeen[c] - 1);\n    }\n\n    return ans;\n  }\n};\n", "1625": "class Solution {\n public:\n  string findLexSmallestString(string s, int a, int b) {\n    string ans = s;\n\n    dfs(s, a, b, {}, ans);\n\n    return ans;\n  }\n\n private:\n  void dfs(string s, int a, int b, unordered_set<string>&& seen, string& ans) {\n    if (seen.contains(s))\n      return;\n\n    seen.insert(s);\n    ans = min(ans, s);\n\n    dfs(add(s, a), a, b, std::move(seen), ans);\n    dfs(rotate(s, b), a, b, std::move(seen), ans);\n  }\n\n  string add(string& s, int a) {\n    for (int i = 1; i < s.length(); i += 2)\n      s[i] = '0' + (s[i] - '0' + a) % 10;\n    return s;\n  }\n\n  string rotate(const string& s, int b) {\n    const int n = s.length();\n    return s.substr(n - b, n) + s.substr(0, n - b);\n  }\n};\n", "1626": "struct Player {\n  int age;\n  int score;\n  Player(int age, int score) : age(age), score(score) {}\n};\n\nclass Solution {\n public:\n  int bestTeamScore(vector<int>& scores, vector<int>& ages) {\n    const int n = scores.size();\n    vector<Player> players;\n    // dp[i] := the maximum score of choosing the players[0..i] with the\n    // players[i] being selected\n    vector<int> dp(n);\n\n    for (int i = 0; i < n; ++i)\n      players.emplace_back(ages[i], scores[i]);\n\n    ranges::sort(players, ranges::greater{}, [](const Player& player) {\n      return pair<int, int>{player.age, player.score};\n    });\n\n    for (int i = 0; i < n; ++i) {\n      // For each player, choose it first.\n      dp[i] = players[i].score;\n      // players[j].age >= players[i].age since we sort in descending order.\n      // So, we only have to check that players[j].score >= players[i].score.\n      for (int j = 0; j < i; ++j)\n        if (players[j].score >= players[i].score)\n          dp[i] = max(dp[i], dp[j] + players[i].score);\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "1627": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  bool unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return false;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    return true;\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<bool> areConnected(int n, int threshold,\n                            vector<vector<int>>& queries) {\n    vector<bool> ans;\n    UnionFind uf(n + 1);\n\n    for (int z = threshold + 1; z <= n; ++z)\n      for (int x = z * 2; x <= n; x += z)\n        uf.unionByRank(z, x);\n\n    for (const vector<int>& query : queries) {\n      const int a = query[0];\n      const int b = query[1];\n      ans.push_back(uf.find(a) == uf.find(b));\n    }\n\n    return ans;\n  }\n};\n", "1628": "/**\n * This is the interface for the expression tree Node.\n * You should not remove it, and you can define some classes to implement it.\n */\n\nclass Node {\n public:\n  virtual ~Node() {};\n  virtual int evaluate() const = 0;\n\n protected:\n  // define your fields here\n};\n\nclass ExpNode : public Node {\n public:\n  ExpNode(const string& val, ExpNode* left, ExpNode* right)\n      : val(val), left(left), right(right) {}\n\n  int evaluate() const override {\n    return left == nullptr && right == nullptr\n               ? stoi(val)\n               : op.at(val)(left->evaluate(), right->evaluate());\n  }\n\n private:\n  static const inline unordered_map<string, function<long(long, long)>> op{\n      {\"+\", std::plus<long>()},\n      {\"-\", std::minus<long>()},\n      {\"*\", std::multiplies<long>()},\n      {\"/\", std::divides<long>()}};\n  const string val;\n  const ExpNode* const left;\n  const ExpNode* const right;\n};\n\n/**\n * This is the TreeBuilder class.\n * You can treat it as the driver code that takes the postinfix input\n * and returns the expression tree represnting it as a Node.\n */\n\nclass TreeBuilder {\n public:\n  Node* buildTree(vector<string>& postfix) {\n    stack<ExpNode*> stack;\n\n    for (const string& val : postfix)\n      if (val == \"+\" || val == \"-\" || val == \"*\" || val == \"/\") {\n        ExpNode* right = stack.top();\n        stack.pop();\n        ExpNode* left = stack.top();\n        stack.pop();\n        stack.push(new ExpNode(val, left, right));\n      } else {\n        stack.push(new ExpNode(val, nullptr, nullptr));\n      }\n\n    return stack.top();\n  }\n};\n", "1629": "class Solution {\n public:\n  char slowestKey(vector<int>& releaseTimes, string keysPressed) {\n    char ans = keysPressed[0];\n    int maxDuration = releaseTimes[0];\n\n    for (int i = 1; i < keysPressed.length(); ++i) {\n      const int duration = releaseTimes[i] - releaseTimes[i - 1];\n      if (duration > maxDuration ||\n          (duration == maxDuration && keysPressed[i] > ans)) {\n        ans = keysPressed[i];\n        maxDuration = duration;\n      }\n    }\n\n    return ans;\n  }\n};\n", "163": "class Solution {\n public:\n  vector<vector<int>> findMissingRanges(vector<int>& nums, int lower,\n                                        int upper) {\n    if (nums.empty())\n      return {getRange(lower, upper)};\n\n    vector<vector<int>> ans;\n\n    if (nums.front() > lower)\n      ans.push_back(getRange(lower, nums.front() - 1));\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1] + 1)\n        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));\n\n    if (nums.back() < upper)\n      ans.push_back(getRange(nums.back() + 1, upper));\n\n    return ans;\n  }\n\n private:\n  vector<int> getRange(int lo, int hi) {\n    if (lo == hi)\n      return vector<int>{lo, lo};\n    return vector<int>{lo, hi};\n  }\n};\n", "1630": "class Solution {\n public:\n  vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l,\n                                        vector<int>& r) {\n    vector<bool> ans;\n\n    for (int i = 0; i < l.size(); ++i)\n      ans.push_back(isArithmetic(nums, l[i], r[i]));\n\n    return ans;\n  }\n\n private:\n  bool isArithmetic(vector<int>& nums, int l, int r) {\n    if (r - l < 2)\n      return true;\n\n    unordered_set<int> numsSet;\n    int mn = INT_MAX;\n    int mx = INT_MIN;\n\n    for (int i = l; i <= r; ++i) {\n      mn = min(mn, nums[i]);\n      mx = max(mx, nums[i]);\n      numsSet.insert(nums[i]);\n    }\n\n    if ((mx - mn) % (r - l) != 0)\n      return false;\n\n    const int interval = (mx - mn) / (r - l);\n\n    for (int k = 1; k <= r - l; ++k)\n      if (!numsSet.contains(mn + k * interval))\n        return false;\n\n    return true;\n  }\n};\n", "1631": "struct T {\n  int i;\n  int j;\n  int d;  // the maximum difference of (i, j) and its neighbors\n};\n\nclass Solution {\n public:\n  int minimumEffortPath(vector<vector<int>>& heights) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = heights.size();\n    const int n = heights[0].size();\n    auto compare = [](const T& a, const T& b) { return a.d > b.d; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    // diff[i][j] := the maximum absolute difference to reach (i, j)\n    vector<vector<int>> diff(m, vector<int>(n, INT_MAX));\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    minHeap.emplace(0, 0, 0);\n    diff[0][0] = 0;\n\n    while (!minHeap.empty()) {\n      const auto [i, j, d] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return d;\n      seen[i][j] = true;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        const int newDiff = abs(heights[i][j] - heights[x][y]);\n        const int maxDiff = max(diff[i][j], newDiff);\n        if (diff[x][y] > maxDiff) {\n          diff[x][y] = maxDiff;\n          minHeap.emplace(x, y, maxDiff);\n        }\n      }\n    }\n\n    throw;\n  }\n};\n", "1632": "class UnionFind {\n public:\n  void union_(int u, int v) {\n    if (!id.contains(u))\n      id[u] = u;\n    if (!id.contains(v))\n      id[v] = v;\n    const int i = find(u);\n    const int j = find(v);\n    if (i != j)\n      id[i] = j;\n  }\n\n  unordered_map<int, vector<int>> getGroupIdToValues() {\n    unordered_map<int, vector<int>> groupIdToValues;\n    for (const auto& [u, _] : id)\n      groupIdToValues[find(u)].push_back(u);\n    return groupIdToValues;\n  }\n\n private:\n  unordered_map<int, int> id;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n    // {val: [(i, j)]}\n    map<int, vector<pair<int, int>>> valToGrids;\n    // rank[i] := the maximum rank of the row or column so far\n    vector<int> maxRankSoFar(m + n);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        valToGrids[matrix[i][j]].emplace_back(i, j);\n\n    for (const auto& [val, grids] : valToGrids) {\n      UnionFind uf;\n      for (const auto& [i, j] : grids)\n        // Union i-th row with j-th col.\n        uf.union_(i, j + m);\n      for (const auto& [groupId, values] : uf.getGroupIdToValues()) {\n        // Get the maximum rank of all the included rows and columns.\n        int maxRank = 0;\n        for (const int i : values)\n          maxRank = max(maxRank, maxRankSoFar[i]);\n        // Update all the rows and columns to maxRank + 1.\n        for (const int i : values)\n          maxRankSoFar[i] = maxRank + 1;\n      }\n      for (const auto& [i, j] : grids)\n        ans[i][j] = maxRankSoFar[i];\n    }\n\n    return ans;\n  }\n};\n", "1634": "/**\n * Definition for polynomial singly-linked list.\n * struct PolyNode {\n *   int coefficient, power;\n *   PolyNode *next;\n *   PolyNode(): coefficient(0), power(0), next(nullptr) {};\n *   PolyNode(int x, int y): coefficient(x), power(y), next(nullptr) {};\n *   PolyNode(int x, int y, PolyNode* next): coefficient(x), power(y),\n *                                           next(next) {};\n * };\n */\n\nclass Solution {\n public:\n  PolyNode* addPoly(PolyNode* poly1, PolyNode* poly2) {\n    PolyNode* dummy = new PolyNode();\n    PolyNode* curr = dummy;\n    PolyNode* p = poly1;  // poly1's pointer\n    PolyNode* q = poly2;  // poly2's pointer\n\n    while (p != nullptr && q != nullptr) {\n      if (p->power > q->power) {\n        curr->next = new PolyNode(p->coefficient, p->power);\n        curr = curr->next;\n        p = p->next;\n      } else if (p->power < q->power) {\n        curr->next = new PolyNode(q->coefficient, q->power);\n        curr = curr->next;\n        q = q->next;\n      } else {  // p->power == q->power\n        const int sumCoefficient = p->coefficient + q->coefficient;\n        if (sumCoefficient != 0) {\n          curr->next = new PolyNode(sumCoefficient, p->power);\n          curr = curr->next;\n        }\n        p = p->next;\n        q = q->next;\n      }\n    }\n\n    while (p != nullptr) {\n      curr->next = new PolyNode(p->coefficient, p->power);\n      curr = curr->next;\n      p = p->next;\n    }\n\n    while (q != nullptr) {\n      curr->next = new PolyNode(q->coefficient, q->power);\n      curr = curr->next;\n      q = q->next;\n    }\n\n    return dummy->next;\n  }\n};\n", "1636": "struct T {\n  int num;\n  int freq;\n};\n\nclass Solution {\n public:\n  vector<int> frequencySort(vector<int>& nums) {\n    vector<int> ans;\n    auto compare = [](const T& a, const T& b) {\n      return a.freq == b.freq ? a.num < b.num : a.freq > b.freq;\n    };\n    priority_queue<T, vector<T>, decltype(compare)> heap(compare);\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count)\n      heap.emplace(num, freq);\n\n    while (!heap.empty()) {\n      const auto [num, freq] = heap.top();\n      heap.pop();\n      for (int i = 0; i < freq; ++i)\n        ans.push_back(num);\n    }\n\n    return ans;\n  }\n};\n", "1637": "class Solution {\n public:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    int ans = 0;\n    vector<int> xs;\n\n    for (const vector<int>& point : points) {\n      const int x = point[0];\n      xs.push_back(x);\n    }\n\n    ranges::sort(xs);\n\n    for (int i = 1; i < xs.size(); ++i)\n      ans = max(ans, xs[i] - xs[i - 1]);\n\n    return ans;\n  }\n};\n", "1638": "class Solution {\n public:\n  int countSubstrings(string s, string t) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      ans += count(s, t, i, 0);\n\n    for (int j = 1; j < t.length(); ++j)\n      ans += count(s, t, 0, j);\n\n    return ans;\n  }\n\n private:\n  // Returns the number of substrings of s[i..n) and t[j..n) that differ by one\n  // letter.\n  int count(const string& s, const string& t, int i, int j) {\n    int res = 0;\n    // the number of substrings starting at s[i] and t[j] ending in the current\n    // index with zero different letter\n    int dp0 = 0;\n    // the number of substrings starting at s[i] and t[j] ending in the current\n    // index with one different letter\n    int dp1 = 0;\n\n    for (; i < s.length() && j < t.length(); ++i, ++j) {\n      if (s[i] == t[j]) {\n        ++dp0;\n      } else {\n        dp1 = dp0 + 1;\n        dp0 = 0;\n      }\n      res += dp1;\n    }\n\n    return res;\n  }\n};\n", "1639": "class Solution {\n public:\n  int numWays(vector<string>& words, string target) {\n    constexpr int kMod = 1'000'000'007;\n    const int wordLength = words[0].length();\n    // dp[i][j] := the number of ways to form the first i characters of the\n    // `target` using the j first characters in each word\n    vector<vector<int>> dp(target.length() + 1, vector<int>(wordLength + 1));\n    // counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    vector<vector<int>> counts(wordLength, vector<int>(26));\n\n    for (int i = 0; i < wordLength; ++i)\n      for (const string& word : words)\n        ++counts[i][word[i] - 'a'];\n\n    dp[0][0] = 1;\n\n    for (int i = 0; i <= target.length(); ++i)\n      for (int j = 0; j < wordLength; ++j) {\n        if (i < target.length())\n          // Pick the character target[i] from word[j].\n          dp[i + 1][j + 1] =\n              static_cast<long>(dp[i][j]) * counts[j][target[i] - 'a'] % kMod;\n        // Skip the word[j].\n        dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % kMod;\n      }\n\n    return dp[target.length()][wordLength];\n  };\n};\n", "164": "struct Bucket {\n  int mn;\n  int mx;\n};\n\nclass Solution {\n public:\n  int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2)\n      return 0;\n\n    const int mn = ranges::min(nums);\n    const int mx = ranges::max(nums);\n    if (mn == mx)\n      return 0;\n\n    const int gap = ceil((mx - mn) / (double)(nums.size() - 1));\n    const int bucketSize = (mx - mn) / gap + 1;\n    vector<Bucket> buckets(bucketSize, {INT_MAX, INT_MIN});\n\n    for (const int num : nums) {\n      const int i = (num - mn) / gap;\n      buckets[i].mn = min(buckets[i].mn, num);\n      buckets[i].mx = max(buckets[i].mx, num);\n    }\n\n    int ans = 0;\n    int prevMax = mn;\n\n    for (const Bucket& bucket : buckets) {\n      if (bucket.mn == INT_MAX)\n        continue;  // empty bucket\n      ans = max(ans, bucket.mn - prevMax);\n      prevMax = bucket.mx;\n    }\n\n    return ans;\n  }\n};\n", "1640": "class Solution {\n public:\n  bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {\n    vector<int> concatenated;\n    unordered_map<int, vector<int>> startToPiece;\n\n    for (const vector<int>& piece : pieces)\n      startToPiece[piece[0]] = piece;\n\n    for (const int a : arr)\n      if (startToPiece.contains(a))\n        for (const int num : startToPiece[a])\n          concatenated.push_back(num);\n\n    return concatenated == arr;\n  }\n};\n", "1641": "class Solution {\n public:\n  int countVowelStrings(int n) {\n    return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24;\n  }\n};\n", "1642": "class Solution {\n public:\n  int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    for (int i = 1; i < heights.size(); ++i) {\n      const int diff = heights[i] - heights[i - 1];\n      if (diff <= 0)\n        continue;\n      minHeap.push(diff);\n      // If we run out of ladders, greedily use as less bricks as possible.\n      if (minHeap.size() > ladders)\n        bricks -= minHeap.top(), minHeap.pop();\n      if (bricks < 0)\n        return i - 1;\n    }\n\n    return heights.size() - 1;\n  }\n};\n", "1643": "class Solution {\n public:\n  string kthSmallestPath(vector<int>& destination, int k) {\n    string ans;\n    int v = destination[0];\n    int h = destination[1];\n    const int totalSteps = v + h;\n    const vector<vector<int>> comb = getComb(totalSteps - 1, v);\n\n    for (int i = 0; i < totalSteps; ++i) {\n      // If 'H' is picked, we can reach ranks [1, availableRank].\n      const int availableRank = comb[h + v - 1][v];\n      if (availableRank >= k) {  // Should pick 'H'.\n        ans += 'H';\n        --h;\n      } else {  // Should pick 'V'.\n        k -= availableRank;\n        ans += 'V';\n        --v;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  vector<vector<int>> getComb(int n, int k) {\n    vector<vector<int>> comb(n + 1, vector<int>(k + 1));\n    for (int i = 0; i <= n; ++i)\n      comb[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= k; ++j)\n        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n    return comb;\n  }\n};\n", "1644": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    TreeNode* ans = getLCA(root, p, q);\n    if (ans == p)  // Search q in the subtree rooted at p.\n      return getLCA(p, q, q) == nullptr ? nullptr : ans;\n    if (ans == q)  // Search p in the subtree rooted at q.\n      return getLCA(q, p, p) == nullptr ? nullptr : ans;\n    return ans;  // (ans != p && ans != q) || ans == nullptr\n  }\n\n private:\n  TreeNode* getLCA(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == nullptr || root == p || root == q)\n      return root;\n    TreeNode* left = getLCA(root->left, p, q);\n    TreeNode* right = getLCA(root->right, p, q);\n    if (left != nullptr && right != nullptr)\n      return root;\n    return left == nullptr ? right : left;\n  }\n};\n", "1646": "class Solution {\n public:\n  int getMaximumGenerated(int n) {\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return 1;\n\n    vector<int> nums(n + 1);\n    nums[1] = 1;\n\n    for (int i = 1; (2 * i + 1) <= n; ++i) {\n      nums[2 * i] = nums[i];\n      nums[2 * i + 1] = nums[i] + nums[i + 1];\n    }\n\n    return ranges::max(nums);\n  }\n};\n", "1647": "class Solution {\n public:\n  int minDeletions(string s) {\n    int ans = 0;\n    vector<int> count(26);\n    unordered_set<int> usedFreq;\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int freq : count)\n      while (freq > 0 && !usedFreq.insert(freq).second) {\n        --freq;  // Delete ('a' + i).\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "1648": "class Solution {\n public:\n  int maxProfit(vector<int>& inventory, int orders) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    long largestCount = 1;\n\n    ranges::sort(inventory, greater<>());\n\n    for (int i = 0; i < inventory.size(); ++i, ++largestCount)\n      if (i == inventory.size() - 1 || inventory[i] > inventory[i + 1]) {\n        // If we are at the last inventory, or inventory[i] > inventory[i + 1].\n        // In either case, we will pick inventory[i - largestCount + 1..i].\n        const int pick = (i == inventory.size() - 1)\n                             ? inventory[i]\n                             : inventory[i] - inventory[i + 1];\n        if (largestCount * pick >= orders) {\n          // We have run out of orders, so we need to recalculate the number of\n          // balls that we actually pick for inventory[i - largestCount + 1..i].\n          const int actualPick = orders / largestCount;\n          const int remaining = orders % largestCount;\n          return (ans +\n                  largestCount *\n                      trapezoid(inventory[i], inventory[i] - actualPick + 1) +\n                  static_cast<long>(remaining) * (inventory[i] - actualPick)) %\n                 kMod;\n        }\n        ans += largestCount * trapezoid(inventory[i], inventory[i] - pick + 1);\n        ans %= kMod;\n        orders -= largestCount * pick;\n      }\n\n    throw;\n  }\n\n private:\n  long trapezoid(long a, long b) {\n    return (a + b) * (a - b + 1) / 2;\n  }\n};\n", "1649": "template <typename NodeType, typename ValueType>\nclass SegmentTree {\n public:\n  explicit SegmentTree(const int n, const NodeType& defaultNode)\n      : n(n), defaultNode(defaultNode), tree(4 * n) {}\n\n  // Adds nums[i] to val equivalently.\n  void add(int i, ValueType val) {\n    add(0, 0, n - 1, i, val);\n  }\n\n  // Returns the result of the range query from nums[i..j].\n  NodeType query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n protected:\n  // Merges the result of the left node and the right node.\n  virtual NodeType merge(const NodeType& a, const NodeType& b) const = 0;\n  virtual NodeType makeLeafNode(ValueType val) const = 0;\n\n private:\n  const int n;                 // the size of the input array\n  const NodeType defaultNode;  // default node value for non-overlapping queries\n  vector<NodeType> tree;       // the segment tree\n\n  void add(int treeIndex, int lo, int hi, int i, ValueType val) {\n    if (lo == hi) {\n      tree[treeIndex] += makeLeafNode(val);\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      add(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      add(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  NodeType query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return defaultNode;\n    const int mid = (lo + hi) / 2;\n    return merge(query(2 * treeIndex + 1, lo, mid, i, j),\n                 query(2 * treeIndex + 2, mid + 1, hi, i, j));\n  }\n};\n\nclass SumSegmentTree : public SegmentTree<int, int> {\n public:\n  explicit SumSegmentTree(int n) : SegmentTree(n, 0) {}\n\n protected:\n  int merge(const int& a, const int& b) const override {\n    return a + b;\n  }\n\n  int makeLeafNode(int val) const override {\n    return val;\n  }\n};\n\nclass Solution {\n public:\n  int createSortedArray(vector<int>& instructions) {\n    constexpr int kMod = 1'000'000'007;\n    const int mx = ranges::max(instructions);\n    int ans = 0;\n    SumSegmentTree tree(mx + 1);\n\n    for (const int i : instructions) {\n      ans += min(tree.query(0, i - 1), tree.query(i + 1, mx));\n      ans %= kMod;\n      tree.add(i, 1);\n    }\n\n    return ans;\n  }\n};\n", "165": "class Solution {\n public:\n  int compareVersion(string version1, string version2) {\n    istringstream iss1(version1);\n    istringstream iss2(version2);\n    int v1;\n    int v2;\n    char dotChar;\n\n    while (bool(iss1 >> v1) + bool(iss2 >> v2)) {\n      if (v1 < v2)\n        return -1;\n      if (v1 > v2)\n        return 1;\n      iss1 >> dotChar;\n      iss2 >> dotChar;\n      v1 = 0;\n      v2 = 0;\n    }\n\n    return 0;\n  };\n};\n", "1650": "class Solution {\n public:\n  // Same as 160. Intersection of Two Linked Lists\n  Node* lowestCommonAncestor(Node* p, Node* q) {\n    Node* a = p;\n    Node* b = q;\n\n    while (a != b) {\n      a = a == nullptr ? q : a->parent;\n      b = b == nullptr ? p : b->parent;\n    }\n\n    return a;\n  }\n};\n", "1652": "class Solution {\n public:\n  vector<int> decrypt(vector<int>& code, int k) {\n    const int n = code.size();\n    vector<int> ans(n);\n    if (k == 0)\n      return ans;\n\n    int sum = 0;\n    int start = k > 0 ? 1 : n + k;  // the start of the next k numbers\n    int end = k > 0 ? k : n - 1;    // the end of the next k numbers\n\n    for (int i = start; i <= end; ++i)\n      sum += code[i];\n\n    for (int i = 0; i < n; ++i) {\n      ans[i] = sum;\n      sum -= code[start++ % n];\n      sum += code[++end % n];\n    }\n\n    return ans;\n  }\n};\n", "1653": "class Solution {\n public:\n  // Same as 926. Flip String to Monotone Increasing\n  int minimumDeletions(string s) {\n    // the number of characters to be deleted to make the substring so far\n    // balanced\n    int dp = 0;\n    int countB = 0;\n\n    for (const char c : s)\n      if (c == 'a')\n        // 1. Delete 'a'.\n        // 2. Keep 'a' and delete the previous 'b's.\n        dp = min(dp + 1, countB);\n      else\n        ++countB;\n\n    return dp;\n  }\n};\n", "1654": "enum class Direction { kForward, kBackward };\n\nclass Solution {\n public:\n  int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n    int furthest = x + a + b;\n    unordered_set<int> seenForward;\n    unordered_set<int> seenBackward;\n\n    for (const int pos : forbidden) {\n      seenForward.insert(pos);\n      seenBackward.insert(pos);\n      furthest = max(furthest, pos + a + b);\n    }\n\n    // (direction, position)\n    queue<pair<Direction, int>> q{{{Direction::kForward, 0}}};\n\n    for (int ans = 0; !q.empty(); ++ans)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [dir, pos] = q.front();\n        q.pop();\n        if (pos == x)\n          return ans;\n        const int forward = pos + a;\n        const int backward = pos - b;\n        if (forward <= furthest && seenForward.insert(forward).second)\n          q.emplace(Direction::kForward, forward);\n        // It cannot jump backward twice in a row.\n        if (dir == Direction::kForward && backward >= 0 &&\n            seenBackward.insert(backward).second)\n          q.emplace(Direction::kBackward, backward);\n      }\n\n    return -1;\n  }\n};\n", "1655": "class Solution {\n public:\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\n    // validDistribution[i][j] := true if it's possible to distribute the i-th\n    // freq into a subset of quantity represented by the bitmask j\n    const vector<int> freqs = getFreqs(nums);\n    const vector<vector<bool>> validDistribution =\n        getValidDistribuition(freqs, quantity);\n    const int n = freqs.size();\n    const int m = quantity.size();\n    const int maxMask = 1 << m;\n    // dp[i][j] := true if it's possible to distribute freqs[i..n), where j is\n    // the bitmask of the selected quantity\n    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));\n    dp[n][maxMask - 1] = true;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int mask = 0; mask < maxMask; ++mask) {\n        dp[i][mask] = dp[i + 1][mask];\n        const int availableMask = ~mask & (maxMask - 1);\n        for (int submask = availableMask; submask > 0;\n             submask = (submask - 1) & availableMask)\n          if (validDistribution[i][submask])\n            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];\n      }\n\n    return dp[0][0];\n  }\n\n private:\n  vector<int> getFreqs(const vector<int>& nums) {\n    vector<int> freqs;\n    unordered_map<int, int> count;\n    for (const int num : nums)\n      ++count[num];\n    for (const auto& [_, freq] : count)\n      freqs.push_back(freq);\n    return freqs;\n  }\n\n  vector<vector<bool>> getValidDistribuition(const vector<int>& freqs,\n                                             const vector<int>& quantity) {\n    const int maxMask = 1 << quantity.size();\n    vector<vector<bool>> validDistribution(freqs.size(), vector<bool>(maxMask));\n    for (int i = 0; i < freqs.size(); ++i)\n      for (int mask = 0; mask < maxMask; ++mask)\n        if (freqs[i] >= getQuantitySum(quantity, mask))\n          validDistribution[i][mask] = true;\n    return validDistribution;\n  }\n\n  // Returns the sum of the selected quantity represented by `mask`.\n  int getQuantitySum(const vector<int>& quantity, int mask) {\n    int sum = 0;\n    for (int i = 0; i < quantity.size(); ++i)\n      if (mask >> i & 1)\n        sum += quantity[i];\n    return sum;\n  }\n};\n", "1656": "class OrderedStream {\n public:\n  OrderedStream(int n) : values(n) {}\n\n  vector<string> insert(int idKey, string value) {\n    --idKey;  // Converts to 0-indexed.\n    values[idKey] = value;\n    if (idKey > i)\n      return {};\n    while (i < values.size() && !values[i].empty())\n      ++i;\n    return vector<string>{values.begin() + idKey, values.begin() + i};\n  }\n\n private:\n  vector<string> values;\n  int i = 0;  // values' index (0-indexed)\n};\n", "1657": "class Solution {\n public:\n  bool closeStrings(string word1, string word2) {\n    if (word1.length() != word2.length())\n      return false;\n\n    unordered_map<char, int> count1;\n    unordered_map<char, int> count2;\n    string s1;           // Unique chars in word1\n    string s2;           // Unique chars in word2\n    vector<int> freqs1;  // Freqs of unique chars in word1\n    vector<int> freqs2;  // Freqs of unique chars in word2\n\n    for (const char c : word1)\n      ++count1[c];\n\n    for (const char c : word2)\n      ++count2[c];\n\n    for (const auto& [c, freq] : count1) {\n      s1 += c;\n      freqs1.push_back(freq);\n    }\n\n    for (const auto& [c, freq] : count2) {\n      s2 += c;\n      freqs2.push_back(freq);\n    }\n\n    ranges::sort(s1);\n    ranges::sort(s2);\n\n    if (s1 != s2)\n      return false;\n\n    ranges::sort(freqs1);\n    ranges::sort(freqs2);\n    return freqs1 == freqs2;\n  }\n};\n", "1658": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int x) {\n    const int targetSum = accumulate(nums.begin(), nums.end(), 0) - x;\n    if (targetSum == 0)\n      return nums.size();\n    const int maxLen = maxSubArrayLen(nums, targetSum);\n    return maxLen == -1 ? -1 : nums.size() - maxLen;\n  }\n\n private:\n  // Same as 325. Maximum Size Subarray Sum Equals k\n  int maxSubArrayLen(vector<int>& nums, int k) {\n    int res = -1;\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      const int target = prefix - k;\n      if (const auto it = prefixToIndex.find(target);\n          it != prefixToIndex.cend())\n        res = max(res, i - it->second);\n      // No need to check the existence of the prefix since it's unique.\n      prefixToIndex[prefix] = i;\n    }\n\n    return res;\n  }\n};\n", "1659": "class Solution {\n public:\n  int getMaxGridHappiness(int m, int n, int introvertsCount,\n                          int extrovertsCount) {\n    const int twoToThePowerOfN = pow(2, n);\n    vector<vector<vector<vector<vector<int>>>>> mem(\n        m * n, vector<vector<vector<vector<int>>>>(\n                   twoToThePowerOfN,\n                   vector<vector<vector<int>>>(\n                       twoToThePowerOfN,\n                       vector<vector<int>>(introvertsCount + 1,\n                                           vector<int>(extrovertsCount + 1)))));\n    return getMaxGridHappiness(m, n, 0, 0, 0, introvertsCount, extrovertsCount,\n                               mem);\n  }\n\n private:\n  // Calculates the cost based on left and up neighbors.\n  //\n  // The `diff` parameter represents the happiness change due to the current\n  // placed person in (i, j). We add `diff` each time we encounter a neighbor\n  // (left or up) who is already placed.\n  //\n  // 1. If the neighbor is an introvert, we subtract 30 from cost.\n  // 2. If the neighbor is an extrovert, we add 20 to from cost.\n  int getPlacementCost(int n, int i, int j, int inMask, int exMask, int diff) {\n    int cost = 0;\n    if (i > 0) {\n      if ((1 << (n - 1)) & inMask)\n        cost += diff - 30;\n      if ((1 << (n - 1)) & exMask)\n        cost += diff + 20;\n    }\n    if (j > 0) {\n      if (1 & inMask)\n        cost += diff - 30;\n      if (1 & exMask)\n        cost += diff + 20;\n    }\n    return cost;\n  }\n\n  int getMaxGridHappiness(int m, int n, int pos, int inMask, int exMask,\n                          int inCount, int exCount,\n                          vector<vector<vector<vector<vector<int>>>>>& mem) {\n    // `inMask` is the placement of introvert people in the last n cells.\n    // e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means\n    //\n    // ? 1 0\n    // 1 x ? (x := current position)\n    const int i = pos / n;\n    const int j = pos % n;\n    if (i == m)\n      return 0;\n    if (mem[pos][inMask][exMask][inCount][exCount] > 0)\n      return mem[pos][inMask][exMask][inCount][exCount];\n\n    const int shiftedInMask = (inMask << 1) & ((1 << n) - 1);\n    const int shiftedExMask = (exMask << 1) & ((1 << n) - 1);\n\n    const int skip = getMaxGridHappiness(m, n, pos + 1, shiftedInMask,\n                                         shiftedExMask, inCount, exCount, mem);\n    const int placeIntrovert =\n        inCount > 0\n            ? 120 + getPlacementCost(n, i, j, inMask, exMask, -30) +\n                  getMaxGridHappiness(m, n, pos + 1, shiftedInMask | 1,\n                                      shiftedExMask, inCount - 1, exCount, mem)\n            : INT_MIN;\n    const int placeExtrovert =\n        exCount > 0 ? 40 + getPlacementCost(n, i, j, inMask, exMask, 20) +\n                          getMaxGridHappiness(m, n, pos + 1, shiftedInMask,\n                                              shiftedExMask | 1, inCount,\n                                              exCount - 1, mem)\n                    : INT_MIN;\n    return mem[pos][inMask][exMask][inCount][exCount] =\n               max({skip, placeIntrovert, placeExtrovert});\n  }\n};\n", "166": "class Solution {\n public:\n  string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0)\n      return \"0\";\n\n    string ans;\n\n    if (numerator < 0 ^ denominator < 0)\n      ans += \"-\";\n\n    long n = labs(numerator);\n    long d = labs(denominator);\n    ans += to_string(n / d);\n\n    if (n % d == 0)\n      return ans;\n\n    ans += '.';\n    unordered_map<int, int> seen;\n\n    for (long r = n % d; r; r %= d) {\n      if (const auto it = seen.find(r); it != seen.cend()) {\n        ans.insert(it->second, 1, '(');\n        ans += ')';\n        break;\n      }\n      seen[r] = ans.size();\n      r *= 10;\n      ans += to_string(r / d);\n    }\n\n    return ans;\n  }\n};\n", "1660": "class Solution {\n public:\n  TreeNode* correctBinaryTree(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->right != nullptr && seen.contains(root->right->val))\n      return nullptr;\n    seen.insert(root->val);\n    root->right = correctBinaryTree(root->right);\n    root->left = correctBinaryTree(root->left);\n    return root;\n  }\n\n private:\n  unordered_set<int> seen;\n};\n", "1662": "class Solution {\n public:\n  bool arrayStringsAreEqual(std::vector<std::string>& word1,\n                            std::vector<std::string>& word2) {\n    int i = 0;  // word1's index\n    int j = 0;  // word2's index\n    int a = 0;  // word1[i]'s index\n    int b = 0;  // word2[j]'s index\n\n    while (i < word1.size() && j < word2.size()) {\n      if (word1[i][a] != word2[j][b])\n        return false;\n      if (++a == word1[i].size()) {\n        ++i;\n        a = 0;\n      }\n      if (++b == word2[j].size()) {\n        ++j;\n        b = 0;\n      }\n    }\n\n    return i == word1.size() && j == word2.size();\n  }\n};\n", "1663": "class Solution {\n public:\n  string getSmallestString(int n, int k) {\n    string ans;\n\n    for (int i = 0; i < n; ++i) {\n      const int remainingLetters = n - 1 - i;\n      const int rank = max(1, k - remainingLetters * 26);\n      ans += 'a' + rank - 1;\n      k -= rank;\n    }\n\n    return ans;\n  }\n};\n", "1664": "class Solution {\n public:\n  int waysToMakeFair(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // l[0] := the sum of even-indexed nums[0..i)\n    // l[1] := the sum of odd-indexed nums[0..i)\n    // r[0] := the sum of even-indexed nums[i + 1..n)\n    // r[1] := the sum of odd-indexed nums[i + 1..n)\n    vector<int> l(2);\n    vector<int> r(2);\n\n    for (int i = 0; i < n; ++i)\n      r[i % 2] += nums[i];\n\n    for (int i = 0; i < n; ++i) {\n      r[i % 2] -= nums[i];\n      if (l[0] + r[1] == l[1] + r[0])\n        ++ans;\n      l[i % 2] += nums[i];\n    }\n\n    return ans;\n  }\n};\n", "1665": "class Solution {\n public:\n  int minimumEffort(vector<vector<int>>& tasks) {\n    int ans = 0;\n    int prevSaved = 0;\n\n    ranges::sort(tasks, ranges::greater{},\n                 [](const vector<int>& task) { return task[1] - task[0]; });\n\n    for (const vector<int>& task : tasks) {\n      const int actual = task[0];\n      const int minimum = task[1];\n      if (prevSaved < minimum) {\n        ans += minimum - prevSaved;\n        prevSaved = minimum - actual;\n      } else {\n        prevSaved -= actual;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1666": "class Solution {\n public:\n  Node* flipBinaryTree(Node* root, Node* leaf) {\n    return reroot(root, leaf, nullptr);\n  }\n\n private:\n  Node* reroot(Node* root, Node* node, Node* newParent) {\n    Node* oldParent = node->parent;\n    node->parent = newParent;\n\n    // Clean up the child if it's the new parent.\n    if (node->left == newParent)\n      node->left = nullptr;\n    if (node->right == newParent)\n      node->right = nullptr;\n\n    // We meet the original root, so we're done.\n    if (node == root)\n      return node;\n\n    if (node->left)\n      node->right = node->left;\n    node->left = reroot(root, oldParent, node);\n\n    return node;\n  }\n};\n", "1668": "class Solution {\n public:\n  int maxRepeating(string sequence, string word) {\n    int ans = 1;\n    string repeating = word;\n    while (sequence.find(repeating) != string::npos) {\n      ++ans;\n      repeating += word;\n    }\n    return ans - 1;\n  }\n};\n", "1669": "class Solution {\n public:\n  ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\n    ListNode* nodeBeforeA = list1;\n    for (int i = 0; i < a - 1; ++i)\n      nodeBeforeA = nodeBeforeA->next;\n\n    ListNode* nodeB = nodeBeforeA->next;\n    for (int i = 0; i < b - a; ++i)\n      nodeB = nodeB->next;\n\n    nodeBeforeA->next = list2;\n    ListNode* lastNodeInList2 = list2;\n\n    while (lastNodeInList2->next != nullptr)\n      lastNodeInList2 = lastNodeInList2->next;\n\n    lastNodeInList2->next = nodeB->next;\n    nodeB->next = nullptr;\n    return list1;\n  }\n};\n", "167": "class Solution {\n public:\n  vector<int> twoSum(vector<int>& numbers, int target) {\n    int l = 0;\n    int r = numbers.size() - 1;\n\n    while (numbers[l] + numbers[r] != target)\n      if (numbers[l] + numbers[r] < target)\n        ++l;\n      else\n        --r;\n\n    return {l + 1, r + 1};\n  }\n};\n", "1670": "class FrontMiddleBackQueue {\n public:\n  void pushFront(int val) {\n    frontQueue.push_front(val);\n    moveFrontToBackIfNeeded();\n  }\n\n  void pushMiddle(int val) {\n    if (| frontQueue | == | backQueue |)\n      backQueue.push_front(val);\n    else\n      frontQueue.push_back(val);\n  }\n\n  void pushBack(int val) {\n    backQueue.push_back(val);\n    moveBackToFrontIfNeeded();\n  }\n\n  int popFront() {\n    if (!frontQueue.empty()) {\n      const int x = frontQueue.front();\n      frontQueue.pop_front();\n      moveBackToFrontIfNeeded();\n      return x;\n    }\n    if (!backQueue.empty()) {\n      const int x = backQueue.front();\n      backQueue.pop_front();\n      moveFrontToBackIfNeeded();\n      return x;\n    }\n    return -1;\n  }\n\n  int popMiddle() {\n    if (frontQueue.empty() && backQueue.empty())\n      return -1;\n    if (frontQueue.size() + 1 == backQueue.size()) {\n      const int x = backQueue.front();\n      backQueue.pop_front();\n      return x;\n    } else {  // |frontQueue| == |backQueue|\n      const int x = frontQueue.back();\n      frontQueue.pop_back();\n      return x;\n    }\n  }\n\n  int popBack() {\n    if (backQueue.empty())\n      return -1;\n    const int x = backQueue.back();\n    backQueue.pop_back();\n    moveFrontToBackIfNeeded();\n    return x;\n  }\n\n private:\n  // |frontQueue| = |backQueue| or\n  // |frontQueue| = |backQueue| - 1\n  deque<int> frontQueue;\n  deque<int> backQueue;\n\n  void moveFrontToBackIfNeeded() {\n    if (frontQueue.size() - 1 == backQueue.size()) {\n      const int x = frontQueue.back();\n      frontQueue.pop_back();\n      backQueue.push_front(x);\n    }\n  }\n\n  void moveBackToFrontIfNeeded() {\n    if (frontQueue.size() + 2 == backQueue.size()) {\n      const int x = backQueue.front();\n      backQueue.pop_front();\n      frontQueue.push_back(x);\n    }\n  }\n};\n", "1671": "class Solution {\n public:\n  int minimumMountainRemovals(vector<int>& nums) {\n    const vector<int> l = lengthOfLIS(nums);\n    const vector<int> r = reversed(lengthOfLIS(reversed(nums)));\n    int maxMountainSeq = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (l[i] > 1 && r[i] > 1)\n        maxMountainSeq = max(maxMountainSeq, l[i] + r[i] - 1);\n\n    return nums.size() - maxMountainSeq;\n  }\n\n private:\n  // Similar to 300. Longest Increasing Subsequence\n  vector<int> lengthOfLIS(vector<int> nums) {\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n    // dp[i] := the length of LIS ending in nums[i]\n    vector<int> dp;\n    for (const int num : nums) {\n      if (tails.empty() || num > tails.back())\n        tails.push_back(num);\n      else\n        tails[firstGreaterEqual(tails, num)] = num;\n      dp.push_back(tails.size());\n    }\n    return dp;\n  }\n\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n\n  vector<int> reversed(const vector<int>& nums) {\n    return {nums.rbegin(), nums.rend()};\n  }\n};\n", "1672": "class Solution {\n public:\n  int maximumWealth(vector<vector<int>>& accounts) {\n    return accumulate(accounts.begin(), accounts.end(), 0,\n                      [](int acc, const vector<int>& account) {\n      return max(acc, accumulate(account.begin(), account.end(), 0));\n    });\n  }\n};\n", "1673": "class Solution {\n public:\n  vector<int> mostCompetitive(vector<int>& nums, int k) {\n    vector<int> ans;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      // If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough\n      // numbers, and we can safely pop an element from ans.\n      while (!ans.empty() && ans.back() > nums[i] &&\n             ans.size() - 1 + nums.size() - i >= k)\n        ans.pop_back();\n      if (ans.size() < k)\n        ans.push_back(nums[i]);\n    }\n\n    return ans;\n  }\n};\n", "1674": "class Solution {\n public:\n  int minMoves(vector<int>& nums, int limit) {\n    const int n = nums.size();\n    int ans = n;\n    // delta[i] := the number of moves needed when target goes from i - 1 to i\n    vector<int> delta(limit * 2 + 2);\n\n    for (int i = 0; i < n / 2; ++i) {\n      const int a = nums[i];\n      const int b = nums[n - 1 - i];\n      --delta[min(a, b) + 1];\n      --delta[a + b];\n      ++delta[a + b + 1];\n      ++delta[max(a, b) + limit + 1];\n    }\n\n    // Initially, we need `moves` when the target is 2.\n    for (int i = 2, moves = n; i <= limit * 2; ++i) {\n      moves += delta[i];\n      ans = min(ans, moves);\n    }\n\n    return ans;\n  }\n};\n", "1675": "class Solution {\n public:\n  int minimumDeviation(vector<int>& nums) {\n    int ans = INT_MAX;\n    int mn = INT_MAX;\n    priority_queue<int> maxHeap;\n\n    for (const int num : nums) {\n      const int evenNum = num % 2 == 0 ? num : num * 2;\n      mn = min(mn, evenNum);\n      maxHeap.push(evenNum);\n    }\n\n    while (maxHeap.top() % 2 == 0) {\n      const int mx = maxHeap.top();\n      maxHeap.pop();\n      ans = min(ans, mx - mn);\n      mn = min(mn, mx / 2);\n      maxHeap.push(mx / 2);\n    }\n\n    return min(ans, maxHeap.top() - mn);\n  }\n};\n", "1676": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {\n    unordered_set<TreeNode*> nodesSet{nodes.begin(), nodes.end()};\n    return lca(root, nodesSet);\n  }\n\n private:\n  TreeNode* lca(TreeNode* root, unordered_set<TreeNode*>& nodesSet) {\n    if (root == nullptr)\n      return nullptr;\n    if (nodesSet.contains(root))\n      return root;\n    TreeNode* left = lca(root->left, nodesSet);\n    TreeNode* right = lca(root->right, nodesSet);\n    if (left != nullptr && right != nullptr)\n      return root;\n    return left == nullptr ? right : left;\n  }\n};\n", "1678": "class Solution {\n public:\n  string interpret(string command) {\n    string ans;\n    for (int i = 0; i < command.size();)\n      if (command[i] == 'G') {\n        ans += \"G\";\n        ++i;\n      } else if (command[i + 1] == ')') {\n        ans += \"o\";\n        i += 2;\n      } else {\n        ans += \"al\";\n        i += 4;\n      }\n    return ans;\n  }\n};\n", "1679": "class Solution {\n public:\n  int maxOperations(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count)\n      if (const auto it = count.find(k - num); it != count.end())\n        ans += min(freq, it->second);\n\n    return ans / 2;\n  }\n};\n", "168": "class Solution {\n public:\n  string convertToTitle(int n) {\n    return n == 0 ? \"\"\n                  : convertToTitle((n - 1) / 26) + (char)('A' + ((n - 1) % 26));\n  }\n};\n", "1680": "class Solution {\n public:\n  int concatenatedBinary(int n) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    int numberOfBits = 0;\n\n    for (unsigned i = 1; i <= n; ++i) {\n      if (popcount(i) == 1)\n        ++numberOfBits;\n      ans = ((ans << numberOfBits) % kMod + i) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "1681": "class Solution {\n public:\n  int minimumIncompatibility(vector<int>& nums, int k) {\n    constexpr int kMaxCompatibility = (16 - 1) * (16 / 2);\n    const int n = nums.size();\n    const int subsetSize = n / k;\n    const int maxMask = 1 << n;\n    const vector<int> incompatibilities =\n        getIncompatibilities(nums, subsetSize);\n    // dp[i] := the minimum possible sum of incompatibilities of the subset\n    // of numbers represented by the bitmask i\n    vector<int> dp(maxMask, kMaxCompatibility);\n    dp[0] = 0;\n\n    for (unsigned mask = 1; mask < maxMask; ++mask) {\n      // The number of 1s in `mask` isn't a multiple of `subsetSize`.\n      if (popcount(mask) % subsetSize != 0)\n        continue;\n      // https://cp-algorithms.com/algebra/all-submasks.html\n      for (int submask = mask; submask > 0; submask = (submask - 1) & mask)\n        if (incompatibilities[submask] != -1)  // valid subset\n          dp[mask] =\n              min(dp[mask], dp[mask - submask] + incompatibilities[submask]);\n    }\n\n    return dp.back() == kMaxCompatibility ? -1 : dp.back();\n  }\n\n private:\n  static constexpr int kMaxNum = 16;\n\n  // Returns an incompatibilities array where\n  // * incompatibilities[i] := the incompatibility of the subset of numbers\n  //   represented by the bitmask i\n  // * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not\n  //   `subsetSize`\n  vector<int> getIncompatibilities(const vector<int>& nums, int subsetSize) {\n    const int maxMask = 1 << nums.size();\n    vector<int> incompatibilities(maxMask, -1);\n    for (unsigned mask = 0; mask < maxMask; ++mask)\n      if (popcount(mask) == subsetSize && isUnique(nums, mask, subsetSize))\n        incompatibilities[mask] = getIncompatibility(nums, mask);\n    return incompatibilities;\n  }\n\n  // Returns true if the numbers selected by `mask` are unique.\n  //\n  // e.g. If we call isUnique(0b1010, 2, [1, 2, 1, 4]), `used` variable\n  // will be 0b1, which only has one 1 (less than `subsetSize`). In this case,\n  // we should return false.\n  bool isUnique(const vector<int>& nums, int mask, int subsetSize) {\n    unsigned used = 0;\n    for (int i = 0; i < nums.size(); ++i)\n      if (mask >> i & 1)\n        used |= 1 << nums[i];\n    return popcount(used) == subsetSize;\n  }\n\n  // Returns the incompatibility of the selected numbers represented by the\n  // `mask`.\n  int getIncompatibility(const vector<int>& nums, int mask) {\n    int mn = kMaxNum;\n    int mx = 0;\n    for (int i = 0; i < nums.size(); ++i)\n      if (mask >> i & 1) {\n        mx = max(mx, nums[i]);\n        mn = min(mn, nums[i]);\n      }\n    return mx - mn;\n  }\n};\n", "1682": "class Solution {\n public:\n  int longestPalindromeSubseq(string s) {\n    const int n = s.length();\n    // dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is\n    // ('a' + k).\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(27)));\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i)\n        for (int k = 0; k <= 26; ++k) {\n          const int j = i + d;\n          if (s[i] == s[j] && s[i] != 'a' + k)\n            dp[i][j][k] = dp[i + 1][j - 1][s[i] - 'a'] + 2;\n          else\n            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k]);\n        }\n\n    return dp[0][n - 1][26];\n  }\n};\n", "1684": "class Solution {\n public:\n  int countConsistentStrings(string allowed, vector<string>& words) {\n    return accumulate(words.begin(), words.end(), 0,\n                      [&allowed](int acc, const string& word) {\n      return acc + ranges::all_of(word, [&allowed](char c) {\n        return allowed.find(c) != string::npos;\n      });\n    });\n  }\n};\n", "1685": "class Solution {\n public:\n  vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans;\n    // prefix[i] := sum(nums[0..i])\n    vector<int> prefix(n);\n    // suffix[i] := sum(nums[i..n - 1])\n    vector<int> suffix(n);\n\n    prefix[0] = nums[0];\n    for (int i = 1; i < n; ++i)\n      prefix[i] = prefix[i - 1] + nums[i];\n\n    suffix[n - 1] = nums[n - 1];\n    for (int i = n - 2; i >= 0; --i)\n      suffix[i] = suffix[i + 1] + nums[i];\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int left = nums[i] * (i + 1) - prefix[i];\n      const int right = suffix[i] - nums[i] * (n - i);\n      ans.push_back(left + right);\n    }\n\n    return ans;\n  }\n};\n", "1686": "class Solution {\n public:\n  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n    const int n = aliceValues.size();\n    vector<vector<int>> values;\n    int a = 0;\n    int b = 0;\n\n    for (int i = 0; i < n; ++i)\n      values.push_back({aliceValues[i], bobValues[i]});\n\n    ranges::sort(values, ranges::greater{},\n                 [](const vector<int>& value) { return value[0] + value[1]; });\n\n    for (int i = 0; i < n; ++i)\n      if (i % 2 == 0)\n        a += values[i][0];\n      else\n        b += values[i][1];\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n};\n", "1687": "class Solution {\n public:\n  int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes,\n                    int maxWeight) {\n    const int n = boxes.size();\n    // dp[i] := the minimum trips to deliver boxes[0..i) and return to the\n    // storage\n    vector<int> dp(n + 1);\n    int trips = 2;\n    int weight = 0;\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      weight += boxes[r][1];\n\n      // The current box is different from the previous one, need to make one\n      // more trip.\n      if (r > 0 && boxes[r][0] != boxes[r - 1][0])\n        ++trips;\n\n      while (r - l + 1 > maxBoxes || weight > maxWeight ||\n             // Loading boxes[l] in the previous turn is always no bad than\n             // loading it in this turn.\n             (l < r && dp[l + 1] == dp[l])) {\n        weight -= boxes[l][1];\n        if (boxes[l][0] != boxes[l + 1][0])\n          --trips;\n        ++l;\n      }\n\n      //   min trips to deliver boxes[0..r]\n      // = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]\n      dp[r + 1] = dp[l] + trips;\n    }\n\n    return dp[n];\n  }\n};\n", "1688": "class Solution {\n public:\n  int numberOfMatches(int n) {\n    return n - 1;\n  }\n};\n", "1689": "class Solution {\n public:\n  int minPartitions(string n) {\n    return ranges::max(n) - '0';\n  }\n};\n", "169": "class Solution {\n public:\n  int majorityElement(vector<int>& nums) {\n    int ans;\n    int count = 0;\n\n    for (const int num : nums) {\n      if (count == 0)\n        ans = num;\n      count += num == ans ? 1 : -1;\n    }\n\n    return ans;\n  }\n};\n", "1690": "class Solution {\n public:\n  int stoneGameVII(vector<int>& stones) {\n    const int n = stones.size();\n    // dp[i][j] := the maximum score you can get more than your opponent in\n    // stones[i..j]\n    vector<vector<int>> dp(n, vector<int>(n));\n    vector<int> prefix(n + 1);\n\n    partial_sum(stones.begin(), stones.end(), prefix.begin() + 1);\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        dp[i][j] = max(prefix[j + 1] - prefix[i + 1] - dp[i + 1][j],\n                       prefix[j] - prefix[i] - dp[i][j - 1]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "1691": "class Solution {\n public:\n  int maxHeight(vector<vector<int>>& cuboids) {\n    // For each cuboid, sort it so that c[0] <= c[1] <= c[2].\n    for (vector<int>& cuboid : cuboids)\n      ranges::sort(cuboid);\n\n    ranges::sort(cuboids);\n\n    // dp[i] := the maximum height with cuboids[i] in the bottom\n    vector<int> dp(cuboids.size());\n\n    for (int i = 0; i < cuboids.size(); ++i)\n      dp[i] = cuboids[i][2];\n\n    for (int i = 1; i < cuboids.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        if (cuboids[j][0] <= cuboids[i][0] &&  //\n            cuboids[j][1] <= cuboids[i][1] &&  //\n            cuboids[j][2] <= cuboids[i][2])\n          dp[i] = max(dp[i], dp[j] + cuboids[i][2]);\n\n    return ranges::max(dp);\n  }\n};\n", "1692": "class Solution {\n public:\n  int waysToDistribute(int n, int k) {\n    constexpr int kMod = 1'000'000'007;\n    vector<vector<long>> dp(k + 1, vector<long>(n + 1));\n\n    for (int i = 0; i <= k; ++i)\n      dp[i][i] = 1;\n\n    for (int i = 1; i <= k; ++i)\n      for (int j = i + 1; j <= n; ++j)\n        dp[i][j] = (dp[i - 1][j - 1] + i * dp[i][j - 1]) % kMod;\n\n    return dp[k][n];\n  }\n};\n", "1694": "class Solution {\n public:\n  string reformatNumber(string number) {\n    string ans;\n\n    std::erase(number, '-');\n    std::erase(number, ' ');\n\n    int i = 0;  // number's index\n    for (i = 0; i + 4 < number.length(); i += 3)\n      ans += number.substr(i, 3) + '-';\n\n    const int countFinalDigits = number.length() - i;\n    if (countFinalDigits < 4)\n      ans += number.substr(i);\n    else  // countFinalDigits == 4\n      ans += number.substr(i, 2) + '-' + number.substr(i + 2);\n\n    return ans;\n  }\n};\n", "1695": "class Solution {\n public:\n  int maximumUniqueSubarray(vector<int>& nums) {\n    int ans = 0;\n    int score = 0;\n    unordered_set<int> seen;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      while (!seen.insert(nums[r]).second) {\n        score -= nums[l];\n        seen.erase(nums[l++]);\n      }\n      score += nums[r];\n      ans = max(ans, score);\n    }\n\n    return ans;\n  }\n};\n", "1696": "class Solution {\n public:\n  int maxResult(vector<int>& nums, int k) {\n    // Stores dp[i] within the bounds.\n    deque<int> maxQ{0};\n    // dp[i] := the maximum score to consider nums[0..i]\n    vector<int> dp(nums.size());\n    dp[0] = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i) {\n      // Pop the index if it's out-of-bounds.\n      if (maxQ.front() + k < i)\n        maxQ.pop_front();\n      dp[i] = dp[maxQ.front()] + nums[i];\n      // Pop indices that won't be chosen in the future.\n      while (!maxQ.empty() && dp[maxQ.back()] <= dp[i])\n        maxQ.pop_back();\n      maxQ.push_back(i);\n    }\n\n    return dp.back();\n  }\n};\n", "1697": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,\n                                         vector<vector<int>>& queries) {\n    vector<bool> ans(queries.size());\n    UnionFind uf(n);\n\n    for (int i = 0; i < queries.size(); ++i)\n      queries[i].push_back(i);\n\n    ranges::sort(queries, ranges::less{},\n                 [](const vector<int>& query) { return query[2]; });\n    ranges::sort(edgeList, ranges::less{},\n                 [](const vector<int>& edge) { return edge[2]; });\n\n    int i = 0;  // i := edgeList's index\n    for (const vector<int>& query : queries) {\n      const int p = query[0];\n      const int q = query[1];\n      const int limit = query[2];\n      // Union edges whose distances < limit.\n      while (i < edgeList.size() && edgeList[i][2] < limit)\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\n      if (uf.find(p) == uf.find(q))\n        ans[query.back()] = true;\n    }\n\n    return ans;\n  }\n};\n", "1698": "class Solution {\n public:\n  int countDistinct(string s) {\n    const int n = s.length();\n    int ans = 0;\n    vector<long> pow(n + 1);     // pow[i] := kBase^i\n    vector<long> hashes(n + 1);  // hashes[i] := the hash of s[0..i)\n\n    pow[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      pow[i] = pow[i - 1] * kBase % kHash;\n      hashes[i] = (hashes[i - 1] * kBase + val(s[i - 1])) % kHash;\n    }\n\n    for (int length = 1; length <= n; ++length) {\n      unordered_set<int> seen;\n      for (int i = 0; i + length <= n; ++i)\n        seen.insert(getHash(i, i + length, hashes, pow));\n      ans += seen.size();\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kBase = 26;\n  static constexpr int kHash = 1'000'000'007;\n\n  static constexpr int val(char c) {\n    return c - 'a';\n  }\n\n  // Returns the hash of s[l..r).\n  long getHash(int l, int r, const vector<long>& hashes,\n               const vector<long>& pow) {\n    const long hash = (hashes[r] - hashes[l] * pow[r - l]) % kHash;\n    return hash < 0 ? hash + kHash : hash;\n  }\n};\n", "17": "class Solution {\n public:\n  vector<string> letterCombinations(string digits) {\n    if (digits.empty())\n      return {};\n\n    vector<string> ans{\"\"};\n    const vector<string> digitToLetters{\"\",    \"\",    \"abc\",  \"def\", \"ghi\",\n                                        \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    for (const char d : digits) {\n      vector<string> temp;\n      for (const string& s : ans)\n        for (const char c : digitToLetters[d - '0'])\n          temp.push_back(s + c);\n      ans = std::move(temp);\n    }\n\n    return ans;\n  }\n};\n", "170": "class TwoSum {\n public:\n  void add(int number) {\n    ++count[number];\n  }\n\n  bool find(int value) {\n    for (const auto& [key, freq] : count) {\n      const int remain = value - key;\n      if (key == remain && freq > 1)\n        return true;\n      if (key != remain && count.contains(remain))\n        return true;\n    }\n\n    return false;\n  }\n\n private:\n  unordered_map<int, int> count;\n};\n", "1700": "class Solution {\n public:\n  int countStudents(vector<int>& students, vector<int>& sandwiches) {\n    vector<int> count(2);\n\n    for (const int student : students)\n      ++count[student];\n\n    for (int i = 0; i < sandwiches.size(); ++i) {\n      if (count[sandwiches[i]] == 0)\n        return sandwiches.size() - i;\n      --count[sandwiches[i]];\n    }\n\n    return 0;\n  }\n};\n", "1701": "class Solution {\n public:\n  double averageWaitingTime(vector<vector<int>>& customers) {\n    double wait = 0;\n    double curr = 0;\n\n    for (const vector<int>& c : customers) {\n      curr = max(curr, 1.0 * c[0]) + c[1];\n      wait += curr - c[0];\n    }\n\n    return 1.0 * wait / customers.size();\n  }\n};\n", "1702": "class Solution {\n public:\n  string maximumBinaryString(string binary) {\n    //     e.g. binary = \"100110\"\n    // Do Operation 2 -> \"100011\"\n    // Do Operation 1 -> \"111011\"\n    // So, the index of the only '0' is prefixOnes + zeros - 1.\n    const int zeros = ranges::count(binary, '0');\n    const int prefixOnes = binary.find('0');\n\n    // Make the entire string as 1s.\n    binary.assign(binary.length(), '1');\n\n    // Make the only '0' if necessary.\n    if (prefixOnes != string::npos)\n      binary[prefixOnes + zeros - 1] = '0';\n    return binary;\n  }\n};\n", "1703": "class Solution {\n public:\n  int minMoves(vector<int>& nums, int k) {\n    vector<int> ones;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == 1)\n        ones.push_back(i);\n\n    // Returns the median index of [i..i + k).\n    auto getMedIndex = [&](int i) { return (i + (i + k - 1)) / 2; };\n\n    // Calculate the first group: window[0] = A[0..k).\n    const int median = ones[getMedIndex(0)];\n    int moves = 0;\n    for (int i = 0; i < k; ++i)\n      moves += abs(ones[i] - median);\n\n    int ans = moves;\n\n    for (int i = 1; i <= ones.size() - k; ++i) {\n      const int oldMedianIndex = ones[getMedIndex(i - 1)];\n      const int newMedianIndex = ones[getMedIndex(i)];\n      if (k % 2 == 1)\n        moves += newMedianIndex - oldMedianIndex;\n      moves -= newMedianIndex - ones[i - 1];\n      moves += ones[i + k - 1] - newMedianIndex;\n      ans = min(ans, moves);\n    }\n\n    auto nThSum = [&](int n) { return n * (n + 1) / 2; };\n    return ans - nThSum((k - 1) / 2) - nThSum(k / 2);\n  }\n};\n", "1704": "class Solution {\n public:\n  bool halvesAreAlike(string s) {\n    const string a = s.substr(0, s.length() / 2);\n    const string b = s.substr(s.length() / 2);\n    const int aVowelsCount =\n        ranges::count_if(a, [this](char c) { return isVowel(c); });\n    const int bVowelsCount =\n        ranges::count_if(b, [this](char c) { return isVowel(c); });\n    return aVowelsCount == bVowelsCount;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "1705": "class Solution {\n public:\n  int eatenApples(vector<int>& apples, vector<int>& days) {\n    const int n = apples.size();\n    int ans = 0;\n    using P = pair<int, int>;  // (the rotten day, the number of apples)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    for (int i = 0; i < n || !minHeap.empty(); ++i) {  // i := day\n      // Remove the rotten apples.\n      while (!minHeap.empty() && minHeap.top().first <= i)\n        minHeap.pop();\n      // Add today's apples.\n      if (i < n && apples[i] > 0)\n        minHeap.emplace(i + days[i], apples[i]);\n      // Eat one apple today.\n      if (!minHeap.empty()) {\n        const auto [rottenDay, numApples] = minHeap.top();\n        minHeap.pop();\n        if (numApples > 1)\n          minHeap.emplace(rottenDay, numApples - 1);\n        ++ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1706": "class Solution {\n public:\n  vector<int> findBall(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dp[i] := status of the i-th column\n    // -1 := empty, 0 := b0, 1 := b1, ...\n    vector<int> dp(n);\n    // ans[i] := the i-th ball's final position\n    vector<int> ans(n, -1);\n\n    iota(dp.begin(), dp.end(), 0);\n\n    for (int i = 0; i < m; ++i) {\n      vector<int> newDp(n, -1);\n      for (int j = 0; j < n; ++j) {\n        // out-of-bounds\n        if (j + grid[i][j] < 0 || j + grid[i][j] == n)\n          continue;\n        // Stuck\n        if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||\n            grid[i][j] == -1 && grid[i][j - 1] == 1)\n          continue;\n        newDp[j + grid[i][j]] = dp[j];\n      }\n      dp = std::move(newDp);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (dp[i] != -1)\n        ans[dp[i]] = i;\n\n    return ans;\n  }\n};\n", "1707": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n    }\n  }\n\n  int getMaxXor(int num) {\n    int maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      const int toggleBit = bit ^ 1;\n      if (node->children[toggleBit] != nullptr) {\n        maxXor = maxXor | 1 << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nstruct IndexedQuery {\n  int queryIndex;\n  int x;\n  int m;\n};\n\nclass Solution {\n public:\n  vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> ans(queries.size(), -1);\n    const int maxNumInNums = ranges::max(nums);\n    const int maxNumInQuery = ranges::max_element(queries, ranges::less{},\n                                                  [](const vector<int>& query) {\n      return query[0];\n    })->at(0);\n    const int maxBit = static_cast<int>(log2(max(maxNumInNums, maxNumInQuery)));\n    BitTrie bitTrie(maxBit);\n\n    ranges::sort(nums);\n\n    int i = 0;  // nums' index\n    for (const auto& [queryIndex, x, m] : getIndexedQueries(queries)) {\n      while (i < nums.size() && nums[i] <= m)\n        bitTrie.insert(nums[i++]);\n      if (i > 0 && nums[i - 1] <= m)\n        ans[queryIndex] = bitTrie.getMaxXor(x);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {\n    vector<IndexedQuery> indexedQueries;\n    for (int i = 0; i < queries.size(); ++i)\n      indexedQueries.emplace_back(i, queries[i][0], queries[i][1]);\n    ranges::sort(\n        indexedQueries, ranges::less{},\n        [](const IndexedQuery& indexedQuery) { return indexedQuery.m; });\n    return indexedQueries;\n  }\n};\n", "1708": "class Solution {\n public:\n  vector<int> largestSubarray(vector<int>& nums, int k) {\n    const auto it = max_element(nums.begin(), nums.end() - k + 1);\n    return std::vector<int>(it, it + k);\n  }\n};\n", "171": "class Solution {\n public:\n  int titleToNumber(string columnTitle) {\n    return accumulate(columnTitle.begin(), columnTitle.end(), 0,\n                      [](int acc, char c) { return acc * 26 + (c - 'A' + 1); });\n  }\n};\n", "1710": "class Solution {\n public:\n  int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n    int ans = 0;\n\n    ranges::sort(boxTypes, ranges::greater{},\n                 [](const vector<int>& boxType) { return boxType[1]; });\n\n    for (const vector<int>& boxType : boxTypes) {\n      const int boxes = boxType[0];\n      const int units = boxType[1];\n      if (boxes >= truckSize)\n        return ans + truckSize * units;\n      ans += boxes * units;\n      truckSize -= boxes;\n    }\n\n    return ans;\n  }\n};\n", "1711": "class Solution {\n public:\n  int countPairs(vector<int>& deliciousness) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMaxBit = 20 + 1;\n    const int kMaxPower = pow(2, kMaxBit);\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int d : deliciousness) {\n      for (int power = 1; power <= kMaxPower; power *= 2)\n        if (const auto it = count.find(power - d); it != count.cend()) {\n          ans += it->second;\n          ans %= kMod;\n        }\n      ++count[d];\n    }\n\n    return ans;\n  }\n};\n", "1712": "class Solution {\n public:\n  int waysToSplit(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    vector<int> prefix(n);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin());\n\n    for (int i = 0, j = 0, k = 0; i < n - 2; ++i) {\n      // Find the first index j s.t.\n      // left = prefix[i] <= mid = prefix[j] - prefix[i]\n      j = max(j, i + 1);\n      while (j < n - 1 && prefix[i] > prefix[j] - prefix[i])\n        ++j;\n      // Find the first index k s.t.\n      // mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      k = max(k, j);\n      while (k < n - 1 && prefix[k] - prefix[i] <= prefix.back() - prefix[k])\n        ++k;\n      ans += k - j;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "1713": "class Solution {\n public:\n  int minOperations(vector<int>& target, vector<int>& arr) {\n    vector<int> indices;\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < target.size(); ++i)\n      numToIndex[target[i]] = i;\n\n    for (const int a : arr)\n      if (const auto it = numToIndex.find(a); it != numToIndex.end())\n        indices.push_back(it->second);\n\n    return target.size() - lengthOfLIS(indices);\n  }\n\n private:\n  // Same as 300. Longest Increasing Subsequence\n  int lengthOfLIS(vector<int>& nums) {\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n    for (const int num : nums)\n      if (tails.empty() || num > tails.back())\n        tails.push_back(num);\n      else\n        tails[firstGreaterEqual(tails, num)] = num;\n    return tails.size();\n  }\n\n private:\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "1714": "class Solution {\n public:\n  vector<int> solve(vector<int>& nums, vector<vector<int>>& queries) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    const int sqrtN = static_cast<int>(sqrt(n));\n    vector<int> ans;\n    // prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n\n    vector<vector<int>> prefix(n, vector<int>(sqrtN));\n\n    // Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < sqrtN; ++j)\n        prefix[i][j] = nums[i];\n\n    for (int x = n - 1; x >= 0; --x)\n      for (int y = 1; y < sqrtN; ++y)\n        if (x + y < n) {\n          prefix[x][y] += prefix[x + y][y];\n          prefix[x][y] %= kMod;\n        }\n\n    for (const vector<int>& query : queries) {\n      const int x = query[0];\n      const int y = query[1];\n      if (y < sqrtN) {\n        ans.push_back(prefix[x][y]);\n      } else {\n        int sum = 0;\n        for (int i = x; i < n; i += y)\n          sum = (sum + nums[i]) % kMod;\n        ans.push_back(sum);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1716": "class Solution {\n public:\n  int totalMoney(int n) {\n    const int weeks = n / 7;\n    const int firstWeek = trapezoid(1, 7);\n    const int lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1);\n    const int remainingDays = trapezoid(1 + weeks, n % 7 + weeks);\n    return (firstWeek + lastFullWeek) * weeks / 2 + remainingDays;\n  }\n\n  // Returns sum(a..b).\n  int trapezoid(int a, int b) {\n    return (a + b) * (b - a + 1) / 2;\n  }\n};\n", "1717": "class Solution {\n public:\n  int maximumGain(string s, int x, int y) {\n    // The assumption that gain(\"ab\") > gain(\"ba\") while removing \"ba\" first is\n    // optimal is contradicted. Only \"b(ab)a\" satisfies the condition of\n    // preventing two \"ba\" removals, but after removing \"ab\", we can still\n    // remove one \"ba\", resulting in a higher gain. Thus, removing \"ba\" first is\n    // not optimal.\n    return x > y ? gain(s, \"ab\", x, \"ba\", y) : gain(s, \"ba\", y, \"ab\", x);\n  }\n\n private:\n  // Returns the points gained by first removing sub1 (\"ab\" | \"ba\") from s with\n  // point1, then removing sub2 (\"ab\" | \"ba\") from s with point2.\n  int gain(const string& s, const string& sub1, int point1, const string& sub2,\n           int point2) {\n    int points = 0;\n    vector<char> stack1;\n    vector<char> stack2;\n\n    // Remove \"sub1\" from s with point1 gain.\n    for (const char c : s)\n      if (!stack1.empty() && stack1.back() == sub1[0] && c == sub1[1]) {\n        stack1.pop_back();\n        points += point1;\n      } else {\n        stack1.push_back(c);\n      }\n\n    // Remove \"sub2\" from s with point2 gain.\n    for (const char c : stack1)\n      if (!stack2.empty() && stack2.back() == sub2[0] && c == sub2[1]) {\n        stack2.pop_back();\n        points += point2;\n      } else {\n        stack2.push_back(c);\n      }\n\n    return points;\n  }\n};\n", "1718": "class Solution {\n public:\n  vector<int> constructDistancedSequence(int n) {\n    vector<int> ans(2 * n - 1);\n    dfs(n, 0, 0, ans);\n    return ans;\n  }\n\n private:\n  bool dfs(int n, int i, int mask, vector<int>& ans) {\n    if (i == ans.size())\n      return true;\n    if (ans[i] > 0)\n      return dfs(n, i + 1, mask, ans);\n\n    // Greedily fill in `ans` in descending order.\n    for (int num = n; num >= 1; --num) {\n      if (mask >> num & 1)\n        continue;\n      if (num == 1) {\n        ans[i] = num;\n        if (dfs(n, i + 1, mask | 1 << num, ans))\n          return true;\n        ans[i] = 0;\n      } else {  // num in [2, n]\n        if (i + num >= ans.size() || ans[i + num] > 0)\n          continue;\n        ans[i] = num;\n        ans[i + num] = num;\n        if (dfs(n, i + 1, mask | 1 << num, ans))\n          return true;\n        ans[i + num] = 0;\n        ans[i] = 0;\n      }\n    }\n\n    return false;\n  }\n};\n", "1719": "class Solution {\n public:\n  int checkWays(vector<vector<int>>& pairs) {\n    constexpr int kMax = 501;\n    unordered_map<int, vector<int>> graph;\n    vector<int> degrees(kMax);\n    vector<vector<bool>> connected(kMax, vector<bool>(kMax));\n\n    for (const vector<int>& pair : pairs) {\n      const int u = pair[0];\n      const int v = pair[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n      ++degrees[u];\n      ++degrees[v];\n      connected[u][v] = true;\n      connected[v][u] = true;\n    }\n\n    // For each node, sort its children by degrees in descending order.\n    for (auto& [_, children] : graph)\n      ranges::sort(children, ranges::greater{},\n                   [&degrees](int child) { return degrees[child]; });\n\n    const int root = getRoot(degrees, graph.size());\n    if (root == -1)\n      return 0;\n    if (!dfs(graph, root, degrees, connected, {}, vector<bool>(kMax)))\n      return 0;\n    return hasMoreThanOneWay ? 2 : 1;\n  }\n\n private:\n  bool hasMoreThanOneWay = false;\n\n  // Returns the root by finding the node with a degree that equals to n - 1.\n  int getRoot(const vector<int>& degrees, int n) {\n    for (int i = 1; i < degrees.size(); ++i)\n      if (degrees[i] == n - 1)\n        return i;\n    return -1;\n  }\n\n  // Returns true if each node rooted at u is connected to all of its ancestors.\n  bool dfs(const unordered_map<int, vector<int>>& graph, int u,\n           vector<int>& degrees, vector<vector<bool>>& connected,\n           vector<int>&& ancestors, vector<bool>&& seen) {\n    seen[u] = true;\n\n    for (const int ancestor : ancestors)\n      if (!connected[u][ancestor])\n        return false;\n\n    ancestors.push_back(u);\n\n    for (const int v : graph.at(u)) {\n      if (seen[v])\n        continue;\n      // We can swap u with v, so there are more than one way.\n      if (degrees[v] == degrees[u])\n        hasMoreThanOneWay = true;\n      if (!dfs(graph, v, degrees, connected, std::move(ancestors),\n               std::move(seen)))\n        return false;\n    }\n\n    ancestors.pop_back();\n    return true;\n  }\n};\n", "172": "class Solution {\n public:\n  int trailingZeroes(int n) {\n    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\n  }\n};\n", "1720": "class Solution {\n public:\n  vector<int> decode(vector<int>& encoded, int first) {\n    vector<int> ans(encoded.size() + 1);\n    ans[0] = first;\n\n    for (int i = 0; i < encoded.size(); ++i)\n      ans[i + 1] = ans[i] ^ encoded[i];\n\n    return ans;\n  }\n};\n", "1721": "class Solution {\n public:\n  ListNode* swapNodes(ListNode* head, int k) {\n    ListNode* p = nullptr;  // Points the k-th node from the beginning.\n    ListNode* q = nullptr;  // Points the k-th node from the end.\n\n    for (ListNode* curr = head; curr != nullptr; curr = curr->next) {\n      if (q != nullptr)\n        q = q->next;\n      if (--k == 0) {\n        p = curr;\n        q = head;\n      }\n    }\n\n    swap(p->val, q->val);\n    return head;\n  }\n};\n", "1722": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int minimumHammingDistance(vector<int>& source, vector<int>& target,\n                             vector<vector<int>>& allowedSwaps) {\n    const int n = source.size();\n    int ans = 0;\n    UnionFind uf(n);\n    vector<unordered_map<int, int>> groupIdToCount(n);\n\n    for (const vector<int>& allowedSwap : allowedSwaps) {\n      const int a = allowedSwap[0];\n      const int b = allowedSwap[1];\n      uf.unionByRank(a, b);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ++groupIdToCount[uf.find(i)][source[i]];\n\n    for (int i = 0; i < n; ++i) {\n      const int groupId = uf.find(i);\n      unordered_map<int, int>& count = groupIdToCount[groupId];\n      if (!count.contains(target[i]))\n        ++ans;\n      else if (--count[target[i]] == 0)\n        count.erase(target[i]);\n    }\n\n    return ans;\n  }\n};\n", "1723": "class Solution {\n public:\n  int minimumTimeRequired(std::vector<int>& jobs, int k) {\n    int ans = accumulate(jobs.begin(), jobs.end(), 0);\n    vector<int> times(k);\n\n    ranges::sort(jobs, greater<>());\n    dfs(jobs, 0, times, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& jobs, int s, vector<int>& times, int& ans) {\n    if (s == jobs.size()) {\n      ans = min(ans, ranges::max(times));\n      return;\n    }\n    for (int i = 0; i < times.size(); ++i) {\n      if (times[i] + jobs[s] >= ans)\n        continue;\n      times[i] += jobs[s];\n      dfs(jobs, s + 1, times, ans);\n      times[i] -= jobs[s];\n      if (times[i] == 0)\n        return;\n    }\n  };\n};\n", "1724": "class UnionFind {\n public:\n  UnionFind() {}\n  UnionFind(int n) {\n    id.resize(n);\n\n    for (int i = 0; i < n; ++i)\n      id[i][0] = i;\n  }\n\n  void union_(int u, int v, int limit) {\n    const int i = find(u, limit);\n    const int j = find(v, limit);\n    if (i == j)\n      return;\n    id[i][limit] = j;\n  }\n\n  int find(int u, int limit) {\n    // the minimum iterator of id[u] > limit\n    const auto it = id[u].upper_bound(limit);\n    const int i = prev(it)->second;\n    if (i == u)\n      return u;\n    // Recursively find i's id.\n    const int j = find(i, limit);\n    id[u][limit] = j;\n    return j;\n  }\n\n private:\n  // id[i]'s (key, value) := (limit, id of node i <= limit)\n  vector<map<int, int>> id;\n};\n\nclass DistanceLimitedPathsExist {\n public:\n  DistanceLimitedPathsExist(int n, vector<vector<int>>& edgeList) {\n    uf = UnionFind(n);\n\n    ranges::sort(edgeList, ranges::less{},\n                 [](const vector<int>& edge) { return edge[2]; });\n\n    for (const vector<int>& edge : edgeList) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int d = edge[2];\n      uf.union_(u, v, d);\n    }\n  }\n\n  bool query(int p, int q, int limit) {\n    return uf.find(p, limit - 1) == uf.find(q, limit - 1);\n  }\n\n private:\n  UnionFind uf;\n};\n", "1725": "class Solution {\n public:\n  int countGoodRectangles(vector<vector<int>>& rectangles) {\n    vector<int> minSides;\n\n    for (const vector<int>& rectangle : rectangles) {\n      const int x = rectangle[0];\n      const int y = rectangle[1];\n      minSides.push_back(min(x, y));\n    }\n\n    const int maxLen = ranges::max(minSides);\n    return ranges::count(minSides, maxLen);\n  }\n};\n", "1726": "class Solution {\n public:\n  int tupleSameProduct(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        ans += count[nums[i] * nums[j]]++ * 8;\n\n    return ans;\n  }\n};\n", "1727": "class Solution {\n public:\n  int largestSubmatrix(vector<vector<int>>& matrix) {\n    const int n = matrix[0].size();\n    int ans = 0;\n    vector<int> hist(n);\n\n    for (const vector<int>& row : matrix) {\n      // Accumulate the histogram if possible.\n      for (int i = 0; i < n; ++i)\n        hist[i] = row[i] == 0 ? 0 : hist[i] + 1;\n\n      // Get the sorted histogram.\n      vector<int> sortedHist(hist);\n      ranges::sort(sortedHist);\n\n      // Greedily calculate the answer.\n      for (int i = 0; i < n; ++i)\n        ans = max(ans, sortedHist[i] * (n - i));\n    }\n\n    return ans;\n  }\n};\n", "1728": "class Solution {\n public:\n  bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int nFloors = 0;\n    int cat;    // cat's position\n    int mouse;  // mouse's position\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (grid[i][j] != '#')\n          ++nFloors;\n        if (grid[i][j] == 'C')\n          cat = hash(i, j, n);\n        else if (grid[i][j] == 'M')\n          mouse = hash(i, j, n);\n      }\n\n    vector<vector<vector<int>>> mem(\n        m * n, vector<vector<int>>(m * n, vector<int>(nFloors * 2, -1)));\n    return canMouseWin(grid, cat, mouse, 0, catJump, mouseJump, m, n, nFloors,\n                       mem);\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  // Returns true if the mouse can win, where the cat is on (i / 8, i % 8), the\n  // mouse is on (j / 8, j % 8), and the turns is k.\n  bool canMouseWin(const vector<string>& grid, int cat, int mouse, int turn,\n                   const int& catJump, const int& mouseJump, const int& m,\n                   const int& n, const int& nFloors,\n                   vector<vector<vector<int>>>& mem) {\n    // We already search the whole touchable grid.\n    if (turn == nFloors * 2)\n      return false;\n    if (mem[cat][mouse][turn] != -1)\n      return mem[cat][mouse][turn];\n\n    if (turn % 2 == 0) {\n      // the mouse's turn\n      const int i = mouse / n;\n      const int j = mouse % n;\n      for (const auto& [dx, dy] : kDirs) {\n        for (int jump = 0; jump <= mouseJump; ++jump) {\n          const int x = i + dx * jump;\n          const int y = j + dy * jump;\n          if (x < 0 || x == m || y < 0 || y == n)\n            break;\n          if (grid[x][y] == '#')\n            break;\n          // The mouse eats the food, so the mouse wins.\n          if (grid[x][y] == 'F')\n            return mem[cat][mouse][turn] = true;\n          if (canMouseWin(grid, cat, hash(x, y, n), turn + 1, catJump,\n                          mouseJump, m, n, nFloors, mem))\n            return mem[cat][mouse][turn] = true;\n        }\n      }\n      // The mouse can't win, so the mouse loses.\n      return mem[cat][mouse][turn] = false;\n    } else {\n      // the cat's turn\n      const int i = cat / n;\n      const int j = cat % n;\n      for (const auto& [dx, dy] : kDirs) {\n        for (int jump = 0; jump <= catJump; ++jump) {\n          const int x = i + dx * jump;\n          const int y = j + dy * jump;\n          if (x < 0 || x == m || y < 0 || y == n)\n            break;\n          if (grid[x][y] == '#')\n            break;\n          // The cat eats the food, so the mouse loses.\n          if (grid[x][y] == 'F')\n            return mem[cat][mouse][turn] = false;\n          const int nextCat = hash(x, y, n);\n          // The cat catches the mouse, so the mouse loses.\n          if (nextCat == mouse)\n            return mem[cat][mouse][turn] = false;\n          if (!canMouseWin(grid, nextCat, mouse, turn + 1, catJump, mouseJump,\n                           m, n, nFloors, mem))\n            return mem[cat][mouse][turn] = false;\n        }\n      }\n      // The cat can't win, so the mouse wins.\n      return mem[cat][mouse][turn] = true;\n    }\n  }\n\n  int hash(int i, int j, int n) {\n    return i * n + j;\n  }\n};\n", "173": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root) {\n    pushLeftsUntilNull(root);\n  }\n\n  int next() {\n    TreeNode* root = stack.top();\n    stack.pop();\n    pushLeftsUntilNull(root->right);\n    return root->val;\n  }\n\n  bool hasNext() {\n    return !stack.empty();\n  }\n\n private:\n  stack<TreeNode*> stack;\n\n  void pushLeftsUntilNull(TreeNode* root) {\n    while (root != nullptr) {\n      stack.push(root);\n      root = root->left;\n    }\n  }\n};\n", "1730": "class Solution {\n public:\n  int getFood(vector<vector<char>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    queue<pair<int, int>> q{{getStartLocation(grid)}};\n\n    for (int ans = 0; !q.empty(); ++ans)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (grid[x][y] == 'X')\n            continue;\n          if (grid[x][y] == '#')\n            return ans + 1;\n          q.emplace(x, y);\n          grid[x][y] = 'X';  // Mark as visited.\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  pair<int, int> getStartLocation(const vector<vector<char>>& grid) {\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == '*')\n          return {i, j};\n    throw;\n  }\n};\n", "1732": "class Solution {\n public:\n  int largestAltitude(vector<int>& gain) {\n    int ans = 0;\n    int currAltitude = 0;\n    for (const int g : gain) {\n      currAltitude += g;\n      ans = max(ans, currAltitude);\n    }\n    return ans;\n  }\n};\n", "1733": "class Solution {\n public:\n  int minimumTeachings(int n, vector<vector<int>>& languages,\n                       vector<vector<int>>& friendships) {\n    vector<unordered_set<int>> languageSets;\n    unordered_set<int> needTeach;\n    unordered_map<int, int> languageCount;\n\n    for (const vector<int>& language : languages)\n      languageSets.push_back({language.begin(), language.end()});\n\n    // Find friends that can't communicate.\n    for (const vector<int>& friendship : friendships) {\n      const int u = friendship[0] - 1;\n      const int v = friendship[1] - 1;\n      if (cantTalk(languageSets, u, v)) {\n        needTeach.insert(u);\n        needTeach.insert(v);\n      }\n    }\n\n    // Find the most popular language.\n    for (const int u : needTeach)\n      for (const int language : languageSets[u])\n        ++languageCount[language];\n\n    // Teach the most popular language to people who don't understand.\n    int maxCount = 0;\n    for (const auto& [_, freq] : languageCount)\n      maxCount = max(maxCount, freq);\n\n    return needTeach.size() - maxCount;\n  }\n\n private:\n  // Returns true if u can't talk with v.\n  bool cantTalk(const vector<unordered_set<int>>& languageSets, int u, int v) {\n    for (const int language : languageSets[u])\n      if (languageSets[v].contains(language))\n        return false;\n    return true;\n  }\n};\n", "1734": "class Solution {\n public:\n  vector<int> decode(vector<int>& encoded) {\n    // Our goal is to find the value of a1, which will allow us to decode a2,\n    // a3, ..., an. This can be achieved by performing XOR operation between\n    // each element in `encoded` and a1.\n    //\n    // e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3]\n    //               encoded = [a1^a2, a2^a3]\n    //    accumulatedEncoded = [a1^a2, a1^a3]\n    //    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)\n    //    a2 = a1^(a1^a2)\n    //    a3 = a2^(a2^a3)\n    const int n = encoded.size() + 1;\n    int nXors = 0;\n    for (int i = 1; i <= n; i++)\n      nXors ^= i;\n\n    // Instead of constructing the array, we can track of the running XOR value\n    // of `accumulatedEncoded`.\n    int runningXors = 0;\n    int xors = 0;  // xors(accumulatedEncoded)\n\n    for (const int encode : encoded) {\n      runningXors ^= encode;\n      xors ^= runningXors;\n    }\n\n    vector<int> ans{xors ^ nXors};\n\n    for (const int encode : encoded)\n      ans.push_back(ans.back() ^ encode);\n\n    return ans;\n  }\n};\n", "1735": "class Solution {\n public:\n  vector<int> waysToFillArray(vector<vector<int>>& queries) {\n    constexpr int kMax = 10000;\n    constexpr int kMaxFreq = 13;  // 2^13 = 8192 < kMax\n    const vector<int> minPrimeFactors = sieveEratosthenes(kMax + 1);\n    const auto [fact, invFact] = getFactAndInvFact(kMax + kMaxFreq - 1);\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int n = query[0];\n      const int k = query[1];\n      int res = 1;\n      for (const auto& [_, freq] : getPrimeFactorsCount(k, minPrimeFactors))\n        res = static_cast<long>(res) * nCk(n - 1 + freq, freq, fact, invFact) %\n              kMod;\n      ans.push_back(res);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Gets the minimum prime factor of i, where 1 < i <= n.\n  vector<int> sieveEratosthenes(int n) {\n    vector<int> minPrimeFactors(n + 1);\n    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);\n    for (int i = 2; i * i < n; ++i)\n      if (minPrimeFactors[i] == i)  // `i` is prime.\n        for (int j = i * i; j < n; j += i)\n          minPrimeFactors[j] = min(minPrimeFactors[j], i);\n    return minPrimeFactors;\n  }\n\n  unordered_map<int, int> getPrimeFactorsCount(\n      int num, const vector<int>& minPrimeFactors) {\n    unordered_map<int, int> count;\n    while (num > 1) {\n      const int divisor = minPrimeFactors[num];\n      while (num % divisor == 0) {\n        num /= divisor;\n        ++count[divisor];\n      }\n    }\n    return count;\n  }\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {\n    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;\n  }\n};\n", "1736": "class Solution {\n public:\n  string maximumTime(string time) {\n    string ans = time;\n    if (time[0] == '?')\n      ans[0] = time[1] == '?' || time[1] < '4' ? '2' : '1';\n    if (time[1] == '?')\n      ans[1] = ans[0] == '2' ? '3' : '9';\n    if (time[3] == '?')\n      ans[3] = '5';\n    if (time[4] == '?')\n      ans[4] = '9';\n    return ans;\n  }\n};\n", "1737": "class Solution {\n public:\n  int minCharacters(string a, string b) {\n    const int m = a.length();\n    const int n = b.length();\n    vector<int> countA(26);\n    vector<int> countB(26);\n\n    for (const char c : a)\n      ++countA[c - 'a'];\n\n    for (const char c : b)\n      ++countB[c - 'a'];\n\n    int ans = INT_MAX;\n    int prevA = 0;  // the number of characters in a <= c\n    int prevB = 0;  // the number of characters in b <= c\n\n    for (char c = 'a'; c <= 'z'; ++c) {\n      // the condition 3\n      ans = min(ans, m + n - countA[c - 'a'] - countB[c - 'a']);\n      // the conditions 1 and 2\n      if (c > 'a')\n        ans = min({ans, m - prevA + prevB, n - prevB + prevA});\n      prevA += countA[c - 'a'];\n      prevB += countB[c - 'a'];\n    }\n\n    return ans;\n  }\n};\n", "1738": "class Solution {\n public:\n  int kthLargestValue(vector<vector<int>>& matrix, int k) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<vector<int>> xors(m + 1, vector<int>(n + 1));\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j) {\n        xors[i][j] = xors[i - 1][j] ^ xors[i][j - 1] ^ xors[i - 1][j - 1] ^\n                     matrix[i - 1][j - 1];\n        minHeap.push(xors[i][j]);\n        if (minHeap.size() > k)\n          minHeap.pop();\n      }\n\n    return minHeap.top();\n  }\n};\n", "1739": "class Solution {\n public:\n  int minimumBoxes(int n) {\n    int nBoxes = 0;\n    int nextTouchings = 0;   // j\n    int currLevelBoxes = 0;  // 1 + 2 + ... + j\n\n    // Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)\n    // >= n.\n    while (nBoxes < n) {\n      ++nextTouchings;\n      currLevelBoxes += nextTouchings;\n      nBoxes += currLevelBoxes;\n    }\n\n    // If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.\n    if (nBoxes == n)\n      return currLevelBoxes;\n\n    // Otherwise, need to remove the boxes in the current level and rebuild it.\n    nBoxes -= currLevelBoxes;\n    currLevelBoxes -= nextTouchings;\n    nextTouchings = 0;\n\n    while (nBoxes < n) {\n      ++nextTouchings;\n      nBoxes += nextTouchings;\n    }\n\n    return currLevelBoxes + nextTouchings;\n  }\n};\n", "174": "class Solution {\n public:\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\n    const int m = dungeon.size();\n    const int n = dungeon[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));\n    dp[m][n - 1] = 1;\n    dp[m - 1][n] = 1;\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\n        dp[i][j] = max(dp[i][j], 1);\n      }\n\n    return dp[0][0];\n  }\n};\n", "1740": "class Solution {\n public:\n  int findDistance(TreeNode* root, int p, int q) {\n    TreeNode* lca = getLCA(root, p, q);\n    return dist(lca, p) + dist(lca, q);\n  }\n\n private:\n  TreeNode* getLCA(TreeNode* root, int p, int q) {\n    if (root == nullptr || root->val == p || root->val == q)\n      return root;\n    TreeNode* left = getLCA(root->left, p, q);\n    TreeNode* right = getLCA(root->right, p, q);\n    if (left != nullptr && right != nullptr)\n      return root;\n    return left == nullptr ? right : left;\n  }\n\n  int dist(TreeNode* lca, int target) {\n    if (lca == nullptr)\n      return 10000;\n    if (lca->val == target)\n      return 0;\n    return 1 + min(dist(lca->left, target), dist(lca->right, target));\n  }\n};\n", "1742": "class Solution {\n public:\n  int countBalls(int lowLimit, int highLimit) {\n    const int maxDigitSum = 9 * 5;  // 99999\n    int ans = 0;\n    vector<int> count(maxDigitSum + 1);\n\n    for (int num = lowLimit; num <= highLimit; ++num)\n      ans = max(ans, ++count[getDigitSum(num)]);\n\n    return ans;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "1743": "class Solution {\n public:\n  vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {\n    vector<int> ans;\n    unordered_map<int, vector<int>> numToAdjs;\n\n    for (const vector<int>& pair : adjacentPairs) {\n      const int u = pair[0];\n      const int v = pair[1];\n      numToAdjs[u].push_back(v);\n      numToAdjs[v].push_back(u);\n    }\n\n    for (const auto& [num, adjs] : numToAdjs)\n      if (adjs.size() == 1) {\n        ans.push_back(num);\n        ans.push_back(adjs[0]);\n        break;\n      }\n\n    while (ans.size() < adjacentPairs.size() + 1) {\n      const int tail = ans.back();\n      const int prev = ans[ans.size() - 2];\n      const vector<int>& adjs = numToAdjs[tail];\n      if (adjs[0] == prev)\n        ans.push_back(adjs[1]);\n      else\n        ans.push_back(adjs[0]);\n    }\n\n    return ans;\n  }\n};\n", "1745": "class Solution {\n public:\n  bool checkPartitioning(string s) {\n    const int n = s.length();\n    // dp[i][j] := true if s[i..j] is a palindrome\n    vector<vector<bool>> dp(n + 1, vector<bool>(n + 1));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = true;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j])\n          dp[i][j] = i + 1 > j - 1 || dp[i + 1][j - 1];\n      }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j)\n        if (dp[0][i] && dp[i + 1][j] && dp[j + 1][n - 1])\n          return true;\n\n    return false;\n  }\n};\n", "1746": "class Solution {\n public:\n  int maxSumAfterOperation(vector<int>& nums) {\n    int ans = INT_MIN;\n    int regular = 0;\n    int squared = 0;\n\n    for (const int num : nums) {\n      squared = max({num * num, regular + num * num, squared + num});\n      regular = max(num, regular + num);\n      ans = max(ans, squared);\n    }\n\n    return ans;\n  }\n};\n", "1748": "class Solution {\n public:\n  int sumOfUnique(vector<int>& nums) {\n    constexpr int kMax = 100;\n    int ans = 0;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = 1; i <= kMax; ++i)\n      if (count[i] == 1)\n        ans += i;\n\n    return ans;\n  }\n};\n", "1749": "class Solution {\n public:\n  int maxAbsoluteSum(vector<int>& nums) {\n    int sum = 0;\n    int maxPrefix = 0;\n    int minPrefix = 0;\n\n    for (const int num : nums) {\n      sum += num;\n      maxPrefix = max(maxPrefix, sum);\n      minPrefix = min(minPrefix, sum);\n    }\n\n    return maxPrefix - minPrefix;\n  }\n};\n", "1750": "class Solution {\n public:\n  int minimumLength(string s) {\n    int i = 0;\n    int j = s.length() - 1;\n\n    while (i < j && s[i] == s[j]) {\n      const char c = s[i];\n      while (i <= j && s[i] == c)\n        ++i;\n      while (i <= j && s[j] == c)\n        --j;\n    }\n\n    return j - i + 1;\n  }\n};\n", "1751": "class Solution {\n public:\n  int maxValue(vector<vector<int>>& events, int k) {\n    vector<vector<int>> mem(events.size(), vector<int>(k + 1, -1));\n    ranges::sort(events);\n    return maxValue(events, 0, k, mem);\n  }\n\n private:\n  // Returns the maximum sum of values that you can receive by attending\n  // events[i..n), where k is the maximum number of attendancevents.\n  int maxValue(const vector<vector<int>>& events, int i, int k,\n               vector<vector<int>>& mem) {\n    if (k == 0 || i == events.size())\n      return 0;\n    if (mem[i][k] != -1)\n      return mem[i][k];\n\n    // Binary search `events` to find the first index j\n    // s.t. events[j][0] > events[i][1].\n    const auto it = upper_bound(\n        events.begin() + i, events.end(), events[i][1],\n        [](int end, const vector<int>& event) { return event[0] > end; });\n    const int j = distance(events.begin(), it);\n    return mem[i][k] = max(events[i][2] + maxValue(events, j, k - 1, mem),\n                           maxValue(events, i + 1, k, mem));\n  }\n};\n", "1752": "class Solution {\n public:\n  bool check(vector<int>& nums) {\n    const int n = nums.size();\n    int rotates = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] > nums[(i + 1) % n] && ++rotates > 1)\n        return false;\n\n    return true;\n  }\n};\n", "1753": "class Solution {\n public:\n  int maximumScore(int a, int b, int c) {\n    // the maximum <= the minimum + the middle\n    const int x = (a + b + c) / 2;\n    // the maximum > the minimum + the middle\n    const int y = a + b + c - max({a, b, c});\n    return min(x, y);\n  }\n};\n", "1754": "class Solution {\n public:\n  string largestMerge(string word1, string word2) {\n    if (word1.empty())\n      return word2;\n    if (word2.empty())\n      return word1;\n    return word1 > word2 ? word1[0] + largestMerge(word1.substr(1), word2)\n                         : word2[0] + largestMerge(word1, word2.substr(1));\n  }\n};\n", "1755": "class Solution {\n public:\n  int minAbsDifference(vector<int>& nums, int goal) {\n    const int n = nums.size() / 2;\n    const vector<int> lNums(nums.begin(), nums.begin() + n);\n    const vector<int> rNums(nums.begin() + n, nums.end());\n    int ans = INT_MAX;\n    vector<int> lSums;\n    vector<int> rSums;\n\n    dfs(lNums, 0, 0, lSums);\n    dfs(rNums, 0, 0, rSums);\n    ranges::sort(rSums);\n\n    for (const int lSum : lSums) {\n      const int i = firstGreaterEqual(rSums, goal - lSum);\n      if (i < rSums.size())  // 2^n\n        ans = min(ans, abs(goal - lSum - rSums[i]));\n      if (i > 0)\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]));\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& arr, int i, int path, vector<int>& sums) {\n    if (i == arr.size()) {\n      sums.push_back(path);\n      return;\n    }\n    dfs(arr, i + 1, path + arr[i], sums);\n    dfs(arr, i + 1, path, sums);\n  }\n\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "1758": "class Solution {\n public:\n  int minOperations(string s) {\n    int cost10;  // the cost to make s \"1010\"\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] - '0' == i % 2)\n        ++cost10;\n\n    const int cost01 = s.length() - cost10;  // the cost to make s \"0101\"\n    return min(cost10, cost01);\n  }\n};\n", "1759": "class Solution {\n public:\n  int countHomogenous(string s) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    int count = 0;\n    char currentChar = '@';\n\n    for (const char c : s) {\n      count = c == currentChar ? count + 1 : 1;\n      currentChar = c;\n      ans += count;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "1760": "class Solution {\n public:\n  int minimumSize(vector<int>& nums, int maxOperations) {\n    int l = 1;\n    int r = ranges::max(nums);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numOperations(nums, m) <= maxOperations)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the number of operations required to make m penalty.\n  int numOperations(const vector<int>& nums, int m) {\n    int operations = 0;\n    for (const int num : nums)\n      operations += (num - 1) / m;\n    return operations;\n  }\n};\n", "1761": "class Solution {\n public:\n  int minTrioDegree(int n, vector<vector<int>>& edges) {\n    int ans = INT_MAX;\n    vector<unordered_set<int>> graph(n);\n    vector<int> degrees(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0] - 1;\n      const int v = edge[1] - 1;\n      // Store the mapping from `min(u, v)` to `max(u, v)` to speed up.\n      graph[min(u, v)].insert(max(u, v));\n      ++degrees[u];\n      ++degrees[v];\n    }\n\n    for (int u = 0; u < n; ++u)\n      for (const int v : graph[u])\n        for (const int w : graph[u])\n          if (graph[v].contains(w))\n            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "1762": "class Solution {\n public:\n  vector<int> findBuildings(vector<int>& heights) {\n    vector<int> stack;\n\n    for (int i = 0; i < heights.size(); ++i) {\n      while (!stack.empty() && heights[stack.back()] <= heights[i])\n        stack.pop_back();\n      stack.push_back(i);\n    }\n\n    return stack;\n  }\n};\n", "1763": "class Solution {\n public:\n  string longestNiceSubstring(string s) {\n    if (s.length() < 2)\n      return \"\";\n\n    unordered_set<char> seen{s.begin(), s.end()};\n\n    for (int i = 0; i < s.size(); ++i)\n      // If both upper and lower case letters exists in the string, keep moving,\n      // else take the erroneous character as a partition and check for its left\n      // and right parts to be nice strings.\n      if (!seen.contains(toggleCase(s[i]))) {\n        const string prefix = longestNiceSubstring(s.substr(0, i));\n        const string suffix = longestNiceSubstring(s.substr(i + 1));\n        return prefix.length() >= suffix.length() ? prefix : suffix;\n      }\n\n    return s;\n  }\n\n private:\n  char toggleCase(char c) {\n    return islower(c) ? toupper(c) : tolower(c);\n  }\n};\n", "1764": "class Solution {\n public:\n  bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\n    int i = 0;  // groups' index\n    int j = 0;  // nums' index\n\n    while (i < groups.size() && j < nums.size())\n      if (isMatch(groups[i], nums, j)) {\n        j += groups[i].size();\n        ++i;\n      } else {\n        ++j;\n      }\n\n    return i == groups.size();\n  }\n\n private:\n  // Returns true if group == nums[j..j + |group|].\n  bool isMatch(const vector<int>& group, const vector<int>& nums, int j) {\n    if (j + group.size() > nums.size())\n      return false;\n    for (int i = 0; i < group.size(); ++i)\n      if (group[i] != nums[j + i])\n        return false;\n    return true;\n  }\n};\n", "1765": "class Solution {\n public:\n  vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = isWater.size();\n    const int n = isWater[0].size();\n    vector<vector<int>> ans(m, vector<int>(n, -1));\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (isWater[i][j] == 1) {\n          q.emplace(i, j);\n          ans[i][j] = 0;\n        }\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (ans[x][y] != -1)\n          continue;\n        ans[x][y] = ans[i][j] + 1;\n        q.emplace(x, y);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1766": "class Solution {\n public:\n  vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {\n    vector<int> ans(nums.size(), -1);\n    vector<vector<int>> tree(nums.size());\n    // stacks[i] := (node, depth)s of nodes with value i\n    vector<stack<pair<int, int>>> stacks(kMax + 1);\n\n    for (const vector<int> edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, /*prev=*/-1, /*depth=*/0, nums, stacks, ans);\n    return ans;\n  }\n\n private:\n  static constexpr int kMax = 50;\n\n  void dfs(const vector<vector<int>>& tree, int u, int prev, int depth,\n           const vector<int>& nums, vector<stack<pair<int, int>>>& stacks,\n           vector<int>& ans) {\n    ans[u] = getAncestor(u, stacks, nums);\n    stacks[nums[u]].push({u, depth});\n\n    for (const int v : tree[u])\n      if (v != prev)\n        dfs(tree, v, u, depth + 1, nums, stacks, ans);\n\n    stacks[nums[u]].pop();\n  }\n\n  int getAncestor(int u, const vector<stack<pair<int, int>>>& stacks,\n                  const vector<int>& nums) {\n    int maxNode = -1;\n    int maxDepth = -1;\n    for (int i = 1; i <= kMax; ++i)\n      if (!stacks[i].empty() && stacks[i].top().second > maxDepth &&\n          __gcd(nums[u], i) == 1) {\n        maxNode = stacks[i].top().first;\n        maxDepth = stacks[i].top().second;\n      }\n    return maxNode;\n  }\n};\n", "1768": "class Solution {\n public:\n  string mergeAlternately(string word1, string word2) {\n    const int n = min(word1.length(), word2.length());\n    string prefix;\n\n    for (int i = 0; i < n; ++i) {\n      prefix += word1[i];\n      prefix += word2[i];\n    }\n\n    return prefix + word1.substr(n) + word2.substr(n);\n  }\n};\n", "1769": "class Solution {\n public:\n  vector<int> minOperations(string boxes) {\n    vector<int> ans(boxes.length());\n\n    for (int i = 0, count = 0, moves = 0; i < boxes.length(); ++i) {\n      ans[i] += moves;\n      count += boxes[i] - '0';\n      moves += count;\n    }\n\n    for (int i = boxes.length() - 1, count = 0, moves = 0; i >= 0; --i) {\n      ans[i] += moves;\n      count += boxes[i] - '0';\n      moves += count;\n    }\n\n    return ans;\n  }\n};\n", "1770": "class Solution {\n public:\n  int maximumScore(vector<int>& nums, vector<int>& multipliers) {\n    vector<vector<int>> mem(multipliers.size(),\n                            vector<int>(multipliers.size(), -1));\n    return maximumScore(nums, 0, multipliers, 0, mem);\n  }\n\n private:\n  // Returns the maximum score of nums[s..e] and multipliers[i].\n  int maximumScore(const vector<int>& nums, int s,\n                   const vector<int>& multipliers, int i,\n                   vector<vector<int>>& mem) {\n    if (i == multipliers.size())\n      return 0;\n    if (mem[s][i] != -1)\n      return mem[s][i];\n\n    // The number of nums picked on the start side is s.\n    // The number of nums picked on the end side is i - s.\n    // So, e = n - (i - s) - 1.\n    const int e = nums.size() - (i - s) - 1;\n    const int pickStart = nums[s] * multipliers[i] +\n                          maximumScore(nums, s + 1, multipliers, i + 1, mem);\n    const int pickEnd = nums[e] * multipliers[i] +\n                        maximumScore(nums, s, multipliers, i + 1, mem);\n    return mem[s][i] = max(pickStart, pickEnd);\n  }\n};\n", "1771": "class Solution {\n public:\n  int longestPalindrome(string word1, string word2) {\n    const string& s = word1 + word2;\n    const int n = s.length();\n    int ans = 0;\n    // dp[i][j] := the length of LPS(s[i..j])\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j]) {\n          dp[i][j] = 2 + dp[i + 1][j - 1];\n          if (i < word1.length() && j >= word1.length())\n            ans = max(ans, dp[i][j]);\n        } else {\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n        }\n      }\n\n    return ans;\n  }\n};\n", "1772": "class Solution {\n public:\n  vector<string> sortFeatures(vector<string>& features,\n                              vector<string>& responses) {\n    vector<string> ans;\n    vector<pair<int, int>> featCount;  // {i: count[features[i]]}\n    unordered_map<string, int> count;\n\n    for (const string& res : responses) {\n      istringstream iss(res);\n      unordered_set<string> seen;\n      for (string token; getline(iss, token, ' ');)\n        seen.insert(token);\n      for (const string& token : seen)\n        ++count[token];\n    }\n\n    for (int i = 0; i < features.size(); ++i)\n      featCount.emplace_back(i, count[features[i]]);\n\n    ranges::sort(featCount, ranges::less{}, [](const pair<int, int>& a) {\n      const auto& [i, count] = a;\n      return pair<int, int>{-count, i};\n    });\n\n    for (const auto& [i, count] : featCount)\n      ans.push_back(features[i]);\n\n    return ans;\n  }\n};\n", "1773": "class Solution {\n public:\n  int countMatches(vector<vector<string>>& items, string ruleKey,\n                   string ruleValue) {\n    const int index = ruleKey == \"type\" ? 0 : ruleKey == \"color\" ? 1 : 2;\n    return ranges::count_if(items, [index, &ruleValue](const auto& item) {\n      return item[index] == ruleValue;\n    });\n  }\n};\n", "1774": "class Solution {\n public:\n  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts,\n                  int target) {\n    int ans = INT_MAX;\n\n    for (const int baseCost : baseCosts)\n      dfs(toppingCosts, 0, target, baseCost, ans);\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& toppingCosts, int i, int target, int currCost,\n           int& ans) {\n    if (abs(currCost - target) < abs(ans - target))\n      ans = currCost;\n    if (i == toppingCosts.size() || currCost >= target)\n      return;\n\n    for (int k = 0; k < 3; ++k)\n      dfs(toppingCosts, i + 1, target, currCost + k * toppingCosts[i], ans);\n  }\n};\n", "1775": "class Solution {\n public:\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())\n      return -1;\n\n    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\n    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\n    if (sum1 > sum2)\n      return minOperations(nums2, nums1);\n\n    int ans = 0;\n    // increasing in `nums1` and decreasing in `nums2`\n    vector<int> count(6);\n\n    for (const int num : nums1)\n      ++count[6 - num];\n\n    for (const int num : nums2)\n      ++count[num - 1];\n\n    for (int i = 5; sum2 > sum1;) {\n      while (count[i] == 0)\n        --i;\n      sum1 += i;\n      --count[i];\n      ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1776": "struct Car {\n  int pos;\n  int speed;\n  double collisionTime;\n  Car(int pos, int speed, double collisionTime)\n      : pos(pos), speed(speed), collisionTime(collisionTime) {}\n};\n\nclass Solution {\n public:\n  vector<double> getCollisionTimes(vector<vector<int>>& cars) {\n    vector<double> ans(cars.size());\n    stack<Car> stack;\n\n    for (int i = cars.size() - 1; i >= 0; --i) {\n      const int pos = cars[i][0];\n      const int speed = cars[i][1];\n      while (!stack.empty() && (speed <= stack.top().speed ||\n                                getCollisionTime(stack.top(), pos, speed) >=\n                                    stack.top().collisionTime))\n        stack.pop();\n      if (stack.empty()) {\n        stack.emplace(pos, speed, INT_MAX);\n        ans[i] = -1;\n      } else {\n        const double collisionTime = getCollisionTime(stack.top(), pos, speed);\n        stack.emplace(pos, speed, collisionTime);\n        ans[i] = collisionTime;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  double getCollisionTime(const Car& car, int pos, int speed) {\n    return (car.pos - pos) / (double)(speed - car.speed);\n  }\n};\n", "1778": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *  public:\n *   bool canMove(char direction);\n *   void std::move(char direction);\n *   boolean isTarget();\n * };\n */\n\nenum class Grid { kUnvisited, kStart, kTarget, kBlocked, kEmpty };\n\nclass Solution {\n public:\n  int findShortestPath(GridMaster& master) {\n    constexpr int m = 501;\n    constexpr int startX = m;\n    constexpr int startY = m;\n    vector<vector<Grid>> grid(m * 2, vector<Grid>(m * 2, Grid::kUnvisited));\n\n    // Build the grid information by DFS.\n    dfs(master, grid, startX, startY);\n\n    queue<pair<int, int>> q{{{startX, startY}}};\n    grid[startX][startY] = Grid::kBlocked;\n\n    // Find the steps by BFS.\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (grid[x][y] == Grid::kTarget)\n            return step;\n          if (grid[x][y] == Grid::kBlocked)\n            continue;\n          grid[x][y] = Grid::kBlocked;\n          q.emplace(x, y);\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n  static constexpr char charTable[4] = {'R', 'D', 'L', 'U'};\n\n  void dfs(GridMaster& master, vector<vector<Grid>>& grid, int i, int j) {\n    if (grid[i][j] != Grid::kUnvisited)\n      return;\n    if (master.isTarget())\n      grid[i][j] = Grid::kTarget;\n    else\n      grid[i][j] = Grid::kEmpty;\n\n    for (int k = 0; k < 4; ++k) {\n      const int x = i + kDirs[k][0];\n      const int y = j + kDirs[k][1];\n      const char d = charTable[k];\n      const char undoD = charTable[(k + 2) % 4];\n      if (master.canMove(d)) {\n        master.move(d);\n        dfs(master, grid, x, y);\n        master.move(undoD);\n      } else {\n        grid[x][y] = Grid::kBlocked;\n      }\n    }\n  }\n};\n", "1779": "class Solution {\n public:\n  int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\n    int ans = -1;\n    int minDist = INT_MAX;\n\n    for (int i = 0; i < points.size(); ++i) {\n      const int dx = x - points[i][0];\n      const int dy = y - points[i][1];\n      if (dx == 0 || dy == 0) {\n        const int dist = abs(dx + dy);\n        if (dist < minDist) {\n          minDist = dist;\n          ans = i;\n        }\n      }\n    }\n\n    return ans;\n  }\n};\n", "1780": "class Solution {\n public:\n  bool checkPowersOfThree(int n) {\n    while (n > 1) {\n      const int r = n % 3;\n      if (r == 2)\n        return false;\n      n /= 3;\n    }\n\n    return true;\n  }\n};\n", "1781": "class Solution {\n public:\n  int beautySum(string s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i) {\n      vector<int> count(26);\n      for (int j = i; j < s.length(); ++j) {\n        ++count[s[j] - 'a'];\n        ans += ranges::max(count) - getMinFreq(count);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the minimum frequency > 0.\n  int getMinFreq(const vector<int>& count) {\n    int minFreq = INT_MAX;\n    for (const int freq : count)\n      if (freq > 0)\n        minFreq = min(minFreq, freq);\n    return minFreq;\n  }\n};\n", "1782": "class Solution {\n public:\n  vector<int> countPairs(int n, vector<vector<int>>& edges,\n                         vector<int>& queries) {\n    vector<int> ans(queries.size());\n\n    // count[i] := the number of edges of node i\n    vector<int> count(n + 1);\n\n    // shared[i][j] := the number of edges incident to i or j, where i < j\n    vector<unordered_map<int, int>> shared(n + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      ++count[u];\n      ++count[v];\n      ++shared[min(u, v)][max(u, v)];\n    }\n\n    vector<int> sortedCount(count);\n    ranges::sort(sortedCount);\n\n    int k = 0;\n    for (const int query : queries) {\n      for (int i = 1, j = n; i < j;)\n        if (sortedCount[i] + sortedCount[j] > query)\n          // sortedCount[i] + sortedCount[j] > query\n          // sortedCount[i + 1] + sortedCount[j] > query\n          // ...\n          // sortedCount[j - 1] + sortedCount[j] > query\n          // So, there are (j - 1) - i + 1 = j - i pairs > query\n          ans[k] += (j--) - i;\n        else\n          ++i;\n      for (int i = 1; i <= n; ++i)\n        for (const auto& [j, sh] : shared[i])\n          if (count[i] + count[j] > query && count[i] + count[j] - sh <= query)\n            --ans[k];\n      ++k;\n    }\n\n    return ans;\n  }\n};\n", "1784": "class Solution {\n public:\n  bool checkOnesSegment(string s) {\n    return s.find(\"01\") == string::npos;\n  }\n};\n", "1785": "class Solution {\n public:\n  int minElements(vector<int>& nums, int limit, int goal) {\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    const double diff = abs(goal - sum);\n    return ceil(diff / limit);\n  }\n};\n", "1786": "class Solution {\n public:\n  int countRestrictedPaths(int n, vector<vector<int>>& edges) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0] - 1;\n      const int v = edge[1] - 1;\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dijkstra(graph, 0, n - 1);\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {\n    constexpr int kMod = 1'000'000'007;\n    // ways[i] := the number of restricted path from i to n\n    vector<long> ways(graph.size());\n    // dist[i] := the distance to the last node of i\n    vector<long> dist(graph.size(), LONG_MAX);\n\n    ways[dst] = 1;\n    dist[dst] = 0;\n    using P = pair<long, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[dst], dst);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u]) {\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n        if (dist[v] < dist[u]) {\n          ways[u] += ways[v];\n          ways[u] %= kMod;\n        }\n      }\n    }\n\n    return ways[src];\n  }\n};\n", "1787": "class Solution {\n public:\n  int minChanges(vector<int>& nums, int k) {\n    constexpr int kMax = 1024;\n    const int n = nums.size();\n    // counts[i] := the counter that maps at the i-th position\n    vector<unordered_map<int, int>> counts(k);\n    // dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k -\n    // 1]) is j\n    vector<vector<int>> dp(k, vector<int>(kMax, n));\n\n    for (int i = 0; i < n; ++i)\n      ++counts[i % k][nums[i]];\n\n    auto countAt = [n, k](int i) -> int { return n / k + (n % k > i ? 1 : 0); };\n\n    // Initialize the DP array.\n    for (int j = 0; j < kMax; ++j)\n      dp[k - 1][j] =\n          countAt(k - 1) - (counts[k - 1].contains(j) ? counts[k - 1][j] : 0);\n\n    for (int i = k - 2; i >= 0; --i) {\n      // The worst-case scenario is changing all the i-th position numbers to a\n      // non-existent value in the current bucket.\n      const int changeAll = countAt(i) + ranges::min(dp[i + 1]);\n      for (int j = 0; j < kMax; ++j) {\n        dp[i][j] = changeAll;\n        for (const auto& [num, freq] : counts[i]) {\n          // the cost to change every number in the i-th position to `num`\n          const int cost = countAt(i) - freq;\n          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost);\n        }\n      }\n    }\n\n    return dp[0][0];\n  }\n};\n", "1788": "class Solution {\n public:\n  int maximumBeauty(vector<int>& flowers) {\n    int ans = INT_MIN;\n    int prefix = 0;\n    unordered_map<int, int> flowerToPrefix;\n\n    for (const int flower : flowers) {\n      if (const auto it = flowerToPrefix.find(flower);\n          it != flowerToPrefix.cend())\n        ans = max(ans, prefix - it->second + flower * 2);\n      prefix += max(0, flower);\n      if (!flowerToPrefix.contains(flower))\n        flowerToPrefix[flower] = prefix;\n    }\n\n    return ans;\n  }\n};\n", "179": "class Solution {\n public:\n  string largestNumber(vector<int>& nums) {\n    string ans;\n\n    ranges::sort(nums, [](int a, int b) {\n      return to_string(a) + to_string(b) > to_string(b) + to_string(a);\n    });\n\n    for (const int num : nums)\n      ans += to_string(num);\n\n    return ans[0] == '0' ? \"0\" : ans;\n  }\n};\n", "1790": "class Solution {\n public:\n  // Similar to 859. Buddy Strings\n  bool areAlmostEqual(string s1, string s2) {\n    vector<int> diffIndices;\n    for (int i = 0; i < s1.length(); ++i)\n      if (s1[i] != s2[i])\n        diffIndices.push_back(i);\n    return diffIndices.empty() || (diffIndices.size() == 2 &&\n                                   s1[diffIndices[0]] == s2[diffIndices[1]] &&\n                                   s1[diffIndices[1]] == s2[diffIndices[0]]);\n  }\n};\n", "1791": "class Solution {\n public:\n  int findCenter(vector<vector<int>>& edges) {\n    return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]\n               ? edges[0][0]\n               : edges[0][1];\n  }\n};\n", "1792": "class Solution {\n public:\n  double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\n    // (extra pass ratio, pass, total)\n    priority_queue<tuple<double, int, int>> maxHeap;\n\n    for (const vector<int>& c : classes) {\n      const int pass = c[0];\n      const int total = c[1];\n      maxHeap.emplace(extraPassRatio(pass, total), pass, total);\n    }\n\n    for (int i = 0; i < extraStudents; ++i) {\n      const auto [_, pass, total] = maxHeap.top();\n      maxHeap.pop();\n      maxHeap.emplace(extraPassRatio(pass + 1, total + 1), pass + 1, total + 1);\n    }\n\n    double ratioSum = 0;\n\n    while (!maxHeap.empty()) {\n      const auto [_, pass, total] = maxHeap.top();\n      maxHeap.pop();\n      ratioSum += pass / static_cast<double>(total);\n    }\n\n    return ratioSum / classes.size();\n  }\n\n private:\n  // Returns the extra pass ratio if a brilliant student joins.\n  double extraPassRatio(int pass, int total) {\n    return (pass + 1) / static_cast<double>(total + 1) -\n           pass / static_cast<double>(total);\n  }\n};\n", "1793": "class Solution {\n public:\n  int maximumScore(vector<int>& nums, int k) {\n    const int n = nums.size();\n    int ans = nums[k];\n    int mn = nums[k];\n    int i = k;\n    int j = k;\n\n    // Greedily expand the window and decrease the minimum as slow as possible.\n    while (i > 0 || j < n - 1) {\n      if (i == 0)\n        ++j;\n      else if (j == n - 1)\n        --i;\n      else if (nums[i - 1] < nums[j + 1])\n        ++j;\n      else  // nums[i - 1] >= nums[j + 1]\n        --i;\n      mn = min({mn, nums[i], nums[j]});\n      ans = max(ans, mn * (j - i + 1));\n    }\n\n    return ans;\n  }\n};\n", "1794": "class Solution {\n public:\n  int countQuadruples(const string& s1, const string& s2) {\n    // To minimize j - a, the length of the substring should be 1. This is\n    // because for substrings with a size greater than 1, a will decrease,\n    // causing j - a to become larger.\n    int ans = 0;\n    int diff = INT_MAX;  // diff := j - a\n    vector<int> firstJ(26, -1);\n    vector<int> lastA(26, -1);\n\n    for (int j = s1.length() - 1; j >= 0; --j)\n      firstJ[s1[j] - 'a'] = j;\n\n    for (int a = 0; a < s2.length(); ++a)\n      lastA[s2[a] - 'a'] = a;\n\n    for (int i = 0; i < 26; ++i) {\n      if (firstJ[i] == -1 || lastA[i] == -1)\n        continue;\n      if (firstJ[i] - lastA[i] < diff) {\n        diff = firstJ[i] - lastA[i];\n        ans = 0;\n      }\n      if (firstJ[i] - lastA[i] == diff)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1796": "class Solution {\n public:\n  int secondHighest(string s) {\n    int maxDigit = -1;\n    int secondMaxDigit = -1;\n\n    for (const char c : s)\n      if (isdigit(c)) {\n        const int digit = c - '0';\n        if (digit > maxDigit) {\n          secondMaxDigit = maxDigit;\n          maxDigit = digit;\n        } else if (maxDigit > digit && digit > secondMaxDigit) {\n          secondMaxDigit = digit;\n        }\n      }\n\n    return secondMaxDigit;\n  }\n};\n", "1797": "class AuthenticationManager {\n public:\n  AuthenticationManager(int timeToLive) : timeToLive(timeToLive) {}\n\n  void generate(string tokenId, int currentTime) {\n    tokenIdToExpiryTime[tokenId] = currentTime;\n    times.emplace(currentTime);\n  }\n\n  void renew(string tokenId, int currentTime) {\n    if (const auto it = tokenIdToExpiryTime.find(tokenId);\n        it == tokenIdToExpiryTime.cend() ||\n        currentTime >= it->second + timeToLive)\n      return;\n    times.erase(tokenIdToExpiryTime[tokenId]);\n    tokenIdToExpiryTime[tokenId] = currentTime;\n    times.emplace(currentTime);\n  }\n\n  int countUnexpiredTokens(int currentTime) {\n    const auto it = times.lower_bound(currentTime - timeToLive + 1);\n    // Remove expired tokens.\n    times.erase(times.begin(), it);\n    return times.size();\n  }\n\n private:\n  const int timeToLive;\n  unordered_map<string, int> tokenIdToExpiryTime;\n  set<int> times;\n};\n", "1798": "class Solution {\n public:\n  int getMaximumConsecutive(vector<int>& coins) {\n    int ans = 1;  // the next value we want to make\n\n    ranges::sort(coins);\n\n    for (const int coin : coins) {\n      if (coin > ans)\n        return ans;\n      ans += coin;\n    }\n\n    return ans;\n  }\n};\n", "1799": "class Solution {\n public:\n  int maxScore(vector<int>& nums) {\n    const int n = nums.size() / 2;\n    vector<vector<int>> mem(n + 1, vector<int>(1 << n * 2));\n    return maxScore(nums, 1, 0, mem);\n  }\n\n private:\n  // Returns the maximum score you can receive after performing the k to n\n  // operations, where `mask` is the bitmask of the chosen numbers.\n  int maxScore(const vector<int>& nums, int k, int mask,\n               vector<vector<int>>& mem) {\n    if (k == mem.size())\n      return 0;\n    if (mem[k][mask] > 0)\n      return mem[k][mask];\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = i + 1; j < nums.size(); ++j) {\n        const int chosenMask = 1 << i | 1 << j;\n        if ((mask & chosenMask) == 0)\n          mem[k][mask] = max(mem[k][mask],\n                             k * __gcd(nums[i], nums[j]) +\n                                 maxScore(nums, k + 1, mask | chosenMask, mem));\n      }\n\n    return mem[k][mask];\n  }\n};\n", "18": "class Solution {\n public:\n  vector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> ans;\n    vector<int> path;\n    ranges::sort(nums);\n    nSum(nums, 4, target, 0, nums.size() - 1, path, ans);\n    return ans;\n  }\n\n private:\n  // Finds n numbers that add up to the target in [l, r].\n  void nSum(const vector<int>& nums, long n, long target, int l, int r,\n            vector<int>& path, vector<vector<int>>& ans) {\n    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)\n      return;\n    if (n == 2) {\n      // Similar to the sub procedure in 15. 3Sum\n      while (l < r) {\n        const int sum = nums[l] + nums[r];\n        if (sum == target) {\n          path.push_back(nums[l]);\n          path.push_back(nums[r]);\n          ans.push_back(path);\n          path.pop_back();\n          path.pop_back();\n          ++l;\n          --r;\n          while (l < r && nums[l] == nums[l - 1])\n            ++l;\n          while (l < r && nums[r] == nums[r + 1])\n            --r;\n        } else if (sum < target) {\n          ++l;\n        } else {\n          --r;\n        }\n      }\n      return;\n    }\n\n    for (int i = l; i <= r; ++i) {\n      if (i > l && nums[i] == nums[i - 1])\n        continue;\n      path.push_back(nums[i]);\n      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);\n      path.pop_back();\n    }\n  }\n};\n", "1800": "class Solution {\n public:\n  int maxAscendingSum(vector<int>& nums) {\n    int ans = 0;\n    int sum = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1]) {\n        sum += nums[i];\n      } else {\n        ans = max(ans, sum);\n        sum = nums[i];\n      }\n\n    return max(ans, sum);\n  }\n};\n", "1801": "class Solution {\n public:\n  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    priority_queue<vector<int>> buysMaxHeap;\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> sellsMinHeap;\n\n    for (const vector<int>& order : orders) {\n      if (order[2] == 0)\n        buysMaxHeap.push(order);\n      else\n        sellsMinHeap.push(order);\n      while (!buysMaxHeap.empty() && !sellsMinHeap.empty() &&\n             buysMaxHeap.top()[0] >= sellsMinHeap.top()[0]) {\n        const int minAmount = min(buysMaxHeap.top()[1], sellsMinHeap.top()[1]);\n        vector<int> buysMaxHeapTop = buysMaxHeap.top();\n        buysMaxHeap.pop();\n        buysMaxHeapTop[1] -= minAmount;\n        if (buysMaxHeapTop[1] > 0)\n          buysMaxHeap.push(buysMaxHeapTop);\n\n        vector<int> sellsMinHeapTop = sellsMinHeap.top();\n        sellsMinHeap.pop();\n        sellsMinHeapTop[1] -= minAmount;\n        if (sellsMinHeapTop[1] > 0)\n          sellsMinHeap.push(sellsMinHeapTop);\n      }\n    }\n\n    while (!buysMaxHeap.empty()) {\n      ans += buysMaxHeap.top()[1], buysMaxHeap.pop();\n      ans %= kMod;\n    }\n\n    while (!sellsMinHeap.empty()) {\n      ans += sellsMinHeap.top()[1], sellsMinHeap.pop();\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "1802": "class Solution {\n public:\n  int maxValue(int n, int index, int maxSum) {\n    maxSum -= n;\n\n    int l = 0;\n    int r = maxSum;\n\n    // Find the first value x s.t. if A[index] = x, then sum(A) >= maxSum.\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (getSum(n, index, m) >= maxSum)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return getSum(n, index, l) > maxSum ? l : l + 1;\n  }\n\n private:\n  // Returns the minimum sum if nums[index] = x.\n  long getSum(int n, int index, int x) {\n    long l = min(index, x - 1);\n    long r = min(n - index, x);\n    long lSum = ((x - 1) + (x - 1 - l + 1)) * l / 2;\n    long rSum = (x + (x - r + 1)) * r / 2;\n    return lSum + rSum;\n  }\n};\n", "1803": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int count = 0;\n  TrieNode() : children(2) {}\n};\n\nclass Solution {\n public:\n  int countPairs(vector<int>& nums, int low, int high) {\n    int ans = 0;\n\n    for (const int num : nums) {\n      ans += getCount(num, high + 1) - getCount(num, low);\n      insert(num);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kHeight = 14;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = kHeight; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n      ++node->count;\n    }\n  }\n\n  // Returns the number of numbers < limit.\n  int getCount(int num, int limit) {\n    int count = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = kHeight; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      const int bitLimit = limit >> i & 1;\n      if (bitLimit == 1) {\n        if (node->children[bit] != nullptr)\n          count += node->children[bit]->count;\n        node = node->children[bit ^ 1];\n      } else {\n        node = node->children[bit];\n      }\n      if (node == nullptr)\n        break;\n    }\n    return count;\n  }\n};\n", "1804": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int prefixCount = 0;\n  int wordCount = 0;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  void insert(string word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      ++node->prefixCount;\n    }\n    ++node->wordCount;\n  }\n\n  int countWordsEqualTo(string word) {\n    shared_ptr<TrieNode> node = find(word);\n    return node ? node->wordCount : 0;\n  }\n\n  int countWordsStartingWith(string prefix) {\n    shared_ptr<TrieNode> node = find(prefix);\n    return node ? node->prefixCount : 0;\n  }\n\n  void erase(string word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      node = node->children[i];\n      --node->prefixCount;\n    }\n    --node->wordCount;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  shared_ptr<TrieNode> find(const string& s) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : s) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return nullptr;\n      node = node->children[i];\n    }\n    return node;\n  }\n};\n", "1805": "class Solution {\n public:\n  int numDifferentIntegers(string word) {\n    unordered_set<string> nums;\n    string curr;\n\n    for (const char c : word)\n      if (isdigit(c)) {\n        curr += c;\n      } else if (curr.length() > 0) {\n        nums.insert(removeLeadingZeros(curr));\n        curr = \"\";\n      }\n\n    if (curr.length() > 0)\n      nums.insert(removeLeadingZeros(curr));\n    return nums.size();\n  }\n\n private:\n  string removeLeadingZeros(const string& s) {\n    const int index = s.find_first_not_of('0');\n    return index == string::npos ? \"0\" : s.substr(index);\n  }\n};\n", "1806": "class Solution {\n public:\n  int reinitializePermutation(int n) {\n    int ans = 0;\n    int i = 1;\n\n    do {\n      if (i < n / 2)\n        i = i * 2;\n      else\n        i = (i - n / 2) * 2 + 1;\n      ++ans;\n    } while (i != 1);\n\n    return ans;\n  }\n};\n", "1807": "class Solution {\n public:\n  string evaluate(string s, vector<vector<string>>& knowledge) {\n    string ans;\n    unordered_map<string, string> map;\n\n    for (const vector<string>& list : knowledge)\n      map[\"(\" + list[0] + \")\"] = list[1];\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (c == '(') {\n        const int j = s.find_first_of(')', i);\n        const string& key = s.substr(i, j - i + 1);\n        ans += map.contains(key) ? map[key] : \"?\";\n        i = j;\n      } else {\n        ans += c;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1808": "class Solution {\n public:\n  int maxNiceDivisors(int primeFactors) {\n    if (primeFactors <= 3)\n      return primeFactors;\n    if (primeFactors % 3 == 0)\n      return modPow(3, primeFactors / 3) % kMod;\n    if (primeFactors % 3 == 1)\n      return 4L * modPow(3, (primeFactors - 4) / 3) % kMod;\n    return 2L * modPow(3, (primeFactors - 2) / 3) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "1810": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *  public:\n *   bool canMove(char direction);\n *   int std::move(char direction);\n *   boolean isTarget();\n * };\n */\n\nclass Solution {\n public:\n  int findShortestPath(GridMaster& master) {\n    constexpr int m = 100;\n    constexpr int startX = m;\n    constexpr int startY = m;\n    vector<int> target{m * 2, m * 2};\n    vector<vector<int>> grid(m * 2, vector<int>(m * 2, -1));\n    vector<vector<bool>> seen(m * 2, vector<bool>(m * 2));\n\n    // Build the grid information by DFS.\n    dfs(master, grid, startX, startY, target);\n\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> minHeap;\n    minHeap.push({0, startX, startY});\n\n    // Find the steps by BFS.\n    while (!minHeap.empty()) {\n      const vector<int> tuple = minHeap.top();\n      const int cost = tuple[0];\n      const int i = tuple[1];\n      const int j = tuple[2];\n      minHeap.pop();\n      if (i == target[0] && j == target[1])\n        return cost;\n      if (seen[i][j])\n        continue;\n      seen[i][j] = true;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == 2 * m || y < 0 || y == 2 * m)\n          continue;\n        if (seen[x][y] || grid[x][y] == -1)\n          continue;\n        const int nextCost = cost + grid[x][y];\n        minHeap.push({nextCost, x, y});\n      }\n    }\n\n    return -1;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n  static constexpr char charTable[4] = {'R', 'D', 'L', 'U'};\n\n  void dfs(GridMaster& master, vector<vector<int>>& grid, int i, int j,\n           vector<int>& target) {\n    if (master.isTarget()) {\n      target[0] = i;\n      target[1] = j;\n    }\n\n    for (int k = 0; k < 4; ++k) {\n      const int x = i + kDirs[k][0];\n      const int y = j + kDirs[k][1];\n      const char d = charTable[k];\n      const char undoD = charTable[(k + 2) % 4];\n      if (master.canMove(d) && grid[x][y] == -1) {\n        grid[x][y] = master.move(d);\n        dfs(master, grid, x, y, target);\n        master.move(undoD);\n      }\n    }\n  }\n};\n", "1812": "class Solution {\n public:\n  bool squareIsWhite(string coordinates) {\n    const char letter = coordinates[0];\n    const char digit = coordinates[1];\n    return letter % 2 != digit % 2;\n  }\n};\n", "1813": "class Solution {\n public:\n  bool areSentencesSimilar(string sentence1, string sentence2) {\n    if (sentence1.length() == sentence2.length())\n      return sentence1 == sentence2;\n\n    vector<string> words1 = split(sentence1);\n    vector<string> words2 = split(sentence2);\n    const int m = words1.size();\n    const int n = words2.size();\n    if (m > n)\n      return areSentencesSimilar(sentence2, sentence1);\n\n    int i = 0;  // words1's index\n    while (i < m && words1[i] == words2[i])\n      ++i;\n    while (i < m && words1[i] == words2[i + n - m])\n      ++i;\n\n    return i == m;\n  }\n\n private:\n  vector<string> split(const string& sentence) {\n    vector<string> words;\n    istringstream iss(sentence);\n\n    for (string s; iss >> s;)\n      words.push_back(s);\n\n    return words;\n  }\n};\n", "1814": "class Solution {\n public:\n  int countNicePairs(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    unordered_map<int, long> count;\n\n    for (const int num : nums)\n      ++count[num - rev(num)];\n\n    for (const auto& [_, freq] : count) {\n      ans += freq * (freq - 1) / 2;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  int rev(int n) {\n    int x = 0;\n    while (n > 0) {\n      x = x * 10 + (n % 10);\n      n /= 10;\n    }\n    return x;\n  }\n};\n", "1815": "class Solution {\n public:\n  int maxHappyGroups(int batchSize, vector<int>& groups) {\n    int happy = 0;\n    vector<int> freq(batchSize);\n\n    for (int g : groups) {\n      g %= batchSize;\n      if (g == 0) {\n        ++happy;\n      } else if (freq[batchSize - g]) {\n        --freq[batchSize - g];\n        ++happy;\n      } else {\n        ++freq[g];\n      }\n    }\n\n    return happy + dp(freq, 0, batchSize);\n  }\n\n private:\n  map<vector<int>, int> mem;\n\n  // Returns the maximum number of partitions can be formed.\n  int dp(const vector<int>& freq, int remainder, const int& batchSize) {\n    if (const auto it = mem.find(freq); it != mem.cend())\n      return it->second;\n\n    int ans = 0;\n\n    if (ranges::any_of(freq, [](int f) { return f != 0; })) {\n      for (int i = 0; i < freq.size(); ++i)\n        if (freq[i]) {\n          vector<int> newFreq(freq);\n          --newFreq[i];\n          ans = max(ans, dp(newFreq, (remainder + i) % batchSize, batchSize));\n        }\n      if (remainder == 0)\n        ++ans;\n    }\n\n    return mem[freq] = ans;\n  }\n};\n", "1816": "class Solution {\n public:\n  string truncateSentence(string s, int k) {\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == ' ' && --k == 0)\n        return s.substr(0, i);\n    return s;\n  }\n};\n", "1817": "class Solution {\n public:\n  vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {\n    vector<int> ans(k);\n    unordered_map<int, unordered_set<int>> idToTimes;\n\n    for (const vector<int>& log : logs)\n      idToTimes[log[0]].insert(log[1]);\n\n    for (const auto& [_, mins] : idToTimes)\n      ++ans[mins.size() - 1];\n\n    return ans;\n  }\n};\n", "1818": "class Solution {\n public:\n  int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {\n    constexpr int kMod = 1'000'000'007;\n    long sumDiff = 0;\n    long maxDecrement = 0;\n    set<int> sorted(nums1.begin(), nums1.end());\n\n    for (int i = 0; i < nums1.size(); ++i) {\n      const long currDiff = abs(nums1[i] - nums2[i]);\n      sumDiff += currDiff;\n      const auto it = sorted.lower_bound(nums2[i]);\n      if (it != sorted.begin())\n        maxDecrement = max(maxDecrement, currDiff - abs(*prev(it) - nums2[i]));\n      if (it != sorted.end())\n        maxDecrement = max(maxDecrement, currDiff - abs(*it - nums2[i]));\n    }\n\n    return (sumDiff - maxDecrement) % kMod;\n  }\n};\n", "1819": "class Solution {\n public:\n  int countDifferentSubsequenceGCDs(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    int ans = 0;\n    // factor[i] := the GCD of numbers having factor i\n    vector<int> factor(maxNum + 1);\n\n    for (const int num : nums)\n      for (int i = 1; i * i <= num; ++i)\n        if (num % i == 0) {\n          const int j = num / i;\n          factor[i] = __gcd(factor[i], num);\n          factor[j] = __gcd(factor[j], num);\n        }\n\n    for (int i = 1; i <= maxNum; ++i)\n      if (factor[i] == i)\n        ++ans;\n\n    return ans;\n  }\n};\n", "1820": "class Solution {\n public:\n  int maximumInvitations(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    vector<int> mates(n, -1);  // mates[i] := the i-th girl's mate\n\n    for (int i = 0; i < m; ++i)\n      if (canInvite(grid, i, vector<bool>(n), mates))\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  // Returns true if the i-th boy can make an invitation.\n  bool canInvite(const vector<vector<int>>& grid, int i, vector<bool>&& seen,\n                 vector<int>& mates) {\n    // The i-th boy asks each girl.\n    for (int j = 0; j < seen.size(); ++j) {\n      if (!grid[i][j] || seen[j])\n        continue;\n      seen[j] = true;\n      if (mates[j] == -1 || canInvite(grid, mates[j], std::move(seen), mates)) {\n        mates[j] = i;  // Match the j-th girl with i-th boy.\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n", "1822": "class Solution {\n public:\n  int arraySign(vector<int>& nums) {\n    int sign = 1;\n\n    for (const int num : nums) {\n      if (num == 0)\n        return 0;\n      if (num < 0)\n        sign = -sign;\n    }\n\n    return sign;\n  }\n};\n", "1823": "class Solution {\n public:\n  int findTheWinner(int n, int k) {\n    // Converts back to 1-indexed.\n    return f(n, k) + 1;\n  }\n\n  // e.g. n = 4, k = 2.\n  // By using 0-indexed notation, we have the following circle:\n  //\n  // 0 -> 1 -> 2 -> 3 -> 0\n  //      x\n  //           0 -> 1 -> 2 -> 0\n  //\n  // After the first round, 1 is removed.\n  // So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n  // Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n  // By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n private:\n  int f(int n, int k) {\n    if (n == 1)\n      return 0;\n    return (f(n - 1, k) + k) % n;\n  }\n};\n", "1824": "class Solution {\n public:\n  int minSideJumps(vector<int>& obstacles) {\n    constexpr int kInf = 1'000'000;\n    // dp[i] := the minimum jump to reach the i-th lane\n    vector<int> dp{kInf, 1, 0, 1};\n\n    for (const int obstacle : obstacles) {\n      if (obstacle > 0)\n        dp[obstacle] = kInf;\n      for (int i = 1; i <= 3; ++i)  // the current\n        if (i != obstacle)\n          for (int j = 1; j <= 3; ++j)  // the previous\n            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});\n    }\n\n    return ranges::min(dp);\n  }\n};\n", "1825": "struct MyMap {\n  map<int, int> map;\n  int size = 0;\n  long sum = 0;\n};\n\nclass MKAverage {\n public:\n  MKAverage(int m, int k) : m(m), k(k), kMidSize(m - 2 * k) {}\n\n  void addElement(int num) {\n    q.push(num);\n    add(num);\n\n    if (q.size() > m) {\n      const int removed = q.front();\n      q.pop();\n      remove(removed);\n    }\n  }\n\n  int calculateMKAverage() {\n    return q.size() == m ? mid.sum / kMidSize : -1;\n  }\n\n private:\n  const int m;\n  const int k;\n  const int kMidSize;\n  queue<int> q;\n  MyMap top;\n  MyMap mid;\n  MyMap bot;\n\n  void add(int num) {\n    add(bot, num);\n    if (bot.size > k)\n      add(mid, remove(bot, bot.map.rbegin()->first));\n    if (mid.size > kMidSize)\n      add(top, remove(mid, mid.map.rbegin()->first));\n  }\n\n  void remove(int num) {\n    if (bot.map.contains(num))\n      remove(bot, num);\n    else if (mid.map.contains(num))\n      remove(mid, num);\n    else\n      remove(top, num);\n\n    if (bot.size < k)\n      add(bot, remove(mid, mid.map.begin()->first));\n    if (mid.size < kMidSize)\n      add(mid, remove(top, top.map.begin()->first));\n  }\n\n  void add(MyMap& m, int num) {\n    ++m.map[num];\n    ++m.size;\n    m.sum += num;\n  }\n\n  int remove(MyMap& m, int num) {\n    if (--m.map[num] == 0)\n      m.map.erase(num);\n    --m.size;\n    m.sum -= num;\n    return num;\n  }\n};\n", "1826": "class Solution {\n public:\n  int badSensor(vector<int>& sensor1, vector<int>& sensor2) {\n    const bool oneDefect = canReplace(sensor2, sensor1);\n    const bool twoDefect = canReplace(sensor1, sensor2);\n    if (oneDefect && twoDefect)\n      return -1;\n    if (!oneDefect && !twoDefect)\n      return -1;\n    return oneDefect ? 1 : 2;\n  }\n\n private:\n  bool canReplace(const vector<int>& A, const vector<int>& B) {\n    int i = 0;  // A's index\n    int j = 0;  // B's index\n    int droppedValue = -1;\n\n    while (i < A.size())\n      if (A[i] == B[j]) {\n        ++i;\n        ++j;\n      } else {\n        droppedValue = A[i];\n        ++i;\n      }\n\n    return j == B.size() - 1 && B[j] != droppedValue;\n  }\n};\n", "1827": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n    int last = 0;\n\n    for (const int num : nums) {\n      ans += max(0, last - num + 1);\n      last = max(num, last + 1);\n    }\n\n    return ans;\n  }\n};\n", "1828": "class Solution {\n public:\n  vector<int> countPoints(vector<vector<int>>& points,\n                          vector<vector<int>>& queries) {\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int xj = query[0];\n      const int yj = query[1];\n      const int rj = query[2];\n      int count = 0;\n      for (const vector<int>& point : points) {\n        const int xi = point[0];\n        const int yi = point[1];\n        if (squared(xi - xj) + squared(yi - yj) <= squared(rj))\n          ++count;\n      }\n      ans.push_back(count);\n    }\n\n    return ans;\n  }\n\n private:\n  int squared(int x) {\n    return x * x;\n  }\n};\n", "1829": "class Solution {\n public:\n  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\n    const int mx = (1 << maximumBit) - 1;\n    vector<int> ans;\n    int xors = 0;\n\n    for (const int num : nums) {\n      xors ^= num;\n      ans.push_back(xors ^ mx);\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "1830": "class Solution {\n public:\n  int makeStringSorted(string s) {\n    const int n = s.length();\n    const auto [fact, invFact] = getFactAndInvFact(n);\n    int ans = 0;\n    vector<int> count(26);\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int order = s[i] - 'a';\n      ++count[order];\n      long perm = accumulate(count.begin(), count.begin() + order, 0) *\n                  fact[n - 1 - i] % kMod;\n      for (int j = 0; j < 26; ++j)\n        perm = perm * invFact[count[j]] % kMod;\n      ans = (ans + perm) % kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n};\n", "1832": "class Solution {\n public:\n  bool checkIfPangram(string sentence) {\n    int seen = 0;\n\n    for (const char c : sentence)\n      seen |= 1 << c - 'a';\n\n    return seen == (1 << 26) - 1;\n  }\n};\n", "1833": "class Solution {\n public:\n  int maxIceCream(vector<int>& costs, int coins) {\n    ranges::sort(costs);\n\n    for (int i = 0; i < costs.size(); ++i)\n      if (coins >= costs[i])\n        coins -= costs[i];\n      else\n        return i;\n\n    return costs.size();\n  }\n};\n", "1834": "class Solution {\n public:\n  vector<int> getOrder(vector<vector<int>>& tasks) {\n    const int n = tasks.size();\n\n    // Add index information.\n    for (int i = 0; i < n; ++i)\n      tasks[i].push_back(i);\n\n    vector<int> ans;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\n    int i = 0;      // tasks' index\n    long time = 0;  // the current time\n\n    ranges::sort(tasks);\n    while (i < n || !minHeap.empty()) {\n      if (minHeap.empty())\n        time = max(time, static_cast<long>(tasks[i][0]));\n      while (i < n && time >= tasks[i][0]) {\n        minHeap.emplace(tasks[i][1], tasks[i][2]);\n        ++i;\n      }\n      const auto [procTime, index] = minHeap.top();\n      minHeap.pop();\n      time += procTime;\n      ans.push_back(index);\n    }\n\n    return ans;\n  }\n};\n", "1835": "class Solution {\n public:\n  int getXORSum(vector<int>& arr1, vector<int>& arr2) {\n    const int xors1 = accumulate(arr1.begin(), arr1.end(), 0, bit_xor<>());\n    const int xors2 = accumulate(arr2.begin(), arr2.end(), 0, bit_xor<>());\n    return xors1 & xors2;\n  }\n};\n", "1836": "class Solution {\n public:\n  ListNode* deleteDuplicatesUnsorted(ListNode* head) {\n    ListNode dummy(0, head);\n    unordered_map<int, int> count;\n\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++count[curr->val];\n\n    ListNode* curr = &dummy;\n\n    while (curr != nullptr) {\n      while (curr->next && count.contains(curr->next->val) &&\n             count[curr->next->val] > 1)\n        curr->next = curr->next->next;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "1837": "class Solution {\n public:\n  int sumBase(int n, int k) {\n    int ans = 0;\n\n    while (n > 0) {\n      ans += n % k;\n      n /= k;\n    }\n\n    return ans;\n  }\n};\n", "1838": "class Solution {\n public:\n  int maxFrequency(vector<int>& nums, int k) {\n    int ans = 0;\n    long sum = 0;\n\n    ranges::sort(nums);\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      sum += nums[r];\n      while (sum + k < static_cast<long>(nums[r]) * (r - l + 1))\n        sum -= nums[l++];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "1839": "class Solution {\n public:\n  int longestBeautifulSubstring(string word) {\n    int ans = 0;\n    int count = 1;\n\n    for (int l = 0, r = 1; r < word.length(); ++r) {\n      const char curr = word[r];\n      const char prev = word[r - 1];\n      if (curr >= prev) {\n        if (curr > prev)\n          ++count;\n        if (count == 5)\n          ans = max(ans, r - l + 1);\n      } else {\n        count = 1;\n        l = r;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1840": "class Solution {\n public:\n  int maxBuilding(int n, vector<vector<int>>& restrictions) {\n    vector<vector<int>> A(restrictions);\n\n    A.push_back({1, 0});\n    A.push_back({n, n - 1});\n    ranges::sort(A);\n\n    for (int i = 1; i < A.size(); ++i) {\n      const int dist = A[i][0] - A[i - 1][0];\n      A[i][1] = min(A[i][1], A[i - 1][1] + dist);\n    }\n\n    for (int i = A.size() - 2; i >= 0; --i) {\n      const int dist = A[i + 1][0] - A[i][0];\n      A[i][1] = min(A[i][1], A[i + 1][1] + dist);\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i < A.size(); ++i) {\n      const int l = A[i - 1][0];\n      const int r = A[i][0];\n      const int hL = A[i - 1][1];\n      const int hR = A[i][1];\n      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) / 2);\n    }\n\n    return ans;\n  }\n};\n", "1842": "class Solution {\n public:\n  string nextPalindrome(string num) {\n    const int n = num.length();\n    vector<int> arr(n / 2);\n\n    for (int i = 0; i < arr.size(); ++i)\n      arr[i] = num[i] - '0';\n\n    if (!ranges::next_permutation(arr).found)\n      return \"\";\n\n    string s;\n\n    for (const int a : arr)\n      s += '0' + a;\n\n    if (n % 2 == 1)\n      return s + num[n / 2] + reversed(s);\n    return s + reversed(s);\n  }\n\n private:\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n};\n", "1844": "class Solution {\n public:\n  string replaceDigits(string s) {\n    for (int i = 1; i < s.length(); i += 2)\n      s[i] += s[i - 1] - '0';\n    return s;\n  }\n};\n", "1845": "class SeatManager {\n public:\n  SeatManager(int n) {}\n\n  int reserve() {\n    if (minHeap.empty())\n      return ++num;\n\n    const int minNum = minHeap.top();\n    minHeap.pop();\n    return minNum;\n  }\n\n  void unreserve(int seatNumber) {\n    minHeap.push(seatNumber);\n  }\n\n private:\n  priority_queue<int, vector<int>, greater<>> minHeap;\n  int num = 0;\n};\n", "1846": "class Solution {\n public:\n  int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {\n    ranges::sort(arr);\n    arr[0] = 1;\n\n    for (int i = 1; i < arr.size(); ++i)\n      arr[i] = min(arr[i], arr[i - 1] + 1);\n\n    return arr.back();\n  }\n};\n", "1847": "class Solution {\n public:\n  vector<int> closestRoom(vector<vector<int>>& rooms,\n                          vector<vector<int>>& queries) {\n    vector<int> ans(queries.size());\n    set<int> roomIds;\n\n    for (int i = 0; i < queries.size(); ++i)\n      queries[i].push_back(i);\n\n    ranges::sort(rooms, ranges::greater{},\n                 [](const vector<int>& room) { return room[1]; });\n    ranges::sort(queries, ranges::greater{},\n                 [](const vector<int>& query) { return query[1]; });\n\n    int i = 0;  // rooms' index\n    for (const vector<int>& query : queries) {\n      while (i < rooms.size() && rooms[i][1] >= query[1])\n        roomIds.insert(rooms[i++][0]);\n      ans[query[2]] = searchClosestRoomId(roomIds, query[0]);\n    }\n\n    return ans;\n  }\n\n private:\n  int searchClosestRoomId(set<int>& roomIds, int preferred) {\n    const auto it = roomIds.lower_bound(preferred);\n    const int id1 = it == roomIds.cbegin() ? -1 : *(prev(it));\n    const int id2 = it == roomIds.cend() ? -1 : *it;\n    if (id1 == -1)\n      return id2;\n    if (id2 == -1)\n      return id1;\n    if (abs(preferred - id1) <= abs(preferred - id2))\n      return id1;\n    return id2;\n  }\n};\n", "1848": "class Solution {\n public:\n  int getMinDistance(vector<int>& nums, int target, int start) {\n    int ans = INT_MAX;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == target)\n        ans = min(ans, abs(i - start));\n\n    return ans;\n  }\n};\n", "1849": "class Solution {\n public:\n  bool splitString(string s) {\n    return isValid(s, 0, -1, 0);\n  }\n\n private:\n  bool isValid(const string& s, int start, long prev, int segment) {\n    if (start == s.length() && segment > 1)\n      return true;\n\n    long curr = 0;\n    for (int i = start; i < s.length(); ++i) {\n      curr = curr * 10 + s[i] - '0';\n      if (curr > 9999999999L)\n        return false;\n      if ((prev == -1 || curr == prev - 1) &&\n          isValid(s, i + 1, curr, segment + 1)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n", "1850": "class Solution {\n public:\n  int getMinSwaps(string num, int k) {\n    string perm = num;\n\n    while (k-- > 0)\n      next_permutation(perm.begin(), perm.end());\n\n    return countSteps(num, perm);\n  }\n\n private:\n  int countSteps(const string& A, string& B) {\n    int count = 0;\n\n    for (int i = 0, j = 0; i < A.length(); ++i) {\n      j = i;\n      while (A[i] != B[j])\n        ++j;\n      while (i < j) {\n        swap(B[j], B[j - 1]);\n        --j;\n        ++count;\n      }\n    }\n\n    return count;\n  }\n};\n", "1851": "struct T {\n  int size;\n  int right;\n};\n\nclass Solution {\n public:\n  vector<int> minInterval(vector<vector<int>>& intervals,\n                          vector<int>& queries) {\n    vector<int> ans(queries.size(), -1);\n    auto compare = [](const T& a, const T& b) { return a.size > b.size; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    vector<vector<int>> qs;\n\n    for (int i = 0; i < queries.size(); ++i)\n      qs.push_back({queries[i], i});\n\n    ranges::sort(intervals);\n    ranges::sort(qs);\n\n    int i = 0;  // intervals' index\n    for (const vector<int>& q : qs) {\n      while (i < intervals.size() && intervals[i][0] <= q[0]) {\n        minHeap.emplace(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);\n        ++i;\n      }\n      while (!minHeap.empty() && minHeap.top().right < q[0])\n        minHeap.pop();\n      if (!minHeap.empty())\n        ans[q[1]] = minHeap.top().size;\n    }\n\n    return ans;\n  }\n};\n", "1852": "class Solution {\n public:\n  vector<int> distinctNumbers(vector<int>& nums, int k) {\n    vector<int> ans;\n    int distinct = 0;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (++count[nums[i]] == 1)\n        ++distinct;\n      if (i >= k && --count[nums[i - k]] == 0)\n        --distinct;\n      if (i >= k - 1)\n        ans.push_back(distinct);\n    }\n\n    return ans;\n  }\n};\n", "1854": "class Solution {\n public:\n  int maximumPopulation(vector<vector<int>>& logs) {\n    constexpr int kMinYear = 1950;\n    constexpr int kMaxYear = 2050;\n    int ans = 0;\n    int maxPopulation = 0;\n    int runningPopulation = 0;\n    // population[i] := the population of year i\n    vector<int> population(kMaxYear + 1);\n\n    for (const vector<int>& log : logs) {\n      const int birth = log[0];\n      const int death = log[1];\n      ++population[birth];\n      --population[death];\n    }\n\n    for (int year = kMinYear; year <= kMaxYear; ++year) {\n      runningPopulation += population[year];\n      if (runningPopulation > maxPopulation) {\n        maxPopulation = runningPopulation;\n        ans = year;\n      }\n    }\n\n    return ans;\n  }\n};\n", "1855": "class Solution {\n public:\n  int maxDistance(vector<int>& nums1, vector<int>& nums2) {\n    int i = 0;\n    int j = 0;\n\n    for (; i < nums1.size() && j < nums2.size(); ++j)\n      if (nums1[i] > nums2[j])\n        ++i;\n\n    return i == j ? 0 : j - i - 1;\n  }\n};\n", "1856": "class Solution {\n public:\n  int maxSumMinProduct(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    stack<int> stack;\n    vector<long> prefix(nums.size() + 1);\n\n    for (int i = 0; i < nums.size(); ++i)\n      prefix[i + 1] = prefix[i] + nums[i];\n\n    for (int i = 0; i <= nums.size(); ++i) {\n      while (!stack.empty() &&\n             (i == nums.size() || nums[stack.top()] > nums[i])) {\n        const int minVal = nums[stack.top()];\n        stack.pop();\n        const long sum =\n            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];\n        ans = max(ans, minVal * sum);\n      }\n      stack.push(i);\n    }\n\n    return ans % kMod;\n  }\n};\n", "1857": "class Solution {\n public:\n  int largestPathValue(string colors, vector<vector<int>>& edges) {\n    const int n = colors.length();\n    int ans = 0;\n    int processed = 0;\n    vector<vector<int>> graph(n);\n    vector<int> inDegrees(n);\n    queue<int> q;\n    vector<vector<int>> count(n, vector<int>(26));\n\n    // Build the graph.\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty()) {\n      const int out = q.front();\n      q.pop();\n      ++processed;\n      ans = max(ans, ++count[out][colors[out] - 'a']);\n      for (const int in : graph[out]) {\n        for (int i = 0; i < 26; ++i)\n          count[in][i] = max(count[in][i], count[out][i]);\n        if (--inDegrees[in] == 0)\n          q.push(in);\n      }\n    }\n\n    return processed == n ? ans : -1;\n  }\n};\n", "1858": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  string longestWord(vector<string>& words) {\n    string ans;\n\n    for (const string& word : words)\n      insert(word);\n\n    for (const string& word : words) {\n      if (!allPrefixed(word))\n        continue;\n      if (ans.length() < word.length() ||\n          (ans.length() == word.length() && ans > word))\n        ans = word;\n    }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool allPrefixed(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      node = node->children[i];\n      if (!node->isWord)\n        return false;\n    }\n    return true;\n  }\n};\n", "1859": "class Solution {\n public:\n  string sortSentence(string s) {\n    vector<string> words;\n    istringstream iss(s);\n    string word;\n\n    while (iss >> word)\n      words.push_back(word);\n\n    ranges::sort(words, ranges::less(),\n                 [](const string& word) { return word.back(); });\n\n    string ans = trim(words[0]);\n\n    for (int i = 1; i < words.size(); ++i)\n      ans += \" \" + trim(words[i]);\n\n    return ans;\n  }\n\n private:\n  string trim(const string& s) {\n    return s.substr(0, s.length() - 1);\n  }\n};\n", "186": "class Solution {\n public:\n  void reverseWords(vector<char>& s) {\n    ranges::reverse(s);         // Reverse the whole string.\n    reverseWords(s, s.size());  // Reverse each word.\n  }\n\n private:\n  void reverseWords(vector<char>& s, int n) {\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n      while (i < j || i < n && s[i] == ' ')  // Skip the spaces.\n        ++i;\n      while (j < i || j < n && s[j] != ' ')  // Skip the spaces.\n        ++j;\n      reverse(s.begin() + i, s.begin() + j);  // Reverse the word.\n    }\n  }\n};\n", "1860": "class Solution {\n public:\n  vector<int> memLeak(int memory1, int memory2) {\n    int i = 1;\n\n    while (memory1 >= i || memory2 >= i) {\n      if (memory1 >= memory2)\n        memory1 -= i;\n      else\n        memory2 -= i;\n      ++i;\n    }\n\n    return {i, memory1, memory2};\n  }\n};\n", "1861": "class Solution {\n public:\n  vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {\n    const int m = box.size();\n    const int n = box[0].size();\n    vector<vector<char>> ans(n, vector<char>(m, '.'));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = n - 1, k = n - 1; j >= 0; --j)\n        if (box[i][j] != '.') {\n          if (box[i][j] == '*')\n            k = j;\n          ans[k--][m - i - 1] = box[i][j];\n        }\n\n    return ans;\n  }\n};\n", "1862": "class Solution {\n public:\n  int sumOfFlooredPairs(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int kMax = ranges::max(nums);\n    long ans = 0;\n    // count[i] := the number of `nums` <= i\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = 1; i <= kMax; ++i)\n      count[i] += count[i - 1];\n\n    for (int i = 1; i <= kMax; ++i)\n      if (count[i] > count[i - 1]) {\n        long sum = 0;\n        for (int j = 1; i * j <= kMax; ++j) {\n          const int lo = i * j - 1;\n          const int hi = i * (j + 1) - 1;\n          sum += (count[min(hi, kMax)] - count[lo]) * j;\n        }\n        ans += sum * (count[i] - count[i - 1]);\n        ans %= kMod;\n      }\n\n    return ans;\n  }\n};\n", "1863": "class Solution {\n public:\n  int subsetXORSum(vector<int>& nums) {\n    return accumulate(nums.begin(), nums.end(), 0, bit_or<>())\n           << nums.size() - 1;\n  }\n};\n", "1864": "class Solution {\n public:\n  int minSwaps(string s) {\n    const int ones = ranges::count(s, '1');\n    const int zeros = s.length() - ones;\n    if (abs(ones - zeros) > 1)\n      return -1;\n    if (ones > zeros)\n      return countSwaps(s, '1');\n    if (zeros > ones)\n      return countSwaps(s, '0');\n    return min(countSwaps(s, '1'), countSwaps(s, '0'));\n  }\n\n private:\n  int countSwaps(const string& s, char curr) {\n    int swaps = 0;\n    for (const char c : s) {\n      if (c != curr)\n        ++swaps;\n      curr ^= 1;\n    }\n    return swaps / 2;\n  }\n};\n", "1865": "class FindSumPairs {\n public:\n  FindSumPairs(vector<int>& nums1, vector<int>& nums2)\n      : nums1(nums1), nums2(nums2) {\n    for (const int num : nums2)\n      ++count2[num];\n  }\n\n  void add(int index, int val) {\n    --count2[nums2[index]];\n    nums2[index] += val;\n    ++count2[nums2[index]];\n  }\n\n  int count(int tot) {\n    int ans = 0;\n    for (const int num : nums1) {\n      const int target = tot - num;\n      if (const auto it = count2.find(target); it != count2.cend())\n        ans += it->second;\n    }\n    return ans;\n  }\n\n private:\n  vector<int> nums1;\n  vector<int> nums2;\n  unordered_map<int, int> count2;\n};\n", "1866": "class Solution {\n public:\n  long rearrangeSticks(int n, int k) {\n    if (n == k)\n      return 1;\n    if (k == 0)\n      return 0;\n    if (dp[n][k])\n      return dp[n][k];\n    return dp[n][k] = (rearrangeSticks(n - 1, k - 1) +\n                       rearrangeSticks(n - 1, k) * (n - 1)) %\n                      kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  vector<vector<int>> dp = vector<vector<int>>(1001, vector<int>(1001));\n};\n", "1868": "class Solution {\n public:\n  vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1,\n                                   vector<vector<int>>& encoded2) {\n    vector<vector<int>> ans;\n    int i = 0;  // encoded1's index\n    int j = 0;  // encodes2's index\n\n    while (i < encoded1.size() && j < encoded2.size()) {\n      const int mult = encoded1[i][0] * encoded2[j][0];\n      const int minFreq = min(encoded1[i][1], encoded2[j][1]);\n      if (!ans.empty() && mult == ans.back()[0])\n        ans.back()[1] += minFreq;\n      else\n        ans.push_back({mult, minFreq});\n      encoded1[i][1] -= minFreq;\n      encoded2[j][1] -= minFreq;\n      if (encoded1[i][1] == 0)\n        ++i;\n      if (encoded2[j][1] == 0)\n        ++j;\n    }\n\n    return ans;\n  }\n};\n", "1869": "class Solution {\n public:\n  bool checkZeroOnes(string s) {\n    int longestOnes = 0;\n    int longestZeros = 0;\n    int currentOnes = 0;\n    int currentZeros = 0;\n\n    for (const char c : s)\n      if (c == '0') {\n        currentOnes = 0;\n        longestZeros = max(longestZeros, ++currentZeros);\n      } else {\n        currentZeros = 0;\n        longestOnes = max(longestOnes, ++currentOnes);\n      }\n\n    return longestOnes > longestZeros;\n  }\n};\n", "187": "class Solution {\n public:\n  vector<string> findRepeatedDnaSequences(string s) {\n    unordered_set<string> ans;\n    unordered_set<string_view> seen;\n    const string_view sv(s);\n\n    for (int i = 0; i + 10 <= s.length(); ++i) {\n      if (seen.contains(sv.substr(i, 10)))\n        ans.insert(s.substr(i, 10));\n      seen.insert(sv.substr(i, 10));\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n};\n", "1870": "class Solution {\n public:\n  int minSpeedOnTime(vector<int>& dist, double hour) {\n    int ans = -1;\n    int l = 1;\n    int r = 10'000'000;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (time(dist, hour, m) > hour) {\n        l = m + 1;\n      } else {\n        ans = m;\n        r = m - 1;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  double time(const vector<int>& dist, double hour, int speed) {\n    double sum = 0;\n    for (int i = 0; i < dist.size() - 1; ++i)\n      sum += ceil((double)dist[i] / speed);\n    return sum + (double)dist.back() / speed;\n  }\n};\n", "1871": "class Solution {\n public:\n  bool canReach(string s, int minJump, int maxJump) {\n    int count = 0;\n    vector<bool> dp(s.length());\n    dp[0] = true;\n\n    for (int i = minJump; i < s.length(); ++i) {\n      count += dp[i - minJump];\n      if (i - maxJump > 0)\n        count -= dp[i - maxJump - 1];\n      dp[i] = count && s[i] == '0';\n    }\n\n    return dp.back();\n  }\n};\n", "1872": "class Solution {\n public:\n  int stoneGameVIII(vector<int>& stones) {\n    const int n = stones.size();\n    vector<int> prefix(n);\n    // dp[i] := the maximum score difference the current player can get when the\n    // game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    vector<int> dp(n, INT_MIN);\n\n    partial_sum(stones.begin(), stones.end(), prefix.begin());\n\n    // Must take all when there're only two stones left.\n    dp[n - 2] = prefix.back();\n\n    for (int i = n - 3; i >= 0; --i)\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);\n\n    return dp[0];\n  }\n};\n", "1874": "class Solution {\n public:\n  int minProductSum(vector<int>& nums1, vector<int>& nums2) {\n    int ans = 0;\n\n    ranges::sort(nums1);\n    ranges::sort(nums2, greater<>());\n\n    for (int i = 0; i < nums1.size(); ++i)\n      ans += nums1[i] * nums2[i];\n\n    return ans;\n  }\n};\n", "1876": "class Solution {\n public:\n  int countGoodSubstrings(string s) {\n    int ans = 0;\n\n    for (int i = 0; i + 2 < s.length(); ++i) {\n      const char a = s[i];\n      const char b = s[i + 1];\n      const char c = s[i + 2];\n      if (a == b || a == c || b == c)\n        continue;\n      ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1877": "class Solution {\n public:\n  int minPairSum(vector<int>& nums) {\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (int i = 0, j = nums.size() - 1; i < j;)\n      ans = max(ans, nums[i++] + nums[j--]);\n\n    return ans;\n  }\n};\n", "1878": "class Solution {\n public:\n  vector<int> getBiggestThree(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    set<int> sums;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int sz = 0; i + sz < m && i - sz >= 0 && j + 2 * sz < n; ++sz) {\n          const int sum = sz == 0 ? grid[i][j] : getSum(grid, i, j, sz);\n          sums.insert(sum);\n          if (sums.size() > 3)\n            sums.erase(sums.begin());\n        }\n\n    return vector<int>(sums.rbegin(), sums.rend());\n  }\n\n private:\n  // Returns the sum of the rhombus, where the top grid is (i, j) and the edge\n  // size is `sz`.\n  int getSum(const vector<vector<int>>& grid, int i, int j, int sz) {\n    int x = i;\n    int y = j;\n    int sum = 0;\n\n    // Go left down.\n    for (int k = 0; k < sz; ++k)\n      sum += grid[--x][++y];\n\n    // Go right down.\n    for (int k = 0; k < sz; ++k)\n      sum += grid[++x][++y];\n\n    // Go right up.\n    for (int k = 0; k < sz; ++k)\n      sum += grid[++x][--y];\n\n    // Go left up.\n    for (int k = 0; k < sz; ++k)\n      sum += grid[--x][--y];\n\n    return sum;\n  }\n};\n", "1879": "class Solution {\n public:\n  int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> mem(1 << nums2.size(), INT_MAX);\n    return minimumXORSum(nums1, nums2, 0, mem);\n  }\n\n private:\n  int minimumXORSum(const vector<int>& nums1, const vector<int>& nums2,\n                    unsigned mask, vector<int>& mem) {\n    const int i = popcount(mask);\n    if (i == nums1.size())\n      return 0;\n    if (mem[mask] < INT_MAX)\n      return mem[mask];\n\n    for (int j = 0; j < nums2.size(); ++j)\n      if ((mask >> j & 1) == 0)\n        mem[mask] =\n            min(mem[mask], (nums1[i] ^ nums2[j]) +\n                               minimumXORSum(nums1, nums2, mask | 1 << j, mem));\n\n    return mem[mask];\n  }\n};\n", "188": "class Solution {\n public:\n  int maxProfit(int k, vector<int>& prices) {\n    if (k >= prices.size() / 2) {\n      int sell = 0;\n      int hold = INT_MIN;\n\n      for (const int price : prices) {\n        sell = max(sell, hold + price);\n        hold = max(hold, sell - price);\n      }\n\n      return sell;\n    }\n\n    vector<int> sell(k + 1);\n    vector<int> hold(k + 1, INT_MIN);\n\n    for (const int price : prices)\n      for (int i = k; i > 0; --i) {\n        sell[i] = max(sell[i], hold[i] + price);\n        hold[i] = max(hold[i], sell[i - 1] - price);\n      }\n\n    return sell[k];\n  }\n};\n", "1880": "class Solution {\n public:\n  bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n    const int first = getNumber(firstWord);\n    const int second = getNumber(secondWord);\n    const int target = getNumber(targetWord);\n    return first + second == target;\n  }\n\n private:\n  int getNumber(const string& word) {\n    int num = 0;\n    for (const char c : word)\n      num = num * 10 + (c - 'a');\n    return num;\n  }\n};\n", "1881": "class Solution {\n public:\n  string maxValue(string n, int x) {\n    bool isNegative = n[0] == '-';\n\n    for (int i = 0; i < n.length(); ++i)\n      if (!isNegative && n[i] - '0' < x || isNegative && n[i] - '0' > x)\n        return n.substr(0, i) + (char)('0' + x) + n.substr(i);\n\n    return n + (char)('0' + x);\n  }\n};\n", "1882": "struct T {\n  int weight;\n  int index;\n  int freeTime;\n};\n\nclass Solution {\n public:\n  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\n    const int n = servers.size();\n    const int m = tasks.size();\n    vector<int> ans(m);\n    auto compareFree = [](const T& a, const T& b) {\n      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;\n    };\n    auto compareUsed = [](const T& a, const T& b) {\n      if (a.freeTime != b.freeTime)\n        return a.freeTime > b.freeTime;\n      if (a.weight != b.weight)\n        return a.weight > b.weight;\n      return a.index > b.index;\n    };\n    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);\n    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);\n\n    for (int i = 0; i < n; ++i)\n      free.emplace(servers[i], i, 0);\n\n    for (int i = 0; i < m; ++i) {  // i := the current time\n      const int executionTime = tasks[i];\n      // Pop all the servers that'll be free at time i.\n      while (!used.empty() && used.top().freeTime <= i) {\n        const T curr = used.top();\n        used.pop();\n        free.push(curr);\n      }\n      if (free.empty()) {\n        T server = used.top();\n        used.pop();\n        ans[i] = server.index;\n        server.freeTime += executionTime;\n        used.push(server);\n      } else {\n        T server = free.top();\n        free.pop();\n        ans[i] = server.index;\n        server.freeTime = i + executionTime;\n        used.push(server);\n      }\n    }\n\n    return ans;\n  }\n};\n", "1883": "class Solution {\n public:\n  int minSkips(vector<int>& dist, int speed, int hoursBefore) {\n    constexpr double kInf = 10'000'000;\n    constexpr double kEps = 1e-9;\n    const int n = dist.size();\n    // dp[i][j] := the minimum time, where i is the number of roads we traversed\n    // so far and j is the number of skips we did\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, kInf));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n      const double d = dist[i - 1];\n      dp[i][0] = ceil(dp[i - 1][0] + d / speed - kEps);\n      for (int j = 1; j <= i; ++j)\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       ceil(dp[i - 1][j] + d / speed - kEps));\n    }\n\n    for (int j = 0; j <= n; ++j)\n      if (dp[n][j] <= hoursBefore)\n        return j;\n\n    return -1;\n  }\n};\n", "1884": "class Solution {\n public:\n  int twoEggDrop(int n) {\n    return superEggDrop(2, n);\n  }\n\n private:\n  // Same as 887. Super Egg Drop\n  int superEggDrop(int k, int n) {\n    vector<vector<int>> mem(k + 1, vector<int>(n + 1, -1));\n    return drop(k, n, mem);\n  }\n\n  // Returns the minimum number of moves to know f with k eggs and n floors.\n  int drop(int k, int n, vector<vector<int>>& mem) {\n    if (k == 0)  // no eggs -> done\n      return 0;\n    if (k == 1)  // one egg -> drop from 1-th floor to n-th floor\n      return n;\n    if (n == 0)  // no floor -> done\n      return 0;\n    if (n == 1)  // one floor -> drop from that floor\n      return 1;\n    if (mem[k][n] != -1)\n      return mem[k][n];\n\n    //   broken[i] := drop(k - 1, i - 1) is increasing with i\n    // unbroken[i] := drop(k,     n - i) is decreasing with i\n    // mem[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n\n    // Find the first index i s.t broken[i] >= unbroken[i], which minimizes\n    // max(broken[i], unbroken[i]).\n\n    int l = 1;\n    int r = n + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const int broken = drop(k - 1, m - 1, mem);\n      const int unbroken = drop(k, n - m, mem);\n      if (broken >= unbroken)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return mem[k][n] = 1 + drop(k - 1, l - 1, mem);\n  }\n};\n", "1885": "class Solution {\n public:\n  long long countPairs(vector<int>& nums1, vector<int>& nums2) {\n    long ans = 0;\n    vector<int> arr(nums1.size());\n\n    for (int i = 0; i < arr.size(); ++i)\n      arr[i] = nums1[i] - nums2[i];\n\n    ranges::sort(arr);\n\n    for (int i = 0; i < arr.size(); ++i) {\n      const auto it = lower_bound(arr.begin() + i + 1, arr.end(), -arr[i] + 1);\n      ans += arr.cend() - it;\n    }\n\n    return ans;\n  }\n};\n", "1886": "class Solution {\n public:\n  bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n    for (int i = 0; i < 4; ++i) {\n      if (mat == target)\n        return true;\n      rotate(mat);\n    }\n    return false;\n  }\n\n private:\n  void rotate(vector<vector<int>>& mat) {\n    ranges::reverse(mat);\n    for (int i = 0; i < mat.size(); ++i)\n      for (int j = i + 1; j < mat.size(); ++j)\n        swap(mat[i][j], mat[j][i]);\n  }\n};\n", "1887": "class Solution {\n public:\n  int reductionOperations(vector<int>& nums) {\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (int i = nums.size() - 1; i > 0; --i)\n      if (nums[i] != nums[i - 1])\n        ans += nums.size() - i;\n\n    return ans;\n  }\n};\n", "1888": "class Solution {\n public:\n  int minFlips(string s) {\n    const int n = s.length();\n    // count[0][0] := the number of 0s in the even indices\n    // count[0][1] := the number of 0s in the odd indices\n    // count[1][0] := the number of 1s in the even indices\n    // count[1][1] := the number of 1s in the odd indices\n    vector<vector<int>> count(2, vector<int>(2));\n\n    for (int i = 0; i < n; ++i)\n      ++count[s[i] - '0'][i % 2];\n\n    // min(make all 0s in the even indices + make all 1s in the odd indices,\n    //     make all 1s in the even indices + make all 0s in the odd indices)\n    int ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1]);\n\n    for (int i = 0; i < n; ++i) {\n      --count[s[i] - '0'][i % 2];\n      ++count[s[i] - '0'][(n + i) % 2];\n      ans = min({ans, count[1][0] + count[0][1], count[0][0] + count[1][1]});\n    }\n\n    return ans;\n  }\n};\n", "1889": "class Solution {\n public:\n  int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr long kInf = 100'000'000'000;\n    const long packagesSum = accumulate(packages.begin(), packages.end(), 0L);\n    long minBoxesSum = kInf;\n\n    ranges::sort(packages);\n\n    for (vector<int>& box : boxes) {\n      ranges::sort(box);\n      if (box.back() < packages.back())\n        continue;\n      long accu = 0;\n      long i = 0;\n      for (const int b : box) {\n        const long j = firstGreaterEqual(packages, b + 1);\n        accu += b * (j - i);\n        i = j;\n      }\n      minBoxesSum = min(minBoxesSum, accu);\n    }\n\n    return minBoxesSum == kInf ? -1 : (minBoxesSum - packagesSum) % kMod;\n  }\n\n private:\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "189": "class Solution {\n public:\n  void rotate(vector<int>& nums, int k) {\n    k %= nums.size();\n    reverse(nums, 0, nums.size() - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.size() - 1);\n  }\n\n private:\n  void reverse(vector<int>& nums, int l, int r) {\n    while (l < r)\n      swap(nums[l++], nums[r--]);\n  }\n};\n", "1891": "class Solution {\n public:\n  int maxLength(vector<int>& ribbons, int k) {\n    int l = 1;\n    int r = accumulate(ribbons.begin(), ribbons.end(), 0L) / k + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (!isCutPossible(ribbons, m, k))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l - 1;\n  }\n\n private:\n  bool isCutPossible(const vector<int>& ribbons, int length, int k) {\n    int count = 0;\n    for (const int ribbon : ribbons)\n      count += ribbon / length;\n    return count >= k;\n  }\n};\n", "1893": "class Solution {\n public:\n  bool isCovered(vector<vector<int>>& ranges, int left, int right) {\n    vector<int> seen(52);\n\n    for (const vector<int>& range : ranges) {\n      ++seen[range[0]];\n      --seen[range[1] + 1];\n    }\n\n    for (int i = 1; i < 52; ++i)\n      seen[i] += seen[i - 1];\n\n    for (int i = left; i <= right; ++i)\n      if (!seen[i])\n        return false;\n\n    return true;\n  }\n};\n", "1894": "class Solution {\n public:\n  int chalkReplacer(vector<int>& chalk, int k) {\n    k %= accumulate(chalk.begin(), chalk.end(), 0L);\n    if (k == 0)\n      return 0;\n\n    for (int i = 0; i < chalk.size(); ++i) {\n      k -= chalk[i];\n      if (k < 0)\n        return i;\n    }\n\n    throw;\n  }\n};\n", "1895": "class Solution {\n public:\n  int largestMagicSquare(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // prefixRow[i][j] := the sum of the first j numbers in the i-th row\n    vector<vector<int>> prefixRow(m, vector<int>(n + 1));\n    // prefixCol[i][j] := the sum of the first j numbers in the i-th column\n    vector<vector<int>> prefixCol(n, vector<int>(m + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j];\n        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j];\n      }\n\n    for (int k = min(m, n); k >= 2; --k)\n      if (containsMagicSquare(grid, prefixRow, prefixCol, k))\n        return k;\n\n    return 1;\n  }\n\n private:\n  // Returns true if the grid contains any magic square of size k x k.\n  bool containsMagicSquare(const vector<vector<int>>& grid,\n                           const vector<vector<int>>& prefixRow,\n                           const vector<vector<int>>& prefixCol, int k) {\n    for (int i = 0; i + k - 1 < grid.size(); ++i)\n      for (int j = 0; j + k - 1 < grid[0].size(); ++j)\n        if (isMagicSquare(grid, prefixRow, prefixCol, i, j, k))\n          return true;\n    return false;\n  }\n\n  // Returns true if grid[i..i + k)[j..j + k) is a magic square.\n  bool isMagicSquare(const vector<vector<int>>& grid,\n                     const vector<vector<int>>& prefixRow,\n                     const vector<vector<int>>& prefixCol, int i, int j,\n                     int k) {\n    int diag = 0;\n    int antiDiag = 0;\n    for (int d = 0; d < k; ++d) {\n      diag += grid[i + d][j + d];\n      antiDiag += grid[i + d][j + k - 1 - d];\n    }\n    if (diag != antiDiag)\n      return false;\n    for (int d = 0; d < k; ++d) {\n      if (getSum(prefixRow, i + d, j, j + k - 1) != diag)\n        return false;\n      if (getSum(prefixCol, j + d, i, i + k - 1) != diag)\n        return false;\n    }\n    return true;\n  }\n\n  // Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).\n  int getSum(const vector<vector<int>>& prefix, int i, int l, int r) {\n    return prefix[i][r + 1] - prefix[i][l];\n  }\n};\n", "1896": "class Solution {\n public:\n  int minOperationsToFlip(string expression) {\n    // [(the expression, the cost to toggle the expression)]\n    stack<pair<char, int>> stack;\n    pair<char, int> lastPair;\n\n    for (const char e : expression) {\n      if (e == '(' || e == '&' || e == '|') {\n        // These aren't expressions, so the cost is meaningless.\n        stack.push({e, 0});\n        continue;\n      }\n      if (e == ')') {\n        lastPair = stack.top();\n        stack.pop();\n        stack.pop();  // Pop '('.\n      } else {        // e == '0' || e == '1'\n        // Store the '0' or '1'. The cost to change their values is just 1,\n        // whether it's changing '0' to '1' or '1' to '0'.\n        lastPair = {e, 1};\n      }\n      if (!stack.empty() &&\n          (stack.top().first == '&' || stack.top().first == '|')) {\n        const char op = stack.top().first;\n        stack.pop();\n        const auto [a, costA] = stack.top();\n        stack.pop();\n        const auto [b, costB] = lastPair;\n        // Determine the cost to toggle op(a, b).\n        if (op == '&') {\n          if (a == '0' && b == '0')\n            // Change '&' to '|' and a|b to '1'.\n            lastPair = {'0', 1 + min(costA, costB)};\n          else if (a == '0' && b == '1')\n            // Change '&' to '|'.\n            lastPair = {'0', 1};\n          else if (a == '1' && b == '0')\n            // Change '&' to '|'.\n            lastPair = {'0', 1};\n          else  // a == '1' and b == '1'\n            // Change a|b to '0'.\n            lastPair = {'1', min(costA, costB)};\n        } else {  // op == '|'\n          if (a == '0' && b == '0')\n            // Change a|b to '1'.\n            lastPair = {'0', min(costA, costB)};\n          else if (a == '0' && b == '1')\n            // Change '|' to '&'.\n            lastPair = {'1', 1};\n          else if (a == '1' && b == '0')\n            // Change '|' to '&'.\n            lastPair = {'1', 1};\n          else  // a == '1' and b == '1'\n            // Change '|' to '&' and a|b to '0'.\n            lastPair = {'1', 1 + min(costA, costB)};\n        }\n      }\n      stack.push(lastPair);\n    }\n\n    return stack.top().second;\n  }\n};\n", "1897": "class Solution {\n public:\n  bool makeEqual(vector<string>& words) {\n    vector<int> count(26);\n\n    for (const string& word : words)\n      for (const char c : word)\n        ++count[c - 'a'];\n\n    return ranges::all_of(count,\n                          [&](const int c) { return c % words.size() == 0; });\n  }\n};\n", "1898": "class Solution {\n public:\n  int maximumRemovals(string s, string p, vector<int>& removable) {\n    int l = 0;\n    int r = removable.size() + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const string removed = remove(s, removable, m);\n      if (isSubsequence(p, removed))\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l - 1;\n  }\n\n private:\n  string remove(const string& s, const vector<int>& removable, int k) {\n    string removed(s);\n    for (int i = 0; i < k; ++i)\n      removed[removable[i]] = '*';\n    return removed;\n  }\n\n  bool isSubsequence(const string& p, const string& s) {\n    int i = 0;  // p's index\n    for (int j = 0; j < s.length(); ++j)\n      if (p[i] == s[j])\n        if (++i == p.length())\n          return true;\n    return false;\n  }\n};\n", "1899": "class Solution {\n public:\n  bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {\n    vector<int> merged(target.size());\n\n    for (const vector<int>& triplet : triplets)\n      if (equal(triplet.begin(), triplet.end(), target.begin(),\n                [](int a, int b) { return a <= b; }))\n        transform(triplet.begin(), triplet.end(), merged.begin(),\n                  merged.begin(), [](int a, int b) { return max(a, b); });\n\n    return merged == target;\n  }\n};\n", "19": "class Solution {\n public:\n  ListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (n-- > 0)\n      fast = fast->next;\n    if (fast == nullptr)\n      return head->next;\n\n    while (fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next;\n    }\n    slow->next = slow->next->next;\n\n    return head;\n  }\n};\n", "190": "class Solution {\n public:\n  uint32_t reverseBits(uint32_t n) {\n    uint32_t ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if (n >> i & 1)\n        ans |= 1 << 31 - i;\n\n    return ans;\n  }\n};\n", "1900": "class Solution {\n public:\n  vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n    using P = pair<int, int>;\n    vector<vector<vector<P>>> mem(n + 1,\n                                  vector<vector<P>>(n + 1, vector<P>(n + 1)));\n    const auto [a, b] = solve(firstPlayer, n - secondPlayer + 1, n, mem);\n    return {a, b};\n  }\n\n private:\n  // Returns the (earliest, latest) pair, the first player is the l-th player\n  // from the front, the second player is the r-th player from the end, and\n  // there're k people.\n  pair<int, int> solve(int l, int r, int k,\n                       vector<vector<vector<pair<int, int>>>>& mem) {\n    if (l == r)\n      return {1, 1};\n    if (l > r)\n      swap(l, r);\n    if (mem[l][r][k] != pair<int, int>{0, 0})\n      return mem[l][r][k];\n\n    int a = INT_MAX;\n    int b = INT_MIN;\n\n    // Enumerate all the possible positions.\n    for (int i = 1; i <= l; ++i)\n      for (int j = l - i + 1; j <= r - i; ++j) {\n        if (i + j > (k + 1) / 2 || i + j < l + r - k / 2)\n          continue;\n        const auto [x, y] = solve(i, j, (k + 1) / 2, mem);\n        a = min(a, x + 1);\n        b = max(b, y + 1);\n      }\n\n    return mem[l][r][k] = {a, b};\n  }\n};\n", "1901": "class Solution {\n public:\n  vector<int> findPeakGrid(vector<vector<int>>& mat) {\n    int l = 0;\n    int r = mat.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (ranges::max(mat[m]) >= ranges::max(mat[m + 1]))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return {l, getMaxIndex(mat[l])};\n  }\n\n private:\n  int getMaxIndex(const vector<int>& arr) {\n    pair<int, int> res{0, arr[0]};\n    for (int i = 1; i < arr.size(); ++i)\n      if (arr[i] > res.second)\n        res = {i, arr[i]};\n    return res.first;\n  }\n};\n", "1902": "class Solution {\n public:\n  int maxDepthBST(vector<int>& order) {\n    int ans = 1;\n    map<int, int> valToDepth;\n\n    for (const int val : order) {\n      const auto l = valToDepth.upper_bound(val);\n      const auto r = valToDepth.lower_bound(val);\n      const int leftDepth = l == valToDepth.cbegin() ? 0 : prev(l)->second;\n      const int rightDepth = r == valToDepth.cend() ? 0 : r->second;\n      const int depth = max(leftDepth, rightDepth) + 1;\n      ans = max(ans, depth);\n      valToDepth[val] = depth;\n    }\n\n    return ans;\n  }\n};\n", "1903": "class Solution {\n public:\n  string largestOddNumber(string num) {\n    for (int i = num.length() - 1; i >= 0; --i)\n      if ((num[i] - '0') % 2 == 1)\n        return num.substr(0, i + 1);\n    return \"\";\n  }\n};\n", "1904": "class Solution {\n public:\n  int numberOfRounds(string loginTime, string logoutTime) {\n    const int start = getMinutes(loginTime);\n    int finish = getMinutes(logoutTime);\n    if (start > finish)\n      finish += 60 * 24;\n    return max(0, finish / 15 - (start + 14) / 15);\n  }\n\n private:\n  int getMinutes(const string& time) {\n    const int h = stoi(time.substr(0, 2));\n    const int m = stoi(time.substr(3));\n    return 60 * h + m;\n  }\n};\n", "1905": "class Solution {\n public:\n  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\n    int ans = 0;\n\n    for (int i = 0; i < grid2.size(); ++i)\n      for (int j = 0; j < grid2[0].size(); ++j)\n        if (grid2[i][j] == 1)\n          ans += dfs(grid1, grid2, i, j);\n\n    return ans;\n  }\n\n private:\n  int dfs(const vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i,\n          int j) {\n    if (i < 0 || i == grid1.size() || j < 0 || j == grid2[0].size())\n      return 1;\n    if (grid2[i][j] != 1)\n      return 1;\n\n    grid2[i][j] = 2;  // Mark 2 as visited.\n\n    return dfs(grid1, grid2, i + 1, j) & dfs(grid1, grid2, i - 1, j) &\n           dfs(grid1, grid2, i, j + 1) & dfs(grid1, grid2, i, j - 1) &\n           grid1[i][j];\n  }\n};\n", "1906": "class Solution {\n public:\n  vector<int> minDifference(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<vector<int>> numToIndices(101);\n\n    for (int i = 0; i < nums.size(); ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    if (numToIndices[nums[0]].size() == nums.size())\n      return vector<int>(queries.size(), -1);\n\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      int prevNum = -1;\n      int minDiff = 101;\n      for (int num = 1; num <= 100; ++num) {\n        const auto& indices = numToIndices[num];\n        const auto it = ranges::lower_bound(indices, l);\n        if (it == indices.cend() || *it > r)\n          continue;\n        if (prevNum != -1)\n          minDiff = min(minDiff, num - prevNum);\n        prevNum = num;\n      }\n      ans.push_back(minDiff == 101 ? -1 : minDiff);\n    }\n\n    return ans;\n  }\n};\n", "1908": "class Solution {\n public:\n  bool nimGame(vector<int>& piles) {\n    return accumulate(piles.begin(), piles.end(), 0, bit_xor<>()) > 0;\n  }\n};\n", "1909": "class Solution {\n public:\n  bool canBeIncreasing(vector<int>& nums) {\n    bool removed = false;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i - 1] >= nums[i]) {\n        if (removed)\n          return false;\n        removed = true;  // Remove nums[i - 1].\n        if (i > 1 && nums[i - 2] >= nums[i])\n          nums[i] = nums[i - 1];  // Remove nums[i] instead.\n      }\n\n    return true;\n  }\n};\n", "191": "class Solution {\n public:\n  int hammingWeight(uint32_t n) {\n    return popcount(n);\n  }\n};\n", "1910": "class Solution {\n public:\n  string removeOccurrences(string s, string part) {\n    const int n = s.length();\n    const int k = part.length();\n\n    string t(n, ' ');\n    int j = 0;  // t's index\n\n    for (int i = 0; i < n; ++i) {\n      t[j++] = s[i];\n      if (j >= k && t.substr(j - k, k) == part)\n        j -= k;\n    }\n\n    return t.substr(0, j);\n  }\n};\n", "1911": "class Solution {\n public:\n  long long maxAlternatingSum(vector<int>& nums) {\n    long even = 0;  // the maximum alternating sum ending in an even index\n    long odd = 0;   // the maximum alternating sum ending in an odd index\n\n    for (const int num : nums) {\n      even = max(even, odd + num);\n      odd = even - num;\n    }\n\n    return even;\n  }\n};\n", "1912": "class MovieRentingSystem {\n public:\n  MovieRentingSystem(int n, vector<vector<int>>& entries) {\n    for (const vector<int>& e : entries) {\n      const int shop = e[0];\n      const int movie = e[1];\n      const int price = e[2];\n      unrented[movie].insert({price, shop});\n      shopAndMovieToPrice[{shop, movie}] = price;\n    }\n  }\n\n  vector<int> search(int movie) {\n    vector<int> ans;\n    int i = 0;\n\n    for (const auto& [price, shop] : unrented[movie]) {\n      ans.push_back(shop);\n      if (++i >= 5)\n        break;\n    }\n\n    return ans;\n  }\n\n  void rent(int shop, int movie) {\n    const int price = shopAndMovieToPrice[{shop, movie}];\n    unrented[movie].erase({price, shop});\n    rented.insert({price, {shop, movie}});\n  }\n\n  void drop(int shop, int movie) {\n    const int price = shopAndMovieToPrice[{shop, movie}];\n    unrented[movie].insert({price, shop});\n    rented.erase({price, {shop, movie}});\n  }\n\n  vector<vector<int>> report() {\n    vector<vector<int>> ans;\n    int i = 0;\n\n    for (const auto& [_, shopAndMovie] : rented) {\n      ans.push_back({shopAndMovie.first, shopAndMovie.second});\n      if (++i >= 5)\n        break;\n    }\n\n    return ans;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n\n  // {movie: (price, shop)}\n  unordered_map<int, set<pair<int, int>>> unrented;\n\n  // {(shop, movie): price}\n  unordered_map<pair<int, int>, int, PairHash> shopAndMovieToPrice;\n\n  // (price, (shop, movie))\n  set<pair<int, pair<int, int>>> rented;\n};\n", "1913": "class Solution {\n public:\n  int maxProductDifference(vector<int>& nums) {\n    int max1 = INT_MIN;\n    int max2 = INT_MIN;\n    int min1 = INT_MAX;\n    int min2 = INT_MAX;\n\n    for (const int num : nums) {\n      if (num > max1) {\n        max2 = max1;\n        max1 = num;\n      } else if (num > max2) {\n        max2 = num;\n      }\n      if (num < min1) {\n        min2 = min1;\n        min1 = num;\n      } else if (num < min2) {\n        min2 = num;\n      }\n    }\n\n    return max1 * max2 - min1 * min2;\n  }\n};\n", "1914": "class Solution {\n public:\n  vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int t = 0;      // the top\n    int l = 0;      // the left\n    int b = m - 1;  // the bottom\n    int r = n - 1;  // the right\n\n    while (t < b && l < r) {\n      const int elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4;\n      const int netRotations = k % elementInThisLayer;\n      for (int rotate = 0; rotate < netRotations; ++rotate) {\n        const int topLeft = grid[t][l];\n        for (int j = l; j < r; ++j)\n          grid[t][j] = grid[t][j + 1];\n        for (int i = t; i < b; ++i)\n          grid[i][r] = grid[i + 1][r];\n        for (int j = r; j > l; --j)\n          grid[b][j] = grid[b][j - 1];\n        for (int i = b; i > t; --i)\n          grid[i][l] = grid[i - 1][l];\n        grid[t + 1][l] = topLeft;\n      }\n      ++t;\n      ++l;\n      --b;\n      --r;\n    }\n\n    return grid;\n  }\n};\n", "1915": "class Solution {\n public:\n  long long wonderfulSubstrings(string word) {\n    long ans = 0;\n    int prefix = 0;           // the binary prefix\n    vector<int> count(1024);  // the binary prefix count\n    count[0] = 1;             // the empty string \"\"\n\n    for (const char c : word) {\n      prefix ^= 1 << c - 'a';\n      // All the letters occur even number of times.\n      ans += count[prefix];\n      // ('a' + i) occurs odd number of times.\n      for (int i = 0; i < 10; ++i)\n        ans += count[prefix ^ 1 << i];\n      ++count[prefix];\n    }\n\n    return ans;\n  }\n};\n", "1918": "class Solution {\n public:\n  int kthSmallestSubarraySum(vector<int>& nums, int k) {\n    int l = 0;\n    int r = accumulate(nums.begin(), nums.end(), 0);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numSubarrayLessThan(nums, m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numSubarrayLessThan(const vector<int>& nums, int m) {\n    int res = 0;\n    int sum = 0;\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      sum += nums[r];\n      while (sum > m)\n        sum -= nums[l++];\n      res += r - l + 1;\n    }\n    return res;\n  }\n};\n", "1920": "class Solution {\n public:\n  vector<int> buildArray(vector<int>& nums) {\n    const int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n      nums[i] += n * (nums[nums[i]] % n);\n\n    for (int i = 0; i < n; ++i)\n      nums[i] /= n;\n\n    return nums;\n  }\n};\n", "1921": "class Solution {\n public:\n  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n    const int n = dist.size();\n    vector<int> arrivalTime(n);\n\n    for (int i = 0; i < n; ++i)\n      arrivalTime[i] = (dist[i] - 1) / speed[i];\n\n    ranges::sort(arrivalTime);\n\n    for (int i = 0; i < n; ++i)\n      if (i > arrivalTime[i])\n        return i;\n\n    return n;\n  }\n};\n", "1922": "class Solution {\n public:\n  int countGoodNumbers(long long n) {\n    return modPow(4 * 5, n / 2) * (n % 2 == 0 ? 1 : 5) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x, n - 1) % kMod;\n    return modPow(x * x % kMod, n / 2);\n  }\n};\n", "1923": "class Solution {\n public:\n  int longestCommonSubpath(int n, vector<vector<int>>& paths) {\n    int l = 0;\n    int r = paths[0].size();\n\n    while (l < r) {\n      const int m = l + (r - l + 1) / 2;\n      if (checkCommonSubpath(paths, m))\n        l = m;\n      else\n        r = m - 1;\n    }\n\n    return l;\n  }\n\n  static constexpr long kBase = 165'131;\n  static constexpr long kHash = 8'417'508'174'513;\n\n  // Returns true if there's a common subpath of length m for all the paths.\n  bool checkCommonSubpath(const vector<vector<int>>& paths, int m) {\n    vector<unordered_set<long>> hashSets;\n\n    // Calculate the hash values for subpaths of length m for every path.\n    for (const vector<int>& path : paths)\n      hashSets.push_back(rabinKarp(path, m));\n\n    // Check if there is a common subpath of length m.\n    for (const long subpathHash : hashSets[0])\n      if (ranges::all_of(hashSets,\n                         [subpathHash](const unordered_set<long>& hashSet) {\n        return hashSet.contains(subpathHash);\n      }))\n        return true;\n\n    return false;\n  }\n\n  // Returns the hash values for subpaths of length m in the path.\n  unordered_set<long> rabinKarp(const vector<int>& path, int m) {\n    unordered_set<long> hashes;\n    long maxPower = 1;\n    long hash = 0;\n    for (int i = 0; i < path.size(); ++i) {\n      hash = (hash * kBase + path[i]) % kHash;\n      if (i >= m)\n        hash = (hash - path[i - m] * maxPower % kHash + kHash) % kHash;\n      else\n        maxPower = maxPower * kBase % kHash;\n      if (i >= m - 1)\n        hashes.insert(hash);\n    }\n    return hashes;\n  }\n};\n", "1924": "struct Point {\n  double x;\n  double y;\n  Point(double x, double y) : x(x), y(y) {}\n};\n\nstruct Disk {\n  Point center;\n  double radius;\n  Disk(const Point& center, double radius) : center(center), radius(radius) {}\n};\n\nclass Solution {\n public:\n  vector<double> outerTrees(vector<vector<int>>& trees) {\n    vector<Point> points;\n    for (int i = 0; i < trees.size(); ++i)\n      points.emplace_back(trees[i][0], trees[i][1]);\n    Disk disk = welzl(points, 0, {});\n    return {disk.center.x, disk.center.y, disk.radius};\n  }\n\n private:\n  // Returns the smallest disk that encloses points[i..n).\n  //\n  // https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm\n  Disk welzl(const vector<Point>& points, int i, vector<Point> planePoints) {\n    if (i == points.size() || planePoints.size() == 3)\n      return trivial(planePoints);\n    Disk disk = welzl(points, i + 1, planePoints);\n    if (inside(disk, points[i]))\n      return disk;\n    return welzl(points, i + 1, addPlanePoint(planePoints, points[i]));\n  }\n\n  vector<Point> addPlanePoint(const vector<Point>& planePoints,\n                              const Point& point) {\n    vector<Point> newPlanePoints(planePoints);\n    newPlanePoints.push_back(point);\n    return newPlanePoints;\n  }\n  // Returns the smallest disk that encloses `planePoints`.\n  Disk trivial(const vector<Point>& planePoints) {\n    if (planePoints.empty())\n      return Disk(Point(0, 0), 0);\n    if (planePoints.size() == 1)\n      return Disk(Point(planePoints[0].x, planePoints[0].y), 0);\n    if (planePoints.size() == 2)\n      return getDisk(planePoints[0], planePoints[1]);\n\n    Disk disk01 = getDisk(planePoints[0], planePoints[1]);\n    if (inside(disk01, planePoints[2]))\n      return disk01;\n\n    Disk disk02 = getDisk(planePoints[0], planePoints[2]);\n    if (inside(disk02, planePoints[1]))\n      return disk02;\n\n    Disk disk12 = getDisk(planePoints[1], planePoints[2]);\n    if (inside(disk12, planePoints[0]))\n      return disk12;\n\n    return getDisk(planePoints[0], planePoints[1], planePoints[2]);\n  }\n\n  // Returns the smallest disk that encloses the points A and B.\n  Disk getDisk(const Point& A, const Point& B) {\n    const double x = (A.x + B.x) / 2;\n    const double y = (A.y + B.y) / 2;\n    return Disk(Point(x, y), distance(A, B) / 2);\n  }\n\n  // Returns the smallest disk that encloses the points A, B, and C.\n  Disk getDisk(const Point& A, const Point& B, const Point& C) {\n    // Calculate midpoints.\n    Point mAB((A.x + B.x) / 2, (A.y + B.y) / 2);\n    Point mBC((B.x + C.x) / 2, (B.y + C.y) / 2);\n\n    // Calculate the slopes and the perpendicular slopes.\n    const double slopeAB = (B.y - A.y) / (B.x - A.x);\n    const double slopeBC = (C.y - B.y) / (C.x - B.x);\n    const double perpSlopeAB = -1 / slopeAB;\n    const double perpSlopeBC = -1 / slopeBC;\n\n    // Calculate the center.\n    const double x =\n        (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x + mAB.y - mBC.y) /\n        (perpSlopeBC - perpSlopeAB);\n    const double y = perpSlopeAB * (x - mAB.x) + mAB.y;\n    Point center(x, y);\n    return Disk(center, distance(center, A));\n  }\n\n  // Returns true if the point is inside the disk.\n  bool inside(Disk disk, Point point) {\n    return disk.radius > 0 && distance(disk.center, point) <= disk.radius;\n  }\n\n  double distance(Point A, Point B) {\n    const double dx = A.x - B.x;\n    const double dy = A.y - B.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n};\n", "1925": "class Solution {\n public:\n  int countTriples(int n) {\n    int ans = 0;\n    unordered_set<int> squared;\n\n    for (int i = 1; i <= n; ++i)\n      squared.insert(i * i);\n\n    for (const int a : squared)\n      for (const int b : squared)\n        if (squared.contains(a + b))\n          ++ans;\n\n    return ans;\n  }\n};\n", "1926": "class Solution {\n public:\n  int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = maze.size();\n    const int n = maze[0].size();\n    queue<pair<int, int>> q{{{entrance[0], entrance[1]}}};\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    seen[entrance[0]][entrance[1]] = true;\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (seen[x][y] || maze[x][y] == '+')\n            continue;\n          if (x == 0 || x == m - 1 || y == 0 || y == n - 1)\n            return step;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  }\n};\n", "1927": "class Solution {\n public:\n  bool sumGame(string num) {\n    const int n = num.length();\n    double ans = 0.0;\n\n    for (int i = 0; i < n / 2; ++i)\n      ans += getExpectation(num[i]);\n\n    for (int i = n / 2; i < n; ++i)\n      ans -= getExpectation(num[i]);\n\n    return ans != 0.0;\n  }\n\n private:\n  double getExpectation(char c) {\n    return c == '?' ? 4.5 : c - '0';\n  }\n};\n", "1928": "class Solution {\n public:\n  int minCost(int maxTime, vector<vector<int>>& edges,\n              vector<int>& passingFees) {\n    const int n = passingFees.size();\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dijkstra(graph, 0, n - 1, maxTime, passingFees);\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,\n               int maxTime, const vector<int>& passingFees) {\n    // cost[i] := the minimum cost to reach the i-th city\n    vector<int> cost(graph.size(), INT_MAX);\n    // dist[i] := the minimum time to reach the i-th city\n    vector<int> dist(graph.size(), maxTime + 1);\n\n    cost[src] = passingFees[src];\n    dist[src] = 0;\n    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.emplace(cost[src], dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [currCost, d, u] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return cost[dst];\n      if (d > dist[u] && currCost > cost[u])\n        continue;\n      for (const auto& [v, w] : graph[u]) {\n        if (d + w > maxTime)\n          continue;\n        // Go from u -> v.\n        if (currCost + passingFees[v] < cost[v]) {\n          cost[v] = currCost + passingFees[v];\n          dist[v] = d + w;\n          minHeap.emplace(cost[v], dist[v], v);\n        } else if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(currCost + passingFees[v], dist[v], v);\n        }\n      }\n    }\n\n    return -1;\n  }\n};\n", "1929": "class Solution {\n public:\n  vector<int> getConcatenation(vector<int>& nums) {\n    const int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n      nums.push_back(nums[i]);\n\n    return nums;\n  }\n};\n", "1930": "class Solution {\n public:\n  int countPalindromicSubsequence(string s) {\n    int ans = 0;\n    vector<int> first(26, s.length());\n    vector<int> last(26, -1);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int index = s[i] - 'a';\n      first[index] = min(first[index], i);\n      last[index] = i;\n    }\n\n    for (int i = 0; i < 26; ++i)\n      if (first[i] < last[i])\n        ans += unordered_set<int>(s.begin() + first[i] + 1, s.begin() + last[i])\n                   .size();\n\n    return ans;\n  }\n};\n", "1931": "class Solution {\n public:\n  int colorTheGrid(int m, int n) {\n    this->m = m;\n    this->n = n;\n    return dp(0, 0, 0, 0);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  int m;\n  int n;\n  vector<vector<int>> mem = vector<vector<int>>(1000, vector<int>(1024));\n\n  int dp(int r, int c, int prevColMask, int currColMask) {\n    if (c == n)\n      return 1;\n    if (mem[c][prevColMask])\n      return mem[c][prevColMask];\n    if (r == m)\n      return dp(0, c + 1, currColMask, 0);\n\n    int ans = 0;\n\n    // 1 := red, 2 := green, 3 := blue\n    for (int color = 1; color <= 3; ++color) {\n      if (getColor(prevColMask, r) == color)\n        continue;\n      if (r > 0 && getColor(currColMask, r - 1) == color)\n        continue;\n      ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color));\n      ans %= kMod;\n    }\n\n    if (r == 0)\n      mem[c][prevColMask] = ans;\n\n    return ans;\n  }\n\n  // e.g. __ __ __ __ __\n  //      01 10 11 11 11\n  //      R  G  B  B  B\n  // getColor(0110111111, 3) -> G\n  int getColor(int mask, int r) {\n    return mask >> r * 2 & 3;\n  }\n\n  int setColor(int mask, int r, int color) {\n    return mask | color << r * 2;\n  }\n};\n", "1932": "class Solution {\n public:\n  TreeNode* canMerge(vector<TreeNode*>& trees) {\n    unordered_map<int, TreeNode*> valToNode;  // {val: node}\n    unordered_map<int, int> count;            // {val: freq}\n\n    for (TreeNode* tree : trees) {\n      valToNode[tree->val] = tree;\n      ++count[tree->val];\n      if (tree->left)\n        ++count[tree->left->val];\n      if (tree->right)\n        ++count[tree->right->val];\n    }\n\n    for (TreeNode* tree : trees)\n      if (count[tree->val] == 1) {\n        if (isValidBST(tree, nullptr, nullptr, valToNode) &&\n            valToNode.size() <= 1)\n          return tree;\n        return nullptr;\n      }\n\n    return nullptr;\n  }\n\n private:\n  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,\n                  unordered_map<int, TreeNode*>& valToNode) {\n    if (tree == nullptr)\n      return true;\n    if (minNode && tree->val <= minNode->val)\n      return false;\n    if (maxNode && tree->val >= maxNode->val)\n      return false;\n    if (!tree->left && !tree->right && valToNode.contains(tree->val)) {\n      const int val = tree->val;\n      tree->left = valToNode[val]->left;\n      tree->right = valToNode[val]->right;\n      valToNode.erase(val);\n    }\n\n    return isValidBST(tree->left, minNode, tree, valToNode) &&\n           isValidBST(tree->right, tree, maxNode, valToNode);\n  }\n};\n", "1933": "class Solution {\n public:\n  bool isDecomposable(string s) {\n    int twos = 0;\n    int groupLength = 0;\n    char letter = '@';  // the running letter\n\n    for (const char c : s)\n      if (c == letter) {\n        ++groupLength;\n      } else {\n        if (groupLength % 3 == 1)\n          return false;\n        if (groupLength % 3 == 2 && ++twos > 1)\n          return false;\n        groupLength = 1;\n        letter = c;\n      }\n\n    // Check the final group.\n    if (groupLength % 3 == 1)\n      return false;\n    if (groupLength % 3 == 2 && ++twos > 1)\n      return false;\n    return twos == 1;\n  }\n};\n", "1935": "class Solution {\n public:\n  int canBeTypedWords(string text, string brokenLetters) {\n    int ans = 0;\n    istringstream iss(text);\n    vector<bool> broken(26);\n\n    for (const char c : brokenLetters)\n      broken[c - 'a'] = true;\n\n    for (string word; iss >> word;)\n      ans += canBeTyped(word, broken);\n\n    return ans;\n  }\n\n private:\n  bool canBeTyped(const string& word, const vector<bool>& broken) {\n    for (const char c : word)\n      if (broken[c - 'a'])\n        return false;\n    return true;\n  }\n};\n", "1936": "class Solution {\n public:\n  int addRungs(vector<int>& rungs, int dist) {\n    int ans = 0;\n    int prev = 0;\n\n    for (const int rung : rungs) {\n      ans += (rung - prev - 1) / dist;\n      prev = rung;\n    }\n\n    return ans;\n  }\n};\n", "1937": "class Solution {\n public:\n  long long maxPoints(vector<vector<int>>& points) {\n    const int n = points[0].size();\n    // dp[j] := the maximum number of points you can have if points[i][j] is the\n    // most recent cell you picked\n    vector<long> dp(n);\n\n    for (const vector<int>& row : points) {\n      vector<long> leftToRight(n);\n      long runningMax = 0;\n\n      for (int j = 0; j < n; ++j) {\n        runningMax = max(runningMax - 1, dp[j]);\n        leftToRight[j] = runningMax;\n      }\n\n      vector<long> rightToLeft(n);\n      runningMax = 0;\n\n      for (int j = n - 1; j >= 0; --j) {\n        runningMax = max(runningMax - 1, dp[j]);\n        rightToLeft[j] = runningMax;\n      }\n\n      for (int j = 0; j < n; ++j)\n        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j];\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "1938": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int count = 0;\n  TrieNode() : children(2) {}\n};\n\nclass Trie {\n public:\n  void update(int num, int val) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = kHeight; i >= 0; --i) {\n      const int bit = (num >> i) & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n      node->count += val;\n    }\n  }\n\n  int query(int num) {\n    int ans = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = kHeight; i >= 0; --i) {\n      const int bit = (num >> i) & 1;\n      const int targetBit = bit ^ 1;\n      if (node->children[targetBit] && node->children[targetBit]->count) {\n        ans += 1 << i;\n        node = node->children[targetBit];\n      } else {\n        node = node->children[targetBit ^ 1];\n      }\n    }\n    return ans;\n  }\n\n private:\n  static constexpr int kHeight = 17;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  vector<int> maxGeneticDifference(vector<int>& parents,\n                                   vector<vector<int>>& queries) {\n    const int n = parents.size();\n    vector<int> ans(queries.size());\n    int rootVal = -1;\n    vector<vector<int>> tree(n);\n    // {node: (index, val)}\n    unordered_map<int, vector<pair<int, int>>> nodeToQueries;\n    Trie trie;\n\n    for (int i = 0; i < parents.size(); ++i)\n      if (parents[i] == -1)\n        rootVal = i;\n      else\n        tree[parents[i]].push_back(i);\n\n    for (int i = 0; i < queries.size(); ++i) {\n      const int node = queries[i][0];\n      const int val = queries[i][1];\n      nodeToQueries[node].emplace_back(i, val);\n    }\n\n    dfs(rootVal, trie, tree, nodeToQueries, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int node, Trie& trie, const vector<vector<int>>& tree,\n           const unordered_map<int, vector<pair<int, int>>>& nodeToQueries,\n           vector<int>& ans) {\n    trie.update(node, 1);\n\n    if (const auto it = nodeToQueries.find(node); it != nodeToQueries.cend())\n      for (const auto& [i, val] : it->second)\n        ans[i] = trie.query(val);\n\n    for (const int child : tree[node])\n      dfs(child, trie, tree, nodeToQueries, ans);\n\n    trie.update(node, -1);\n  }\n};\n", "1940": "class Solution {\n public:\n  vector<int> longestCommonSubsequence(vector<vector<int>>& arrays) {\n    constexpr int kMax = 100;\n    vector<int> ans;\n    vector<int> count(kMax + 1);\n\n    for (const vector<int>& array : arrays)\n      for (const int a : array)\n        if (++count[a] == arrays.size())\n          ans.push_back(a);\n\n    return ans;\n  }\n};\n", "1941": "class Solution {\n public:\n  bool areOccurrencesEqual(string s) {\n    vector<int> count(26);\n    for (const char c : s)\n      ++count[c - 'a'];\n    return equalFreq(count, count[s[0] - 'a']);\n  }\n\n private:\n  bool equalFreq(const vector<int>& count, int theFreq) {\n    return ranges::all_of(\n        count, [theFreq](int freq) { return freq == 0 || freq == theFreq; });\n  }\n};\n", "1942": "class Solution {\n public:\n  int smallestChair(vector<vector<int>>& times, int targetFriend) {\n    int nextUnsatChair = 0;\n    priority_queue<int, vector<int>, greater<>> emptyChairs;\n    using P = pair<int, int>;  // (leaving, chair)\n    priority_queue<P, vector<P>, greater<>> occupied;\n\n    for (int i = 0; i < times.size(); ++i)\n      times[i].push_back(i);\n\n    ranges::sort(times);\n\n    for (const vector<int>& time : times) {\n      const int arrival = time[0];\n      const int leaving = time[1];\n      const int i = time[2];\n      while (!occupied.empty() && occupied.top().first <= arrival)\n        emptyChairs.push(occupied.top().second), occupied.pop();\n      if (i == targetFriend)\n        return emptyChairs.empty() ? nextUnsatChair : emptyChairs.top();\n      if (emptyChairs.empty())\n        occupied.emplace(leaving, nextUnsatChair++);\n      else\n        occupied.emplace(leaving, emptyChairs.top()), emptyChairs.pop();\n    }\n\n    throw;\n  }\n};\n", "1943": "class Solution {\n public:\n  vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {\n    vector<vector<long long>> ans;\n    int prevIndex = 0;\n    long runningMix = 0;\n    map<int, long> line;\n\n    for (const vector<int>& segment : segments) {\n      const int start = segment[0];\n      const int end = segment[1];\n      const int color = segment[2];\n      line[start] += color;\n      line[end] -= color;\n    }\n\n    for (const auto& [i, mix] : line) {\n      if (runningMix > 0)\n        ans.push_back({prevIndex, i, runningMix});\n      runningMix += mix;\n      prevIndex = i;\n    }\n\n    return ans;\n  }\n};\n", "1944": "class Solution {\n public:\n  vector<int> canSeePersonsCount(vector<int>& heights) {\n    const int n = heights.size();\n    vector<int> ans(n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && heights[stack.top()] <= heights[i])\n        ++ans[stack.top()], stack.pop();\n      if (!stack.empty())\n        ++ans[stack.top()];\n      stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "1945": "class Solution {\n public:\n  int getLucky(string s, int k) {\n    int ans = convert(s);\n    for (int i = 1; i < k; ++i)\n      ans = getDigitSum(ans);\n    return ans;\n  }\n\n private:\n  int convert(string s) {\n    int sum = 0;\n    for (const char c : s) {\n      const int val = c - 'a' + 1;\n      // Do one transform to prevent integer overflow.\n      sum += val < 10 ? val : (val % 10 + val / 10);\n    }\n    return sum;\n  }\n\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "1946": "class Solution {\n public:\n  string maximumNumber(string num, vector<int>& change) {\n    bool mutated = false;\n\n    for (char& c : num) {\n      const int d = c - '0';\n      c = '0' + max(d, change[d]);\n      if (mutated && d > change[d])\n        return num;\n      if (d < change[d])\n        mutated = true;\n    }\n\n    return num;\n  }\n};\n", "1947": "class Solution {\n public:\n  int maxCompatibilitySum(vector<vector<int>>& students,\n                          vector<vector<int>>& mentors) {\n    int ans = 0;\n    dfs(students, mentors, 0, /*score=*/0, vector<bool>(students.size()), ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& students,\n           const vector<vector<int>>& mentors, int i, int scoreSum,\n           vector<bool>&& used, int& ans) {\n    if (i == students.size()) {\n      ans = max(ans, scoreSum);\n      return;\n    }\n    for (int j = 0; j < students.size(); ++j) {\n      if (used[j])\n        continue;\n      used[j] = true;  // The `mentors[j]` is used.\n      dfs(students, mentors, i + 1,\n          scoreSum + getScore(students[i], mentors[j]), std::move(used), ans);\n      used[j] = false;\n    }\n  }\n\n  int getScore(const vector<int>& student, const vector<int>& mentor) {\n    int score = 0;\n    for (int i = 0; i < student.size(); ++i)\n      if (student[i] == mentor[i])\n        ++score;\n    return score;\n  }\n};\n", "1948": "struct TrieNode {\n  unordered_map<string, shared_ptr<TrieNode>> children;\n  bool deleted = false;\n};\n\nclass Solution {\n public:\n  vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {\n    vector<vector<string>> ans;\n    vector<string> path;\n    unordered_map<string, vector<shared_ptr<TrieNode>>> subtreeToNodes;\n\n    ranges::sort(paths);\n\n    for (const vector<string>& path : paths) {\n      shared_ptr<TrieNode> node = root;\n      for (const string& s : path) {\n        if (!node->children.contains(s))\n          node->children[s] = make_shared<TrieNode>();\n        node = node->children[s];\n      }\n    }\n\n    buildSubtreeToRoots(root, subtreeToNodes);\n\n    for (const auto& [_, nodes] : subtreeToNodes)\n      if (nodes.size() > 1)\n        for (shared_ptr<TrieNode> node : nodes)\n          node->deleted = true;\n\n    constructPath(root, path, ans);\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  string buildSubtreeToRoots(\n      shared_ptr<TrieNode> node,\n      unordered_map<string, vector<shared_ptr<TrieNode>>>& subtreeToNodes) {\n    string subtree = \"(\";\n    for (const auto& [s, child] : node->children)\n      subtree += s + buildSubtreeToRoots(child, subtreeToNodes);\n    subtree += \")\";\n    if (subtree != \"()\")\n      subtreeToNodes[subtree].push_back(node);\n    return subtree;\n  }\n\n  void constructPath(shared_ptr<TrieNode> node, vector<string>& path,\n                     vector<vector<string>>& ans) {\n    for (const auto& [s, child] : node->children)\n      if (!child->deleted) {\n        path.push_back(s);\n        constructPath(child, path, ans);\n        path.pop_back();\n      }\n    if (!path.empty())\n      ans.push_back(path);\n  }\n};\n", "1950": "class Solution {\n public:\n  // Similar to 1950. Maximum of Minimum Values in All Subarrays\n  vector<int> findMaximums(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n);\n    // prevMin[i] := the index k s.t.\n    // nums[k] is the previous minimum in nums[0..n)\n    vector<int> prevMin(n, -1);\n    // nextMin[i] := the index k s.t.\n    // nums[k] is the next minimum innums[i + 1..n)\n    vector<int> nextMin(n, n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && nums[stack.top()] > nums[i]) {\n        const int index = stack.top();\n        stack.pop();\n        nextMin[index] = i;\n      }\n      if (!stack.empty())\n        prevMin[i] = stack.top();\n      stack.push(i);\n    }\n\n    // For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.\n    // nums[i] is the minimum in nums[l..r].\n    // So, the ans[r - l + 1] will be at least nums[i].\n    for (int i = 0; i < n; ++i) {\n      const int sz = nextMin[i] - prevMin[i] - 1;\n      ans[sz - 1] = max(ans[sz - 1], nums[i]);\n    }\n\n    // ans[i] should always >= ans[i + 1..n).\n    for (int i = n - 2; i >= 0; --i)\n      ans[i] = max(ans[i], ans[i + 1]);\n\n    return ans;\n  }\n};\n", "1952": "class Solution {\n public:\n  bool isThree(int n) {\n    if (n == 1)\n      return false;\n    // The numbers with exactly three divisors are perfect squares of a prime\n    // number.\n    const int root = sqrt(n);\n    return root * root == n && isPrime(root);\n  }\n\n private:\n  bool isPrime(int num) {\n    for (int i = 2; i <= sqrt(num); ++i)\n      if (num % i == 0)\n        return false;\n    return true;\n  }\n};\n", "1953": "class Solution {\n public:\n  long long numberOfWeeks(vector<int>& milestones) {\n    // The best strategy is to pick \"max, nonMax, max, nonMax, ...\".\n    const int mx = ranges::max(milestones);\n    const long sum = accumulate(milestones.begin(), milestones.end(), 0L);\n    const long nonMax = sum - mx;\n    return min(sum, 2 * nonMax + 1);\n  }\n};\n", "1954": "class Solution {\n public:\n  long long minimumPerimeter(long long neededApples) {\n    long l = 1;\n    long r = 100'000;  // \\sqrt [3] {10^{15}}\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (numApples(m) >= neededApples)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l * 8;\n  }\n\n private:\n  // Returns the number of apples at the k-th level.\n  //    k := the level making perimeter = 8k\n  // p(k) := the number of apples at the k-th level on the perimeter\n  // n(k) := the number of apples at the k-th level not no the perimeter\n  //\n  // p(1) =             1 + 2\n  // p(2) =         3 + 2 + 3 + 4\n  // p(3) =     5 + 4 + 3 + 4 + 5 + 6\n  // p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8\n  // p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k\n  //      = k + 2k^2 + 2*k(k-1)/2\n  //      = k + 2k^2 + k^2 - k = 3k^2\n  //\n  // n(k) = p(1) + p(2) + p(3) + ... + p(k)\n  //      = 3*1  + 3*4  + 3*9  + ... + 3*k^2\n  //      = 3 * (1 + 4 + 9 + ... + k^2)\n  //      = 3 * k(k+1)(2k+1)/6 = k(k+1)(2k+1)/2\n  // So, the number of apples at the k-th level should be\n  //   k(k+1)(2k+1)/2 * 4 = 2k(k+1)(2k+1)\n  long numApples(long k) {\n    return 2 * k * (k + 1) * (2 * k + 1);\n  }\n};\n", "1955": "class Solution {\n public:\n  int countSpecialSubsequences(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    // dp[i][j] := the number of increasing subsequences of the first i numbers\n    // that end in j\n    vector<vector<long>> dp(n, vector<long>(3));\n\n    if (nums[0] == 0)\n      dp[0][0] = 1;\n\n    for (int i = 1; i < n; ++i) {\n      for (int ending = 0; ending < 3; ++ending)\n        dp[i][ending] = dp[i - 1][ending];\n\n      if (nums[i] == 0)\n        // 1. The number of the previous subsequences that end in 0.\n        // 2. Append a 0 to the previous subsequences that end in 0.\n        // 3. Start a new subsequence from this 0.\n        dp[i][0] = dp[i - 1][0] * 2 + 1;\n      else if (nums[i] == 1)\n        // 1. The number of the previous subsequences that end in 1.\n        // 2. Append a 1 to the previous subsequences that end in 1.\n        // 3. Append a 1 to the previous subsequences that end in 0.\n        dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0];\n      else  // nums[i] == 2\n        // 1. The number of the previous subsequences that end in 2.\n        // 2. Append a 2 to the previous subsequences that end in 2.\n        // 3. Append a 2 to the previous subsequences that end in 1.\n        dp[i][2] = dp[i - 1][2] * 2 + dp[i - 1][1];\n\n      for (int ending = 0; ending < 3; ++ending)\n        dp[i][ending] %= kMod;\n    }\n\n    return dp.back()[2];\n  }\n};\n", "1956": "class Solution {\n public:\n  int minDayskVariants(vector<vector<int>>& points, int k) {\n    constexpr int kMax = 100;\n    int ans = INT_MAX;\n\n    for (int a = 1; a <= kMax; ++a)\n      for (int b = 1; b <= kMax; ++b) {\n        // Stores the k minimum distances of points that can reach (a, b).\n        priority_queue<int> maxHeap;\n        for (const vector<int>& point : points) {\n          const int x = point[0];\n          const int y = point[1];\n          maxHeap.push(abs(x - a) + abs(y - b));\n          if (maxHeap.size() > k)\n            maxHeap.pop();\n        }\n        ans = min(ans, maxHeap.top());\n      }\n\n    return ans;\n  }\n};\n", "1957": "class Solution {\n public:\n  string makeFancyString(string s) {\n    string ans;\n    for (const char c : s)\n      if (ans.length() < 2 || ans.back() != c || ans[ans.size() - 2] != c)\n        ans.push_back(c);\n    return ans;\n  }\n};\n", "1958": "class Solution {\n public:\n  bool checkMove(vector<vector<char>>& board, int rMove, int cMove,\n                 char color) {\n    constexpr int kDirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                 {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n\n    for (const auto& [dx, dy] : kDirs) {\n      int cellsCount = 2;\n      int i = rMove + dx;\n      int j = cMove + dy;\n      while (0 <= i && i < 8 && 0 <= j && j < 8) {\n        // There are no free cells in between.\n        if (board[i][j] == '.')\n          break;\n        // Need >= 3 cells.\n        if (cellsCount == 2 && board[i][j] == color)\n          break;\n        // >= 3 cells.\n        if (board[i][j] == color)\n          return true;\n        i += dx;\n        j += dy;\n        ++cellsCount;\n      }\n    }\n\n    return false;\n  }\n};\n", "1959": "class Solution {\n public:\n  int minSpaceWastedKResizing(vector<int>& nums, int k) {\n    vector<vector<int>> mem(nums.size(), vector<int>(k + 1, -1));\n    return minSpaceWasted(nums, 0, k, mem);\n  }\n\n private:\n  static constexpr int kMax = 200'000'000;\n\n  // Returns the minimum space wasted for nums[i..n) if you can resize k times.\n  int minSpaceWasted(const vector<int>& nums, int i, int k,\n                     vector<vector<int>>& mem) {\n    if (i == nums.size())\n      return 0;\n    if (k == -1)\n      return kMax;\n    if (mem[i][k] != -1)\n      return mem[i][k];\n\n    int res = kMax;\n    int sum = 0;\n    int maxNum = nums[i];\n\n    for (int j = i; j < nums.size(); ++j) {\n      sum += nums[j];\n      maxNum = max(maxNum, nums[j]);\n      const int wasted = maxNum * (j - i + 1) - sum;\n      res = min(res, minSpaceWasted(nums, j + 1, k - 1, mem) + wasted);\n    }\n\n    return mem[i][k] = res;\n  }\n};\n", "1960": "class Solution {\n public:\n  long long maxProduct(string s) {\n    const int n = s.length();\n    long ans = 1;\n    vector<long> pows{1};  // pows[i] := kBase^i % kHash\n    // hashL[i] = the hash of the first i letters of s, where hashL[i] =\n    // (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % kHash\n    vector<long> hashL{0};\n    // hashR[i] = the hash of the last i letters of s, where hashR[i] =\n    // (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % kHash\n    vector<long> hashR{0};\n    // maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    vector<int> maxLeft(n);\n    // maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    vector<int> maxRight(n);\n\n    for (int i = 0; i < n; ++i)\n      pows.push_back(pows.back() * kBase % kHash);\n\n    for (int i = 0; i < n; ++i)\n      hashL.push_back((hashL.back() * kBase + val(s[i])) % kHash);\n\n    for (int i = n - 1; i >= 0; --i)\n      hashR.push_back((hashR.back() * kBase + val(s[i])) % kHash);\n\n    ranges::reverse(hashR);\n\n    int maxLength = 1;\n    for (int r = 0; r < n; ++r) {\n      const int l = (r - maxLength - 2) + 1;\n      if (l >= 0 && isPalindrome(l, r + 1, hashL, hashR, pows))\n        maxLength += 2;\n      maxLeft[r] = maxLength;\n    }\n\n    maxLength = 1;\n    for (int l = n - 1; l >= 0; --l) {\n      const int r = (l + maxLength + 2) - 1;\n      if (r < n && isPalindrome(l, r + 1, hashL, hashR, pows))\n        maxLength += 2;\n      maxRight[l] = maxLength;\n    }\n\n    for (int i = 1; i < n; ++i)\n      ans = max(ans, static_cast<long>(maxLeft[i - 1]) * maxRight[i]);\n\n    return ans;\n  }\n\n private:\n  static constexpr int kBase = 26;\n  static constexpr int kHash = 1'000'000'007;\n\n  static constexpr int val(char c) {\n    return c - 'a';\n  }\n\n  // Returns true if s[l..r) is a palindrome.\n  bool isPalindrome(int l, int r, const vector<long>& hashL,\n                    const vector<long>& hashR, const vector<long>& pows) {\n    return getLeftRollingHash(l, r, hashL, pows) ==\n           getRightRollingHash(l, r, hashR, pows);\n  }\n\n  // Returns the left rolling hash of s[l..r).\n  long getLeftRollingHash(int l, int r, const vector<long>& hashL,\n                          const vector<long>& pows) {\n    const long h = (hashL[r] - hashL[l] * pows[r - l]) % kHash;\n    return h < 0 ? h + kHash : h;\n  }\n\n  // Returns the right rolling hash of s[l..r).\n  long getRightRollingHash(int l, int r, const vector<long>& hashR,\n                           const vector<long>& pows) {\n    const long h = (hashR[l] - hashR[r] * pows[r - l]) % kHash;\n    return h < 0 ? h + kHash : h;\n  }\n};\n", "1961": "class Solution {\n public:\n  bool isPrefixString(string s, vector<string>& words) {\n    string prefix;\n    for (const string& word : words) {\n      prefix += word;\n      if (prefix == s)\n        return true;\n    }\n    return false;\n  }\n};\n", "1962": "class Solution {\n public:\n  int minStoneSum(vector<int>& piles, int k) {\n    int ans = accumulate(piles.begin(), piles.end(), 0);\n    priority_queue<int> maxHeap;\n\n    for (const int pile : piles)\n      maxHeap.push(pile);\n\n    for (int i = 0; i < k; ++i) {\n      const int maxPile = maxHeap.top();\n      maxHeap.pop();\n      maxHeap.push(maxPile - maxPile / 2);\n      ans -= maxPile / 2;\n    }\n\n    return ans;\n  }\n};\n", "1963": "class Solution {\n public:\n  int minSwaps(string s) {\n    // Cancel out all the matched pairs, then we'll be left with \"]]]..[[[\".\n    // The answer is ceil(the number of unmatched pairs / 2).\n    int unmatched = 0;\n\n    for (const char c : s)\n      if (c == '[')\n        ++unmatched;\n      else if (unmatched > 0)  // c == ']' and there's a match.\n        --unmatched;\n\n    return (unmatched + 1) / 2;\n  }\n};\n", "1964": "class Solution {\n public:\n  // Similar to 300. Longest Increasing Subsequence\n  vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {\n    vector<int> ans;\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n\n    for (const int obstacle : obstacles)\n      if (tails.empty() || obstacle >= tails.back()) {\n        tails.push_back(obstacle);\n        ans.push_back(tails.size());\n      } else {\n        const int index = firstGreater(tails, obstacle);\n        tails[index] = obstacle;\n        ans.push_back(index + 1);\n      }\n\n    return ans;\n  }\n\n private:\n  int firstGreater(const vector<int>& arr, int target) {\n    return ranges::upper_bound(arr, target) - arr.begin();\n  }\n};\n", "1966": "class Solution {\n public:\n  int binarySearchableNumbers(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // prefixMaxs[i] := max(nums[0..i))\n    vector<int> prefixMaxs(n);\n    // suffixMins[i] := min(nums[i + 1..n))\n    vector<int> suffixMins(n);\n\n    // Fill in `prefixMaxs`.\n    prefixMaxs[0] = INT_MIN;\n    for (int i = 1; i < n; ++i)\n      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1]);\n\n    // Fill in `suffixMins`.\n    suffixMins[n - 1] = INT_MAX;\n    for (int i = n - 2; i >= 0; --i)\n      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1]);\n\n    for (int i = 0; i < n; ++i)\n      if (prefixMaxs[i] < nums[i] && nums[i] < suffixMins[i])\n        ++ans;\n\n    return ans;\n  }\n};\n", "1967": "class Solution {\n public:\n  int numOfStrings(vector<string>& patterns, string word) {\n    return ranges::count_if(patterns, [&word](const string& pattern) {\n      return word.find(pattern) != word.npos;\n    });\n  }\n};\n", "1968": "class Solution {\n public:\n  vector<int> rearrangeArray(vector<int>& nums) {\n    ranges::sort(nums);\n    for (int i = 1; i < nums.size(); i += 2)\n      swap(nums[i], nums[i - 1]);\n    return nums;\n  }\n};\n", "1969": "class Solution {\n public:\n  int minNonZeroProduct(int p) {\n    // Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].\n    const long n = 1L << p;\n    const long halfCount = n / 2 - 1;\n    return modPow(n - 2, halfCount) * ((n - 1) % kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1L;\n    x %= kMod;\n    if (n % 2 == 1)\n      return x * modPow(x, n - 1) % kMod;\n    return modPow(x * x, n / 2) % kMod;\n  }\n};\n", "1970": "class Solution {\n public:\n  int latestDayToCross(int row, int col, vector<vector<int>>& cells) {\n    int ans = 0;\n    int l = 1;\n    int r = cells.size() - 1;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (canWalk(m, row, col, cells)) {\n        ans = m;\n        l = m + 1;\n      } else {\n        r = m - 1;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  bool canWalk(int day, int row, int col, const vector<vector<int>>& cells) {\n    vector<vector<int>> matrix(row, vector<int>(col));\n    for (int i = 0; i < day; ++i) {\n      const int x = cells[i][0] - 1;\n      const int y = cells[i][1] - 1;\n      matrix[x][y] = 1;\n    }\n\n    queue<pair<int, int>> q;\n\n    for (int j = 0; j < col; ++j)\n      if (matrix[0][j] == 0) {\n        q.emplace(0, j);\n        matrix[0][j] = 1;\n      }\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == row || y < 0 || y == col)\n          continue;\n        if (matrix[x][y] == 1)\n          continue;\n        if (x == row - 1)\n          return true;\n        q.emplace(x, y);\n        matrix[x][y] = 1;\n      }\n    }\n\n    return false;\n  }\n};\n", "1971": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  bool validPath(int n, vector<vector<int>>& edges, int source,\n                 int destination) {\n    UnionFind uf(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      uf.unionByRank(u, v);\n    }\n\n    return uf.find(source) == uf.find(destination);\n  }\n};\n", "1973": "struct T {\n  long sum;\n  int count;\n};\n\nclass Solution {\n public:\n  int equalToDescendants(TreeNode* root) {\n    return dfs(root).count;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return T{.sum = 0, .count = 0};\n    T left = dfs(root->left);\n    T right = dfs(root->right);\n    return T{.sum = root->val + left.sum + right.sum,\n             .count = left.count + right.count +\n                      (root->val == left.sum + right.sum ? 1 : 0)};\n  }\n};\n", "1974": "class Solution {\n public:\n  int minTimeToType(string word) {\n    int moves = 0;\n    char letter = 'a';\n\n    for (const char c : word) {\n      const int diff = abs(c - letter);\n      moves += min(diff, 26 - diff);\n      letter = c;\n    }\n\n    return moves + word.length();\n  }\n};\n", "1975": "class Solution {\n public:\n  long long maxMatrixSum(vector<vector<int>>& matrix) {\n    long absSum = 0;\n    int minAbs = INT_MAX;\n    // 0 := even number of negatives\n    // 1 := odd number of negatives\n    int oddNeg = 0;\n\n    for (const vector<int>& row : matrix)\n      for (const int num : row) {\n        absSum += abs(num);\n        minAbs = min(minAbs, abs(num));\n        if (num < 0)\n          oddNeg ^= 1;\n      }\n\n    return absSum - oddNeg * minAbs * 2;\n  }\n};\n", "1976": "class Solution {\n public:\n  int countPaths(int n, vector<vector<int>>& roads) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      const int w = road[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dijkstra(graph, 0, n - 1);\n  }\n\n private:\n  // Similar to 1786. Number of Restricted Paths From First to Last Node\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {\n    constexpr int kMod = 1'000'000'007;\n    vector<long> ways(graph.size());\n    vector<long> dist(graph.size(), LONG_MAX);\n\n    ways[src] = 1;\n    dist[src] = 0;\n    using P = pair<long, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          ways[v] = ways[u];\n          minHeap.emplace(dist[v], v);\n        } else if (d + w == dist[v]) {\n          ways[v] += ways[u];\n          ways[v] %= kMod;\n        }\n    }\n\n    return ways[dst];\n  }\n};\n", "1977": "class Solution {\n public:\n  int numberOfCombinations(string num) {\n    if (num[0] == '0')\n      return 0;\n\n    constexpr int kMod = 1'000'000'007;\n    const int n = num.size();\n    // dp[i][k] := the number of possible lists of integers ending in num[i]\n    // with the length of the last number being 1..k\n    vector<vector<long>> dp(n, vector<long>(n + 1));\n    // lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n    vector<vector<int>> lcs(n + 1, vector<int>(n + 1));\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i + 1; j < n; ++j)\n        if (num[i] == num[j])\n          lcs[i][j] = lcs[i + 1][j + 1] + 1;\n\n    for (int i = 0; i < n; ++i)\n      for (int k = 1; k <= i + 1; ++k) {\n        dp[i][k] += dp[i][k - 1];\n        dp[i][k] %= kMod;\n        // The last number is num[s..i].\n        const int s = i - k + 1;\n        if (num[s] == '0')\n          // the number of possible lists of integers ending in num[i] with the\n          // length of the last number being k\n          continue;\n        if (s == 0) {\n          // the whole string\n          dp[i][k] += 1;\n          continue;\n        }\n        if (s < k) {\n          // The length k is not enough, so add the number of possible lists of\n          // integers in num[0..s - 1].\n          dp[i][k] += dp[s - 1][s];\n          continue;\n        }\n        const int l = lcs[s - k][s];\n        if (l >= k || num[s - k + l] <= num[s + l])\n          // Have enough length k and num[s - k..s - 1] <= num[j..i].\n          dp[i][k] += dp[s - 1][k];\n        else\n          // Have enough length k but num[s - k..s - 1] > num[j..i].\n          dp[i][k] += dp[s - 1][k - 1];\n      }\n\n    return dp[n - 1][n] % kMod;\n  }\n};\n", "1979": "class Solution {\n public:\n  int findGCD(vector<int>& nums) {\n    return __gcd(ranges::min(nums), ranges::max(nums));\n  }\n};\n", "198": "class Solution {\n public:\n  int rob(vector<int>& nums) {\n    int prev1 = 0;  // dp[i - 1]\n    int prev2 = 0;  // dp[i - 2]\n\n    for (const int num : nums) {\n      const int dp = max(prev1, prev2 + num);\n      prev2 = prev1;\n      prev1 = dp;\n    }\n\n    return prev1;\n  }\n};\n", "1980": "class Solution {\n public:\n  string findDifferentBinaryString(vector<string>& nums) {\n    string ans;\n\n    // Flip the i-th bit for each nums[i] so that `ans` is unique.\n    for (int i = 0; i < nums.size(); ++i)\n      ans += nums[i][i] == '0' ? '1' : '0';\n\n    return ans;\n  }\n};\n", "1981": "class Solution {\n public:\n  int minimizeTheDifference(vector<vector<int>>& mat, int target) {\n    const int minSum = getMinSum(mat);\n    if (minSum >= target)  // No need to consider any larger combination.\n      return minSum - target;\n\n    const int maxSum = getMaxSum(mat);\n    vector<vector<int>> mem(mat.size(), vector<int>(maxSum + 1, -1));\n    return minimizeTheDifference(mat, 0, 0, target, mem);\n  }\n\n private:\n  int minimizeTheDifference(const vector<vector<int>>& mat, int i, int sum,\n                            int target, vector<vector<int>>& mem) {\n    if (i == mat.size())\n      return abs(sum - target);\n    if (mem[i][sum] != -1)\n      return mem[i][sum];\n    int res = INT_MAX;\n    for (const int num : mat[i])\n      res = min(res, minimizeTheDifference(mat, i + 1, sum + num, target, mem));\n    return mem[i][sum] = res;\n  }\n\n  int getMinSum(const vector<vector<int>>& mat) {\n    return accumulate(\n        mat.begin(), mat.end(), 0,\n        [](int acc, const vector<int>& row) { return acc + ranges::min(row); });\n  }\n\n  int getMaxSum(const vector<vector<int>>& mat) {\n    return accumulate(\n        mat.begin(), mat.end(), 0,\n        [](int acc, const vector<int>& row) { return acc + ranges::max(row); });\n  }\n};\n", "1982": "class Solution {\n public:\n  vector<int> recoverArray(int n, vector<int>& sums) {\n    ranges::sort(sums);\n    return recover(sums);\n  }\n\n private:\n  vector<int> recover(const vector<int>& sums) {\n    if (sums.size() == 1)  // sums[0] must be 0.\n      return {};\n\n    // Either num or -num must be in the final array.\n    //  num + sumsExcludingNum = sumsIncludingNum\n    // -num + sumsIncludingNum = sumsExcludingNum\n    unordered_map<int, int> count;\n    for (const int sum : sums)\n      ++count[sum];\n\n    const int num = sums[1] - sums[0];\n    vector<int> sumsExcludingNum;\n    vector<int> sumsIncludingNum;\n    bool chooseSumsIncludingNum = false;\n\n    for (const int sum : sums) {\n      if (count[sum] == 0)\n        continue;\n      --count[sum];\n      --count[sum + num];\n      sumsExcludingNum.push_back(sum);\n      sumsIncludingNum.push_back(sum + num);\n      if (sum + num == 0)\n        chooseSumsIncludingNum = true;\n    }\n\n    // Choose `sumsExludingNum` by default since we want to gradually strip\n    // `num` from each sum in `sums` to have the final array. However, we should\n    // always choose the group of sums with 0 since it's a must-have.\n    vector<int> recovered =\n        recover(chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);\n    recovered.push_back(chooseSumsIncludingNum ? -num : num);\n    return recovered;\n  }\n};\n", "1983": "class Solution {\n public:\n  int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums1.size(); ++i) {\n      prefix += nums1[i] - nums2[i];\n      if (const auto it = prefixToIndex.find(prefix);\n          it != prefixToIndex.cend())\n        ans = max(ans, i - it->second);\n      else\n        prefixToIndex[prefix] = i;\n    }\n\n    return ans;\n  }\n};\n", "1984": "class Solution {\n public:\n  int minimumDifference(vector<int>& nums, int k) {\n    ranges::sort(nums);\n\n    int ans = nums[k - 1] - nums[0];\n\n    for (int i = k; i < nums.size(); ++i)\n      ans = min(ans, nums[i] - nums[i - k + 1]);\n\n    return ans;\n  }\n};\n", "1985": "class Solution {\n public:\n  // Similar to 215. Kth Largest Element in an Array\n  string kthLargestNumber(vector<string>& nums, int k) {\n    auto compare = [](const string& a, const string& b) {\n      return a.length() == b.length() ? a > b : a.length() > b.length();\n    };\n    priority_queue<string, vector<string>, decltype(compare)> minHeap(compare);\n\n    for (const string& num : nums) {\n      minHeap.push(num);\n      if (minHeap.size() > k)\n        minHeap.pop();\n    }\n\n    return minHeap.top();\n  }\n};\n", "1986": "class Solution {\n public:\n  int minSessions(vector<int>& tasks, int sessionTime) {\n    for (int numSessions = 1; numSessions <= tasks.size(); ++numSessions)\n      if (dfs(tasks, 0, vector<int>(numSessions), sessionTime))\n        return numSessions;\n    throw;\n  }\n\n  // Returns true if we can assign tasks[s..n) to `sessions`. Note that\n  // `sessions` may be occupied by some tasks.\n  bool dfs(const vector<int>& tasks, int s, vector<int>&& sessions,\n           const int& sessionTime) {\n    if (s == tasks.size())\n      return true;\n\n    for (int& session : sessions) {\n      // Can't assign the tasks[s] to this session.\n      if (session + tasks[s] > sessionTime)\n        continue;\n      // Assign the tasks[s] to this session.\n      session += tasks[s];\n      if (dfs(tasks, s + 1, std::move(sessions), sessionTime))\n        return true;\n      // Backtracking.\n      session -= tasks[s];\n      // If it's the first time we assign the tasks[s] to this session, then\n      // future `session`s can't satisfy either.\n      if (session == 0)\n        return false;\n    }\n\n    return false;\n  }\n};\n", "1987": "class Solution {\n public:\n  // Similar to 940. Distinct Subsequences II\n  int numberOfUniqueGoodSubsequences(string binary) {\n    constexpr int kMod = 1'000'000'007;\n    // endsIn[i] := the number of subsequence that end in ('0' + i)\n    vector<int> endsIn(2);\n\n    for (const char c : binary) {\n      endsIn[c - '0'] = (endsIn[0] + endsIn[1]) % kMod;\n      // Don't count '0' since we want to avoid the leading zeros case.\n      // However, we can always count '1'.\n      if (c == '1')\n        ++endsIn[1];\n    }\n\n    // Count '0' in the end.\n    return (endsIn[0] + endsIn[1] +\n            (binary.find('0') == string::npos ? 0 : 1)) %\n           kMod;\n  }\n};\n", "1989": "class Solution {\n public:\n  int catchMaximumAmountofPeople(vector<int>& team, int dist) {\n    int ans = 0;\n    int i = 0;  // 0s index\n    int j = 0;  // 1s index\n\n    while (i < team.size() && j < team.size())\n      if (i + dist < j || team[i] != 0) {\n        // Find the next 0 that can be caught by 1.\n        ++i;\n      } else if (j + dist < i || team[j] != 1) {\n        // Find the next 1 that can catch 0.\n        ++j;\n      } else {\n        // team[j] catches team[i], so move both.\n        ++ans;\n        ++i;\n        ++j;\n      }\n\n    return ans;\n  }\n};\n", "199": "class Solution {\n public:\n  vector<int> rightSideView(TreeNode* root) {\n    vector<int> ans;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int depth, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n\n    if (depth == ans.size())\n      ans.push_back(root->val);\n    dfs(root->right, depth + 1, ans);\n    dfs(root->left, depth + 1, ans);\n  }\n};\n", "1991": "class Solution {\n public:\n  int findMiddleIndex(vector<int>& nums) {\n    int prefix = 0;\n    int suffix = accumulate(nums.begin(), nums.end(), 0);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      suffix -= nums[i];\n      if (prefix == suffix)\n        return i;\n      prefix += nums[i];\n    }\n\n    return -1;\n  }\n};\n", "1992": "class Solution {\n public:\n  vector<vector<int>> findFarmland(vector<vector<int>>& land) {\n    vector<vector<int>> ans;\n\n    for (int i = 0; i < land.size(); ++i)\n      for (int j = 0; j < land[0].size(); ++j)\n        if (land[i][j] == 1) {\n          int x = i;\n          int y = j;\n          dfs(land, i, j, x, y);\n          ans.push_back({i, j, x, y});\n        }\n\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& land, int i, int j, int& x, int& y) {\n    if (i < 0 || i == land.size() || j < 0 || j == land[0].size())\n      return;\n    if (land[i][j] != 1)\n      return;\n    land[i][j] = 2;  // Mark as visited.\n    x = max(x, i);\n    y = max(y, j);\n    dfs(land, i + 1, j, x, y);\n    dfs(land, i, j + 1, x, y);\n  }\n};\n", "1993": "struct Node {\n  vector<int> children;\n  int lockedBy = -1;\n};\n\nclass LockingTree {\n public:\n  LockingTree(vector<int>& parent) : parent(parent) {\n    nodes.resize(parent.size());\n    for (int i = 1; i < parent.size(); ++i)\n      nodes[parent[i]].children.push_back(i);\n  }\n\n  bool lock(int num, int user) {\n    if (nodes[num].lockedBy != -1)\n      return false;\n    return nodes[num].lockedBy = user;\n  }\n\n  bool unlock(int num, int user) {\n    if (nodes[num].lockedBy != user)\n      return false;\n    return nodes[num].lockedBy = -1;\n  }\n\n  bool upgrade(int num, int user) {\n    if (nodes[num].lockedBy != -1)\n      return false;\n    if (!anyLockedDescendant(num))\n      return false;\n\n    // Walk up the hierarchy to ensure that there are no locked ancestors.\n    for (int i = num; i != -1; i = parent[i])\n      if (nodes[i].lockedBy != -1)\n        return false;\n\n    unlockDescendants(num);\n    return nodes[num].lockedBy = user;\n  }\n\n private:\n  const vector<int> parent;\n  vector<Node> nodes;\n\n  bool anyLockedDescendant(int i) {\n    return nodes[i].lockedBy != -1 ||\n           ranges::any_of(nodes[i].children, [this](const int child) {\n      return anyLockedDescendant(child);\n    });\n  }\n\n  void unlockDescendants(int i) {\n    nodes[i].lockedBy = -1;\n    for (const int child : nodes[i].children)\n      unlockDescendants(child);\n  }\n};\n", "1994": "class Solution {\n public:\n  int numberOfGoodSubsets(vector<int>& nums) {\n    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    const int n = 1 << primes.size();\n    const int maxNum = ranges::max(nums);\n    vector<long> dp(n);\n    vector<int> count(maxNum + 1);\n\n    dp[0] = 1;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int num = 2; num <= maxNum; ++num) {\n      if (count[num] == 0)\n        continue;\n      if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0)\n        continue;\n      const int numPrimesMask = getPrimesMask(num, primes);\n      for (int primesMask = 0; primesMask < n; ++primesMask) {\n        if ((primesMask & numPrimesMask) > 0)\n          continue;\n        const int nextPrimesMask = primesMask | numPrimesMask;\n        dp[nextPrimesMask] += dp[primesMask] * count[num];\n        dp[nextPrimesMask] %= kMod;\n      }\n    }\n\n    return modPow(2, count[1]) *\n           (accumulate(dp.begin() + 1, dp.end(), 0L) % kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  int getPrimesMask(int num, const vector<int>& primes) {\n    int primesMask = 0;\n    for (int i = 0; i < primes.size(); ++i)\n      if (num % primes[i] == 0)\n        primesMask |= 1 << i;\n    return primesMask;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "1995": "class Solution {\n public:\n  int countQuadruplets(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int c = n - 1; c > 1; --c) {  // `c` also represents `d`.\n      for (int b = c - 1; b > 0; --b)\n        for (int a = b - 1; a >= 0; --a)\n          if (const auto it = count.find(nums[a] + nums[b] + nums[c]);\n              it != count.cend())\n            ans += it->second;\n      ++count[nums[c]];  // c := d\n    }\n\n    return ans;\n  }\n};\n", "1996": "class Solution {\n public:\n  int numberOfWeakCharacters(vector<vector<int>>& properties) {\n    int ans = 0;\n    const int maxAttack = (*ranges::max_element(\n        properties, ranges::less{},\n        [](const vector<int>& property) { return property[0]; }))[0];\n    // maxDefenses[i] := the maximum defense for the i-th attack\n    vector<int> maxDefenses(maxAttack + 2);\n\n    for (const vector<int>& property : properties) {\n      const int attack = property[0];\n      const int defense = property[1];\n      maxDefenses[attack] = max(maxDefenses[attack], defense);\n    }\n\n    for (int i = maxAttack; i >= 1; --i)\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1]);\n\n    for (const vector<int>& property : properties) {\n      const int attack = property[0];\n      const int defense = property[1];\n      if (maxDefenses[attack + 1] > defense)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "1997": "class Solution {\n public:\n  int firstDayBeenInAllRooms(vector<int>& nextVisit) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nextVisit.size();\n    // dp[i] := the number of days to visit room i for the first time\n    vector<int> dp(n);\n\n    // Whenever we visit i, visit times of room[0..i - 1] are all even.\n    // Therefore, the rooms before i can be seen as reset and we can safely\n    // reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for (int i = 1; i < n; ++i)\n      // The total days to visit room[i] is the sum of\n      //   * dp[i - 1]: 1st-time visit room[i - 1]\n      //   * 1: visit room[nextVisit[i - 1]]\n      //   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      //   * 1: visit room[i]\n      dp[i] = (2L * dp[i - 1] - dp[nextVisit[i - 1]] + 2 + kMod) % kMod;\n\n    return dp.back();\n  }\n};\n", "1998": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  bool gcdSort(vector<int>& nums) {\n    const int mx = ranges::max(nums);\n    const vector<int> minPrimeFactors = sieveEratosthenes(mx + 1);\n    UnionFind uf(mx + 1);\n\n    for (const int num : nums)\n      for (const int primeFactor : getPrimeFactors(num, minPrimeFactors))\n        uf.unionByRank(num, primeFactor);\n\n    vector<int> sortedNums(nums);\n    ranges::sort(sortedNums);\n\n    for (int i = 0; i < nums.size(); ++i)\n      // Can't swap nums[i] with sortedNums[i].\n      if (uf.find(nums[i]) != uf.find(sortedNums[i]))\n        return false;\n\n    return true;\n  }\n\n private:\n  // Gets the minimum prime factor of i, where 1 < i <= n.\n  vector<int> sieveEratosthenes(int n) {\n    vector<int> minPrimeFactors(n + 1);\n    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);\n    for (int i = 2; i * i < n; ++i)\n      if (minPrimeFactors[i] == i)  // `i` is prime.\n        for (int j = i * i; j < n; j += i)\n          minPrimeFactors[j] = min(minPrimeFactors[j], i);\n    return minPrimeFactors;\n  }\n\n  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactors) {\n    vector<int> primeFactors;\n    while (num > 1) {\n      const int divisor = minPrimeFactors[num];\n      primeFactors.push_back(divisor);\n      while (num % divisor == 0)\n        num /= divisor;\n    }\n    return primeFactors;\n  }\n};\n", "1999": "class Solution {\n public:\n  int findInteger(int k, int digit1, int digit2) {\n    return findInteger(k, digit1, digit2, 0);\n  }\n\n private:\n  int findInteger(int k, int d1, int d2, long x) {\n    if (x > INT_MAX)\n      return -1;\n    if (x > k && x % k == 0)\n      return x;\n    // Skip if d1/d2 and x are zero.\n    const int a = (x + d1 == 0) ? -1 : findInteger(k, d1, d2, x * 10 + d1);\n    const int b = (x + d2 == 0) ? -1 : findInteger(k, d1, d2, x * 10 + d2);\n    if (a == -1)\n      return b;\n    if (b == -1)\n      return a;\n    return min(a, b);\n  }\n};\n", "2": "class Solution {\n public:\n  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode dummy(0);\n    ListNode* curr = &dummy;\n    int carry = 0;\n\n    while (l1 != nullptr || l2 != nullptr || carry > 0) {\n      if (l1 != nullptr) {\n        carry += l1->val;\n        l1 = l1->next;\n      }\n      if (l2 != nullptr) {\n        carry += l2->val;\n        l2 = l2->next;\n      }\n      curr->next = new ListNode(carry % 10);\n      carry /= 10;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "20": "class Solution {\n public:\n  bool isValid(string s) {\n    stack<char> stack;\n\n    for (const char c : s)\n      if (c == '(')\n        stack.push(')');\n      else if (c == '{')\n        stack.push('}');\n      else if (c == '[')\n        stack.push(']');\n      else if (stack.empty() || pop(stack) != c)\n        return false;\n\n    return stack.empty();\n  }\n\n private:\n  int pop(stack<char>& stack) {\n    const int c = stack.top();\n    stack.pop();\n    return c;\n  }\n};\n", "200": "class Solution {\n public:\n  int numIslands(vector<vector<char>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == '1') {\n          dfs(grid, i, j);\n          ++ans;\n        }\n\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<char>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] != '1')\n      return;\n\n    grid[i][j] = '2';  // Mark '2' as visited.\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n  }\n};\n", "2000": "class Solution {\n public:\n  string reversePrefix(string word, char ch) {\n    reverse(word.begin(), word.begin() + word.find(ch) + 1);\n    return word;\n  }\n};\n", "2001": "class Solution {\n public:\n  long long interchangeableRectangles(vector<vector<int>>& rectangles) {\n    long ans = 0;\n    unordered_map<pair<int, int>, int, PairHash> ratioCount;\n\n    for (const vector<int>& rectangle : rectangles) {\n      const int width = rectangle[0];\n      const int height = rectangle[1];\n      const int d = __gcd(width, height);\n      ++ratioCount[{width / d, height / d}];\n    }\n\n    for (const auto& [_, count] : ratioCount)\n      ans += static_cast<long>(count) * (count - 1) / 2;\n\n    return ans;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "2002": "class Solution {\n public:\n  int maxProduct(string s) {\n    size_t ans = 0;\n    dfs(s, 0, \"\", \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int i, string&& s1, string&& s2, size_t& ans) {\n    if (i == s.length()) {\n      if (isPalindrome(s1) && isPalindrome(s2))\n        ans = max(ans, s1.length() * s2.length());\n      return;\n    }\n\n    s1.push_back(s[i]);\n    dfs(s, i + 1, std::move(s1), std::move(s2), ans);\n    s1.pop_back();\n\n    s2.push_back(s[i]);\n    dfs(s, i + 1, std::move(s1), std::move(s2), ans);\n    s2.pop_back();\n\n    dfs(s, i + 1, std::move(s1), std::move(s2), ans);\n  }\n\n  bool isPalindrome(const string& s) {\n    int i = 0;\n    int j = s.length() - 1;\n    while (i < j) {\n      if (s[i] != s[j])\n        return false;\n      ++i;\n      --j;\n    }\n    return true;\n  }\n};\n", "2003": "class Solution {\n public:\n  vector<int> smallestMissingValueSubtree(vector<int>& parents,\n                                          vector<int>& nums) {\n    const int n = parents.size();\n    vector<int> ans(n, 1);\n    vector<vector<int>> tree(n);\n    unordered_set<int> seen;\n    int minMiss = 1;\n\n    for (int i = 1; i < n; ++i)\n      tree[parents[i]].push_back(i);\n\n    int nodeThatsOne = getNode(nums);\n    if (nodeThatsOne == -1)\n      return ans;\n\n    int u = nodeThatsOne;\n    int prev = -1;  // the u that just handled\n\n    // Upward from `nodeThatsOne` to the root `u`.\n    while (u != -1) {\n      for (const int v : tree[u])\n        if (v != prev)\n          dfs(v, tree, seen, nums);\n      seen.insert(nums[u]);\n      while (seen.contains(minMiss))\n        ++minMiss;\n      ans[u] = minMiss;\n      prev = u;\n      u = parents[u];\n    }\n\n    return ans;\n  }\n\n private:\n  int getNode(const vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == 1)\n        return i;\n    return -1;\n  }\n\n  void dfs(int u, const vector<vector<int>>& tree, unordered_set<int>& seen,\n           const vector<int>& nums) {\n    seen.insert(nums[u]);\n    for (const int v : tree[u])\n      dfs(v, tree, seen, nums);\n  }\n};\n", "2005": "class Solution {\n public:\n  bool findGameWinner(int n) {\n    return n % 6 != 1;\n  }\n};\n", "2006": "class Solution {\n public:\n  int countKDifference(vector<int>& nums, int k) {\n    constexpr int kMax = 100;\n    int ans = 0;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = k + 1; i <= kMax; ++i)\n      ans += count[i] * count[i - k];\n\n    return ans;\n  }\n};\n", "2007": "class Solution {\n public:\n  vector<int> findOriginalArray(vector<int>& changed) {\n    vector<int> ans;\n    queue<int> q;\n\n    ranges::sort(changed);\n\n    for (const int num : changed)\n      if (!q.empty() && num == q.front()) {\n        q.pop();\n      } else {\n        q.push(num * 2);\n        ans.push_back(num);\n      }\n\n    return q.empty() ? ans : vector<int>();\n  }\n};\n", "2008": "class Solution {\n public:\n  long long maxTaxiEarnings(int n, vector<vector<int>>& rides) {\n    vector<vector<pair<int, int>>> endToStartAndEarns(n + 1);\n    // dp[i] := the maximum dollars you can earn ending in i\n    vector<long> dp(n + 1);\n\n    for (const vector<int>& ride : rides) {\n      const int start = ride[0];\n      const int end = ride[1];\n      const int tip = ride[2];\n      const int earn = end - start + tip;\n      endToStartAndEarns[end].emplace_back(start, earn);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = dp[i - 1];\n      for (const auto& [start, earn] : endToStartAndEarns[i])\n        dp[i] = max(dp[i], dp[start] + earn);\n    }\n\n    return dp[n];\n  }\n};\n", "2009": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = n;\n\n    ranges::sort(nums);\n    nums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int start = nums[i];\n      const int end = start + n - 1;\n      const int index = firstGreater(nums, end);\n      const int uniqueLength = index - i;\n      ans = min(ans, n - uniqueLength);\n    }\n\n    return ans;\n  }\n\n private:\n  int firstGreater(const vector<int>& arr, int target) {\n    return ranges::upper_bound(arr, target) - arr.begin();\n  }\n};\n", "201": "class Solution {\n public:\n  int rangeBitwiseAnd(int m, int n) {\n    int shiftBits = 0;\n\n    while (m != n) {\n      m >>= 1;\n      n >>= 1;\n      ++shiftBits;\n    }\n\n    return m << shiftBits;\n  }\n};\n", "2011": "class Solution {\n public:\n  int finalValueAfterOperations(vector<string>& operations) {\n    int ans = 0;\n\n    for (const string& op : operations)\n      ans += op[1] == '+' ? 1 : -1;\n\n    return ans;\n  }\n};\n", "2012": "class Solution {\n public:\n  int sumOfBeauties(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    vector<int> minOfRight(n);\n    minOfRight.back() = nums.back();\n\n    for (int i = n - 2; i >= 2; --i)\n      minOfRight[i] = min(nums[i], minOfRight[i + 1]);\n\n    int maxOfLeft = nums[0];\n\n    for (int i = 1; i <= n - 2; ++i) {\n      if (maxOfLeft < nums[i] && nums[i] < minOfRight[i + 1])\n        ans += 2;\n      else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])\n        ans += 1;\n      maxOfLeft = max(maxOfLeft, nums[i]);\n    }\n\n    return ans;\n  }\n};\n", "2013": "class DetectSquares {\n public:\n  void add(vector<int> point) {\n    ++pointCount[getHash(point[0], point[1])];\n  }\n\n  int count(vector<int> point) {\n    const int x1 = point[0];\n    const int y1 = point[1];\n    int ans = 0;\n\n    for (const auto& [hash, count] : pointCount) {\n      const int x3 = hash >> 10;\n      const int y3 = hash & 1023;\n      if (x1 != x3 && abs(x1 - x3) == abs(y1 - y3)) {\n        const int p = getHash(x1, y3);\n        const int q = getHash(x3, y1);\n        if (pointCount.contains(p) && pointCount.contains(q))\n          ans += count * pointCount[p] * pointCount[q];\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  unordered_map<int, int> pointCount;\n\n  int getHash(int i, int j) {\n    return i << 10 | j;\n  }\n};\n", "2014": "class Solution {\n public:\n  string longestSubsequenceRepeatedK(string s, int k) {\n    string ans;\n    vector<int> count(26);\n    vector<char> possibleChars;\n    // Stores subsequences, where the length grows by 1 each time.\n    queue<string> q{{\"\"}};\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c - 'a'] >= k)\n        possibleChars.push_back(c);\n\n    while (!q.empty()) {\n      const string currSubseq = q.front();\n      q.pop();\n      if (currSubseq.length() * k > s.length())\n        return ans;\n      for (const char c : possibleChars) {\n        const string& newSubseq = currSubseq + c;\n        if (isSubsequence(newSubseq, s, k)) {\n          q.push(newSubseq);\n          ans = newSubseq;\n        }\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  bool isSubsequence(const string& subseq, string& s, int k) {\n    int i = 0;  // subseq's index\n    for (const char c : s)\n      if (c == subseq[i])\n        if (++i == subseq.length()) {\n          if (--k == 0)\n            return true;\n          i = 0;\n        }\n    return false;\n  }\n};\n", "2015": "class Solution {\n public:\n  vector<vector<int>> averageHeightOfBuildings(vector<vector<int>>& buildings) {\n    vector<vector<int>> ans;\n    vector<pair<int, int>> events;\n\n    for (const vector<int>& b : buildings) {\n      const int start = b[0];\n      const int end = b[1];\n      const int height = b[2];\n      events.emplace_back(start, height);\n      events.emplace_back(end, -height);\n    }\n\n    ranges::sort(events);\n\n    int prev = 0;\n    int count = 0;\n    int sumHeight = 0;\n\n    for (const auto& [curr, height] : events) {\n      if (sumHeight > 0 && curr > prev) {\n        const int avgHeight = sumHeight / count;\n        if (!ans.empty() && ans.back()[1] == prev && avgHeight == ans.back()[2])\n          ans.back()[1] = curr;\n        else\n          ans.push_back({prev, curr, avgHeight});\n      }\n      sumHeight += height;\n      count += height > 0 ? 1 : -1;\n      prev = curr;\n    }\n\n    return ans;\n  }\n};\n", "2016": "class Solution {\n public:\n  int maximumDifference(vector<int>& nums) {\n    int ans = -1;\n    int mn = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] > mn)\n        ans = max(ans, nums[i] - mn);\n      mn = min(mn, nums[i]);\n    }\n\n    return ans;\n  }\n};\n", "2017": "class Solution {\n public:\n  long long gridGame(vector<vector<int>>& grid) {\n    const int n = grid[0].size();\n    long ans = LONG_MAX;\n    long sumRow0 = accumulate(grid[0].begin(), grid[0].end(), 0L);\n    long sumRow1 = 0;\n\n    for (int i = 0; i < n; ++i) {\n      sumRow0 -= grid[0][i];\n      ans = min(ans, max(sumRow0, sumRow1));\n      sumRow1 += grid[1][i];\n    }\n\n    return ans;\n  }\n};\n", "2018": "class Solution {\n public:\n  bool placeWordInCrossword(vector<vector<char>>& board, string word) {\n    for (const vector<vector<char>>& state : {board, getRotated(board)})\n      for (const vector<char>& chars : state)\n        for (const string& token : getTokens(join(chars)))\n          for (const string& letters :\n               {word, string{word.rbegin(), word.rend()}})\n            if (letters.length() == token.length())\n              if (canFit(letters, token))\n                return true;\n    return false;\n  }\n\n private:\n  vector<vector<char>> getRotated(const vector<vector<char>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n    vector<vector<char>> rotated(n, vector<char>(m));\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        rotated[j][i] = board[i][j];\n    return rotated;\n  }\n\n  vector<string> getTokens(const string& row) {\n    vector<string> tokens;\n    int start = 0;\n    int end;\n    string token;\n    do {\n      end = row.find('#', start);\n      token = row.substr(start, end - start);\n      if (!token.empty())\n        tokens.push_back(token);\n      start = end + 1;\n    } while (end != string::npos);\n    return tokens;\n  }\n\n  string join(const vector<char>& chars) {\n    string joined;\n    for (const char c : chars)\n      joined += c;\n    return joined;\n  }\n\n  bool canFit(const string& letters, const string& token) {\n    for (int i = 0; i < letters.length(); ++i)\n      if (token[i] != ' ' && token[i] != letters[i])\n        return false;\n    return true;\n  }\n};\n", "2019": "class Solution {\n public:\n  int scoreOfStudents(string s, vector<int>& answers) {\n    const int n = s.length() / 2 + 1;\n    const unordered_map<char, function<int(int, int)>> func{\n        {'+', plus<int>()}, {'*', multiplies<int>()}};\n    int ans = 0;\n    vector<vector<unordered_set<int>>> dp(n, vector<unordered_set<int>>(n));\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i].insert(s[i * 2] - '0');\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        for (int k = i; k < j; ++k) {\n          const char op = s[k * 2 + 1];\n          for (const int a : dp[i][k])\n            for (const int b : dp[k + 1][j]) {\n              const int res = func.at(op)(a, b);\n              if (res <= 1000)\n                dp[i][j].insert(res);\n            }\n        }\n      }\n\n    const int correctAnswer = eval(s);\n\n    for (const int answer : answers)\n      ++count[answer];\n\n    for (const auto& [answer, freq] : count)\n      if (answer == correctAnswer)\n        ans += 5 * freq;\n      else if (dp[0][n - 1].contains(answer))\n        ans += 2 * freq;\n\n    return ans;\n  }\n\n private:\n  int eval(const string& s) {\n    int ans = 0;\n    int prevNum = 0;\n    int currNum = 0;\n    char op = '+';\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (isdigit(c))\n        currNum = currNum * 10 + (c - '0');\n      if (!isdigit(c) || i == s.length() - 1) {\n        if (op == '+') {\n          ans += prevNum;\n          prevNum = currNum;\n        } else if (op == '*') {\n          prevNum = prevNum * currNum;\n        }\n        op = c;\n        currNum = 0;\n      }\n    }\n\n    return ans + prevNum;\n  }\n};\n", "202": "class Solution {\n public:\n  bool isHappy(int n) {\n    int slow = squaredSum(n);\n    int fast = squaredSum(squaredSum(n));\n\n    while (slow != fast) {\n      slow = squaredSum(slow);\n      fast = squaredSum(squaredSum(fast));\n    }\n\n    return slow == 1;\n  }\n\n private:\n  int squaredSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n      sum += pow(n % 10, 2);\n      n /= 10;\n    }\n    return sum;\n  };\n};\n", "2021": "class Solution {\n public:\n  int brightestPosition(vector<vector<int>>& lights) {\n    int ans = INT_MAX;\n    int maxBrightness = -1;\n    int currBrightness = 0;\n    map<int, int> line;\n\n    for (const vector<int>& light : lights) {\n      const int position = light[0];\n      const int range = light[1];\n      ++line[position - range];\n      --line[position + range + 1];\n    }\n\n    for (const auto& [pos, brightness] : line) {\n      currBrightness += brightness;\n      if (currBrightness > maxBrightness) {\n        maxBrightness = currBrightness;\n        ans = pos;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2022": "class Solution {\n public:\n  vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {\n    if (original.size() != m * n)\n      return {};\n\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    for (int i = 0; i < original.size(); ++i)\n      ans[i / n][i % n] = original[i];\n\n    return ans;\n  }\n};\n", "2023": "class Solution {\n public:\n  int numOfPairs(vector<string>& nums, string target) {\n    const int n = target.length();\n    int ans = 0;\n    unordered_map<string, int> count;\n\n    for (const string& num : nums) {\n      const int k = num.length();\n      if (k >= n)\n        continue;\n      if (target.substr(0, k) == num)\n        ans += count[target.substr(k)];\n      if (target.substr(n - k) == num)\n        ans += count[target.substr(0, n - k)];\n      ++count[num];\n    }\n\n    return ans;\n  }\n};\n", "2024": "class Solution {\n public:\n  int maxConsecutiveAnswers(string answerKey, int k) {\n    int ans = 0;\n    int maxCount = 0;\n    vector<int> count(2);\n\n    for (int l = 0, r = 0; r < answerKey.length(); ++r) {\n      maxCount = max(maxCount, ++count[answerKey[r] == 'T']);\n      while (maxCount + k < r - l + 1)\n        --count[answerKey[l++] == 'T'];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "2025": "class Solution {\n public:\n  int waysToPartition(vector<int>& nums, int k) {\n    const int n = nums.size();\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    long prefix = 0;\n    // count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    unordered_map<long, int> l;\n    // count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    unordered_map<long, int> r;\n\n    for (int pivot = 1; pivot < n; ++pivot) {\n      prefix += nums[pivot - 1];\n      const long suffix = sum - prefix;\n      ++r[prefix - suffix];\n    }\n\n    int ans = r[0];\n    prefix = 0;\n\n    for (const int num : nums) {\n      ans = max(ans, l[k - num] + r[num - k]);\n      prefix += num;\n      const long suffix = sum - prefix;\n      const long diff = prefix - suffix;\n      --r[diff];\n      ++l[diff];\n    }\n\n    return ans;\n  }\n};\n", "2027": "class Solution {\n public:\n  int minimumMoves(string s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length();)\n      if (s[i] == 'O') {\n        ++i;\n      } else {\n        ++ans;\n        i += 3;\n      }\n\n    return ans;\n  }\n};\n", "2028": "class Solution {\n public:\n  vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n    const int targetSum = (rolls.size() + n) * mean;\n    int missingSum = targetSum - accumulate(rolls.begin(), rolls.end(), 0);\n    if (missingSum > n * 6 || missingSum < n)\n      return {};\n\n    vector<int> ans(n, missingSum / n);\n    missingSum %= n;\n    for (int i = 0; i < missingSum; ++i)\n      ++ans[i];\n\n    return ans;\n  }\n};\n", "2029": "class Solution {\n public:\n  bool stoneGameIX(vector<int>& stones) {\n    vector<int> count(3);\n\n    for (const int stone : stones)\n      ++count[stone % 3];\n\n    if (count[0] % 2 == 0)\n      return min(count[1], count[2]) > 0;\n    return abs(count[1] - count[2]) > 2;\n  }\n};\n", "203": "class Solution {\n public:\n  ListNode* removeElements(ListNode* head, int val) {\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n\n    for (; head; head = head->next)\n      if (head->val != val) {\n        prev->next = head;\n        prev = prev->next;\n      }\n    prev->next = nullptr;  // In case that the last value equals `val`.\n\n    return dummy.next;\n  }\n};\n", "2030": "class Solution {\n public:\n  string smallestSubsequence(string s, int k, char letter, int repetition) {\n    string ans;\n    vector<char> stack;\n    int required = repetition;\n    int nLetters = ranges::count(s, letter);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      while (!stack.empty() && stack.back() > c &&\n             stack.size() + s.length() - i - 1 >= k &&\n             (stack.back() != letter || nLetters > required)) {\n        const char popped = stack.back();\n        stack.pop_back();\n        if (popped == letter)\n          ++required;\n      }\n      if (stack.size() < k)\n        if (c == letter) {\n          stack.push_back(c);\n          --required;\n        } else if (k > stack.size() + required) {\n          stack.push_back(c);\n        }\n      if (c == letter)\n        --nLetters;\n    }\n\n    for (const char c : stack)\n      ans += c;\n\n    return ans;\n  }\n};\n", "2031": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int subarraysWithMoreZerosThanOnes(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    int prefix = 0;\n    // Map [-n, n] to [1, 2 * n + 1].\n    FenwickTree tree(2 * n + 1);\n    tree.add(remap(0, n), 1);\n\n    for (const int num : nums) {\n      prefix += num == 0 ? -1 : 1;\n      // If prefix[j] > prefix[i], where 0 <= i < j < |prefix|, that means that\n      // there are more ones than zeros in nums[i + 1, j].\n      ans += tree.get(remap(prefix - 1, n));\n      ans %= kMod;\n      tree.add(remap(prefix, n), 1);\n    }\n\n    return ans;\n  }\n\n private:\n  int remap(int i, int n) {\n    return i + n + 1;\n  }\n};\n", "2032": "class Solution {\n public:\n  vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2,\n                            vector<int>& nums3) {\n    vector<int> ans;\n    vector<int> count(101);\n\n    for (const vector<int>& nums : {nums1, nums2, nums3})\n      update(count, nums);\n\n    for (int i = 1; i <= 100; ++i)\n      if (count[i] >= 2)\n        ans.push_back(i);\n\n    return ans;\n  }\n\n private:\n  void update(vector<int>& count, const vector<int>& nums) {\n    for (const int num : unordered_set<int>(nums.begin(), nums.end()))\n      ++count[num];\n  }\n};\n", "2033": "class Solution {\n public:\n  int minOperations(vector<vector<int>>& grid, int x) {\n    vector<int> arr;\n    for (const vector<int>& row : grid)\n      arr.insert(arr.end(), row.begin(), row.end());\n    if (ranges::any_of(arr, [&](int a) { return (a - arr[0]) % x; }))\n      return -1;\n\n    int ans = 0;\n\n    nth_element(arr.begin(), arr.begin() + arr.size() / 2, arr.end());\n\n    for (const int a : arr)\n      ans += abs(a - arr[arr.size() / 2]) / x;\n\n    return ans;\n  }\n};\n", "2034": "class StockPrice {\n public:\n  void update(int timestamp, int price) {\n    if (const auto it = timestampToPrice.find(timestamp);\n        it != timestampToPrice.cend()) {\n      const int prevPrice = it->second;\n      prices.erase(prices.equal_range(prevPrice).first);\n    }\n    timestampToPrice[timestamp] = price;\n    prices.insert(price);\n  }\n\n  int current() {\n    return timestampToPrice.rbegin()->second;\n  }\n\n  int maximum() {\n    return *prices.rbegin();\n  }\n\n  int minimum() {\n    return *prices.begin();\n  }\n\n private:\n  map<int, int> timestampToPrice;\n  multiset<int> prices;\n};\n", "2035": "class Solution {\n public:\n  int minimumDifference(vector<int>& nums) {\n    const int n = nums.size() / 2;\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    const int goal = sum / 2;\n    const vector<int> lNums(nums.begin(), nums.begin() + n);\n    const vector<int> rNums(nums.begin() + n, nums.end());\n    int ans = INT_MAX;\n    vector<vector<int>> lSums(n + 1);\n    vector<vector<int>> rSums(n + 1);\n\n    dfs(lNums, 0, 0, 0, lSums);\n    dfs(rNums, 0, 0, 0, rSums);\n\n    for (int lCount = 0; lCount <= n; ++lCount) {\n      auto& l = lSums[lCount];\n      auto& r = rSums[n - lCount];\n      ranges::sort(r);\n      for (const int lSum : l) {\n        const int i = firstGreaterEqual(r, goal - lSum);\n        if (i < r.size()) {\n          const int sumPartOne = sum - lSum - r[i];\n          const int sumPartTwo = sum - sumPartOne;\n          ans = min(ans, abs(sumPartOne - sumPartTwo));\n        }\n        if (i > 0) {\n          const int sumPartOne = sum - lSum - r[i - 1];\n          const int sumPartTwo = sum - sumPartOne;\n          ans = min(ans, abs(sumPartOne - sumPartTwo));\n        }\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& arr, int i, int count, int path,\n           vector<vector<int>>& sums) {\n    if (i == arr.size()) {\n      sums[count].push_back(path);\n      return;\n    }\n    dfs(arr, i + 1, count + 1, path + arr[i], sums);\n    dfs(arr, i + 1, count, path, sums);\n  }\n\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "2036": "class Solution {\n public:\n  long long maximumAlternatingSubarraySum(vector<int>& nums) {\n    long ans = INT_MIN;\n    long even = 0;  // the subarray sum starting from an even index\n    long odd = 0;   // the subarray sum starting from an odd index\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i % 2 == 0)  // Must pick.\n        even += nums[i];\n      else  // Start a fresh subarray or subtract `nums[i]`.\n        even = max(0L, even - nums[i]);\n      ans = max(ans, even);\n    }\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (i % 2 == 1)  // Must pick.\n        odd += nums[i];\n      else  // Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0L, odd - nums[i]);\n      ans = max(ans, odd);\n    }\n\n    return ans;\n  }\n};\n", "2037": "class Solution {\n public:\n  int minMovesToSeat(vector<int>& seats, vector<int>& students) {\n    int ans = 0;\n\n    ranges::sort(seats);\n    ranges::sort(students);\n\n    for (int i = 0; i < seats.size(); ++i)\n      ans += abs(seats[i] - students[i]);\n\n    return ans;\n  }\n};\n", "2038": "class Solution {\n public:\n  bool winnerOfGame(string colors) {\n    int countAAA = 0;\n    int countBBB = 0;\n\n    for (int i = 1; i + 1 < colors.length(); ++i)\n      if (colors[i - 1] == colors[i] && colors[i] == colors[i + 1])\n        if (colors[i] == 'A')\n          ++countAAA;\n        else\n          ++countBBB;\n\n    return countAAA > countBBB;\n  }\n};\n", "2039": "class Solution {\n public:\n  int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\n    const int n = patience.size();\n    int ans = 0;\n    vector<vector<int>> graph(n);\n    queue<int> q{{0}};\n    vector<int> dist(n, INT_MAX);  // dist[i] := the distance between i and 0\n    dist[0] = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u])\n          if (dist[v] == INT_MAX) {\n            dist[v] = dist[u] + 1;\n            q.push(v);\n          }\n      }\n\n    for (int i = 1; i < n; ++i) {\n      const int numResending = (dist[i] * 2 - 1) / patience[i];\n      const int lastResendingTime = patience[i] * numResending;\n      const int lastArrivingTime = lastResendingTime + dist[i] * 2;\n      ans = max(ans, lastArrivingTime);\n    }\n\n    return ans + 1;\n  }\n};\n", "204": "class Solution {\n public:\n  int countPrimes(int n) {\n    if (n <= 2)\n      return 0;\n    const vector<bool> isPrime = sieveEratosthenes(n);\n    return ranges::count(isPrime, true);\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "2040": "class Solution {\n public:\n  long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2,\n                               long long k) {\n    vector<int> A1;\n    vector<int> A2;\n    vector<int> B1;\n    vector<int> B2;\n\n    seperate(nums1, A1, A2);\n    seperate(nums2, B1, B2);\n\n    const long negCount = A1.size() * B2.size() + A2.size() * B1.size();\n    int sign = 1;\n\n    if (k > negCount) {\n      k -= negCount;  //  Find the (k - negCount)-th positive.\n    } else {\n      k = negCount - k + 1;  // Find the (negCount - k + 1)-th abs(negative).\n      sign = -1;\n      swap(B1, B2);\n    }\n\n    long l = 0;\n    long r = 1e10;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >=\n          k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return sign * l;\n  }\n\n private:\n  void seperate(const vector<int>& arr, vector<int>& A1, vector<int>& A2) {\n    for (const int a : arr)\n      if (a < 0)\n        A1.push_back(-a);\n      else\n        A2.push_back(a);\n    ranges::reverse(A1);  // Reverse to sort ascending\n  }\n\n  long numProductNoGreaterThan(const vector<int>& A, const vector<int>& B,\n                               long m) {\n    long count = 0;\n    int j = B.size() - 1;\n    // For each a, find the first index j s.t. a * B[j] <= m\n    // So numProductNoGreaterThan m for this row will be j + 1\n    for (const long a : A) {\n      while (j >= 0 && a * B[j] > m)\n        --j;\n      count += j + 1;\n    }\n    return count;\n  }\n};\n", "2042": "class Solution {\n public:\n  bool areNumbersAscending(string s) {\n    int prev = 0;\n    istringstream iss(s);\n\n    for (string token; iss >> token;)\n      if (isdigit(token[0])) {\n        const int num = stoi(token);\n        if (num <= prev)\n          return false;\n        prev = num;\n      }\n\n    return true;\n  }\n};\n", "2043": "class Bank {\n public:\n  Bank(vector<long long>& balance) : balance(std::move(balance)) {}\n\n  bool transfer(int account1, int account2, long long money) {\n    if (!isValid(account2))\n      return false;\n    return withdraw(account1, money) && deposit(account2, money);\n  }\n\n  bool deposit(int account, long long money) {\n    if (!isValid(account))\n      return false;\n    balance[account - 1] += money;\n    return true;\n  }\n\n  bool withdraw(int account, long long money) {\n    if (!isValid(account))\n      return false;\n    if (balance[account - 1] < money)\n      return false;\n    balance[account - 1] -= money;\n    return true;\n  }\n\n private:\n  vector<long long> balance;\n\n  bool isValid(int account) {\n    return 1 <= account && account <= balance.size();\n  }\n};\n", "2044": "class Solution {\n public:\n  int countMaxOrSubsets(vector<int>& nums) {\n    const int ors = accumulate(nums.begin(), nums.end(), 0, bit_or<>());\n    int ans = 0;\n    dfs(nums, 0, 0, ors, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int i, int path, const int& ors, int& ans) {\n    if (i == nums.size()) {\n      if (path == ors)\n        ++ans;\n      return;\n    }\n\n    dfs(nums, i + 1, path, ors, ans);\n    dfs(nums, i + 1, path | nums[i], ors, ans);\n  }\n};\n", "2045": "class Solution {\n public:\n  int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n    vector<vector<int>> graph(n + 1);\n    queue<pair<int, int>> q{{{1, 0}}};\n    // minTime[u][0] := the first minimum time to reach the node u\n    // minTime[u][1] := the second minimum time to reach the node u\n    vector<vector<int>> minTime(n + 1, vector<int>(2, INT_MAX));\n    minTime[1][0] = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    while (!q.empty()) {\n      const auto [u, prevTime] = q.front();\n      q.pop();\n      // Start from green.\n      // If `numChangeSignal` is odd, now red.\n      // If `numChangeSignal` is even, now green.\n      const int numChangeSignal = prevTime / change;\n      const int waitTime =\n          numChangeSignal % 2 == 0 ? 0 : change - prevTime % change;\n      const int newTime = prevTime + waitTime + time;\n      for (const int v : graph[u])\n        if (newTime < minTime[v][0]) {\n          minTime[v][0] = newTime;\n          q.emplace(v, newTime);\n        } else if (minTime[v][0] < newTime && newTime < minTime[v][1]) {\n          if (v == n)\n            return newTime;\n          minTime[v][1] = newTime;\n          q.emplace(v, newTime);\n        }\n    }\n\n    throw;\n  }\n};\n", "2046": "class Solution {\n public:\n  ListNode* sortLinkedList(ListNode* head) {\n    ListNode* prev = head;\n    ListNode* curr = head->next;\n\n    while (curr != nullptr)\n      if (curr->val < 0) {\n        prev->next = curr->next;\n        curr->next = head;\n        head = curr;\n        curr = prev->next;\n      } else {\n        prev = curr;\n        curr = curr->next;\n      }\n\n    return head;\n  }\n};\n", "2047": "class Solution {\n public:\n  int countValidWords(string sentence) {\n    const regex re(\"[a-z]*([a-z]-[a-z])?[a-z]*[!,.]?\");\n    int ans = 0;\n    istringstream iss(sentence);\n\n    for (string token; iss >> token;)\n      if (regex_match(token, re))\n        ++ans;\n\n    return ans;\n  }\n};\n", "2048": "class Solution {\n public:\n  int nextBeautifulNumber(int n) {\n    while (!isBalance(++n))\n      ;\n    return n;\n  }\n\n private:\n  bool isBalance(int num) {\n    vector<int> count(10);\n    while (num > 0) {\n      if (num % 10 == 0)\n        return false;\n      ++count[num % 10];\n      num /= 10;\n    }\n    for (int i = 1; i < 10; ++i)\n      if (count[i] && count[i] != i)\n        return false;\n    return true;\n  }\n};\n", "2049": "class Solution {\n public:\n  int countHighestScoreNodes(vector<int>& parents) {\n    int ans = 0;\n    vector<vector<int>> tree(parents.size());\n\n    for (int i = 0; i < parents.size(); ++i) {\n      if (parents[i] == -1)\n        continue;\n      tree[parents[i]].push_back(i);\n    }\n\n    dfs(tree, 0, 0, ans);\n    return ans;\n  }\n\n private:\n  int dfs(const vector<vector<int>>& tree, int u, long&& maxScore, int& ans) {\n    int count = 1;\n    long score = 1;\n    for (const int v : tree[u]) {\n      const int childCount = dfs(tree, v, std::move(maxScore), ans);\n      count += childCount;\n      score *= childCount;\n    }\n    const int aboveCount = tree.size() - count;\n    score *= max(aboveCount, 1);\n    if (score > maxScore) {\n      maxScore = score;\n      ans = 1;\n    } else if (score == maxScore) {\n      ++ans;\n    }\n    return count;\n  }\n};\n", "205": "class Solution {\n public:\n  bool isIsomorphic(string s, string t) {\n    vector<int> charToIndex_s(128);\n    vector<int> charToIndex_t(128);\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (charToIndex_s[s[i]] != charToIndex_t[t[i]])\n        return false;\n      charToIndex_s[s[i]] = i + 1;\n      charToIndex_t[t[i]] = i + 1;\n    }\n\n    return true;\n  }\n};\n", "2050": "class Solution {\n public:\n  int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\n    vector<vector<int>> graph(n);\n    vector<int> inDegrees(n);\n    queue<int> q;\n    vector<int> dist(time);\n\n    // Build the graph.\n    for (const vector<int>& r : relations) {\n      const int u = r[0] - 1;\n      const int v = r[1] - 1;\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u]) {\n        dist[v] = max(dist[v], dist[u] + time[v]);\n        if (--inDegrees[v] == 0)\n          q.push(v);\n      }\n    }\n\n    return ranges::max(dist);\n  }\n};\n", "2052": "class Solution {\n public:\n  int minimumCost(string sentence, int k) {\n    if (sentence.length() <= k)\n      return 0;\n\n    vector<string> words = getWords(sentence);\n\n    // dp[i] := the minimum cost of the first i words\n    vector<int> dp(words.size() + 1);\n\n    for (int i = 1; i <= words.size(); ++i) {\n      int n = words[i - 1].length();  // the length of the current row\n      dp[i] = dp[i - 1] + (k - n) * (k - n);\n      // Gradually add words[j - 1], words[j - 2], ....\n      for (int j = i - 1; j > 0; --j) {\n        n += words[j - 1].length() + 1;\n        if (n > k)\n          break;\n        dp[i] = min(dp[i], dp[j - 1] + (k - n) * (k - n));\n      }\n    }\n\n    int lastRowLen = words.back().length();\n    int i = words.size() - 2;\n\n    while (i > 0 && lastRowLen + words[i].length() + 1 <= k)\n      lastRowLen += words[i--].length() + 1;\n\n    return *min_element(dp.begin() + i + 1, dp.end());\n  }\n\n private:\n  vector<string> getWords(const string& sentence) {\n    vector<string> words;\n    istringstream iss(sentence);\n    for (string token; iss >> token;)\n      words.push_back(token);\n    return words;\n  }\n};\n", "2053": "class Solution {\n public:\n  string kthDistinct(vector<string>& arr, int k) {\n    unordered_map<string, int> count;\n\n    for (const string& a : arr)\n      ++count[a];\n\n    for (const string& a : arr)\n      if (count[a] == 1 && --k == 0)\n        return a;\n\n    return \"\";\n  }\n};\n", "2054": "struct Event {\n  int time;\n  int value;\n  bool isStart;\n};\n\nclass Solution {\n public:\n  int maxTwoEvents(vector<vector<int>>& events) {\n    int ans = 0;\n    int maxValue = 0;\n    vector<Event> evts;\n\n    for (const vector<int>& event : events) {\n      const int start = event[0];\n      const int end = event[1];\n      const int value = event[2];\n      evts.emplace_back(start, value, true);\n      evts.emplace_back(end + 1, value, false);\n    }\n\n    ranges::sort(evts, ranges::less{}, [](const Event& evt) {\n      return pair<int, bool>{evt.time, evt.isStart};\n    });\n\n    for (const auto& [_, value, isStart] : evts)\n      if (isStart)\n        ans = max(ans, value + maxValue);\n      else\n        maxValue = max(maxValue, value);\n\n    return ans;\n  }\n};\n", "2055": "class Solution {\n public:\n  vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\n    const int n = s.length();\n    vector<int> ans;\n    vector<int> closestLeftCandle(n);\n    vector<int> closestRightCandle(n);\n    vector<int> candleCount(\n        n);  // candleCount[i] := the number of candles in s[0..i]\n    int candle = -1;\n    int count = 0;\n\n    for (int i = 0; i < n; ++i) {\n      if (s[i] == '|') {\n        candle = i;\n        ++count;\n      }\n      closestLeftCandle[i] = candle;\n      candleCount[i] = count;\n    }\n\n    candle = -1;\n    for (int i = n - 1; i >= 0; --i) {\n      if (s[i] == '|')\n        candle = i;\n      closestRightCandle[i] = candle;\n    }\n\n    for (const vector<int>& query : queries) {\n      const int left = query[0];\n      const int right = query[1];\n      const int l = closestRightCandle[left];\n      const int r = closestLeftCandle[right];\n      if (l == -1 || r == -1 || l > r) {\n        ans.push_back(0);\n      } else {\n        const int lengthBetweenCandles = r - l + 1;\n        const int numCandles = candleCount[r] - candleCount[l] + 1;\n        ans.push_back(lengthBetweenCandles - numCandles);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2056": "class Solution {\n public:\n  int countCombinations(vector<string>& pieces,\n                        vector<vector<int>>& positions) {\n    const int n = pieces.size();\n    unordered_set<long long> hashedBoards;\n    // Stores all possible move combinations for `pieces`. Each element is a\n    // vector of moves, one for each piece in the input order. e.g., if pieces =\n    // [\"rook\", \"bishop\"], one element might be [[1,0], [1,1]], representing a\n    // rook moving right and a bishop moving diagonally up-right.\n    vector<vector<pair<int, int>>> pieceMovesList;\n\n    getPieceMovesList(pieces, 0, {}, pieceMovesList);\n\n    for (const vector<pair<int, int>>& pieceMoves : pieceMovesList)\n      dfs(positions, n, pieceMoves, (1 << n) - 1, hashedBoards);\n\n    return hashedBoards.size();\n  }\n\n private:\n  const unordered_map<string, vector<pair<int, int>>> kPieceToMoves{\n      {\"rook\", {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}},\n      {\"bishop\", {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}}},\n      {\"queen\",\n       {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}}};\n\n  // Generates all possible combinations of moves.\n  void getPieceMovesList(const vector<string>& pieces, int i,\n                         vector<pair<int, int>>&& path,\n                         vector<vector<pair<int, int>>>& pieceMovesList) {\n    if (i == pieces.size()) {\n      pieceMovesList.push_back(path);\n      return;\n    }\n    for (const pair<int, int>& move : kPieceToMoves.at(pieces[i])) {\n      path.push_back(move);\n      getPieceMovesList(pieces, i + 1, std::move(path), pieceMovesList);\n      path.pop_back();\n    }\n  }\n\n  // Performs a depth-first search to explore all possible board states.\n  void dfs(const vector<vector<int>>& board, int n,\n           const vector<pair<int, int>>& pieceMoves, int activeMask,\n           unordered_set<long long>& hashedBoards) {\n    if (activeMask == 0)\n      return;\n    hashedBoards.insert(getHash(board));\n    for (int nextActiveMask = 1; nextActiveMask < 1 << n; ++nextActiveMask) {\n      if ((activeMask & nextActiveMask) != nextActiveMask)\n        continue;\n\n      // Copy the board.\n      vector<vector<int>> nextBoard = board;\n\n      // Move the pieces that are active in this turn.\n      for (int i = 0; i < n; ++i)\n        if (nextActiveMask >> i & 1) {\n          nextBoard[i][0] += pieceMoves[i].first;\n          nextBoard[i][1] += pieceMoves[i].second;\n        }\n\n      // No two or more pieces occupy the same square.\n      if (getUniqueSize(nextBoard) < n)\n        continue;\n\n      // Every piece needs to be in the boundary.\n      if (ranges::all_of(nextBoard, [](const vector<int>& pos) {\n        return 1 <= pos[0] && pos[0] <= 8 && 1 <= pos[1] && pos[1] <= 8;\n      }))\n        dfs(nextBoard, n, pieceMoves, nextActiveMask, hashedBoards);\n    }\n  }\n\n  long long getHash(const vector<vector<int>>& board) {\n    long long hash = 0;\n    for (const vector<int>& pos : board)\n      hash = (hash * 64) + ((pos[0] - 1) << 3) + (pos[1] - 1);\n    return hash;\n  }\n\n  int getUniqueSize(const vector<vector<int>>& board) {\n    unordered_set<int> unique;\n    for (const vector<int>& pos : board)\n      unique.insert(pos[0] * 8 + pos[1]);\n    return unique.size();\n  }\n};\n", "2057": "class Solution {\n public:\n  int smallestEqual(vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == i % 10)\n        return i;\n    return -1;\n  }\n};\n", "2058": "class Solution {\n public:\n  vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n    int minDistance = INT_MAX;\n    int firstMaIndex = -1;\n    int prevMaIndex = -1;\n    int index = 1;\n    ListNode* prev = head;        // Point to the index 0.\n    ListNode* curr = head->next;  // Point to the index 1.\n\n    while (curr->next != nullptr) {\n      if (curr->val > prev->val && curr->val > curr->next->val ||\n          curr->val < prev->val && curr->val < curr->next->val) {\n        if (firstMaIndex == -1)  // Only assign once.\n          firstMaIndex = index;\n        if (prevMaIndex != -1)\n          minDistance = min(minDistance, index - prevMaIndex);\n        prevMaIndex = index;\n      }\n      prev = curr;\n      curr = curr->next;\n      ++index;\n    }\n\n    if (minDistance == INT_MAX)\n      return {-1, -1};\n    return {minDistance, prevMaIndex - firstMaIndex};\n  }\n};\n", "2059": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums, int start, int goal) {\n    queue<int> q{{start}};\n    vector<bool> seen(1001);\n    seen[start] = true;\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int x = q.front();\n        q.pop();\n        for (const int num : nums) {\n          for (const int res : {x + num, x - num, x ^ num}) {\n            if (res == goal)\n              return step;\n            if (res < 0 || res > 1000 || seen[res])\n              continue;\n            seen[res] = true;\n            q.push(res);\n          }\n        }\n      }\n\n    return -1;\n  }\n};\n", "206": "class Solution {\n public:\n  ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n\n    while (head != nullptr) {\n      ListNode* next = head->next;\n      head->next = prev;\n      prev = head;\n      head = next;\n    }\n\n    return prev;\n  }\n};\n", "2060": "class Solution {\n public:\n  bool possiblyEquals(string s1, string s2) {\n    vector<vector<unordered_map<int, bool>>> mem(\n        s1.length() + 1, vector<unordered_map<int, bool>>(s2.length() + 1));\n    return f(s1, s2, 0, 0, 0, mem);\n  }\n\n private:\n  // Returns true if s1[i..n) matches s2[j..n), accounting for the padding\n  // difference. Here, `paddingDiff` represents the signed padding. A positive\n  // `paddingDiff` indicates that s1 has an additional number of offset bytes\n  // compared to s2.\n  bool f(const string& s1, const string& s2, int i, int j, int paddingDiff,\n         vector<vector<unordered_map<int, bool>>>& mem) {\n    if (const auto it = mem[i][j].find(paddingDiff); it != mem[i][j].cend())\n      return it->second;\n    if (i == s1.length() && j == s2.length())\n      return paddingDiff == 0;\n    if (i < s1.length() && isdigit(s1[i])) {\n      // Add padding on s1.\n      const int nextLetterIndex = getNextLetterIndex(s1, i);\n      for (const int num : getNums(s1.substr(i, nextLetterIndex - i)))\n        if (f(s1, s2, nextLetterIndex, j, paddingDiff + num, mem))\n          return true;\n    } else if (j < s2.length() && isdigit(s2[j])) {\n      // Add padding on s2.\n      const int nextLetterIndex = getNextLetterIndex(s2, j);\n      for (const int num : getNums(s2.substr(j, nextLetterIndex - j)))\n        if (f(s1, s2, i, nextLetterIndex, paddingDiff - num, mem))\n          return true;\n    } else if (paddingDiff > 0) {\n      // `s1` has more padding, so j needs to catch up.\n      if (j < s2.length())\n        return f(s1, s2, i, j + 1, paddingDiff - 1, mem);\n    } else if (paddingDiff < 0) {\n      // `s2` has more padding, so i needs to catch up.\n      if (i < s1.length())\n        return f(s1, s2, i + 1, j, paddingDiff + 1, mem);\n    } else {  // paddingDiff == 0\n      // There's no padding difference, so consume the next letter.\n      if (i < s1.length() && j < s2.length() && s1[i] == s2[j])\n        return f(s1, s2, i + 1, j + 1, 0, mem);\n    }\n    return mem[i][j][paddingDiff] = false;\n  }\n\n  int getNextLetterIndex(const string& s, int i) {\n    int j = i;\n    while (i < s.length() && isdigit(s[j]))\n      ++j;\n    return j;\n  }\n\n  vector<int> getNums(const string& s) {\n    vector<int> nums{stoi(s)};\n    if (s.length() == 2) {\n      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 1)));\n    } else if (s.length() == 3) {\n      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 2)));\n      nums.push_back(stoi(s.substr(0, 2)) + stoi(s.substr(2, 1)));\n      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 1)) +\n                     stoi(s.substr(2, 1)));\n    }\n    return nums;\n  }\n};\n", "2061": "class Solution {\n public:\n  int numberOfCleanRooms(vector<vector<int>>& room) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = room.size();\n    const int n = room[0].size();\n    int ans = 1;\n    int i = 0;\n    int j = 0;\n    int state = 0;  // 0 := right, 1 := down, 2 := left, 3 := up\n    vector<vector<int>> seen(m, vector<int>(n));  // seen[i][j] := bitmask\n    seen[i][j] |= 1 << state;\n    room[i][j] = 2;  // 2 := cleaned\n\n    while (true) {\n      const int x = i + kDirs[state][0];\n      const int y = j + kDirs[state][1];\n      if (x < 0 || x == m || y < 0 || y == n || room[x][y] == 1) {\n        // Turn 90 degrees clockwise.\n        state = (state + 1) % 4;\n      } else {\n        // Walk to (x, y).\n        if (room[x][y] == 0) {\n          ++ans;\n          room[x][y] = 2;\n        }\n        i = x;\n        j = y;\n      }\n      if (seen[i][j] >> state & 1)\n        return ans;\n      seen[i][j] |= (1 << state);\n    }\n  }\n};\n", "2062": "class Solution {\n public:\n  int countVowelSubstrings(string word) {\n    return countVowelSubstringsAtMost(word, 5) -\n           countVowelSubstringsAtMost(word, 4);\n  }\n\n private:\n  int countVowelSubstringsAtMost(const string& s, int goal) {\n    int ans = 0;\n    int k = goal;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (!isVowel(s[r])) {  // Fresh start.\n        l = r + 1;\n        k = goal;\n        count = vector<int>(26);\n        continue;\n      }\n      if (++count[s[r] - 'a'] == 1)\n        --k;\n      while (k == -1)\n        if (--count[s[l++] - 'a'] == 0)\n          ++k;\n      ans += r - l + 1;  // s[l..r], s[l + 1..r], ..., s[r]\n    }\n\n    return ans;\n  }\n\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "2063": "class Solution {\n public:\n  long long countVowels(string word) {\n    long ans = 0;\n\n    for (int i = 0; i < word.length(); ++i)\n      if (isVowel(word[i]))\n        ans += (i + 1) * (word.length() - i);\n\n    return ans;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "2064": "class Solution {\n public:\n  int minimizedMaximum(int n, vector<int>& quantities) {\n    int l = 1;\n    int r = ranges::max(quantities);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numStores(quantities, m) <= n)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numStores(const vector<int>& quantities, int m) {\n    // ceil(q / m)\n    return accumulate(quantities.begin(), quantities.end(), 0,\n                      [&](int acc, int q) { return acc + (q - 1) / m + 1; });\n  }\n};\n", "2065": "class Solution {\n public:\n  int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges,\n                         int maxTime) {\n    const int n = values.size();\n    int ans = 0;\n    vector<vector<pair<int, int>>> graph(n);\n    vector<int> seen(n);\n    seen[0] = 1;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int time = edge[2];\n      graph[u].emplace_back(v, time);\n      graph[v].emplace_back(u, time);\n    }\n\n    dfs(graph, values, 0, values[0], maxTime, seen, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph,\n           const vector<int>& values, int u, int quality, int remainingTime,\n           vector<int>& seen, int& ans) {\n    if (u == 0)\n      ans = max(ans, quality);\n    for (const auto& [v, time] : graph[u]) {\n      if (time > remainingTime)\n        continue;\n      const int newQuality = quality + values[v] * (seen[v] == 0);\n      ++seen[v];\n      dfs(graph, values, v, newQuality, remainingTime - time, seen, ans);\n      --seen[v];\n    }\n  }\n};\n", "2067": "class Solution {\n public:\n  int equalCountSubstrings(string s, int count) {\n    const int maxUnique = unordered_set<int>(s.begin(), s.end()).size();\n    int ans = 0;\n\n    for (int unique = 1; unique <= maxUnique; ++unique) {\n      const int windowSize = unique * count;\n      vector<int> lettersCount(26);\n      int uniqueCount = 0;\n      for (int i = 0; i < s.length(); ++i) {\n        if (++lettersCount[s[i] - 'a'] == count)\n          ++uniqueCount;\n        if (i >= windowSize &&\n            --lettersCount[s[i - windowSize] - 'a'] == count - 1)\n          --uniqueCount;\n        ans += uniqueCount == unique;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2068": "class Solution {\n public:\n  bool checkAlmostEquivalent(string word1, string word2) {\n    vector<int> count(26);\n\n    for (const char c : word1)\n      ++count[c - 'a'];\n\n    for (const char c : word2)\n      --count[c - 'a'];\n\n    return ranges::all_of(count, [](int freq) { return abs(freq) <= 3; });\n  }\n};\n", "2069": "class Robot {\n public:\n  Robot(int width, int height) {\n    pos.push_back({{0, 0}, \"South\"});\n    for (int i = 1; i < width; ++i)\n      pos.push_back({{i, 0}, \"East\"});\n    for (int j = 1; j < height; ++j)\n      pos.push_back({{width - 1, j}, \"North\"});\n    for (int i = width - 2; i >= 0; --i)\n      pos.push_back({{i, height - 1}, \"West\"});\n    for (int j = height - 2; j > 0; --j)\n      pos.push_back({{0, j}, \"South\"});\n  }\n\n  void step(int num) {\n    isOrigin = false;\n    i = (i + num) % pos.size();\n  }\n\n  vector<int> getPos() {\n    return pos[i].first;\n  }\n\n  string getDir() {\n    return isOrigin ? \"East\" : pos[i].second;\n  }\n\n private:\n  bool isOrigin = true;\n  int i = 0;\n  vector<pair<vector<int>, string>> pos;\n};\n", "207": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<State> states(numCourses);\n\n    for (const vector<int>& prerequisite : prerequisites) {\n      const int u = prerequisite[1];\n      const int v = prerequisite[0];\n      graph[u].push_back(v);\n    }\n\n    for (int i = 0; i < numCourses; ++i)\n      if (hasCycle(graph, i, states))\n        return false;\n\n    return true;\n  }\n\n private:\n  bool hasCycle(const vector<vector<int>>& graph, int u,\n                vector<State>& states) {\n    if (states[u] == State::kVisiting)\n      return true;\n    if (states[u] == State::kVisited)\n      return false;\n    states[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (hasCycle(graph, v, states))\n        return true;\n    states[u] = State::kVisited;\n    return false;\n  }\n};\n", "2070": "class Solution {\n public:\n  vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n    vector<int> ans;\n    vector<int> prices;\n    vector<int> maxBeautySoFar(items.size() + 1);\n\n    ranges::sort(items);\n\n    for (const vector<int>& item : items)\n      prices.push_back(item[0]);\n\n    for (int i = 0; i < items.size(); ++i)\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], items[i][1]);\n\n    for (const int query : queries) {\n      const int i = ranges::upper_bound(prices, query) - prices.begin();\n      ans.push_back(maxBeautySoFar[i]);\n    }\n\n    return ans;\n  }\n};\n", "2071": "class Solution {\n public:\n  int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills,\n                    int strength) {\n    int ans = 0;\n    int l = 0;\n    int r = min(tasks.size(), workers.size());\n\n    ranges::sort(tasks);\n    ranges::sort(workers);\n\n    // Returns true if we can finish k tasks.\n    auto canComplete = [&](int k, int pillsLeft) {\n      // k strongest workers\n      map<int, int> sortedWorkers;\n      for (int i = workers.size() - k; i < workers.size(); ++i)\n        ++sortedWorkers[workers[i]];\n\n      // Out of the k smallest tasks, start from the biggest one.\n      for (int i = k - 1; i >= 0; --i) {\n        // Find the first worker that has strength >= tasks[i].\n        auto it = sortedWorkers.lower_bound(tasks[i]);\n        if (it != sortedWorkers.end()) {\n          if (--(it->second) == 0)\n            sortedWorkers.erase(it);\n        } else if (pillsLeft > 0) {\n          // Find the first worker that has strength >= tasks[i] - strength.\n          it = sortedWorkers.lower_bound(tasks[i] - strength);\n          if (it != sortedWorkers.end()) {\n            if (--(it->second) == 0)\n              sortedWorkers.erase(it);\n            --pillsLeft;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (canComplete(m, pills)) {\n        ans = m;\n        l = m + 1;\n      } else {\n        r = m - 1;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2073": "class Solution {\n public:\n  int timeRequiredToBuy(vector<int>& tickets, int k) {\n    int ans = 0;\n\n    for (int i = 0; i < tickets.size(); ++i)\n      if (i <= k)\n        ans += min(tickets[i], tickets[k]);\n      else\n        ans += min(tickets[i], tickets[k] - 1);\n\n    return ans;\n  }\n};\n", "2074": "class Solution {\n public:\n  ListNode* reverseEvenLengthGroups(ListNode* head) {\n    // prev -> (head -> ... -> tail) -> next -> ...\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n    ListNode* tail = head;\n    ListNode* next = head->next;\n    int groupLength = 1;\n\n    while (true) {\n      if (groupLength % 2 == 1) {\n        prev->next = head;\n        prev = tail;\n      } else {\n        tail->next = nullptr;\n        prev->next = reverse(head);\n        // Prev -> (tail -> ... -> head) -> next -> ...\n        head->next = next;\n        prev = head;\n      }\n      if (next == nullptr)\n        break;\n      head = next;\n      const auto [theTail, theLength] = getTailAndLength(head, groupLength + 1);\n      tail = theTail;\n      next = tail->next;\n      groupLength = theLength;\n    }\n\n    return dummy.next;\n  }\n\n private:\n  pair<ListNode*, int> getTailAndLength(ListNode* head, int groupLength) {\n    int length = 1;\n    ListNode* tail = head;\n    while (length < groupLength && tail->next) {\n      tail = tail->next;\n      ++length;\n    }\n    return {tail, length};\n  }\n\n  ListNode* reverse(ListNode* head) {\n    ListNode* prev = nullptr;\n    while (head != nullptr) {\n      ListNode* next = head->next;\n      head->next = prev;\n      prev = head;\n      head = next;\n    }\n    return prev;\n  }\n};\n", "2076": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\n                              vector<vector<int>>& requests) {\n    vector<bool> ans;\n    UnionFind uf(n);\n\n    for (const vector<int>& request : requests) {\n      const int i = uf.find(request[0]);\n      const int j = uf.find(request[1]);\n      bool isValid = true;\n      if (i != j)\n        for (const vector<int>& restriction : restrictions) {\n          const int x = uf.find(restriction[0]);\n          const int y = uf.find(restriction[1]);\n          if (i == x && j == y || i == y && j == x) {\n            isValid = false;\n            break;\n          }\n        }\n      ans.push_back(isValid);\n      if (isValid)\n        uf.unionByRank(i, j);\n    }\n\n    return ans;\n  }\n};\n", "2078": "class Solution {\n public:\n  int maxDistance(vector<int>& colors) {\n    // The maximum distance always includes either the first or the last house.\n    const int n = colors.size();\n    int i = 0;      // the leftmost index, where colors[i] != colors[-1]\n    int j = n - 1;  // the rightmost index, where colors[j] != colors[0]\n    while (colors[i] == colors.back())\n      ++i;\n    while (colors[j] == colors.front())\n      --j;\n    return max(n - 1 - i, j);\n  }\n};\n", "208": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word) {\n    shared_ptr<TrieNode> node = find(word);\n    return node && node->isWord;\n  }\n\n  bool startsWith(const string& prefix) {\n    return find(prefix) != nullptr;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  shared_ptr<TrieNode> find(const string& prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return nullptr;\n      node = node->children[i];\n    }\n    return node;\n  }\n};\n", "2083": "class Solution {\n public:\n  long long numberOfSubstrings(string s) {\n    long ans = 0;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ans += ++count[c - 'a'];\n\n    return ans;\n  }\n};\n", "2085": "class Solution {\n public:\n  int countWords(vector<string>& words1, vector<string>& words2) {\n    unordered_map<string, int> count;\n\n    for (const string& word : words1)\n      ++count[word];\n\n    for (const string& word : words2)\n      if (const auto it = count.find(word);\n          it != count.cend() && it->second < 2)\n        --it->second;\n\n    return ranges::count_if(\n        count, [](const pair<string, int>& c) { return c.second == 0; });\n  }\n};\n", "2086": "class Solution {\n public:\n  int minimumBuckets(string street) {\n    for (int i = 0; i < street.length(); ++i)\n      if (street[i] == 'H') {\n        if (i > 0 && street[i - 1] == 'B')\n          continue;\n        if (i + 1 < street.length() && street[i + 1] == '.')\n          // Always prefer place a bucket in (i + 1) because it enhances the\n          // possibility to collect the upcoming houses.\n          street[i + 1] = 'B';\n        else if (i > 0 && street[i - 1] == '.')\n          street[i - 1] = 'B';\n        else\n          return -1;\n      }\n\n    return ranges::count(street, 'B');\n  }\n};\n", "2087": "class Solution {\n public:\n  int minCost(vector<int>& startPos, vector<int>& homePos,\n              vector<int>& rowCosts, vector<int>& colCosts) {\n    int ans = 0;\n    int i = startPos[0];\n    int j = startPos[1];\n    int x = homePos[0];\n    int y = homePos[1];\n\n    while (i != x)\n      ans += i < x ? rowCosts[++i] : rowCosts[--i];\n    while (j != y)\n      ans += j < y ? colCosts[++j] : colCosts[--j];\n\n    return ans;\n  }\n};\n", "2088": "class Solution {\n public:\n  int countPyramids(vector<vector<int>>& grid) {\n    int ans = count(grid);\n    ranges::reverse(grid);\n    ans += count(grid);\n    return ans;\n  }\n\n private:\n  // dp[i][j] := the maximum height of the pyramid for which it is the apex\n  int count(vector<vector<int>> dp) {\n    int ans = 0;\n    for (int i = dp.size() - 2; i >= 0; --i)\n      for (int j = 1; j + 1 < dp[0].size(); ++j)\n        if (dp[i][j] == 1) {\n          dp[i][j] =\n              min({dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]}) + 1;\n          ans += dp[i][j] - 1;\n        }\n    return ans;\n  }\n};\n", "2089": "class Solution {\n public:\n  vector<int> targetIndices(vector<int>& nums, int target) {\n    vector<int> ans;\n    const int count = ranges::count(nums, target);\n    int lessThan =\n        ranges::count_if(nums, [&](int num) { return num < target; });\n\n    for (int i = 0; i < count; ++i)\n      ans.push_back(lessThan++);\n\n    return ans;\n  }\n};\n", "209": "class Solution {\n public:\n  int minSubArrayLen(int target, vector<int>& nums) {\n    int ans = INT_MAX;\n    int sum = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      sum += nums[r];\n      while (sum >= target) {\n        ans = min(ans, r - l + 1);\n        sum -= nums[l++];\n      }\n    }\n\n    return ans == INT_MAX ? 0 : ans;\n  }\n};\n", "2090": "class Solution {\n public:\n  vector<int> getAverages(vector<int>& nums, int k) {\n    const int n = nums.size();\n    const int size = 2 * k + 1;\n    vector<int> ans(n, -1);\n    if (size > n)\n      return ans;\n\n    long sum = accumulate(nums.begin(), nums.begin() + size, 0L);\n\n    for (int i = k; i + k < n; ++i) {\n      ans[i] = sum / size;\n      if (i + k + 1 < n)\n        sum += nums[i + k + 1] - nums[i - k];\n    }\n\n    return ans;\n  }\n};\n", "2091": "class Solution {\n public:\n  int minimumDeletions(vector<int>& nums) {\n    const int n = nums.size();\n    int a = ranges::min_element(nums) - nums.begin();\n    int b = ranges::max_element(nums) - nums.begin();\n    if (a > b)\n      swap(a, b);\n    return min({a + 1 + n - b, b + 1, n - a});\n  }\n};\n", "2092": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  bool connected(int u, int v) {\n    return find(u) == find(v);\n  }\n\n  void reset(int u) {\n    id[u] = u;\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> findAllPeople(int n, vector<vector<int>>& meetings,\n                            int firstPerson) {\n    vector<int> ans;\n    UnionFind uf(n);\n    map<int, vector<pair<int, int>>> timeToPairs;\n\n    uf.unionByRank(0, firstPerson);\n\n    for (const vector<int>& meeting : meetings) {\n      const int x = meeting[0];\n      const int y = meeting[1];\n      const int time = meeting[2];\n      timeToPairs[time].push_back({x, y});\n    }\n\n    for (const auto& [_, pairs] : timeToPairs) {\n      unordered_set<int> peopleUnioned;\n      for (const auto& [x, y] : pairs) {\n        uf.unionByRank(x, y);\n        peopleUnioned.insert(x);\n        peopleUnioned.insert(y);\n      }\n      for (const int person : peopleUnioned)\n        if (!uf.connected(person, 0))\n          uf.reset(person);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (uf.connected(i, 0))\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "2093": "struct T {\n  int u;\n  int d;\n  int leftDiscounts;\n};\n\nclass Solution {\n public:\n  int minimumCost(int n, vector<vector<int>>& highways, int discounts) {\n    vector<vector<pair<int, int>>> graph(n);\n    auto compare = [](const T& a, const T& b) { return a.d > b.d; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    unordered_map<int, int> minDiscounts;\n\n    for (const vector<int>& h : highways) {\n      const int city1 = h[0];\n      const int city2 = h[1];\n      const int toll = h[2];\n      graph[city1].emplace_back(city2, toll);\n      graph[city2].emplace_back(city1, toll);\n    }\n\n    minHeap.emplace(0, 0, discounts);\n\n    while (!minHeap.empty()) {\n      const auto [u, d, leftDiscounts] = minHeap.top();\n      minHeap.pop();\n      if (u == n - 1)\n        return d;\n      if (const auto it = minDiscounts.find(u);\n          it != minDiscounts.cend() && it->second >= leftDiscounts)\n        continue;\n      minDiscounts[u] = leftDiscounts;\n      for (const auto& [v, w] : graph[u]) {\n        minHeap.emplace(v, d + w, leftDiscounts);\n        if (leftDiscounts > 0)\n          minHeap.emplace(v, d + w / 2, leftDiscounts - 1);\n      }\n    }\n\n    return -1;\n  }\n};\n", "2094": "class Solution {\n public:\n  vector<int> findEvenNumbers(vector<int>& digits) {\n    vector<int> ans;\n    vector<int> count(10);\n\n    for (const int digit : digits)\n      ++count[digit];\n\n    // Try to construct `abc`.\n    for (int a = 1; a <= 9; ++a)\n      for (int b = 0; b <= 9; ++b)\n        for (int c = 0; c <= 8; c += 2)\n          if (count[a] > 0 && count[b] > (b == a) &&\n              count[c] > (c == a) + (c == b))\n            ans.push_back(a * 100 + b * 10 + c);\n\n    return ans;\n  }\n};\n", "2095": "class Solution {\n public:\n  ListNode* deleteMiddle(ListNode* head) {\n    ListNode dummy(0, head);\n    ListNode* slow = &dummy;\n    ListNode* fast = &dummy;\n\n    while (fast->next != nullptr && fast->next->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    // Delete the middle node.\n    slow->next = slow->next->next;\n    return dummy.next;\n  }\n};\n", "2096": "class Solution {\n public:\n  string getDirections(TreeNode* root, int startValue, int destValue) {\n    string pathToStart;\n    string pathToDest;\n\n    dfs(root, startValue, pathToStart);\n    dfs(root, destValue, pathToDest);\n\n    while (!pathToStart.empty() && !pathToDest.empty() &&\n           pathToStart.back() == pathToDest.back()) {\n      pathToStart.pop_back();\n      pathToDest.pop_back();\n    }\n\n    return string(pathToStart.length(), 'U') +\n           string{pathToDest.rbegin(), pathToDest.rend()};\n  }\n\n private:\n  // Builds the string in reverse order to avoid creating a new copy.\n  bool dfs(TreeNode* root, int val, string& path) {\n    if (root->val == val)\n      return true;\n    if (root->left && dfs(root->left, val, path))\n      path.push_back('L');\n    else if (root->right && dfs(root->right, val, path))\n      path.push_back('R');\n    return !path.empty();\n  }\n};\n", "2097": "class Solution {\n public:\n  vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n    vector<vector<int>> ans;\n    unordered_map<int, stack<int>> graph;\n    unordered_map<int, int> outDegree;\n    unordered_map<int, int> inDegrees;\n\n    for (const vector<int>& pair : pairs) {\n      const int start = pair[0];\n      const int end = pair[1];\n      graph[start].push(end);\n      ++outDegree[start];\n      ++inDegrees[end];\n    }\n\n    const int startNode = getStartNode(graph, outDegree, inDegrees, pairs);\n    euler(graph, startNode, ans);\n    ranges::reverse(ans);\n    return ans;\n  }\n\n private:\n  int getStartNode(const unordered_map<int, stack<int>>& graph,\n                   unordered_map<int, int>& outDegree,\n                   unordered_map<int, int>& inDegrees,\n                   const vector<vector<int>>& pairs) {\n    for (const auto& [u, _] : graph)\n      if (outDegree[u] - inDegrees[u] == 1)\n        return u;\n    return pairs[0][0];  // Arbitrarily choose a node.\n  }\n\n  void euler(unordered_map<int, stack<int>>& graph, int u,\n             vector<vector<int>>& ans) {\n    auto& stack = graph[u];\n    while (!stack.empty()) {\n      const int v = stack.top();\n      stack.pop();\n      euler(graph, v, ans);\n      ans.push_back({u, v});\n    }\n  }\n};\n", "2098": "class Solution {\n public:\n  long long largestEvenSum(vector<int>& nums, int k) {\n    ranges::sort(nums);\n    long sum = accumulate(nums.end() - k, nums.end(), 0L);\n    if (sum % 2 == 0)\n      return sum;\n\n    int minOdd = -1;\n    int minEven = -1;\n    int maxOdd = -1;\n    int maxEven = -1;\n\n    for (int i = nums.size() - 1; i + k >= nums.size(); --i)\n      if (nums[i] % 2 == 1)\n        minOdd = nums[i];\n      else\n        minEven = nums[i];\n\n    for (int i = 0; i + k < nums.size(); ++i)\n      if (nums[i] % 2 == 1)\n        maxOdd = nums[i];\n      else\n        maxEven = nums[i];\n\n    long ans = -1;\n\n    if (maxEven >= 0 && minOdd >= 0)\n      ans = max(ans, sum + maxEven - minOdd);\n    if (maxOdd >= 0 && minEven >= 0)\n      ans = max(ans, sum + maxOdd - minEven);\n    return ans;\n  }\n};\n", "2099": "class Solution {\n public:\n  vector<int> maxSubsequence(vector<int>& nums, int k) {\n    vector<int> ans;\n    vector<int> arr(nums);\n    nth_element(arr.begin(), arr.end() - k, arr.end());\n    const int threshold = arr[arr.size() - k];\n    const int larger =\n        ranges::count_if(nums, [&](int num) { return num > threshold; });\n    int equal = k - larger;\n\n    for (const int num : nums)\n      if (num > threshold) {\n        ans.push_back(num);\n      } else if (num == threshold && equal) {\n        ans.push_back(num);\n        --equal;\n      }\n\n    return ans;\n  }\n};\n", "21": "class Solution {\n public:\n  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (!list1 || !list2)\n      return list1 ? list1 : list2;\n    if (list1->val > list2->val)\n      swap(list1, list2);\n    list1->next = mergeTwoLists(list1->next, list2);\n    return list1;\n  }\n};\n", "210": "class Solution {\n public:\n  vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<int> ans;\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegrees(numCourses);\n    queue<int> q;\n\n    // Build the graph.\n    for (const vector<int>& prerequisite : prerequisites) {\n      const int u = prerequisite[1];\n      const int v = prerequisite[0];\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < numCourses; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      ans.push_back(u);\n      for (const int v : graph[u])\n        if (--inDegrees[v] == 0)\n          q.push(v);\n    }\n\n    return ans.size() == numCourses ? ans : vector<int>();\n  }\n};\n", "2100": "class Solution {\n public:\n  vector<int> goodDaysToRobBank(vector<int>& security, int time) {\n    const int n = security.size();\n    vector<int> ans;\n    // dec[i] := the number of continuous decreasing numbers before i\n    vector<int> dec(n);\n    // inc[i] := the number of continuous increasing numbers after i\n    vector<int> inc(n);\n\n    for (int i = 1; i < n; ++i)\n      if (security[i - 1] >= security[i])\n        dec[i] = dec[i - 1] + 1;\n\n    for (int i = n - 2; i >= 0; --i)\n      if (security[i] <= security[i + 1])\n        inc[i] = inc[i + 1] + 1;\n\n    for (int i = 0; i < n; ++i)\n      if (dec[i] >= time && inc[i] >= time)\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "2101": "class Solution {\n public:\n  int maximumDetonation(vector<vector<int>>& bombs) {\n    const int n = bombs.size();\n    size_t ans = 0;\n    vector<vector<int>> graph(n);\n\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (i == j)\n          continue;\n        const long ri = bombs[i][2];\n        if (ri * ri >= squaredDist(bombs, i, j))\n          graph[i].push_back(j);\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      unordered_set<int> seen{i};\n      dfs(graph, i, seen);\n      ans = max(ans, seen.size());\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {\n    for (const int v : graph[u]) {\n      if (seen.contains(v))\n        continue;\n      seen.insert(v);\n      dfs(graph, v, seen);\n    }\n  }\n\n  long squaredDist(const vector<vector<int>>& bombs, int i, int j) {\n    return static_cast<long>(bombs[i][0] - bombs[j][0]) *\n               (bombs[i][0] - bombs[j][0]) +\n           static_cast<long>(bombs[i][1] - bombs[j][1]) *\n               (bombs[i][1] - bombs[j][1]);\n  }\n};\n", "2102": "struct Location {\n  string name;\n  int score;\n  Location(const string& name, int score)\n      : name(std::move(name)), score(score) {}\n};\n\nclass SORTracker {\n public:\n  void add(const string& name, int score) {\n    l.emplace(name, score);\n    if (l.size() > k + 1) {\n      const Location location = l.top();\n      l.pop();\n      r.emplace(location.name, location.score);\n    }\n  }\n\n  string get() {\n    const string name = l.top().name;\n    if (!r.empty()) {\n      const Location location = r.top();\n      r.pop();\n      l.emplace(location.name, location.score);\n    }\n    ++k;\n    return name;\n  }\n\n private:\n  struct CompareLeftMinHeap {\n    bool operator()(const Location& a, const Location& b) {\n      return a.score == b.score ? a.name < b.name : a.score > b.score;\n    }\n  };\n\n  struct CompareRightMaxHeap {\n    bool operator()(const Location& a, const Location& b) {\n      return a.score == b.score ? a.name > b.name : a.score < b.score;\n    }\n  };\n\n  priority_queue<Location, vector<Location>, CompareLeftMinHeap> l;\n  priority_queue<Location, vector<Location>, CompareRightMaxHeap> r;\n  int k = 0;\n};\n", "2103": "class Solution {\n public:\n  int countPoints(string rings) {\n    vector<int> colors(10);\n\n    for (int i = 0; i < rings.length(); i += 2) {\n      const int c = rings[i];\n      const int color = c == 'R' ? 1 : c == 'G' ? 2 : 4;\n      colors[rings[i + 1] - '0'] |= color;\n    }\n\n    return ranges::count(colors, 7);\n  }\n};\n", "2104": "class Solution {\n public:\n  long long subArrayRanges(vector<int>& nums) {\n    const auto [prevGt, nextGt] = getPrevNext(nums, less<>());\n    const auto [prevLt, nextLt] = getPrevNext(nums, greater<>());\n    long ans = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      ans += static_cast<long>(nums[i]) * (i - prevGt[i]) * (nextGt[i] - i);\n      ans -= static_cast<long>(nums[i]) * (i - prevLt[i]) * (nextLt[i] - i);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns `prev` and `next`, that store the indices of the nearest numbers\n  // that are smaller or larger than the current number depending on `op`.\n  pair<vector<int>, vector<int>> getPrevNext(\n      const vector<int>& nums, const function<bool(int, int)>& op) {\n    const int n = nums.size();\n    vector<int> prev(n, -1);\n    vector<int> next(n, n);\n    stack<int> stack;\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && op(nums[stack.top()], nums[i])) {\n        const int index = stack.top();\n        stack.pop();\n        next[index] = i;\n      }\n      if (!stack.empty())\n        prev[i] = stack.top();\n      stack.push(i);\n    }\n    return {prev, next};\n  }\n};\n", "2105": "class Solution {\n public:\n  int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\n    int ans = 0;\n    int i = 0;\n    int j = plants.size() - 1;\n    int canA = capacityA;\n    int canB = capacityB;\n\n    while (i < j) {\n      ans += (canA < plants[i]) + (canB < plants[j]);\n      if (canA < plants[i])\n        canA = capacityA;\n      if (canB < plants[j])\n        canB = capacityB;\n      canA -= plants[i++];\n      canB -= plants[j--];\n    }\n\n    return ans + (i == j && max(canA, canB) < plants[i]);\n  }\n};\n", "2106": "class Solution {\n public:\n  int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\n    const int maxRight = max(startPos, fruits.back()[0]);\n    int ans = 0;\n    vector<int> amounts(1 + maxRight);\n    vector<int> prefix(2 + maxRight);\n\n    for (const vector<int>& f : fruits)\n      amounts[f[0]] = f[1];\n\n    partial_sum(amounts.begin(), amounts.end(), prefix.begin() + 1);\n\n    auto getFruits = [&](int leftSteps, int rightSteps) {\n      const int l = max(0, startPos - leftSteps);\n      const int r = min(maxRight, startPos + rightSteps);\n      return prefix[r + 1] - prefix[l];\n    };\n\n    // Go right first.\n    const int maxRightSteps = min(maxRight - startPos, k);\n    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\n      const int leftSteps = max(0, k - 2 * rightSteps);  // Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps));\n    }\n\n    // Go left first.\n    const int maxLeftSteps = min(startPos, k);\n    for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\n      const int rightSteps = max(0, k - 2 * leftSteps);  // Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps));\n    }\n\n    return ans;\n  }\n};\n", "2107": "class Solution {\n public:\n  int shareCandies(vector<int>& candies, int k) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int candy : candies)\n      ++count[candy];\n\n    int unique = count.size();\n\n    for (int i = 0; i < candies.size(); ++i) {\n      if (--count[candies[i]] == 0) {\n        count.erase(candies[i]);\n        --unique;\n      }\n      if (i >= k && ++count[candies[i - k]] == 1)\n        ++unique;\n      if (i >= k - 1)\n        ans = max(ans, unique);\n    }\n\n    return ans;\n  }\n};\n", "2108": "class Solution {\n public:\n  string firstPalindrome(vector<string>& words) {\n    for (const string& word : words)\n      if (isPalindrome(word))\n        return word;\n    return \"\";\n  }\n\n private:\n  bool isPalindrome(const string& s) {\n    int i = 0;\n    int j = s.length() - 1;\n    while (i < j)\n      if (s[i++] != s[j--])\n        return false;\n    return true;\n  }\n};\n", "2109": "class Solution {\n public:\n  string addSpaces(string s, vector<int>& spaces) {}\n};\n", "211": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass WordDictionary {\n public:\n  void addWord(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word) {\n    return dfs(word, 0, root);\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  bool dfs(const string& word, int s, shared_ptr<TrieNode> node) {\n    if (s == word.length())\n      return node->isWord;\n    if (word[s] != '.') {\n      shared_ptr<TrieNode> next = node->children[word[s] - 'a'];\n      return next ? dfs(word, s + 1, next) : false;\n    }\n\n    // If word[s] == '.', then search all the 26 children.\n    for (int i = 0; i < 26; ++i)\n      if (node->children[i] && dfs(word, s + 1, node->children[i]))\n        return true;\n\n    return false;\n  }\n};\n", "2110": "class Solution {\n public:\n  long long getDescentPeriods(vector<int>& prices) {\n    long ans = 1;  // prices[0]\n    int dp = 1;\n\n    for (int i = 1; i < prices.size(); ++i) {\n      if (prices[i] == prices[i - 1] - 1)\n        ++dp;\n      else\n        dp = 1;\n      ans += dp;\n    }\n\n    return ans;\n  }\n};\n", "2111": "class Solution {\n public:\n  int kIncreasing(vector<int>& arr, int k) {\n    int ans = 0;\n\n    for (int i = 0; i < k; ++i) {\n      vector<int> arr;\n      for (int j = i; j < arr.size(); j += k)\n        arr.push_back(arr[j]);\n      ans += numReplaced(arr);\n    }\n\n    return ans;\n  }\n\n private:\n  int numReplaced(const vector<int>& arr) {\n    vector<int> tails;\n    for (const int a : arr)\n      if (tails.empty() || tails.back() <= a)\n        tails.push_back(a);\n      else\n        tails[firstGreater(tails, a)] = a;\n    return arr.size() - tails.size();\n  }\n\n  int firstGreater(const vector<int>& arr, int target) {\n    return ranges::upper_bound(arr, target) - arr.begin();\n  }\n};\n", "2113": "class Solution {\n public:\n  vector<int> elementInNums(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int time = query[0];\n      const int index = query[1];\n      ans.push_back(f(nums, time % (2 * nums.size()), index));\n    }\n\n    return ans;\n  }\n\n private:\n  int f(const vector<int>& arr, int time, int index) {\n    const int n = arr.size();\n    if (time < n) {  // [0, 1, 2] -> [1, 2] -> [2]\n      index += time;\n      return index >= n ? -1 : arr[index];\n    } else {  // [] -> [0] -> [0, 1]\n      return index >= time - n ? -1 : arr[index];\n    }\n  }\n};\n", "2114": "class Solution {\n public:\n  int mostWordsFound(vector<string>& sentences) {\n    long maxSpaceCount = 0;\n\n    for (const string& s : sentences)\n      maxSpaceCount = max(maxSpaceCount, ranges::count(s, ' '));\n\n    return maxSpaceCount + 1;\n  }\n};\n", "2115": "class Solution {\n public:\n  vector<string> findAllRecipes(vector<string>& recipes,\n                                vector<vector<string>>& ingredients,\n                                vector<string>& supplies) {\n    vector<string> ans;\n    unordered_set<string> suppliesSet(supplies.begin(), supplies.end());\n    unordered_map<string, vector<string>> graph;\n    unordered_map<string, int> inDegrees;\n    queue<string> q;\n\n    // Build the graph.\n    for (int i = 0; i < recipes.size(); ++i)\n      for (const string& ingredient : ingredients[i])\n        if (!suppliesSet.contains(ingredient)) {\n          graph[ingredient].push_back(recipes[i]);\n          ++inDegrees[recipes[i]];\n        }\n\n    // Perform topological sorting.\n    for (const string& recipe : recipes)\n      if (!inDegrees.contains(recipe))\n        q.push(recipe);\n\n    while (!q.empty()) {\n      const string u = q.front();\n      q.pop();\n      ans.push_back(u);\n      if (!graph.contains(u))\n        continue;\n      for (const string& v : graph[u])\n        if (--inDegrees[v] == 0)\n          q.push(v);\n    }\n\n    return ans;\n  }\n};\n", "2116": "class Solution {\n public:\n  bool canBeValid(string s, string locked) {\n    if (s.length() % 2 == 1)\n      return false;\n\n    const bool leftToRightIsOkay = check(s, locked, true);\n    ranges::reverse(s);\n    ranges::reverse(locked);\n    const bool rightToLeftIsOkay = check(s, locked, false);\n    return leftToRightIsOkay && rightToLeftIsOkay;\n  }\n\n private:\n  bool check(const string& s, const string& locked, bool isForward) {\n    int changeable = 0;\n    int l = 0;\n    int r = 0;\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      const char lock = locked[i];\n      if (lock == '0')\n        ++changeable;\n      else if (c == '(')\n        ++l;\n      else  // c == ')'\n        ++r;\n      if (isForward && changeable + l - r < 0)\n        return false;\n      if (!isForward && changeable + r - l < 0)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "2117": "class Solution {\n public:\n  string abbreviateProduct(int left, int right) {\n    constexpr long maxSuf = 100'000'000'000;\n    double prod = 1.0;\n    long suf = 1;\n    int countDigits = 0;\n    int countZeros = 0;\n\n    for (int num = left; num <= right; ++num) {\n      prod *= num;\n      while (prod >= 1.0) {\n        prod /= 10;\n        ++countDigits;\n      }\n      suf *= num;\n      while (suf % 10 == 0) {\n        suf /= 10;\n        ++countZeros;\n      }\n      if (suf > maxSuf)\n        suf %= maxSuf;\n    }\n\n    if (countDigits - countZeros <= 10) {\n      const long tens = pow(10, countDigits - countZeros);\n      return to_string(static_cast<long>(prod * tens + 0.5)) + 'e' +\n             to_string(countZeros);\n    }\n\n    const string pre = to_string(static_cast<long>(prod * pow(10, 5)));\n    string sufStr = to_string(suf);\n    sufStr = sufStr.substr(sufStr.length() - 5);\n    return pre + \"...\" + sufStr + 'e' + to_string(countZeros);\n  }\n};\n", "2119": "class Solution {\n public:\n  bool isSameAfterReversals(int num) {\n    return num == 0 || num % 10;\n  }\n};\n", "212": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  const string* word = nullptr;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n    vector<string> ans;\n\n    for (const string& word : words)\n      insert(word);\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j)\n        dfs(board, i, j, root, ans);\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->word = &word;\n  }\n\n  void dfs(vector<vector<char>>& board, int i, int j, shared_ptr<TrieNode> node,\n           vector<string>& ans) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return;\n    if (board[i][j] == '*')\n      return;\n\n    const char c = board[i][j];\n    shared_ptr<TrieNode> child = node->children[c - 'a'];\n    if (child == nullptr)\n      return;\n    if (child->word != nullptr) {\n      ans.push_back(*child->word);\n      child->word = nullptr;\n    }\n\n    board[i][j] = '*';\n    dfs(board, i + 1, j, child, ans);\n    dfs(board, i - 1, j, child, ans);\n    dfs(board, i, j + 1, child, ans);\n    dfs(board, i, j - 1, child, ans);\n    board[i][j] = c;\n  }\n};\n", "2120": "class Solution {\n public:\n  vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\n    const int m = s.length();\n    const int uMost = startPos[0] + 1;\n    const int dMost = n - startPos[0];\n    const int lMost = startPos[1] + 1;\n    const int rMost = n - startPos[1];\n    const unordered_map<char, pair<int, int>> moves{\n        {'L', {0, -1}},\n        {'R', {0, 1}},\n        {'U', {-1, 0}},\n        {'D', {1, 0}},\n    };\n\n    vector<int> ans(m);\n    unordered_map<int, int> reachX{{0, m}};\n    unordered_map<int, int> reachY{{0, m}};\n    int x = 0;\n    int y = 0;\n\n    for (int i = m - 1; i >= 0; --i) {\n      const auto& [dx, dy] = moves.at(s[i]);\n      x -= dx;\n      y -= dy;\n      reachX[x] = i;\n      reachY[y] = i;\n      int out = INT_MAX;\n      if (const auto it = reachX.find(x - uMost); it != reachX.cend())\n        out = min(out, it->second);\n      if (const auto it = reachX.find(x + dMost); it != reachX.cend())\n        out = min(out, it->second);\n      if (const auto it = reachY.find(y - lMost); it != reachY.cend())\n        out = min(out, it->second);\n      if (const auto it = reachY.find(y + rMost); it != reachY.cend())\n        out = min(out, it->second);\n      ans[i] = out == INT_MAX ? m - i : out - i - 1;\n    }\n\n    return ans;\n  }\n};\n", "2121": "class Solution {\n public:\n  vector<long long> getDistances(vector<int>& arr) {\n    const int n = arr.size();\n    vector<long long> ans(n);\n    vector<long> prefix(n);\n    vector<long> suffix(n);\n    unordered_map<int, vector<int>> numToIndices;\n\n    for (int i = 0; i < n; ++i)\n      numToIndices[arr[i]].push_back(i);\n\n    for (const auto& [_, indices] : numToIndices) {\n      for (int i = 1; i < indices.size(); ++i) {\n        const int currIndex = indices[i];\n        const int prevIndex = indices[i - 1];\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex);\n      }\n      for (int i = indices.size() - 2; i >= 0; --i) {\n        const int currIndex = indices[i];\n        const int prevIndex = indices[i + 1];\n        suffix[currIndex] += suffix[prevIndex] +\n                             (indices.size() - i - 1) * (prevIndex - currIndex);\n      }\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = prefix[i] + suffix[i];\n\n    return ans;\n  }\n};\n", "2122": "class Solution {\n public:\n  vector<int> recoverArray(vector<int>& nums) {\n    const int n = nums.size();\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    ranges::sort(nums);\n\n    for (int i = 1; i < n; ++i) {\n      const int x = nums[i] - nums[0];  // 2 * k\n      if (x <= 0 || x % 2 == 1)\n        continue;\n      vector<int> arr = getArray(nums, x, count);\n      if (!arr.empty())\n        return arr;\n    }\n\n    throw;\n  }\n\n private:\n  vector<int> getArray(const vector<int>& nums, int x,\n                       unordered_map<int, int> count) {\n    vector<int> arr;\n    for (const int num : nums) {\n      if (const auto it = count.find(num);\n          it == count.cend() || it->second == 0)\n        continue;\n      if (const auto it = count.find(num + x);\n          it == count.cend() || it->second == 0)\n        return {};\n      --count[num];\n      --count[num + x];\n      arr.push_back(num + x / 2);\n    }\n    return arr;\n  }\n};\n", "2123": "class Solution {\n public:\n  int minimumOperations(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    vector<vector<int>> seen(m, vector<int>(n));\n    vector<vector<int>> match(m, vector<int>(n, -1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1 && match[i][j] == -1) {\n          const int sessionId = i * n + j;\n          seen[i][j] = sessionId;\n          ans += dfs(grid, i, j, sessionId, seen, match);\n        }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  int dfs(const vector<vector<int>>& grid, int i, int j, int sessionId,\n          vector<vector<int>>& seen, vector<vector<int>>& match) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == m || y < 0 || y == n)\n        continue;\n      if (grid[x][y] == 0 || seen[x][y] == sessionId)\n        continue;\n      seen[x][y] = sessionId;\n      if (match[x][y] == -1 ||\n          dfs(grid, match[x][y] / n, match[x][y] % n, sessionId, seen, match)) {\n        match[x][y] = i * n + j;\n        match[i][j] = x * n + y;\n        return 1;\n      }\n    }\n\n    return 0;\n  }\n};\n", "2124": "class Solution {\n public:\n  bool checkString(string s) {\n    return s.find(\"ba\") == string::npos;\n  }\n};\n", "2125": "class Solution {\n public:\n  int numberOfBeams(vector<string>& bank) {\n    int ans = 0;\n    int prevOnes = 0;\n\n    for (const string& row : bank) {\n      const int ones = ranges::count(row, '1');\n      if (ones > 0) {\n        ans += prevOnes * ones;\n        prevOnes = ones;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2126": "class Solution {\n public:\n  bool asteroidsDestroyed(int mass, vector<int>& asteroids) {\n    ranges::sort(asteroids);\n\n    long m = mass;\n\n    for (const int asteroid : asteroids)\n      if (m >= asteroid)\n        m += asteroid;\n      else\n        return false;\n\n    return true;\n  }\n};\n", "2127": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  int maximumInvitations(vector<int>& favorite) {\n    const int n = favorite.size();\n    int sumComponentsLength = 0;  // the component: a -> b -> c <-> x <- y\n    vector<vector<int>> graph(n);\n    vector<int> inDegrees(n);\n    vector<int> maxChainLength(n, 1);\n    queue<int> q;\n\n    // Build the graph.\n    for (int i = 0; i < n; ++i) {\n      graph[i].push_back(favorite[i]);\n      ++inDegrees[favorite[i]];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u]) {\n        if (--inDegrees[v] == 0)\n          q.push(v);\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u]);\n      }\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (favorite[favorite[i]] == i)\n        // i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]];\n\n    int maxCycleLength = 0;  // the cycle : a -> b -> c -> a\n    vector<int> parent(n, -1);\n    vector<bool> seen(n);\n    vector<State> states(n);\n\n    for (int i = 0; i < n; ++i)\n      if (!seen[i])\n        findCycle(graph, i, parent, seen, states, maxCycleLength);\n\n    return max(sumComponentsLength / 2, maxCycleLength);\n  }\n\n private:\n  void findCycle(const vector<vector<int>>& graph, int u, vector<int>& parent,\n                 vector<bool>& seen, vector<State>& states,\n                 int& maxCycleLength) {\n    seen[u] = true;\n    states[u] = State::kVisiting;\n\n    for (const int v : graph[u]) {\n      if (!seen[v]) {\n        parent[v] = u;\n        findCycle(graph, v, parent, seen, states, maxCycleLength);\n      } else if (states[v] == State::kVisiting) {\n        // Find the cycle's length.\n        int curr = u;\n        int cycleLength = 1;\n        while (curr != v) {\n          curr = parent[curr];\n          ++cycleLength;\n        }\n        maxCycleLength = max(maxCycleLength, cycleLength);\n      }\n    }\n\n    states[u] = State::kVisited;\n  }\n};\n", "2128": "class Solution {\n public:\n  bool removeOnes(vector<vector<int>>& grid) {\n    const vector<int> revRow = getRevRow(grid[0]);\n    return ranges::all_of(\n        grid, [&](const auto& row) { return row == grid[0] || row == revRow; });\n  }\n\n private:\n  vector<int> getRevRow(vector<int>& row) {\n    vector<int> revRow;\n    for (const int a : row)\n      revRow.push_back(a ^ 1);\n    return revRow;\n  }\n};\n", "2129": "class Solution {\n public:\n  string capitalizeTitle(string title) {\n    ranges::transform(title, title.begin(), ::tolower);\n\n    int i = 0;  // Point to the start of a word.\n    int j = 0;  // Point to the end of a word.\n\n    while (j < title.length()) {\n      while (j < title.length() && title[j] != ' ')\n        ++j;\n      if (j - i > 2)\n        title[i] = toupper(title[i]);\n      i = j + 1;\n      ++j;  // Skip the spaces.\n    }\n\n    return title;\n  }\n};\n", "213": "class Solution {\n public:\n  int rob(vector<int>& nums) {\n    if (nums.empty())\n      return 0;\n    if (nums.size() == 1)\n      return nums[0];\n\n    auto rob = [&](int l, int r) {\n      int prev1 = 0;  // dp[i - 1]\n      int prev2 = 0;  // dp[i - 2]\n\n      for (int i = l; i <= r; ++i) {\n        const int dp = max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = dp;\n      }\n\n      return prev1;\n    };\n\n    return max(rob(0, nums.size() - 2), rob(1, nums.size() - 1));\n  }\n};\n", "2130": "class Solution {\n public:\n  int pairSum(ListNode* head) {\n    int ans = 0;\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    // `slow` points to the start of the second half.\n    while (fast != nullptr && fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    // `tail` points to the end of the reversed second half.\n    ListNode* tail = reverseList(slow);\n\n    while (tail != nullptr) {\n      ans = max(ans, head->val + tail->val);\n      head = head->next;\n      tail = tail->next;\n    }\n\n    return ans;\n  }\n\n private:\n  ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    while (head != nullptr) {\n      auto next = head->next;\n      head->next = prev;\n      prev = head;\n      head = next;\n    }\n    return prev;\n  }\n};\n", "2131": "class Solution {\n public:\n  int longestPalindrome(vector<string>& words) {\n    int ans = 0;\n    vector<vector<int>> count(26, vector<int>(26));\n\n    for (const string& word : words) {\n      const int i = word[0] - 'a';\n      const int j = word[1] - 'a';\n      if (count[j][i]) {\n        ans += 4;\n        --count[j][i];\n      } else {\n        ++count[i][j];\n      }\n    }\n\n    for (int i = 0; i < 26; ++i)\n      if (count[i][i])\n        return ans + 2;\n\n    return ans;\n  }\n};\n", "2132": "class Solution {\n public:\n  bool possibleToStamp(vector<vector<int>>& grid, int stampHeight,\n                       int stampWidth) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // A[i][j] := the number of 1s in grid[0..i)[0..j)\n    vector<vector<int>> A(m + 1, vector<int>(n + 1));\n    // B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    vector<vector<int>> B(m + 1, vector<int>(n + 1));\n    // fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    vector<vector<bool>> fit(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j];\n        if (i + 1 >= stampHeight && j + 1 >= stampWidth) {\n          const int x = i - stampHeight + 1;\n          const int y = j - stampWidth + 1;\n          if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0)\n            fit[i][j] = true;\n        }\n      }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (!grid[i][j]) {\n          const int x = min(i + stampHeight, m);\n          const int y = min(j + stampWidth, n);\n          if (B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)\n            return false;\n        }\n\n    return true;\n  }\n};\n", "2133": "class Solution {\n public:\n  bool checkValid(vector<vector<int>>& matrix) {\n    const int n = matrix.size();\n\n    for (int i = 0; i < n; ++i) {\n      bitset<101> row;\n      bitset<101> col;\n      for (int j = 0; j < n; ++j) {\n        row[matrix[i][j]] = true;\n        col[matrix[j][i]] = true;\n      }\n      if (min(row.contains(), col.contains()) < n)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "2134": "class Solution {\n public:\n  int minSwaps(vector<int>& nums) {\n    const int n = nums.size();\n    const int k = ranges::count(nums, 1);\n    int ones = 0;     // the number of ones in the window\n    int maxOnes = 0;  // the maximum number of ones in the window\n\n    for (int i = 0; i < n * 2; ++i) {\n      if (i >= k && nums[(i - k) % n])\n        --ones;\n      if (nums[i % n])\n        ++ones;\n      maxOnes = max(maxOnes, ones);\n    }\n\n    return k - maxOnes;\n  }\n};\n", "2135": "class Solution {\n public:\n  int wordCount(vector<string>& startWords, vector<string>& targetWords) {\n    int ans = 0;\n    unordered_set<int> seen;\n\n    for (const string& w : startWords)\n      seen.insert(getMask(w));\n\n    for (const string& w : targetWords) {\n      const int mask = getMask(w);\n      for (const char c : w)\n        // Toggle one character.\n        if (seen.contains(mask ^ 1 << c - 'a')) {\n          ++ans;\n          break;\n        }\n    }\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& s) {\n    int mask = 0;\n    for (const char c : s)\n      mask ^= 1 << c - 'a';\n    return mask;\n  }\n};\n", "2136": "struct Seed {\n  int p;\n  int g;\n};\n\nclass Solution {\n public:\n  int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\n    int ans = 0;\n    int time = 0;\n    vector<Seed> seeds;\n\n    for (int i = 0; i < plantTime.size(); ++i)\n      seeds.emplace_back(plantTime[i], growTime[i]);\n\n    ranges::sort(seeds, ranges::greater{},\n                 [](const Seed& seed) { return seed.g; });\n\n    for (const auto& [p, g] : seeds) {\n      time += p;\n      ans = max(ans, time + g);\n    }\n\n    return ans;\n  }\n};\n", "2137": "class Solution {\n public:\n  double equalizeWater(vector<int>& buckets, int loss) {\n    constexpr double kErr = 1e-5;\n    const double kPercentage = (100 - loss) / (double)100;\n    double l = 0.0;\n    double r = ranges::max(buckets);\n\n    while (r - l > kErr) {\n      const double m = (l + r) / 2;\n      if (canFill(buckets, m, kPercentage))\n        l = m;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n\n private:\n  bool canFill(const vector<int>& buckets, double target, double kPercentage) {\n    double extra = 0.0;\n    double need = 0.0;\n    for (const int bucket : buckets)\n      if (bucket > target)\n        extra += bucket - target;\n      else\n        need += target - bucket;\n    return extra * kPercentage >= need;\n  }\n};\n", "2138": "class Solution {\n public:\n  vector<string> divideString(string s, int k, char fill) {\n    vector<string> ans;\n\n    for (int i = 0; i < s.length(); i += k)\n      ans.push_back(i + k > s.length()\n                        ? s.substr(i) + string(i + k - s.length(), fill)\n                        : s.substr(i, k));\n\n    return ans;\n  }\n};\n", "2139": "class Solution {\n public:\n  int minMoves(int target, int maxDoubles) {\n    int steps = 0;\n\n    while (target > 1 && maxDoubles) {\n      if (target % 2 == 1) {\n        --target;\n      } else {\n        target /= 2;\n        --maxDoubles;\n      }\n      ++steps;\n    }\n\n    return steps + target - 1;\n  }\n};\n", "214": "class Solution {\n public:\n  string shortestPalindrome(string s) {\n    const string t = {s.rbegin(), s.rend()};\n    const string_view sv_s(s);\n    const string_view sv_t(t);\n\n    for (int i = 0; i < s.length(); ++i)\n      if (sv_s.substr(0, s.length() - i) == sv_t.substr(i))\n        return t.substr(0, i) + s;\n\n    return t + s;\n  }\n};\n", "2140": "class Solution {\n public:\n  long long mostPoints(vector<vector<int>>& questions) {\n    const int n = questions.size();\n    // dp[i] := the maximum points starting from questions[i]\n    vector<long> dp(n + 1);\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int points = questions[i][0];\n      const int brainpower = questions[i][1];\n      const int nextIndex = i + brainpower + 1;\n      const long nextPoints = nextIndex < n ? dp[nextIndex] : 0;\n      dp[i] = max(points + nextPoints, dp[i + 1]);\n    }\n\n    return dp[0];\n  }\n};\n", "2141": "class Solution {\n public:\n  long long maxRunTime(int n, vector<int>& batteries) {\n    long sum = accumulate(batteries.begin(), batteries.end(), 0L);\n\n    ranges::sort(batteries);\n\n    // The maximum battery is greater than the average, so it can last forever.\n    // Reduce the problem from size n to size n - 1.\n    while (batteries.back() > sum / n) {\n      sum -= batteries.back(), batteries.pop_back();\n      --n;\n    }\n\n    // If the maximum battery <= average running time, it won't be waste, and so\n    // do smaller batteries.\n    return sum / n;\n  }\n};\n", "2143": "class Solution {\n public:\n  int countSubranges(vector<int>& nums1, vector<int>& nums2) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    // {sum, count}, add if choose from nums1, minus if choose from nums2\n    unordered_map<int, int> dp;\n\n    for (int i = 0; i < nums1.size(); ++i) {\n      // edge case: nums1[i] == nums2[i] == 0, so can't put them in the\n      // initializer list.\n      unordered_map<int, int> newDp;\n      ++newDp[nums1[i]];\n      ++newDp[-nums2[i]];\n\n      for (const auto& [prevSum, count] : dp) {\n        // Choose nums1[i].\n        newDp[prevSum + nums1[i]] += count;\n        newDp[prevSum + nums1[i]] %= kMod;\n        // Choose nums2[i].\n        newDp[prevSum - nums2[i]] += count;\n        newDp[prevSum - nums2[i]] %= kMod;\n      }\n\n      dp = std::move(newDp);\n      if (const auto it = dp.find(0); it != dp.cend()) {\n        ans += it->second;\n        ans %= kMod;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2144": "class Solution {\n public:\n  int minimumCost(vector<int>& cost) {\n    int ans = 0;\n\n    ranges::sort(cost, greater<>());\n\n    for (int i = 0; i < cost.size(); ++i)\n      if (i % 3 != 2)\n        ans += cost[i];\n\n    return ans;\n  }\n};\n", "2145": "class Solution {\n public:\n  int numberOfArrays(vector<int>& differences, int lower, int upper) {\n    long prefix = 0;\n    long mn = 0;  // Starts from 0.\n    long mx = 0;  // Starts from 0.\n\n    for (const int d : differences) {\n      prefix += d;\n      mn = min(mn, prefix);\n      mx = max(mx, prefix);\n    }\n\n    return max(0L, (upper - lower) - (mx - mn) + 1);\n  }\n};\n", "2146": "class Solution {\n public:\n  vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid,\n                                          vector<int>& pricing,\n                                          vector<int>& start, int k) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int low = pricing[0];\n    const int high = pricing[1];\n    const int row = start[0];\n    const int col = start[1];\n    vector<vector<int>> ans;\n\n    if (low <= grid[row][col] && grid[row][col] <= high) {\n      ans.push_back({row, col});\n      if (k == 1)\n        return ans;\n    }\n\n    queue<pair<int, int>> q{{{row, col}}};\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    seen[row][col] = true;  // Mark as visited.\n\n    while (!q.empty()) {\n      vector<vector<int>> neighbors;\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (!grid[x][y] || seen[x][y])\n            continue;\n          if (low <= grid[x][y] && grid[x][y] <= high)\n            neighbors.push_back({x, y});\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n      ranges::sort(neighbors, [&](const vector<int>& a, const vector<int>& b) {\n        const int x1 = a[0];\n        const int y1 = a[1];\n        const int x2 = b[0];\n        const int y2 = b[1];\n        if (grid[x1][y1] != grid[x2][y2])\n          return grid[x1][y1] < grid[x2][y2];\n        return x1 == x2 ? y1 < y2 : x1 < x2;\n      });\n      for (const vector<int>& neighbor : neighbors) {\n        if (ans.size() < k)\n          ans.push_back(neighbor);\n        if (ans.size() == k)\n          return ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2147": "class Solution {\n public:\n  int numberOfWays(string corridor) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 1;\n    int prevSeat = -1;\n    int numSeats = 0;\n\n    for (int i = 0; i < corridor.length(); ++i) {\n      if (corridor[i] == 'S') {\n        if (++numSeats > 2 && numSeats % 2 == 1)\n          ans = ans * (i - prevSeat) % kMod;\n        prevSeat = i;\n      }\n    }\n\n    return numSeats > 1 && numSeats % 2 == 0 ? ans : 0;\n  }\n};\n", "2148": "class Solution {\n public:\n  int countElements(vector<int>& nums) {\n    const int mn = ranges::min(nums);\n    const int mx = ranges::max(nums);\n    return ranges::count_if(\n        nums, [&](const int num) { return mn < num && num < mx; });\n  }\n};\n", "2149": "class Solution {\n public:\n  vector<int> rearrangeArray(vector<int>& nums) {\n    vector<int> ans;\n    vector<int> pos;\n    vector<int> neg;\n\n    for (const int num : nums)\n      (num > 0 ? pos : neg).push_back(num);\n\n    for (int i = 0; i < pos.size(); ++i) {\n      ans.push_back(pos[i]);\n      ans.push_back(neg[i]);\n    }\n\n    return ans;\n  }\n};\n", "215": "class Solution {\n public:\n  int findKthLargest(vector<int>& nums, int k) {\n    return quickSelect(nums, 0, nums.size() - 1, k);\n  }\n\n private:\n  int quickSelect(vector<int>& nums, int l, int r, int k) {\n    const int pivot = nums[r];\n\n    int nextSwapped = l;\n    for (int i = l; i < r; ++i)\n      if (nums[i] >= pivot)\n        swap(nums[nextSwapped++], nums[i]);\n    swap(nums[nextSwapped], nums[r]);\n\n    const int count = nextSwapped - l + 1;  // the number of `nums` >= pivot\n    if (count == k)\n      return nums[nextSwapped];\n    if (count > k)\n      return quickSelect(nums, l, nextSwapped - 1, k);\n    return quickSelect(nums, nextSwapped + 1, r, k - count);\n  }\n};\n", "2150": "class Solution {\n public:\n  vector<int> findLonely(vector<int>& nums) {\n    vector<int> ans;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count)\n      if (freq == 1 && !count.contains(num - 1) && !count.contains(num + 1))\n        ans.push_back(num);\n\n    return ans;\n  }\n};\n", "2151": "class Solution {\n public:\n  int maximumGood(vector<vector<int>>& statements) {\n    const int maxMask = 1 << statements.size();\n    int ans = 0;\n\n    for (unsigned mask = 0; mask < maxMask; ++mask)\n      if (isValid(statements, mask))\n        ans = max(ans, popcount(mask));\n\n    return ans;\n  }\n\n private:\n  bool isValid(const vector<vector<int>>& statements, int mask) {\n    for (int i = 0; i < statements.size(); ++i) {\n      if ((mask >> i & 1) == 0)  // The i-th person is bad, so no need to check.\n        continue;\n      for (int j = 0; j < statements.size(); ++j) {\n        if (statements[i][j] == 2)\n          continue;\n        if (statements[i][j] != (mask >> j & 1))\n          return false;\n      }\n    }\n    return true;\n  }\n};\n", "2152": "class Solution {\n public:\n  int minimumLines(vector<vector<int>>& points) {\n    const int allCovered = (1 << points.size()) - 1;\n    return dfs(points, 0, allCovered, vector<int>(allCovered, -1));\n  }\n\n private:\n  int dfs(const vector<vector<int>>& points, int covered, int allCovered,\n          vector<int>&& mem) {\n    if (covered == allCovered)\n      return 0;\n    if (mem[covered] != -1)\n      return mem[covered];\n\n    const int n = points.size();\n    int ans = n / 2 + (n & 1);\n\n    for (int i = 0; i < n; ++i) {\n      if (covered >> i & 1)\n        continue;\n      for (int j = 0; j < n; ++j) {\n        if (i == j)\n          continue;\n        // Connect the points[i] with the points[j].\n        int newCovered = covered | 1 << i | 1 << j;\n        // Mark the points covered by this line.\n        const pair<int, int> slope = getSlope(points[i], points[j]);\n        for (int k = 0; k < n; ++k)\n          if (getSlope(points[i], points[k]) == slope)\n            newCovered |= 1 << k;\n        ans = min(ans, 1 + dfs(points, newCovered, allCovered, std::move(mem)));\n      }\n    }\n\n    return mem[covered] = ans;\n  }\n\n  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {\n    const int dx = p[0] - q[0];\n    const int dy = p[1] - q[1];\n    if (dx == 0)\n      return {0, p[0]};\n    if (dy == 0)\n      return {p[1], 0};\n    const int d = __gcd(dx, dy);\n    const int x = dx / d;\n    const int y = dy / d;\n    if (x > 0)\n      return {x, y};\n    return {-x, -y};\n  }\n};\n", "2154": "class Solution {\n public:\n  int findFinalValue(vector<int>& nums, int original) {\n    vector<bool> seen(1001);\n\n    for (const int num : nums)\n      seen[num] = true;\n\n    while (original < 1001 && seen[original])\n      original *= 2;\n\n    return original;\n  }\n};\n", "2155": "class Solution {\n public:\n  vector<int> maxScoreIndices(vector<int>& nums) {\n    const int zeros = ranges::count(nums, 0);\n    const int ones = nums.size() - zeros;\n    vector<int> ans{0};  // the division at index 0\n    int leftZeros = 0;\n    int leftOnes = 0;\n    int maxScore = ones;  // `leftZeros` + `rightOnes`\n\n    for (int i = 0; i < nums.size(); ++i) {\n      leftZeros += nums[i] == 0;\n      leftOnes += nums[i] == 1;\n      const int rightOnes = ones - leftOnes;\n      const int score = leftZeros + rightOnes;\n      if (maxScore == score) {\n        ans.push_back(i + 1);\n      } else if (maxScore < score) {\n        maxScore = score;\n        ans = {i + 1};\n      }\n    }\n\n    return ans;\n  }\n};\n", "2156": "class Solution {\n public:\n  string subStrHash(string s, int power, int modulo, int k, int hashValue) {\n    long maxPower = 1;\n    long hash = 0;\n    int bestLeft = -1;\n\n    auto val = [](char c) -> int { return c - 'a' + 1; };\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      hash = (hash * power + val(s[i])) % modulo;\n      if (i + k < s.length())\n        hash = (hash - val(s[i + k]) * maxPower % modulo + modulo) % modulo;\n      else\n        maxPower = maxPower * power % modulo;\n      if (hash == hashValue)\n        bestLeft = i;\n    }\n\n    return s.substr(bestLeft, k);\n  }\n};\n", "2157": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), sz(n, 1) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionBySize(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (sz[i] < sz[j]) {\n      sz[j] += sz[i];\n      id[i] = j;\n    } else {\n      sz[i] += sz[j];\n      id[j] = i;\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n  int getMaxSize() const {\n    return ranges::max(sz);\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> sz;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> groupStrings(vector<string>& words) {\n    UnionFind uf(words.size());\n    unordered_map<int, int> maskToIndex;\n    unordered_map<int, int> deletedMaskToIndex;\n\n    for (int i = 0; i < words.size(); ++i) {\n      const int mask = getMask(words[i]);\n      for (int j = 0; j < 26; ++j)\n        if (mask >> j & 1) {\n          // Going to delete this bit.\n          const int m = mask ^ 1 << j;\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\n            uf.unionBySize(i, it->second);\n          if (const auto it = deletedMaskToIndex.find(m);\n              it != deletedMaskToIndex.cend())\n            uf.unionBySize(i, it->second);\n          else\n            deletedMaskToIndex[m] = i;\n        } else {\n          // Going to add this bit.\n          const int m = mask | 1 << j;\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\n            uf.unionBySize(i, it->second);\n        }\n      maskToIndex[mask] = i;\n    }\n\n    return {uf.getCount(), uf.getMaxSize()};\n  }\n\n private:\n  int getMask(const string& s) {\n    int mask = 0;\n    for (const char c : s)\n      mask |= 1 << c - 'a';\n    return mask;\n  }\n};\n", "2158": "class Solution {\n public:\n  vector<int> amountPainted(vector<vector<int>>& paint) {\n    map<int, int> intervals;\n    vector<int> result;\n\n    for (const vector<int>& p : paint) {\n      int eraseLen = 0;\n      auto it = intervals.lower_bound(p[0]);\n      if (it != intervals.begin() && prev(it)->second >= p[0])\n        --it;\n      while (it != intervals.end() && p[1] >= it->first) {\n        eraseLen += it->second - it->first;\n        p[0] = min(p[0], it->first);\n        p[1] = max(p[1], it->second);\n        it = intervals.erase(it);\n      }\n      intervals.insert({p[0], p[1]});\n      result.push_back(p[1] - p[0] - eraseLen);\n    }\n\n    return result;\n  }\n};\n", "216": "class Solution {\n public:\n  vector<vector<int>> combinationSum3(int k, int n) {\n    vector<vector<int>> ans;\n    dfs(k, n, 1, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int k, int n, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (k == 0 && n == 0) {\n      ans.push_back(path);\n      return;\n    }\n    if (k == 0 || n <= 0)\n      return;\n\n    for (int i = s; i <= 9; ++i) {\n      path.push_back(i);\n      dfs(k - 1, n - i, i + 1, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "2160": "class Solution {\n public:\n  int minimumSum(int num) {\n    string s = to_string(num);\n    ranges::sort(s);\n    return stoi(s.substr(0, 1) + s.substr(2, 1)) +\n           stoi(s.substr(1, 1) + s.substr(3, 1));\n  }\n};\n", "2161": "class Solution {\n public:\n  vector<int> pivotArray(vector<int>& nums, int pivot) {\n    vector<int> ans;\n\n    for (const int num : nums)\n      if (num < pivot)\n        ans.push_back(num);\n\n    for (const int num : nums)\n      if (num == pivot)\n        ans.push_back(num);\n\n    for (const int num : nums)\n      if (num > pivot)\n        ans.push_back(num);\n\n    return ans;\n  }\n};\n", "2162": "class Solution {\n public:\n  int minCostSetTime(int startAt, int moveCost, int pushCost,\n                     int targetSeconds) {\n    int ans = INT_MAX;\n    int mins = targetSeconds > 5999 ? 99 : targetSeconds / 60;\n    int secs = targetSeconds - mins * 60;\n\n    auto getCost = [&](int mins, int secs) -> int {\n      int cost = 0;\n      char curr = '0' + startAt;\n      for (const char c : to_string(mins * 100 + secs))\n        if (c == curr) {\n          cost += pushCost;\n        } else {\n          cost += moveCost + pushCost;\n          curr = c;\n        }\n      return cost;\n    };\n\n    while (secs < 100) {\n      ans = min(ans, getCost(mins, secs));\n      --mins;\n      secs += 60;\n    }\n\n    return ans;\n  }\n};\n", "2163": "class Solution {\n public:\n  long long minimumDifference(vector<int>& nums) {\n    const int n = nums.size() / 3;\n    long ans = LONG_MAX;\n    long leftSum = 0;\n    long rightSum = 0;\n    // The left part should be as small as possible.\n    priority_queue<int> maxHeap;\n    // The right part should be as big as possible.\n    priority_queue<int, vector<int>, greater<>> minHeap;\n    // minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    vector<long> minLeftSum(nums.size());\n\n    for (int i = 0; i < 2 * n; ++i) {\n      maxHeap.push(nums[i]);\n      leftSum += nums[i];\n      if (maxHeap.size() == n + 1)\n        leftSum -= maxHeap.top(), maxHeap.pop();\n      if (maxHeap.size() == n)\n        minLeftSum[i] = leftSum;\n    }\n\n    for (int i = nums.size() - 1; i >= n; --i) {\n      minHeap.push(nums[i]);\n      rightSum += nums[i];\n      if (minHeap.size() == n + 1)\n        rightSum -= minHeap.top(), minHeap.pop();\n      if (minHeap.size() == n)\n        ans = min(ans, minLeftSum[i - 1] - rightSum);\n    }\n\n    return ans;\n  }\n};\n", "2164": "class Solution {\n public:\n  vector<int> sortEvenOdd(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n);\n    vector<int> evenCount(101);\n    vector<int> oddCount(101);\n\n    for (int i = 0; i < n; ++i)\n      if (i % 2 == 1)\n        ++oddCount[nums[i]];\n      else\n        ++evenCount[nums[i]];\n\n    int ansIndex = 0;\n    for (int i = 1; i < 101; ++i)\n      while (evenCount[i]--) {\n        ans[ansIndex] = i;\n        ansIndex += 2;\n      }\n\n    ansIndex = 1;\n    for (int i = 100; i > 0; --i)\n      while (oddCount[i]--) {\n        ans[ansIndex] = i;\n        ansIndex += 2;\n      }\n\n    return ans;\n  }\n};\n", "2165": "class Solution {\n public:\n  long long smallestNumber(long long num) {\n    string s = to_string(abs(num));\n    ranges::sort(s, [&](int a, int b) { return num < 0 ? a > b : a < b; });\n    if (num > 0)\n      swap(s[0], s[s.find_first_not_of('0')]);\n    return stoll(s) * (num < 0 ? -1 : 1);\n  }\n};\n", "2166": "class Bitset {\n public:\n  Bitset(int size) : s(size, '0'), r(size, '1') {}\n\n  void fix(int idx) {\n    if (s[idx] == '0')\n      ++cnt;\n    s[idx] = '1';\n    r[idx] = '0';\n  }\n\n  void unfix(int idx) {\n    if (s[idx] == '1')\n      --cnt;\n    s[idx] = '0';\n    r[idx] = '1';\n  }\n\n  void flip() {\n    swap(s, r);\n    cnt = s.length() - cnt;\n  }\n\n  bool all() {\n    return cnt == s.length();\n  }\n\n  bool one() {\n    return cnt;\n  }\n\n  int count() {\n    return cnt;\n  }\n\n  string toString() {\n    return s;\n  }\n\n private:\n  string s;  // the original\n  string r;  // the reversed\n  int cnt = 0;\n};\n", "2167": "class Solution {\n public:\n  int minimumTime(string s) {\n    const int n = s.length();\n    int ans = n;\n    int left = 0;  // the minimum time to remove the illegal cars so far\n\n    for (int i = 0; i < n; ++i) {\n      left = min(left + (s[i] - '0') * 2, i + 1);\n      ans = min(ans, left + n - 1 - i);\n    }\n\n    return ans;\n  }\n};\n", "2168": "class Solution {\n public:\n  int equalDigitFrequency(string s) {\n    vector<vector<int>> counts;  // counts[i] := the counter map of s[0..i]\n    vector<int> count(10);\n    vector<long> pows{1};  // pows[i] := kBase^i % kHash\n    // hash[i] = the hash of the first i letters of s, where hash[i] =\n    // (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % kHash\n    vector<long> hash{0};\n    unordered_set<int> seen;\n\n    for (const char c : s) {\n      ++count[c - '0'];\n      counts.push_back(count);\n      pows.push_back(pows.back() * kBase % kHash);\n      hash.push_back((hash.back() * kBase + val(c)) % kHash);\n    }\n\n    for (int i = 0; i < s.length(); ++i)\n      for (int j = i; j < s.length(); ++j)\n        if (isSameFreq(counts, i, j))\n          seen.insert(getRollingHash(i, j + 1, hash, pows));\n\n    return seen.size();\n  }\n\n private:\n  static constexpr int kMax = 1001;\n  static constexpr int kBase = 11;\n  static constexpr int kHash = 1'000'000'007;\n\n  static constexpr int val(char c) {\n    return c - '0' + 1;\n  }\n\n  // Returns true if s[i..j] has the same digit frequency.j\n  bool isSameFreq(const vector<vector<int>>& counts, int i, int j) {\n    vector<int> count = counts[j];\n    if (i > 0)\n      for (int num = 0; num < 10; ++num)\n        count[num] -= counts[i - 1][num];\n    return equalFreq(count);\n  }\n\n  bool equalFreq(const vector<int>& count) {\n    int minfreq = kMax;\n    int maxfreq = 0;\n    for (const int freq : count)\n      if (freq > 0) {\n        minfreq = min(minfreq, freq);\n        maxfreq = max(maxfreq, freq);\n      }\n    return minfreq == maxfreq;\n  }\n\n  // Returns the rolling hash of s[l..r).\n  int getRollingHash(int l, int r, const vector<long>& hash,\n                     const vector<long>& pows) {\n    const long h = (hash[r] - hash[l] * pows[r - l]) % kHash;\n    return h < 0 ? h + kHash : h;\n  }\n};\n", "2169": "class Solution {\n public:\n  int countOperations(int num1, int num2) {\n    int ans = 0;\n\n    while (num1 && num2) {\n      if (num1 < num2)\n        swap(num1, num2);\n      ans += num1 / num2;\n      num1 %= num2;\n    }\n\n    return ans;\n  }\n};\n", "217": "class Solution {\n public:\n  bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> seen;\n\n    for (const int num : nums)\n      if (!seen.insert(num).second)\n        return true;\n\n    return false;\n  }\n};\n", "2170": "struct T {\n  unordered_map<int, int> count;\n  int mx = 0;\n  int secondMax = 0;\n  int maxFreq = 0;\n  int secondMaxFreq = 0;\n};\n\nclass Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    // 0 := odd indices, 1 := even indices\n    vector<T> ts(2);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      T& t = ts[i % 2];\n      const int freq = ++t.count[nums[i]];\n      if (freq > t.maxFreq) {\n        t.maxFreq = freq;\n        t.mx = nums[i];\n      } else if (freq > t.secondMaxFreq) {\n        t.secondMaxFreq = freq;\n        t.secondMax = nums[i];\n      }\n    }\n\n    if (ts[0].mx == ts[1].mx)\n      return nums.size() - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                               ts[1].maxFreq + ts[0].secondMaxFreq);\n    return nums.size() - (ts[0].maxFreq + ts[1].maxFreq);\n  }\n};\n", "2171": "class Solution {\n public:\n  long long minimumRemoval(vector<int>& beans) {\n    const long n = beans.size();\n    const long sum = accumulate(beans.begin(), beans.end(), 0L);\n    long ans = LONG_MAX;\n\n    ranges::sort(beans);\n\n    for (int i = 0; i < n; ++i)\n      ans = min(ans, sum - (n - i) * beans[i]);\n\n    return ans;\n  }\n};\n", "2172": "class Solution {\n public:\n  int maximumANDSum(vector<int>& nums, int numSlots) {\n    const int n = 2 * numSlots;\n    const int nSelected = 1 << n;\n    // dp[i] := the maximum value, where i is the bitmask of the selected\n    // numbers\n    vector<int> dp(nSelected);\n\n    nums.resize(n);\n\n    for (unsigned mask = 1; mask < nSelected; ++mask) {\n      const int selected = popcount(mask);\n      const int slot = (selected + 1) / 2;  // (1, 2) -> 1, (3, 4) -> 2\n      for (int i = 0; i < n; ++i)\n        if (mask >> i & 1)  // Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & nums[i]));\n    }\n\n    return dp.back();\n  }\n};\n", "2174": "class Solution {\n public:\n  int removeOnes(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int maxMask = 1 << m * n;\n    // dp[i] := the minimum number of operations to remove all 1s from the grid,\n    // where `i` is the bitmask of the state of the grid\n    vector<int> dp(maxMask, INT_MAX / 2);\n    dp[0] = 0;\n\n    for (int mask = 0; mask < maxMask; ++mask)\n      for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n          if (grid[i][j] == 1) {\n            int newMask = mask;\n            // Set the cells in the same row with 0.\n            for (int k = 0; k < n; ++k)\n              newMask &= ~(1 << i * n + k);\n            // Set the cells in the same column with 0.\n            for (int k = 0; k < m; ++k)\n              newMask &= ~(1 << k * n + j);\n            dp[mask] = min(dp[mask], 1 + dp[newMask]);\n          }\n\n    return dp[encode(grid, m, n)];\n  }\n\n private:\n  int encode(const vector<vector<int>>& grid, int m, int n) {\n    int encoded = 0;\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j])\n          encoded |= 1 << i * n + j;\n    return encoded;\n  }\n};\n", "2176": "class Solution {\n public:\n  int countPairs(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, vector<int>> numToIndices;\n\n    for (int i = 0; i < nums.size(); ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    for (const auto& [_, indices] : numToIndices) {\n      unordered_map<int, int> gcds;\n      for (const int i : indices) {\n        const int gcd_i = gcd(i, k);\n        for (const auto& [gcd_j, count] : gcds)\n          if (gcd_i * gcd_j % k == 0)\n            ans += count;\n        ++gcds[gcd_i];\n      }\n    }\n\n    return ans;\n  }\n};\n", "2177": "class Solution {\n public:\n  vector<long long> sumOfThree(long long num) {\n    if (num % 3)\n      return {};\n    const long x = num / 3;\n    return {x - 1, x, x + 1};\n  }\n};\n", "2178": "class Solution {\n public:\n  vector<long long> maximumEvenSplit(long long finalSum) {\n    if (finalSum % 2 == 1)\n      return {};\n\n    vector<long long> ans;\n    long needSum = finalSum;\n    long even = 2;\n\n    while (needSum - even >= even + 2) {\n      ans.push_back(even);\n      needSum -= even;\n      even += 2;\n    }\n\n    ans.push_back(needSum);\n    return ans;\n  }\n};\n", "2179": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\n    const int n = nums1.size();\n    long ans = 0;\n    unordered_map<int, int> numToIndex;\n    vector<int> arr;\n    // leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    vector<int> leftSmaller(n);\n    // rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    vector<int> rightLarger(n);\n    FenwickTree tree1(n);  // Calculates `leftSmaller`.\n    FenwickTree tree2(n);  // Calculates `rightLarger`.\n\n    for (int i = 0; i < n; ++i)\n      numToIndex[nums1[i]] = i;\n\n    // Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    // So the problem is to find the number of increasing tripets in `arr`.\n    for (const int num : nums2)\n      arr.push_back(numToIndex[num]);\n\n    for (int i = 0; i < n; ++i) {\n      leftSmaller[i] = tree1.get(arr[i]);\n      tree1.add(arr[i] + 1, 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      rightLarger[i] = tree2.get(n) - tree2.get(arr[i]);\n      tree2.add(arr[i] + 1, 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans += static_cast<long>(leftSmaller[i]) * rightLarger[i];\n\n    return ans;\n  }\n};\n", "218": "class Solution {\n public:\n  vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<vector<int>> ans;\n    vector<vector<int>> events;  // [(Li, Hi) | (Ri, -Hi)]\n\n    for (const vector<int>& b : buildings) {\n      events.push_back({b[0], b[2]});\n      events.push_back({b[1], -b[2]});  // Minus means leaving.\n    }\n\n    ranges::sort(events, ranges::less{}, [](const vector<int>& event) {\n      return pair<int, int>{event[0], -event[1]};\n    });\n\n    for (const vector<int>& event : events) {\n      const int x = event[0];\n      const int h = abs(event[1]);\n      const int isEntering = event[1] > 0;\n      if (isEntering) {\n        if (h > maxHeight())\n          ans.push_back({x, h});\n        set.insert(h);\n      } else {\n        set.erase(set.equal_range(h).first);\n        if (h > maxHeight())\n          ans.push_back({x, maxHeight()});\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  multiset<int> set;\n\n  int maxHeight() const {\n    return set.empty() ? 0 : *set.rbegin();\n  }\n};\n", "2180": "class Solution {\n public:\n  int countEven(int num) {\n    return (num - getDigitSum(num) % 2) / 2;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "2181": "class Solution {\n public:\n  ListNode* mergeNodes(ListNode* head) {\n    ListNode* curr = head->next;\n\n    while (curr != nullptr) {\n      ListNode* running = curr;\n      int sum = 0;\n      while (running->val > 0) {\n        sum += running->val;\n        running = running->next;\n      }\n      curr->val = sum;\n      curr->next = running->next;\n      curr = running->next;\n    }\n\n    return head->next;\n  }\n};\n", "2182": "class Solution {\n public:\n  string repeatLimitedString(string s, int repeatLimit) {\n    string ans;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    while (true) {\n      const bool addOne = !ans.empty() && shouldAddOne(ans, count);\n      const int i = getLargestChar(ans, count);\n      if (i == -1)\n        break;\n      const int repeats = addOne ? 1 : min(count[i], repeatLimit);\n      ans += string(repeats, 'a' + i);\n      count[i] -= repeats;\n    }\n\n    return ans;\n  }\n\n private:\n  bool shouldAddOne(const string& ans, const vector<int>& count) {\n    for (int i = 25; i >= 0; --i)\n      if (count[i])\n        return ans.back() == 'a' + i;\n    return false;\n  }\n\n  int getLargestChar(const string& ans, const vector<int>& count) {\n    for (int i = 25; i >= 0; --i)\n      if (count[i] && (ans.empty() || ans.back() != 'a' + i))\n        return i;\n    return -1;\n  }\n};\n", "2183": "class Solution {\n public:\n  long long countPairs(vector<int>& nums, int k) {\n    long ans = 0;\n    unordered_map<int, int> gcds;\n\n    for (const int num : nums) {\n      const int gcd_i = gcd(num, k);\n      for (const auto& [gcd_j, count] : gcds)\n        if (static_cast<long>(gcd_i) * gcd_j % k == 0)\n          ans += count;\n      ++gcds[gcd_i];\n    }\n\n    return ans;\n  }\n};\n", "2184": "class Solution {\n public:\n  int buildWall(int height, int width, vector<int>& bricks) {\n    constexpr int kMod = 1'000'000'007;\n    // Stores the valid rows in bitmask.\n    vector<int> rows;\n    buildRows(width, bricks, 0, rows);\n\n    const int n = rows.size();\n    // dp[i] := the number of ways to build `h` height walls with rows[i] in the\n    // bottom\n    vector<long> dp(n, 1);\n    // graph[i] := the valid neighbors of rows[i]\n    vector<vector<int>> graph(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (!(rows[i] & rows[j]))\n          graph[i].push_back(j);\n\n    for (int h = 2; h <= height; ++h) {\n      vector<long> newDp(n);\n      for (int i = 0; i < n; ++i)\n        for (const int v : graph[i]) {\n          newDp[i] += dp[v];\n          newDp[i] %= kMod;\n        }\n      dp = std::move(newDp);\n    }\n\n    return accumulate(dp.begin(), dp.end(), 0L) % kMod;\n  }\n\n private:\n  void buildRows(int width, const vector<int>& bricks, int path,\n                 vector<int>& rows) {\n    for (const int brick : bricks)\n      if (brick == width)\n        rows.push_back(path);\n      else if (brick < width) {\n        const int newWidth = width - brick;\n        buildRows(newWidth, bricks, path | 1 << newWidth, rows);\n      }\n  }\n};\n", "2185": "class Solution {\n public:\n  int prefixCount(vector<string>& words, string pref) {\n    return ranges::count_if(\n        words, [&](const string& word) { return word.find(pref) == 0; });\n  }\n};\n", "2186": "class Solution {\n public:\n  int minSteps(string s, string t) {\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : t)\n      --count[c - 'a'];\n\n    return accumulate(count.begin(), count.end(), 0,\n                      [](int acc, int c) { return acc + abs(c); });\n  }\n};\n", "2187": "class Solution {\n public:\n  long long minimumTime(vector<int>& time, int totalTrips) {\n    long l = 1;\n    long r = static_cast<long>(ranges::min(time)) * totalTrips;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (numTrips(time, m) >= totalTrips)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n  long numTrips(const vector<int>& times, long m) {\n    return accumulate(times.begin(), times.end(), 0L,\n                      [&](long acc, int t) { return acc + m / t; });\n  }\n};\n", "2188": "class Solution {\n public:\n  int minimumFinishTime(vector<vector<int>>& tires, int changeTime,\n                        int numLaps) {\n    // dp[i] := the minimum time of the first i laps\n    vector<int> dp(numLaps + 1, INT_MAX);\n\n    for (const vector<int>& t : tires)\n      for (int seconds = t[0], secondsSum = t[0], lapCount = 1;\n           seconds < t[0] + changeTime && lapCount < dp.size();\n           seconds *= t[1], ++lapCount, secondsSum += seconds)\n        dp[lapCount] = min(secondsSum, dp[lapCount]);\n\n    for (int i = 2; i <= numLaps; ++i)\n      for (int j = 1; j * 2 <= i; ++j)\n        dp[i] = min(dp[i], dp[j] + dp[i - j] + changeTime);\n\n    return dp[numLaps];\n  }\n};\n", "2189": "class Solution {\n public:\n  int houseOfCards(int n) {\n    // dp[i] := the number of valid result for i cards\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n\n    for (int baseCards = 2; baseCards <= n; baseCards += 3)\n      for (int i = n; i >= baseCards; --i)\n        // Use `baseCards` as the base, so we're left with `i - baseCards`\n        // cards.\n        dp[i] += dp[i - baseCards];\n\n    return dp[n];\n  }\n};\n", "219": "class Solution {\n public:\n  bool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_set<int> seen;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (!seen.insert(nums[i]).second)\n        return true;\n      if (i >= k)\n        seen.erase(nums[i - k]);\n    }\n\n    return false;\n  }\n};\n", "2190": "class Solution {\n public:\n  int mostFrequent(vector<int>& nums, int key) {\n    vector<int> count(1001);\n\n    for (int i = 0; i + 1 < nums.size(); ++i)\n      if (nums[i] == key)\n        ++count[nums[i + 1]];\n\n    return ranges::max_element(count) - count.begin();\n  }\n};\n", "2191": "class Solution {\n public:\n  vector<int> sortJumbled(vector<int>& mapping, vector<int>& nums) {\n    vector<int> ans;\n    map<int, vector<int>> mappedToOriginalNums;\n\n    for (const int num : nums)\n      mappedToOriginalNums[getMapped(num, mapping)].push_back(num);\n\n    for (const auto& [_, originalNums] : mappedToOriginalNums)\n      ans.insert(ans.end(), originalNums.begin(), originalNums.end());\n\n    return ans;\n  }\n\n private:\n  int getMapped(int num, const vector<int>& mapping) {\n    string mapped;\n    for (const char c : to_string(num))\n      mapped += to_string(mapping[c - '0']);\n    return stoi(mapped);\n  }\n};\n", "2192": "class Solution {\n public:\n  vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> ans;\n    vector<vector<int>> graph(n);\n    vector<set<int>> ancestors(n);  //  {u: {ancestors}}\n    vector<int> inDegrees(n);\n    queue<int> q;\n\n    // Build the graph.\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u]) {\n          ancestors[v].insert(u);\n          std::copy(ancestors[u].begin(), ancestors[u].end(),\n                    std::inserter(ancestors[v], ancestors[v].end()));\n          if (--inDegrees[v] == 0)\n            q.push(v);\n        }\n      }\n\n    for (const set<int>& nodes : ancestors)\n      ans.push_back({nodes.begin(), nodes.end()});\n\n    return ans;\n  }\n};\n", "2193": "class Solution {\n public:\n  int minMovesToMakePalindrome(string s) {\n    int ans = 0;\n\n    while (s.length() > 1) {\n      // Greedily match the last digit.\n      const int i = s.find(s.back());\n      if (i == s.length() - 1) {\n        // s[i] is the middle letter.\n        ans += i / 2;\n      } else {\n        s.erase(i, 1);\n        ans += i;  // Swap the matched letter to the left.\n      }\n      s.pop_back();\n    }\n\n    return ans;\n  }\n};\n", "2194": "class Solution {\n public:\n  vector<string> cellsInRange(string s) {\n    vector<string> ans;\n    const char startCol = s[0];\n    const char endCol = s[3];\n    const char startRow = s[1];\n    const char endRow = s[4];\n\n    for (char col = startCol; col <= endCol; ++col)\n      for (char row = startRow; row <= endRow; ++row)\n        ans.push_back(string(1, col) + row);\n\n    return ans;\n  }\n};\n", "2195": "class Solution {\n public:\n  long long minimalKSum(vector<int>& nums, int k) {\n    long ans = 0;\n    nums.push_back(0);\n    ranges::sort(nums);\n\n    for (int i = 0; i + 1 < nums.size(); ++i) {\n      if (nums[i] == nums[i + 1])\n        continue;\n      const int l = nums[i] + 1;\n      const int r = min(nums[i] + k, nums[i + 1] - 1);\n      ans += static_cast<long>(l + r) * (r - l + 1) / 2;\n      k -= r - l + 1;\n      if (k == 0)\n        return ans;\n    }\n\n    if (k > 0) {\n      const int l = nums.back() + 1;\n      const int r = nums.back() + k;\n      ans += static_cast<long>(l + r) * (r - l + 1) / 2;\n    }\n\n    return ans;\n  }\n};\n", "2196": "class Solution {\n public:\n  TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\n    unordered_map<TreeNode*, TreeNode*> childToParent;\n    unordered_map<int, TreeNode*> valToNode;\n\n    for (const vector<int>& d : descriptions) {\n      const int p = d[0];\n      const int c = d[1];\n      const bool isLeft = d[2];\n      TreeNode* parent = valToNode.contains(p)\n                             ? valToNode[p]\n                             : (valToNode[p] = new TreeNode(p));\n      TreeNode* child = valToNode.contains(c)\n                            ? valToNode[c]\n                            : (valToNode[c] = new TreeNode(c));\n      childToParent[child] = parent;\n      if (isLeft)\n        parent->left = child;\n      else\n        parent->right = child;\n    }\n\n    // Pick a random node and traverse upwardly.\n    TreeNode* root = childToParent.begin()->second;\n    while (childToParent.contains(root))\n      root = childToParent[root];\n    return root;\n  }\n};\n", "2197": "class Solution {\n public:\n  vector<int> replaceNonCoprimes(vector<int>& nums) {\n    vector<int> ans;\n\n    for (int num : nums) {\n      while (!ans.empty() && std::gcd(ans.back(), num) > 1)\n        num = std::lcm(ans.back(), num), ans.pop_back();\n      ans.push_back(num);\n    }\n\n    return ans;\n  }\n};\n", "2198": "class Solution {\n public:\n  long long singleDivisorTriplet(vector<int>& nums) {\n    constexpr int kMax = 100;\n    long ans = 0;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int a = 1; a <= kMax; ++a)\n      for (int b = a; count[a] > 0 && b <= kMax; ++b)\n        for (int c = b; count[b] > 0 && c <= kMax; ++c) {\n          const int sum = a + b + c;\n          if (divisible(sum, a) + divisible(sum, b) + divisible(sum, c) != 1)\n            continue;\n          if (a == b)\n            ans += static_cast<long>(count[a]) * (count[a] - 1) / 2 * count[c];\n          else if (b == c)\n            ans += static_cast<long>(count[b]) * (count[b] - 1) / 2 * count[a];\n          else\n            ans += static_cast<long>(count[a]) * count[b] * count[c];\n        }\n\n    return ans * 6;\n  }\n\n private:\n  int divisible(int sum, int num) {\n    return sum % num == 0;\n  }\n};\n", "22": "class Solution {\n public:\n  vector<string> generateParenthesis(int n) {\n    vector<string> ans;\n    dfs(n, n, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(int l, int r, string&& path, vector<string>& ans) {\n    if (l == 0 && r == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    if (l > 0) {\n      path.push_back('(');\n      dfs(l - 1, r, std::move(path), ans);\n      path.pop_back();\n    }\n    if (l < r) {\n      path.push_back(')');\n      dfs(l, r - 1, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "220": "class Solution {\n public:\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff,\n                                     int valueDiff) {\n    if (nums.empty() || indexDiff <= 0 || valueDiff < 0)\n      return false;\n\n    const long mn = ranges::min(nums);\n    const long diff = valueDiff + 1L;  // In case that `valueDiff` equals 0.\n    // Use long because the corner case INT_MAX - (-1) will overflow.\n    unordered_map<long, long> bucket;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const long num = nums[i];\n      const long key = getKey(num, mn, diff);\n      if (bucket.contains(key))  // the current bucket\n        return true;\n      if (bucket.contains(key - 1) &&\n          num - bucket[key - 1] < diff)  // the left adjacent bucket\n        return true;\n      if (bucket.contains(key + 1) &&\n          bucket[key + 1] - num < diff)  // the right adjacent bucket\n        return true;\n      bucket[key] = num;\n      if (i >= indexDiff)\n        bucket.erase(getKey(nums[i - indexDiff], mn, diff));\n    }\n\n    return false;\n  }\n\n private:\n  int getKey(long num, long mn, long diff) {\n    return (num - mn) / diff;\n  }\n};\n", "2200": "class Solution {\n public:\n  vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\n    const int n = nums.size();\n    vector<int> ans;\n\n    for (int i = 0, j = 0; i < n; ++i) {\n      // the first index j s.t. nums[j] == key and j >= i - k\n      while (j < n && (nums[j] != key || j < i - k))\n        ++j;\n      if (j == n)\n        break;\n      if (abs(i - j) <= k)\n        ans.push_back(i);\n    }\n\n    return ans;\n  }\n};\n", "2201": "class Solution {\n public:\n  int digArtifacts(int n, vector<vector<int>>& artifacts,\n                   vector<vector<int>>& dig) {\n    unordered_set<int> digged;\n\n    for (const vector<int>& d : dig)\n      digged.insert(hash(d[0], d[1]));\n\n    return ranges::count_if(\n        artifacts, [&](const auto& a) { return canExtract(a, digged); });\n  }\n\n private:\n  int hash(int i, int j) {\n    return i << 16 | j;\n  }\n\n  bool canExtract(const vector<int>& a, const unordered_set<int>& digged) {\n    for (int i = a[0]; i <= a[2]; ++i)\n      for (int j = a[1]; j <= a[3]; ++j)\n        if (!digged.contains(hash(i, j)))\n          return false;\n    return true;\n  }\n};\n", "2202": "class Solution {\n public:\n  int maximumTop(vector<int>& nums, int k) {\n    const int n = nums.size();\n    // After taking k elements, if there's something left, then return nums[k].\n    // Otherwise, return -1.\n    if (k == 0 || k == 1)\n      return n == k ? -1 : nums[k];\n    // Remove then add even number of times.\n    if (n == 1)\n      return k % 2 == 0 ? nums[0] : -1;\n    // Take min(n, k - 1) elements and put the largest one back.\n    const int mx = *max_element(nums.begin(), nums.begin() + min(n, k - 1));\n    if (k >= n)\n      return mx;\n    return max(mx, nums[k]);\n  }\n};\n", "2203": "class Solution {\n public:\n  long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2,\n                          int dest) {\n    vector<vector<pair<int, int>>> graph(n);\n    vector<vector<pair<int, int>>> reversedGraph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      reversedGraph[v].emplace_back(u, w);\n    }\n\n    const vector<long> fromSrc1 = dijkstra(graph, src1);\n    const vector<long> fromSrc2 = dijkstra(graph, src2);\n    const vector<long> fromDest = dijkstra(reversedGraph, dest);\n    long ans = kMax;\n\n    for (int i = 0; i < n; ++i) {\n      if (fromSrc1[i] == kMax || fromSrc2[i] == kMax || fromDest[i] == kMax)\n        continue;\n      ans = min(ans, fromSrc1[i] + fromSrc2[i] + fromDest[i]);\n    }\n\n    return ans == kMax ? -1 : ans;\n  }\n\n private:\n  static constexpr long kMax = 10'000'000'000;\n\n  vector<long> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n    vector<long> dist(graph.size(), kMax);\n\n    dist[src] = 0;\n    using P = pair<long, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return dist;\n  }\n};\n", "2204": "class Solution {\n public:\n  vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {\n    vector<int> ans(n);\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    // rank[i] := the minimum node that node i can reach with forward edges\n    // Initialize with NO_RANK = -2 to indicate not visited.\n    vector<int> cycle;\n    getRank(graph, 0, 0, vector<int>(n, NO_RANK), cycle);\n\n    queue<int> q;\n    vector<bool> seen(n);\n    for (const int u : cycle) {\n      q.push(u);\n      seen[u] = true;\n    }\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u]) {\n          if (seen[v])\n            continue;\n          q.push(v);\n          seen[v] = true;\n          ans[v] = step;\n        }\n      }\n\n    return ans;\n  }\n\n private:\n  static constexpr int NO_RANK = -2;\n\n  // The minRank that u can reach with forward edges\n  int getRank(const vector<vector<int>>& graph, int u, int currRank,\n              vector<int>&& rank, vector<int>& cycle) {\n    if (rank[u] != NO_RANK)  // The rank is already determined\n      return rank[u];\n\n    rank[u] = currRank;\n    int minRank = currRank;\n\n    for (const int v : graph[u]) {\n      // Visited || parent (that's why NO_RANK = -2 instead of -1)\n      if (rank[v] == rank.size() || rank[v] == currRank - 1)\n        continue;\n      const int nextRank =\n          getRank(graph, v, currRank + 1, std::move(rank), cycle);\n      // NextRank should > currRank if there's no cycle\n      if (nextRank <= currRank)\n        cycle.push_back(v);\n      minRank = min(minRank, nextRank);\n    }\n\n    rank[u] = rank.size();  // Mark as visited.\n    return minRank;\n  }\n};\n", "2206": "class Solution {\n public:\n  bool divideArray(vector<int>& nums) {\n    vector<int> count(501);\n\n    for (const int num : nums)\n      ++count[num];\n\n    return ranges::all_of(count, [](int c) { return c % 2 == 0; });\n  }\n};\n", "2207": "class Solution {\n public:\n  long long maximumSubsequenceCount(string text, string pattern) {\n    long ans = 0;\n    int count0 = 0;  // the count of the letter pattern[0]\n    int count1 = 0;  // the count of the letter pattern[1]\n\n    for (const char c : text) {\n      if (c == pattern[1]) {\n        ans += count0;\n        ++count1;\n      }\n      if (c == pattern[0])\n        ++count0;\n    }\n\n    // It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    // end of the text.\n    return ans + max(count0, count1);\n  }\n};\n", "2208": "class Solution {\n public:\n  int halveArray(vector<int>& nums) {\n    const double halfSum = accumulate(nums.begin(), nums.end(), 0.) / 2;\n    int ans = 0;\n    double runningSum = 0;\n    priority_queue<double> maxHeap{nums.begin(), nums.end()};\n\n    while (runningSum < halfSum) {\n      const double maxValue = maxHeap.top() / 2;\n      runningSum += maxValue, maxHeap.pop();\n      maxHeap.push(maxValue);\n      ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2209": "class Solution {\n public:\n  int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\n    const int n = floor.length();\n    // dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    // after covering at most j carpets\n    vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\n\n    for (int i = n - 1; i >= 0; --i)\n      dp[i][0] = floor[i] - '0' + dp[i + 1][0];\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = 1; j <= numCarpets; ++j) {\n        const int cover = i + carpetLen < n ? dp[i + carpetLen][j - 1] : 0;\n        const int skip = floor[i] - '0' + dp[i + 1][j];\n        dp[i][j] = min(cover, skip);\n      }\n\n    return dp[0][numCarpets];\n  }\n};\n", "221": "class Solution {\n public:\n  int maximalSquare(vector<vector<char>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> dp(n);\n    int maxLength = 0;\n    int prev = 0;  // dp[i - 1][j - 1]\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        const int cache = dp[j];\n        if (i == 0 || j == 0 || matrix[i][j] == '0')\n          dp[j] = matrix[i][j] == '1' ? 1 : 0;\n        else\n          dp[j] = min({prev, dp[j], dp[j - 1]}) + 1;\n        maxLength = max(maxLength, dp[j]);\n        prev = cache;\n      }\n\n    return maxLength * maxLength;\n  }\n};\n", "2210": "class Solution {\n public:\n  int countHillValley(vector<int>& nums) {\n    int ans = 0;\n    int left = nums[0];\n\n    for (int i = 1; i + 1 < nums.size(); ++i)\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // the hill\n          left > nums[i] && nums[i] < nums[i + 1]) {  // the valley\n        ++ans;\n        left = nums[i];\n      }\n\n    return ans;\n  }\n};\n", "2211": "class Solution {\n public:\n  int countCollisions(string directions) {\n    int l = 0;\n    int r = directions.length() - 1;\n\n    while (l < directions.length() && directions[l] == 'L')\n      ++l;\n\n    while (r >= 0 && directions[r] == 'R')\n      --r;\n\n    return count_if(directions.begin() + l, directions.begin() + r + 1,\n                    [](char c) { return c != 'S'; });\n  }\n};\n", "2212": "class Solution {\n public:\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\n    constexpr int kFullMask = (1 << 12) - 1;\n    int maxPoint = 0;\n    int maxMask = 0;\n\n    for (int mask = 0; mask < kFullMask; ++mask) {\n      const auto& [shotable, point] =\n          getShotableAndPoint(mask, numArrows, aliceArrows);\n      if (shotable && point > maxPoint) {\n        maxPoint = point;\n        maxMask = mask;\n      }\n    }\n\n    return getBobsArrows(maxMask, numArrows, aliceArrows);\n  }\n\n private:\n  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,\n                                      const vector<int>& aliceArrows) {\n    int point = 0;\n    for (int i = 0; i < 12; ++i)\n      if (mask >> i & 1) {\n        leftArrows -= aliceArrows[i] + 1;\n        point += i;\n      }\n    return {leftArrows >= 0, point};\n  }\n\n  vector<int> getBobsArrows(int mask, int leftArrows,\n                            const vector<int>& aliceArrows) {\n    vector<int> bobsArrows(12);\n    for (int i = 0; i < 12; ++i)\n      if (mask >> i & 1) {\n        bobsArrows[i] = aliceArrows[i] + 1;\n        leftArrows -= aliceArrows[i] + 1;\n      }\n    bobsArrows[0] = leftArrows;\n    return bobsArrows;\n  }\n};\n", "2213": "struct SegmentTreeNode {\n  int lo;\n  int hi;\n  char maxLetter;\n  char prefixLetter;\n  char suffixLetter;\n  int maxLength;\n  int prefixLength;\n  int suffixLength;\n  SegmentTreeNode* left;\n  SegmentTreeNode* right;\n  SegmentTreeNode(int lo, int hi, char maxLetter, char prefixLetter,\n                  char suffixLetter, int maxLength, int prefixLength,\n                  int suffixLength, SegmentTreeNode* left = nullptr,\n                  SegmentTreeNode* right = nullptr)\n      : lo(lo),\n        hi(hi),\n        maxLetter(maxLetter),\n        prefixLetter(prefixLetter),\n        suffixLetter(suffixLetter),\n        maxLength(maxLength),\n        prefixLength(prefixLength),\n        suffixLength(suffixLength),\n        left(left),\n        right(right) {}\n  ~SegmentTreeNode() {\n    delete left;\n    delete right;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nclass SegmentTree {\n public:\n  explicit SegmentTree(const string& s) : root(build(s, 0, s.length() - 1)) {}\n  ~SegmentTree() {\n    delete root;\n  }\n\n  void update(int i, char val) {\n    root = update(root, i, val);\n  }\n\n  int getMaxLength() {\n    return root->maxLength;\n  }\n\n private:\n  SegmentTreeNode* root;\n\n  SegmentTreeNode* build(const string& s, int lo, int hi) const {\n    if (lo == hi)\n      return new SegmentTreeNode(lo, hi, s[lo], s[lo], s[lo], 1, 1, 1);\n    const int mid = (lo + hi) / 2;\n    SegmentTreeNode* left = build(s, lo, mid);\n    SegmentTreeNode* right = build(s, mid + 1, hi);\n    return merge(left, right);\n  }\n\n  SegmentTreeNode* update(SegmentTreeNode* root, int i, char c) {\n    if (root->lo == i && root->hi == i) {\n      root->maxLetter = c;\n      root->prefixLetter = c;\n      root->suffixLetter = c;\n      return root;\n    }\n    const int mid = (root->lo + root->hi) / 2;\n    if (i <= mid) {\n      SegmentTreeNode* updatedLeft = update(root->left, i, c);\n      return root = merge(updatedLeft, root->right);\n    } else {\n      SegmentTreeNode* updatedRight = update(root->right, i, c);\n      return root = merge(root->left, updatedRight);\n    }\n  }\n\n  SegmentTreeNode* merge(SegmentTreeNode* left, SegmentTreeNode* right) const {\n    // Get `maxLetter` and `maxLength`.\n    char maxLetter = ' ';\n    int maxLength = 0;\n    if (left->maxLength > right->maxLength) {\n      maxLetter = left->maxLetter;\n      maxLength = left->maxLength;\n    } else {\n      maxLetter = right->maxLetter;\n      maxLength = right->maxLength;\n    }\n    if (left->suffixLetter == right->prefixLetter &&\n        left->suffixLength + right->prefixLength > maxLength) {\n      maxLetter = left->suffixLetter;\n      maxLength = left->suffixLength + right->prefixLength;\n    }\n\n    // Get `prefixLetter` and `prefixLength`.\n    char prefixLetter = left->prefixLetter;\n    int prefixLength = left->prefixLength;\n    if (left->lo + prefixLength == right->lo &&\n        left->prefixLetter == right->prefixLetter)\n      prefixLength += right->prefixLength;\n\n    // Get `suffixLetter` and `suffixLength`.\n    char suffixLetter = right->suffixLetter;\n    int suffixLength = right->suffixLength;\n    if (right->hi - suffixLength == left->hi &&\n        right->suffixLetter == left->suffixLetter)\n      suffixLength += left->suffixLength;\n    return new SegmentTreeNode(left->lo, right->hi, maxLetter, prefixLetter,\n                               suffixLetter, maxLength, prefixLength,\n                               suffixLength, left, right);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> longestRepeating(string s, string queryLetteracters,\n                               vector<int>& queryIndices) {\n    vector<int> ans;\n    SegmentTree tree(s);\n\n    for (int i = 0; i < queryIndices.size(); ++i) {\n      tree.update(queryIndices[i], queryLetteracters[i]);\n      ans.push_back(tree.getMaxLength());\n    }\n\n    return ans;\n  }\n};\n", "2214": "class Solution {\n public:\n  long long minimumHealth(vector<int>& damage, int armor) {\n    const long sum = accumulate(damage.begin(), damage.end(), 0L);\n    const int maxDamage = ranges::max(damage);\n    return 1 + sum - min(maxDamage, armor);\n  }\n};\n", "2215": "class Solution {\n public:\n  vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n    const unordered_set<int> set1{nums1.begin(), nums1.end()};\n    const unordered_set<int> set2{nums2.begin(), nums2.end()};\n    vector<vector<int>> ans(2);\n\n    for (const int num : set1)\n      if (!set2.contains(num))\n        ans[0].push_back(num);\n\n    for (const int num : set2)\n      if (!set1.contains(num))\n        ans[1].push_back(num);\n\n    return ans;\n  }\n};\n", "2216": "class Solution {\n public:\n  int minDeletion(vector<int>& nums) {\n    int ans = 0;\n\n    for (int i = 0; i + 1 < nums.size(); ++i)\n      // i - ans := the index after deletion\n      if (nums[i] == nums[i + 1] && (i - ans) % 2 == 0)\n        ++ans;\n\n    return ans + ((nums.size() - ans) & 1);\n  }\n};\n", "2217": "class Solution {\n public:\n  vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\n    const int start = pow(10, (intLength + 1) / 2 - 1);\n    const int end = pow(10, (intLength + 1) / 2);\n    const int mul = pow(10, intLength / 2);\n    vector<long long> ans;\n\n    for (const int query : queries)\n      if (start + query > end)\n        ans.push_back(-1);\n      else\n        ans.push_back(getKthPalindrome(query, start, mul, intLength));\n\n    return ans;\n  }\n\n private:\n  long getKthPalindrome(int query, int start, int mul, int intLength) {\n    const long prefix = start + query - 1;\n    return prefix * mul + reverse(intLength % 2 == 0 ? prefix : prefix / 10);\n  }\n\n  long reverse(int num) {\n    long res = 0;\n    while (num > 0) {\n      res = res * 10 + num % 10;\n      num /= 10;\n    }\n    return res;\n  }\n};\n", "2218": "class Solution {\n public:\n  int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n    vector<vector<int>> mem(piles.size(), vector<int>(k + 1));\n    return maxValueOfCoins(piles, 0, k, mem);\n  }\n\n private:\n  // Returns the maximum value of picking k coins from piles[i..n)\n  int maxValueOfCoins(const vector<vector<int>>& piles, int i, size_t k,\n                      vector<vector<int>>& mem) {\n    if (i == piles.size() || k == 0)\n      return 0;\n    if (mem[i][k])\n      return mem[i][k];\n\n    // Pick no coins from the current pile.\n    int res = maxValueOfCoins(piles, i + 1, k, mem);\n    int val = 0;  // the coins picked from the current pile\n\n    // Try to pick 1, 2, ..., k coins from the current pile.\n    for (int j = 0; j < min(piles[i].size(), k); ++j) {\n      val += piles[i][j];\n      res = max(res, val + maxValueOfCoins(piles, i + 1, k - j - 1, mem));\n    }\n\n    return mem[i][k] = res;\n  }\n};\n", "2219": "class Solution {\n public:\n  long long maximumSumScore(vector<int>& nums) {\n    long ans = LONG_MIN;\n    long prefix = 0;\n    long sum = accumulate(nums.begin(), nums.end(), 0L);\n\n    for (const int num : nums) {\n      prefix += num;\n      ans = max({ans, prefix, sum - prefix + num});\n    }\n\n    return ans;\n  }\n};\n", "222": "class Solution {\n public:\n  int countNodes(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n\n    TreeNode* left = root;\n    TreeNode* right = root;\n    int heightL = 0;\n    int heightR = 0;\n\n    while (left != nullptr) {\n      ++heightL;\n      left = left->left;\n    }\n\n    while (right != nullptr) {\n      ++heightR;\n      right = right->right;\n    }\n\n    if (heightL == heightR)  // `root` is a complete tree.\n      return pow(2, heightL) - 1;\n    return 1 + countNodes(root->left) + countNodes(root->right);\n  }\n};\n", "2220": "class Solution {\n public:\n  int minBitFlips(unsigned start, unsigned goal) {\n    return popcount(start ^ goal);\n  }\n};\n", "2221": "class Solution {\n public:\n  int triangularSum(vector<int>& nums) {\n    for (int sz = nums.size(); sz > 0; --sz)\n      for (int i = 0; i + 1 < sz; ++i)\n        nums[i] = (nums[i] + nums[i + 1]) % 10;\n    return nums[0];\n  }\n};\n", "2222": "class Solution {\n public:\n  long long numberOfWays(string s) {\n    long ans = 0;\n    // before[i] := the number of i before the current digit\n    vector<int> before(2);\n    // after[i] := the number of i after the current digit\n    vector<int> after(2);\n    after[0] = ranges::count(s, '0');\n    after[1] = s.length() - after[0];\n\n    for (const char c : s) {\n      const int num = c - '0';\n      --after[num];\n      if (num == 0)\n        ans += before[1] * after[1];\n      else\n        ans += before[0] * after[0];\n      ++before[num];\n    }\n\n    return ans;\n  }\n};\n", "2223": "class Solution {\n public:\n  long long sumScores(string s) {\n    const int n = s.length();\n    // https://cp-algorithms.com/string/z-function.html#implementation\n    vector<int> z(n);\n    // [l, r] := the indices of the rightmost segment match\n    int l = 0;\n    int r = 0;\n\n    for (int i = 1; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l]);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n\n    return accumulate(z.begin(), z.end(), 0L) + n;\n  }\n};\n", "2224": "class Solution {\n public:\n  int convertTime(string current, string correct) {\n    const vector<int> ops{60, 15, 5, 1};\n    int diff = getMinutes(correct) - getMinutes(current);\n    int ans = 0;\n\n    for (const int op : ops) {\n      ans += diff / op;\n      diff %= op;\n    }\n\n    return ans;\n  }\n\n private:\n  int getMinutes(const string& s) {\n    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\n  }\n};\n", "2225": "class Solution {\n public:\n  vector<vector<int>> findWinners(vector<vector<int>>& matches) {\n    vector<vector<int>> ans(2);\n    map<int, int> lossesCount;\n\n    for (const vector<int>& m : matches) {\n      const int winner = m[0];\n      const int loser = m[1];\n      if (!lossesCount.contains(winner))\n        lossesCount[winner] = 0;\n      ++lossesCount[loser];\n    }\n\n    for (const auto& [player, nLosses] : lossesCount)\n      if (nLosses < 2)\n        ans[nLosses].push_back(player);\n\n    return ans;\n  }\n};\n", "2226": "class Solution {\n public:\n  int maximumCandies(vector<int>& candies, long long k) {\n    int l = 1;\n    int r = accumulate(candies.begin(), candies.end(), 0L) / k;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numChildren(candies, m) < k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return numChildren(candies, l) >= k ? l : l - 1;\n  }\n\n private:\n  long numChildren(const vector<int>& candies, int m) {\n    return accumulate(candies.begin(), candies.end(), 0L,\n                      [&](long acc, int c) { return acc + c / m; });\n  };\n};\n", "2227": "class Encrypter {\n public:\n  Encrypter(vector<char>& keys, vector<string>& values,\n            vector<string>& dictionary) {\n    for (int i = 0; i < keys.size(); ++i)\n      keyToValue[keys[i]] = values[i];\n\n    for (const string& word : dictionary)\n      ++encryptedCount[encrypt(word)];\n  }\n\n  string encrypt(string word1) {\n    string ans;\n    for (const char c : word1)\n      ans += keyToValue[c];\n    return ans;\n  }\n\n  int decrypt(string word2) {\n    return encryptedCount[word2];\n  }\n\n private:\n  unordered_map<char, string> keyToValue;\n  unordered_map<string, int> encryptedCount;\n};\n", "2229": "class Solution {\n public:\n  bool isConsecutive(vector<int>& nums) {\n    const int n = nums.size();\n    const int mx = ranges::max(nums);\n    const int mn = ranges::min(nums);\n    return mx - mn + 1 == n &&\n           unordered_set<int>{nums.begin(), nums.end()}.size() == n;\n  }\n};\n", "223": "class Solution {\n public:\n  int computeArea(long A, long B, long C, long D,  //\n                  long E, long F, long G, long H) {\n    const long x = max(A, E) < min(C, G) ? (min(C, G) - max(A, E)) : 0;\n    const long y = max(B, F) < min(D, H) ? (min(D, H) - max(B, F)) : 0;\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y;\n  }\n};\n", "2231": "class Solution {\n public:\n  int largestInteger(int num) {\n    const string s = to_string(num);\n    int ans = 0;\n    // maxHeap[0] := the odd digits\n    // maxHeap[1] := the even digits\n    vector<priority_queue<int>> maxHeap(2);\n\n    for (const char c : s) {\n      const int digit = c - '0';\n      maxHeap[digit % 2].push(digit);\n    }\n\n    for (const char c : s) {\n      const int i = c - '0' & 1;\n      ans *= 10;\n      ans += maxHeap[i].top(), maxHeap[i].pop();\n    }\n\n    return ans;\n  }\n};\n", "2232": "class Solution {\n public:\n  string minimizeResult(string expression) {\n    const int plusIndex = expression.find('+');\n    const string left = expression.substr(0, plusIndex);\n    const string right = expression.substr(plusIndex + 1);\n    string ans;\n    int mn = INT_MAX;\n\n    // the expression -> a * (b + c) * d\n    for (int i = 0; i < left.length(); ++i)\n      for (int j = 0; j < right.length(); ++j) {\n        const int a = i == 0 ? 1 : stoi(left.substr(0, i));\n        const int b = stoi(left.substr(i));\n        const int c = stoi(right.substr(0, j + 1));\n        const int d = j == right.length() - 1 ? 1 : stoi(right.substr(j + 1));\n        const int val = a * (b + c) * d;\n        if (val < mn) {\n          mn = val;\n          ans = (i == 0 ? \"\" : to_string(a)) + '(' + to_string(b) + '+' +\n                to_string(c) + ')' +\n                (j == right.length() - 1 ? \"\" : to_string(d));\n        }\n      }\n\n    return ans;\n  }\n};\n", "2233": "class Solution {\n public:\n  int maximumProduct(vector<int>& nums, int k) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 1;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int num : nums)\n      minHeap.push(num);\n\n    for (int i = 0; i < k; ++i) {\n      const int minNum = minHeap.top();\n      minHeap.pop();\n      minHeap.push(minNum + 1);\n    }\n\n    while (!minHeap.empty()) {\n      ans *= minHeap.top(), minHeap.pop();\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "2234": "class Solution {\n public:\n  long long maximumBeauty(vector<int>& flowers, long long newFlowers,\n                          int target, int full, int partial) {\n    const int n = flowers.size();\n\n    // If a garden is already complete, clamp it to the target.\n    for (int& flower : flowers)\n      flower = min(flower, target);\n    ranges::sort(flowers);\n\n    // All gardens are complete, so nothing we can do.\n    if (flowers[0] == target)\n      return static_cast<long>(n) * full;\n\n    // Having many new flowers maximizes the beauty value.\n    if (newFlowers >= static_cast<long>(n) * target -\n                          accumulate(flowers.begin(), flowers.end(), 0L))\n      return max(static_cast<long>(n) * full,\n                 (n - 1L) * full + (target - 1L) * partial);\n\n    long ans = 0;\n    long leftFlowers = newFlowers;\n    // cost[i] := the cost to make flowers[0..i] the same\n    vector<long> cost(n);\n\n    for (int i = 1; i < n; ++i)\n      // Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] =\n          cost[i - 1] + static_cast<long>(i) * (flowers[i] - flowers[i - 1]);\n\n    int i = n - 1;  // flowers' index (flowers[i + 1..n) are complete)\n    while (flowers[i] == target)\n      --i;\n\n    for (; leftFlowers >= 0; --i) {\n      // To maximize the minimum number of incomplete flowers, we find the first\n      // index j that we can't make flowers[0..j] equal to flowers[j], then we\n      // know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      // meantime, evenly increase each of them to seek a bigger minimum value.\n      const int j = firstGreater(cost, i, leftFlowers);\n      const long minIncomplete =\n          flowers[j - 1] + (leftFlowers - cost[j - 1]) / j;\n      ans = max(ans, (n - 1L - i) * full + minIncomplete * partial);\n      leftFlowers -= max(0, target - flowers[i]);\n    }\n\n    return ans;\n  }\n\n private:\n  int firstGreater(const vector<long>& A, int maxIndex, long target) {\n    return upper_bound(A.begin(), A.begin() + maxIndex + 1, target) - A.begin();\n  }\n};\n", "2235": "class Solution {\n public:\n  int sum(int num1, int num2) {\n    return num1 + num2;\n  }\n};\n", "2236": "class Solution {\n public:\n  bool checkTree(TreeNode* root) {\n    return root->val == root->left->val + root->right->val;\n  }\n};\n", "2237": "class Solution {\n public:\n  int meetRequirement(int n, vector<vector<int>>& lights,\n                      vector<int>& requirement) {\n    int ans = 0;\n    int currBrightness = 0;\n    vector<int> change(n + 1);\n\n    for (const vector<int>& light : lights) {\n      const int position = light[0];\n      const int range = light[1];\n      ++change[max(0, position - range)];\n      --change[min(n, position + range + 1)];\n    }\n\n    for (int i = 0; i < n; ++i) {\n      currBrightness += change[i];\n      if (currBrightness >= requirement[i])\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2239": "class Solution {\n public:\n  int findClosestNumber(vector<int>& nums) {\n    return *ranges::min_element(nums, [](const int a, const int b) {\n      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);\n    });\n  }\n};\n", "224": "class Solution {\n public:\n  int calculate(string s) {\n    int ans = 0;\n    int num = 0;\n    int sign = 1;\n    stack<int> stack{{sign}};  // stack.top() := the current environment's sign\n\n    for (const char c : s)\n      if (isdigit(c))\n        num = num * 10 + (c - '0');\n      else if (c == '(')\n        stack.push(sign);\n      else if (c == ')')\n        stack.pop();\n      else if (c == '+' || c == '-') {\n        ans += sign * num;\n        sign = (c == '+' ? 1 : -1) * stack.top();\n        num = 0;\n      }\n\n    return ans + sign * num;\n  }\n};\n", "2240": "class Solution {\n public:\n  long long waysToBuyPensPencils(int total, int cost1, int cost2) {\n    long ans = 0;\n    const int maxPen = total / cost1;\n\n    for (int i = 0; i <= maxPen; ++i)\n      ans += (total - i * cost1) / cost2 + 1;\n\n    return ans;\n  }\n};\n", "2241": "class ATM {\n public:\n  ATM() : bank(5) {}\n\n  void deposit(vector<int> banknotesCount) {\n    for (int i = 0; i < 5; ++i)\n      bank[i] += banknotesCount[i];\n  }\n\n  vector<int> withdraw(int amount) {\n    vector<int> withdrew(5);\n\n    for (int i = 4; i >= 0; --i) {\n      withdrew[i] = min(bank[i], static_cast<long>(amount) / banknotes[i]);\n      amount -= withdrew[i] * banknotes[i];\n    }\n\n    if (amount > 0)\n      return {-1};\n\n    for (int i = 0; i < 5; ++i)\n      bank[i] -= withdrew[i];\n    return withdrew;\n  }\n\n private:\n  vector<int> banknotes{20, 50, 100, 200, 500};\n  vector<long> bank;\n};\n", "2242": "class Solution {\n public:\n  int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\n    int ans = -1;\n    vector<set<pair<int, int>>> graph(scores.size());  // {(score, node)}\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace(scores[v], v);\n      graph[v].emplace(scores[u], u);\n      if (graph[u].size() > 3)\n        graph[u].erase(graph[u].begin());\n      if (graph[v].size() > 3)\n        graph[v].erase(graph[v].begin());\n    }\n\n    // To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    // and find a (u's child) and b (v's child). That's why we find the 3\n    // children that have the highest scores because one of the 3 children is\n    // guaranteed to be valid.\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      for (const auto& [scoreA, a] : graph[u])\n        for (const auto& [scoreB, b] : graph[v])\n          if (a != b && a != v && b != u)\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB);\n    }\n\n    return ans;\n  }\n};\n", "2243": "class Solution {\n public:\n  string digitSum(string s, int k) {\n    while (s.length() > k) {\n      string next;\n      for (int i = 0; i < s.length(); ++i)\n        next += to_string(accumulate(\n            s.begin() + i, s.begin() + min(static_cast<int>(s.length()), i + k),\n            0, [](int acc, char c) { return acc + c - '0'; }));\n      s = std::move(next);\n    }\n    return s;\n  }\n};\n", "2244": "class Solution {\n public:\n  int minimumRounds(vector<int>& tasks) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int task : tasks)\n      ++count[task];\n\n    // freq = 1 -> it's impossible\n    // freq = 2 -> needs 1 round\n    // freq = 3 -> needs 1 round\n    // freq = 3k                           -> needs k rounds\n    // freq = 3k + 1 = 3 * (k - 1) + 2 * 2 -> needs k + 1 rounds\n    // freq = 3k + 2 = 3 * k       + 2 * 1 -> needs k + 1 rounds\n    for (const auto& [_, freq] : count)\n      if (freq == 1)\n        return -1;\n      else\n        ans += (freq + 2) / 3;\n\n    return ans;\n  }\n};\n", "2245": "class Solution {\n public:\n  int maxTrailingZeros(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    // leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    // topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    // topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    vector<vector<int>> leftPrefix2(m, vector<int>(n));\n    vector<vector<int>> leftPrefix5(m, vector<int>(n));\n    vector<vector<int>> topPrefix2(m, vector<int>(n));\n    vector<vector<int>> topPrefix5(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        leftPrefix2[i][j] = getCount(grid[i][j], 2);\n        leftPrefix5[i][j] = getCount(grid[i][j], 5);\n        if (j > 0) {\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1];\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1];\n        }\n      }\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i) {\n        topPrefix2[i][j] = getCount(grid[i][j], 2);\n        topPrefix5[i][j] = getCount(grid[i][j], 5);\n        if (i > 0) {\n          topPrefix2[i][j] += topPrefix2[i - 1][j];\n          topPrefix5[i][j] += topPrefix5[i - 1][j];\n        }\n      }\n\n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        const int curr2 = getCount(grid[i][j], 2);\n        const int curr5 = getCount(grid[i][j], 5);\n        const int l2 = leftPrefix2[i][j];\n        const int l5 = leftPrefix5[i][j];\n        const int r2 = leftPrefix2[i][n - 1] - (j ? leftPrefix2[i][j - 1] : 0);\n        const int r5 = leftPrefix5[i][n - 1] - (j ? leftPrefix5[i][j - 1] : 0);\n        const int t2 = topPrefix2[i][j];\n        const int t5 = topPrefix5[i][j];\n        const int d2 = topPrefix2[m - 1][j] - (i ? topPrefix2[i - 1][j] : 0);\n        const int d5 = topPrefix5[m - 1][j] - (i ? topPrefix5[i - 1][j] : 0);\n        ans = max({ans, min(l2 + t2 - curr2, l5 + t5 - curr5),\n                   min(r2 + t2 - curr2, r5 + t5 - curr5),\n                   min(l2 + d2 - curr2, l5 + d5 - curr5),\n                   min(r2 + d2 - curr2, r5 + d5 - curr5)});\n      }\n\n    return ans;\n  }\n\n private:\n  int getCount(int num, int factor) {\n    int count = 0;\n    while (num % factor == 0) {\n      num /= factor;\n      ++count;\n    }\n    return count;\n  }\n};\n", "2246": "class Solution {\n public:\n  int longestPath(vector<int>& parent, string s) {\n    const int n = parent.size();\n    int ans = 1;\n    vector<vector<int>> graph(n);\n\n    for (int i = 1; i < n; ++i)\n      graph[parent[i]].push_back(i);\n\n    longestPathDownFrom(graph, 0, s, ans);\n    return ans;\n  }\n\n private:\n  int longestPathDownFrom(const vector<vector<int>>& graph, int u,\n                          const string& s, int& ans) {\n    int max1 = 0;\n    int max2 = 0;\n\n    for (const int v : graph[u]) {\n      const int res = longestPathDownFrom(graph, v, s, ans);\n      if (s[u] == s[v])\n        continue;\n      if (res > max1) {\n        max2 = max1;\n        max1 = res;\n      } else if (res > max2) {\n        max2 = res;\n      }\n    }\n\n    ans = max(ans, 1 + max1 + max2);\n    return 1 + max1;\n  }\n};\n", "2247": "class Solution {\n public:\n  int maximumCost(int n, vector<vector<int>>& highways, int k) {\n    if (k + 1 > n)\n      return -1;\n\n    int ans = -1;\n    vector<vector<int>> mem(n, vector<int>(1 << n, -1));\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& h : highways) {\n      const int u = h[0];\n      const int v = h[1];\n      const int w = h[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans = max(ans, maximumCost(graph, i, 1 << i, k, mem));\n\n    return ans;\n  }\n\n private:\n  // Returns the maximum cost of trip starting from u, where `mask` is the\n  // bitmask of the visited cities.\n  int maximumCost(const vector<vector<pair<int, int>>>& graph, int u,\n                  unsigned mask, int k, vector<vector<int>>& mem) {\n    if (popcount(mask) == k + 1)\n      return 0;\n    if (mem[u][mask] != -1)\n      return mem[u][mask];\n\n    int res = -1;\n    for (const auto& [v, w] : graph[u]) {\n      if (mask >> v & 1)\n        continue;\n      const int nextCost = maximumCost(graph, v, mask | 1 << v, k, mem);\n      if (nextCost != -1)\n        res = max(res, w + nextCost);\n    }\n\n    return mem[u][mask] = res;\n  }\n};\n", "2248": "class Solution {\n public:\n  vector<int> intersection(vector<vector<int>>& nums) {\n    constexpr int kMax = 1000;\n    vector<int> ans;\n    vector<int> count(kMax + 1);\n\n    for (const vector<int>& row : nums)\n      for (const int a : row)\n        ++count[a];\n\n    for (int i = 1; i <= kMax; ++i)\n      if (count[i] == nums.size())\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "2249": "class Solution {\n public:\n  int countLatticePoints(vector<vector<int>>& circles) {\n    set<pair<int, int>> points;\n\n    // dx := relative to x\n    // dy := relative to y\n    // So, dx^2 + dy^2 = r^2.\n    for (const vector<int>& c : circles) {\n      const int x = c[0];\n      const int y = c[1];\n      const int r = c[2];\n      for (int dx = -r; dx <= r; ++dx) {\n        const int yMax = sqrt(r * r - dx * dx);\n        for (int dy = -yMax; dy <= yMax; ++dy)\n          points.emplace(x + dx, y + dy);\n      }\n    }\n\n    return points.size();\n  }\n};\n", "225": "class MyStack {\n public:\n  void push(int x) {\n    q.push(x);\n    for (int i = 0; i < q.size() - 1; ++i) {\n      q.push(q.front());\n      q.pop();\n    }\n  }\n\n  int pop() {\n    const int val = q.front();\n    q.pop();\n    return val;\n  }\n\n  int top() {\n    return q.front();\n  }\n\n  bool empty() {\n    return q.empty();\n  }\n\n private:\n  queue<int> q;\n};\n", "2250": "class Solution {\n public:\n  vector<int> countRectangles(vector<vector<int>>& rectangles,\n                              vector<vector<int>>& points) {\n    vector<int> ans;\n    vector<vector<int>> yToXs(101);\n\n    for (const vector<int>& r : rectangles)\n      yToXs[r[1]].push_back(r[0]);\n\n    for (auto& xs : yToXs)\n      ranges::sort(xs);\n\n    for (const vector<int>& p : points) {\n      int count = 0;\n      for (int y = p[1]; y < 101; ++y) {\n        const vector<int>& xs = yToXs[y];\n        count += xs.end() - ranges::lower_bound(xs, p[0]);\n      }\n      ans.push_back(count);\n    }\n\n    return ans;\n  }\n};\n", "2251": "class Solution {\n public:\n  vector<int> fullBloomFlowers(vector<vector<int>>& flowers,\n                               vector<int>& persons) {\n    vector<int> ans;\n    vector<int> starts;\n    vector<int> ends;\n\n    for (const vector<int>& flower : flowers) {\n      starts.push_back(flower[0]);\n      ends.push_back(flower[1]);\n    }\n\n    ranges::sort(starts);\n    ranges::sort(ends);\n\n    for (const int p : persons) {\n      const int started = ranges::upper_bound(starts, p) - starts.begin();\n      const int ended = ranges::lower_bound(ends, p) - ends.begin();\n      ans.push_back(started - ended);\n    }\n\n    return ans;\n  }\n};\n", "2254": "class VideoSharingPlatform {\n public:\n  int upload(string video) {\n    const int videoId = getVideoId();\n    videoIdToVideo[videoId] = video;\n    return videoId;\n  }\n\n  void remove(int videoId) {\n    if (videoIdToVideo.contains(videoId)) {\n      usedIds.push(videoId);\n      videoIdToVideo.erase(videoId);\n      videoIdToViews.erase(videoId);\n      videoIdToLikes.erase(videoId);\n      videoIdToDislikes.erase(videoId);\n    }\n  }\n\n  string watch(int videoId, int startMinute, int endMinute) {\n    const auto it = videoIdToVideo.find(videoId);\n    if (it == videoIdToVideo.cend())\n      return \"-1\";\n    ++videoIdToViews[videoId];\n    const string video = it->second;\n    const int duration =\n        min(endMinute, static_cast<int>(video.length()) - 1) - startMinute + 1;\n    return video.substr(startMinute, duration);\n  }\n\n  void like(int videoId) {\n    if (videoIdToVideo.contains(videoId))\n      ++videoIdToLikes[videoId];\n  }\n\n  void dislike(int videoId) {\n    if (videoIdToVideo.contains(videoId))\n      ++videoIdToDislikes[videoId];\n  }\n\n  vector<int> getLikesAndDislikes(int videoId) {\n    return videoIdToVideo.contains(videoId)\n               ? vector<int>{videoIdToLikes[videoId],\n                             videoIdToDislikes[videoId]}\n               : vector<int>{-1};\n  }\n\n  int getViews(int videoId) {\n    return videoIdToVideo.contains(videoId) ? videoIdToViews[videoId] : -1;\n  }\n\n private:\n  int currVideoId = 0;\n  priority_queue<int, vector<int>, greater<>> usedIds;\n  unordered_map<int, string> videoIdToVideo;\n  unordered_map<int, int> videoIdToViews;\n  unordered_map<int, int> videoIdToLikes;\n  unordered_map<int, int> videoIdToDislikes;\n\n  int getVideoId() {\n    if (usedIds.empty())\n      return currVideoId++;\n    const int minUsedId = usedIds.top();\n    usedIds.pop();\n    return minUsedId;\n  }\n};\n", "2255": "class Solution {\n public:\n  int countPrefixes(vector<string>& words, string s) {\n    return ranges::count_if(\n        words, [&](const string& word) { return s.find(word) == 0; });\n  }\n};\n", "2256": "class Solution {\n public:\n  int minimumAverageDifference(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    int minDiff = INT_MAX;\n    long prefix = 0;\n    long suffix = accumulate(nums.begin(), nums.end(), 0L);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      suffix -= nums[i];\n      const int prefixAvg = prefix / (i + 1);\n      const int suffixAvg = (i == n - 1) ? 0 : suffix / (n - 1 - i);\n      const int diff = abs(prefixAvg - suffixAvg);\n      if (diff < minDiff) {\n        ans = i;\n        minDiff = diff;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2257": "class Solution {\n public:\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\n                     vector<vector<int>>& walls) {\n    int ans = 0;\n    vector<vector<char>> grid(m, vector<char>(n));\n    vector<vector<char>> left(m, vector<char>(n));\n    vector<vector<char>> right(m, vector<char>(n));\n    vector<vector<char>> up(m, vector<char>(n));\n    vector<vector<char>> down(m, vector<char>(n));\n\n    for (const vector<int>& guard : guards)\n      grid[guard[0]][guard[1]] = 'G';\n\n    for (const vector<int>& wall : walls)\n      grid[wall[0]][wall[1]] = 'W';\n\n    for (int i = 0; i < m; ++i) {\n      char lastCell = 0;\n      for (int j = 0; j < n; ++j)\n        recordOrFill(grid[i][j], lastCell, left[i][j]);\n      lastCell = 0;\n      for (int j = n - 1; j >= 0; --j)\n        recordOrFill(grid[i][j], lastCell, right[i][j]);\n    }\n\n    for (int j = 0; j < n; ++j) {\n      char lastCell = 0;\n      for (int i = 0; i < m; ++i)\n        recordOrFill(grid[i][j], lastCell, up[i][j]);\n      lastCell = 0;\n      for (int i = m - 1; i >= 0; --i)\n        recordOrFill(grid[i][j], lastCell, down[i][j]);\n    }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 0 && left[i][j] != 'G' && right[i][j] != 'G' &&\n            up[i][j] != 'G' && down[i][j] != 'G')\n          ++ans;\n\n    return ans;\n  }\n\n private:\n  void recordOrFill(char currCell, char& lastCell, char& infoCell) {\n    if (currCell == 'G' || currCell == 'W')\n      lastCell = currCell;\n    else\n      infoCell = lastCell;\n  }\n};\n", "2258": "class Solution {\n public:\n  int maximumMinutes(vector<vector<int>>& grid) {\n    const int kMax = grid.size() * grid[0].size();\n    vector<vector<int>> fireMinute(grid.size(),\n                                   vector<int>(grid[0].size(), -1));\n    buildFireGrid(grid, fireMinute);\n\n    int ans = -1;\n    int l = 0;\n    int r = kMax;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (canStayFor(grid, fireMinute, m)) {\n        ans = m;\n        l = m + 1;\n      } else {\n        r = m - 1;\n      }\n    }\n\n    return ans == kMax ? 1'000'000'000 : ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  void buildFireGrid(const vector<vector<int>>& grid,\n                     vector<vector<int>>& fireMinute) {\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == 1) {  // the fire\n          q.emplace(i, j);\n          fireMinute[i][j] = 0;\n        }\n\n    for (int minuteFromFire = 1; !q.empty(); ++minuteFromFire)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())\n            continue;\n          if (grid[x][y] == 2)  // the wall\n            continue;\n          if (fireMinute[x][y] != -1)\n            continue;\n          fireMinute[x][y] = minuteFromFire;\n          q.emplace(x, y);\n        }\n      }\n  }\n\n  bool canStayFor(const vector<vector<int>>& grid,\n                  const vector<vector<int>>& fireMinute, int minute) {\n    queue<pair<int, int>> q{{{0, 0}}};  // the start position\n    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));\n    seen[0][0] = true;\n\n    while (!q.empty()) {\n      ++minute;\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())\n            continue;\n          if (grid[x][y] == 2)  // the wall\n            continue;\n          if (x == grid.size() - 1 && y == grid[0].size() - 1) {\n            if (fireMinute[x][y] != -1 && fireMinute[x][y] < minute)\n              continue;\n            return true;\n          }\n          if (fireMinute[x][y] != -1 && fireMinute[x][y] <= minute)\n            continue;\n          if (seen[x][y])\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n    }\n\n    return false;\n  }\n};\n", "2259": "class Solution {\n public:\n  string removeDigit(string number, char digit) {\n    for (int i = 0; i + 1 < number.length(); ++i)\n      if (number[i] == digit && digit < number[i + 1])\n        return number.erase(i, 1);\n    return number.erase(number.rfind(digit), 1);\n  }\n};\n", "226": "class Solution {\n public:\n  TreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    TreeNode* const left = root->left;\n    TreeNode* const right = root->right;\n    root->left = invertTree(right);\n    root->right = invertTree(left);\n    return root;\n  }\n};\n", "2260": "class Solution {\n public:\n  int minimumCardPickup(vector<int>& cards) {\n    int ans = INT_MAX;\n    unordered_map<int, int> lastSeen;\n\n    for (int i = 0; i < cards.size(); ++i) {\n      if (const auto it = lastSeen.find(cards[i]); it != lastSeen.cend())\n        ans = min(ans, i - it->second + 1);\n      lastSeen[cards[i]] = i;\n    }\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "2261": "struct TrieNode {\n  unordered_map<int, shared_ptr<TrieNode>> children;\n  int count = 0;\n};\n\nclass Solution {\n public:\n  int countDistinct(vector<int>& nums, int k, int p) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++i)\n      insert(root, nums, i, k, p, ans);\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(shared_ptr<TrieNode> node, const vector<int>& nums, int i, int k,\n              int p, int& ans) {\n    if (i == nums.size() || k - (nums[i] % p == 0) < 0)\n      return;\n    if (!node->children.contains(nums[i])) {\n      node->children[nums[i]] = make_shared<TrieNode>();\n      ++ans;\n    }\n    insert(node->children[nums[i]], nums, i + 1, k - (nums[i] % p == 0), p,\n           ans);\n  }\n};\n", "2262": "class Solution {\n public:\n  long long appealSum(string s) {\n    const int n = s.length();\n    long ans = 0;\n    vector<int> lastSeen(26, -1);\n\n    for (int i = 0; i < n; ++i) {\n      const int c = s[i] - 'a';\n      ans += (i - lastSeen[c]) * (n - i);\n      lastSeen[c] = i;\n    }\n\n    return ans;\n  }\n};\n", "2263": "class Solution {\n public:\n  int convertArray(vector<int>& nums) {\n    return min(cost(nums), cost(negative(nums)));\n  }\n\n private:\n  int cost(const vector<int>& nums) {\n    int ans = 0;\n    priority_queue<int> maxHeap;\n\n    // Greedily make `nums` non-decreasing.\n    for (const int num : nums) {\n      if (!maxHeap.empty() && maxHeap.top() > num) {\n        ans += maxHeap.top() - num, maxHeap.pop();\n        maxHeap.push(num);\n      }\n      maxHeap.push(num);\n    }\n\n    return ans;\n  }\n\n  vector<int> negative(const vector<int>& nums) {\n    vector<int> arr(nums);\n    for (int& a : arr)\n      a *= -1;\n    return arr;\n  }\n};\n", "2264": "class Solution {\n public:\n  string largestGoodInteger(string num) {\n    string ans;\n\n    for (int i = 2; i < num.length(); ++i)\n      if (num[i - 2] == num[i - 1] && num[i - 1] == num[i])\n        ans = max(ans, num.substr(i - 2, 3));\n\n    return ans;\n  }\n};\n", "2265": "class Solution {\n public:\n  int averageOfSubtree(TreeNode* root) {\n    int ans = 0;\n    dfs(root, ans);\n    return ans;\n  }\n\n private:\n  pair<int, int> dfs(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return {0, 0};\n    const auto [leftSum, leftCount] = dfs(root->left, ans);\n    const auto [rightSum, rightCount] = dfs(root->right, ans);\n    const int sum = root->val + leftSum + rightSum;\n    const int count = 1 + leftCount + rightCount;\n    if (sum / count == root->val)\n      ++ans;\n    return {sum, count};\n  }\n};\n", "2266": "class Solution {\n public:\n  int countTexts(string pressedKeys) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = pressedKeys.length();\n    // dp[i] := the number of possible text messages of pressedKeys[i..n)\n    vector<long> dp(n + 1);\n    dp[n] = 1;  // \"\"\n\n    for (int i = n - 1; i >= 0; --i) {\n      dp[i] = dp[i + 1];\n      if (isSame(pressedKeys, i, 2))\n        dp[i] += dp[i + 2];\n      if (isSame(pressedKeys, i, 3))\n        dp[i] += dp[i + 3];\n      if ((pressedKeys[i] == '7' || pressedKeys[i] == '9') &&\n          isSame(pressedKeys, i, 4))\n        dp[i] += dp[i + 4];\n      dp[i] %= kMod;\n    }\n\n    return dp[0];\n  }\n\n private:\n  // Returns true if s[i..i + k) are the same digits.\n  bool isSame(const string& s, int i, int k) {\n    if (i + k > s.length())\n      return false;\n    for (int j = i + 1; j < i + k; ++j)\n      if (s[j] != s[i])\n        return false;\n    return true;\n  }\n};\n", "2267": "class Solution {\n public:\n  bool hasValidPath(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<vector<int>>> mem(\n        m, vector<vector<int>>(n, vector<int>(m + n, -1)));\n    return hasValidPath(grid, 0, 0, 0, mem);\n  }\n\n private:\n  // Returns true if there's a path from grid[i][j] to grid[m - 1][n - 1], where\n  // the number of '(' - the number of ')' == k.\n  bool hasValidPath(const vector<vector<char>>& grid, int i, int j, int k,\n                    vector<vector<vector<int>>>& mem) {\n    if (i == grid.size() || j == grid[0].size())\n      return false;\n    k += grid[i][j] == '(' ? 1 : -1;\n    if (k < 0)\n      return false;\n    if (i == grid.size() - 1 && j == grid[0].size() - 1)\n      return k == 0;\n    if (mem[i][j][k] != -1)\n      return mem[i][j][k];\n    return mem[i][j][k] = hasValidPath(grid, i + 1, j, k, mem) |\n                          hasValidPath(grid, i, j + 1, k, mem);\n  }\n};\n", "2268": "class Solution {\n public:\n  int minimumKeypresses(string s) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    ranges::sort(count, greater<>());\n\n    for (int i = 0; i < 26; ++i)\n      ans += count[i] * (i / 9 + 1);\n\n    return ans;\n  }\n};\n", "2269": "class Solution {\n public:\n  int divisorSubstrings(int num, int k) {\n    const string s = to_string(num);\n    int ans = 0;\n\n    for (int i = 0; i + k <= s.length(); ++i) {\n      const int x = stoi(s.substr(i, k));\n      if (x != 0 && num % x == 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "227": "class Solution {\n public:\n  int calculate(string s) {\n    int ans = 0;\n    int prevNum = 0;\n    int currNum = 0;\n    char op = '+';\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (isdigit(c))\n        currNum = currNum * 10 + (c - '0');\n      if (!isdigit(c) && !isspace(c) || i == s.length() - 1) {\n        if (op == '+' || op == '-') {\n          ans += prevNum;\n          prevNum = op == '+' ? currNum : -currNum;\n        } else if (op == '*') {\n          prevNum *= currNum;\n        } else if (op == '/') {\n          prevNum /= currNum;\n        }\n        op = c;\n        currNum = 0;\n      }\n    }\n\n    return ans + prevNum;\n  }\n};\n", "2270": "class Solution {\n public:\n  int waysToSplitArray(vector<int>& nums) {\n    int ans = 0;\n    long prefix = 0;\n    long suffix = accumulate(nums.begin(), nums.end(), 0L);\n\n    for (int i = 0; i < nums.size() - 1; ++i) {\n      prefix += nums[i];\n      suffix -= nums[i];\n      if (prefix >= suffix)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2271": "class Solution {\n public:\n  int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\n    if (ranges::any_of(tiles, [&](const auto& tile) {\n      return tile[1] - tile[0] + 1 >= carpetLen;\n    }))\n      return carpetLen;\n\n    int ans = 0;\n    vector<int> starts;\n    vector<int> prefix(tiles.size() + 1);\n\n    ranges::sort(tiles);\n\n    for (const vector<int>& tile : tiles)\n      starts.push_back(tile[0]);\n\n    for (int i = 0; i < tiles.size(); ++i) {\n      const int length = tiles[i][1] - tiles[i][0] + 1;\n      prefix[i + 1] = prefix[i] + length;\n    }\n\n    for (int i = 0; i < tiles.size(); ++i) {\n      const int s = tiles[i][0];\n      const int carpetEnd = s + carpetLen - 1;\n      const int endIndex =\n          ranges::upper_bound(starts, carpetEnd) - starts.begin() - 1;\n      const int notCover = max(0, tiles[endIndex][1] - carpetEnd);\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover);\n    }\n\n    return ans;\n  }\n};\n", "2272": "class Solution {\n public:\n  int largestVariance(string s) {\n    int ans = 0;\n\n    for (char a = 'a'; a <= 'z'; ++a)\n      for (char b = 'a'; b <= 'z'; ++b)\n        if (a != b)\n          ans = max(ans, kadane(s, a, b));\n\n    return ans;\n  }\n\n private:\n  // a := the letter with the higher frequency\n  // b := the letter with the lower frequency\n  int kadane(const string& s, char a, char b) {\n    int ans = 0;\n    int countA = 0;\n    int countB = 0;\n    bool canExtendPrevB = false;\n\n    for (const char c : s) {\n      if (c != a && c != b)\n        continue;\n      if (c == a)\n        ++countA;\n      else\n        ++countB;\n      if (countB > 0) {\n        // An interval should contain at least one b.\n        ans = max(ans, countA - countB);\n      } else if (countB == 0 && canExtendPrevB) {\n        // edge case: consider the previous b.\n        ans = max(ans, countA - 1);\n      }\n      // Reset if the number of b > the number of a.\n      if (countB > countA) {\n        countA = 0;\n        countB = 0;\n        canExtendPrevB = true;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2273": "class Solution {\n public:\n  vector<string> removeAnagrams(vector<string>& words) {\n    vector<string> ans;\n\n    for (int i = 0; i < words.size();) {\n      int j = i + 1;\n      while (j < words.size() && isAnagram(words[i], words[j]))\n        ++j;\n      ans.push_back(words[i]);\n      i = j;\n    }\n\n    return ans;\n  }\n\n private:\n  bool isAnagram(const string& a, const string& b) {\n    if (a.length() != b.length())\n      return false;\n\n    vector<int> count(26);\n\n    for (const char c : a)\n      ++count[c - 'a'];\n\n    for (const char c : b)\n      --count[c - 'a'];\n\n    return ranges::all_of(count, [](const int c) { return c == 0; });\n  }\n};\n", "2274": "class Solution {\n public:\n  int maxConsecutive(int bottom, int top, vector<int>& special) {\n    int ans = 0;\n\n    ranges::sort(special);\n\n    for (int i = 1; i < special.size(); ++i)\n      ans = max(ans, special[i] - special[i - 1] - 1);\n\n    return max({ans, special.front() - bottom, top - special.back()});\n  }\n};\n", "2275": "class Solution {\n public:\n  int largestCombination(vector<int>& candidates) {\n    constexpr int kMaxBit = 24;\n    int ans = 0;\n\n    for (int i = 0; i < kMaxBit; ++i) {\n      int count = 0;\n      for (const int candidate : candidates)\n        if (candidate >> i & 1)\n          ++count;\n      ans = max(ans, count);\n    }\n\n    return ans;\n  }\n};\n", "2276": "class CountIntervals {\n public:\n  void add(int left, int right) {\n    while (isOverlapped(left, right)) {\n      auto it = prev(intervals.upper_bound(right));\n      const int l = it->first;\n      const int r = it->second;\n      left = min(left, l);\n      right = max(right, r);\n      intervals.erase(l);\n      cnt -= r - l + 1;\n    }\n\n    intervals[left] = right;\n    cnt += right - left + 1;\n  }\n\n  int count() {\n    return cnt;\n  }\n\n private:\n  map<int, int> intervals;\n  int cnt = 0;\n\n  bool isOverlapped(int left, int right) {\n    auto it = intervals.upper_bound(right);\n    return it != intervals.begin() && prev(it)->second >= left;\n  }\n};\n", "2277": "class Solution {\n public:\n  vector<int> closestNode(int n, vector<vector<int>>& edges,\n                          vector<vector<int>>& query) {\n    vector<int> ans;\n    vector<vector<int>> tree(n);\n    vector<vector<int>> dist(n, vector<int>(n, -1));\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i)\n      fillDist(tree, i, i, 0, dist);\n\n    for (const vector<int>& query : queries) {\n      const int start = query[0];\n      const int end = query[1];\n      const int node = query[2];\n      ans.push_back(findClosest(tree, dist, start, end, node, start));\n    }\n\n    return ans;\n  }\n\n private:\n  void fillDist(const vector<vector<int>>& tree, int start, int u, int d,\n                vector<vector<int>>& dist) {\n    dist[start][u] = d;\n    for (const int v : tree[u])\n      if (dist[start][v] == -1)\n        fillDist(tree, start, v, d + 1, dist);\n  }\n\n  int findClosest(const vector<vector<int>>& tree,\n                  const vector<vector<int>>& dist, int u, int end, int node,\n                  int ans) {\n    for (const int v : tree[u])\n      if (dist[v][end] < dist[u][end])\n        return findClosest(tree, dist, v, end, node,\n                           dist[ans][node] < dist[v][node] ? ans : v);\n    return ans;\n  }\n};\n", "2278": "class Solution {\n public:\n  int percentageLetter(string s, char letter) {\n    return 100 * ranges::count(s, letter) / s.length();\n  }\n};\n", "2279": "class Solution {\n public:\n  int maximumBags(vector<int>& capacity, vector<int>& rocks,\n                  int additionalRocks) {\n    const int n = capacity.size();\n    vector<int> diff(n);\n\n    for (int i = 0; i < n; ++i)\n      diff[i] = capacity[i] - rocks[i];\n\n    ranges::sort(diff);\n\n    for (int i = 0; i < n; ++i) {\n      if (diff[i] > additionalRocks)\n        return i;\n      additionalRocks -= diff[i];\n    }\n\n    return n;\n  }\n};\n", "228": "class Solution {\n public:\n  vector<string> summaryRanges(vector<int>& nums) {\n    vector<string> ans;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int begin = nums[i];\n      while (i + 1 < nums.size() && nums[i] == nums[i + 1] - 1)\n        ++i;\n      const int end = nums[i];\n      if (begin == end)\n        ans.push_back(to_string(begin));\n      else\n        ans.push_back(to_string(begin) + \"->\" + to_string(end));\n    }\n\n    return ans;\n  }\n};\n", "2280": "class Solution {\n public:\n  int minimumLines(vector<vector<int>>& stockPrices) {\n    int ans = 0;\n\n    ranges::sort(stockPrices);\n\n    for (int i = 2; i < stockPrices.size(); ++i) {\n      const pair<int, int> a = getSlope(stockPrices[i - 2], stockPrices[i - 1]);\n      const pair<int, int> b = getSlope(stockPrices[i - 1], stockPrices[i]);\n      if (a != b)\n        ++ans;\n    }\n\n    return ans + (stockPrices.size() > 1);\n  }\n\n private:\n  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {\n    const int dx = p[0] - q[0];\n    const int dy = p[1] - q[1];\n    if (dx == 0)\n      return {0, p[0]};\n    if (dy == 0)\n      return {p[1], 0};\n    const int d = __gcd(dx, dy);\n    return {dx / d, dy / d};\n  }\n};\n", "2281": "class Solution {\n public:\n  int totalStrength(vector<int>& strength) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = strength.size();\n    vector<long> prefix(n);\n    vector<long> prefixOfPrefix(n + 1);\n    // left[i] := the next index on the left (if any) s.t.\n    // nums[left[i]] <= nums[i]\n    vector<int> left(n, -1);\n    // right[i] := the next index on the right (if any) s.t.\n    // nums[right[i]] < nums[i]\n    vector<int> right(n, n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i)\n      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;\n\n    for (int i = 0; i < n; ++i)\n      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;\n\n    for (int i = n - 1; i >= 0; --i) {\n      while (!stack.empty() && strength[stack.top()] >= strength[i])\n        left[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    stack = std::stack<int>();\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && strength[stack.top()] > strength[i])\n        right[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    long ans = 0;\n\n    // For each strength[i] as minimum, calculate sum.\n    for (int i = 0; i < n; ++i) {\n      const int l = left[i];\n      const int r = right[i];\n      const long leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)];\n      const long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];\n      const int leftLen = i - l;\n      const int rightLen = r - i;\n      ans += strength[i] *\n             (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) %\n             kMod;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "2282": "class Solution {\n public:\n  vector<vector<int>> seePeople(vector<vector<int>>& heights) {\n    const int m = heights.size();\n    const int n = heights[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i) {\n      stack<int> stack;\n      for (int j = 0; j < n; ++j) {\n        bool hasEqualHeight = false;\n        while (!stack.empty() && heights[i][stack.top()] <= heights[i][j]) {\n          if (heights[i][stack.top()] == heights[i][j])\n            // edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = true;\n          ++ans[i][stack.top()], stack.pop();\n        }\n        if (!stack.empty() && !hasEqualHeight)\n          ++ans[i][stack.top()];\n        stack.push(j);\n      }\n    }\n\n    for (int j = 0; j < n; ++j) {\n      stack<int> stack;\n      for (int i = 0; i < m; ++i) {\n        bool hasEqualHeight = false;\n        while (!stack.empty() && heights[stack.top()][j] <= heights[i][j]) {\n          if (heights[stack.top()][j] == heights[i][j])\n            hasEqualHeight = true;\n          ++ans[stack.top()][j], stack.pop();\n        }\n        if (!stack.empty() && !hasEqualHeight)\n          ++ans[stack.top()][j];\n        stack.push(i);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2283": "class Solution {\n public:\n  bool digitCount(string num) {\n    vector<int> count(10);\n\n    for (const char c : num)\n      ++count[c - '0'];\n\n    for (int i = 0; i < num.length(); ++i)\n      if (count[i] != num[i] - '0')\n        return false;\n\n    return true;\n  }\n};\n", "2284": "class Solution {\n public:\n  string largestWordCount(vector<string>& messages, vector<string>& senders) {\n    const int n = messages.size();\n    string ans;\n    int maxWordsSent = 0;\n    unordered_map<string, int> count;  // {sender, the number of words sent}\n\n    for (int i = 0; i < n; ++i) {\n      const string& message = messages[i];\n      const string& sender = senders[i];\n      const int wordsCount = ranges::count(message, ' ') + 1;\n      count[sender] += wordsCount;\n      const int numWordsSent = count[sender];\n      if (numWordsSent > maxWordsSent) {\n        ans = sender;\n        maxWordsSent = numWordsSent;\n      } else if (numWordsSent == maxWordsSent && sender > ans) {\n        ans = sender;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2285": "class Solution {\n public:\n  long long maximumImportance(int n, vector<vector<int>>& roads) {\n    long ans = 0;\n    vector<long> count(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      ++count[u];\n      ++count[v];\n    }\n\n    ranges::sort(count);\n\n    for (int i = 0; i < n; ++i)\n      ans += (i + 1) * count[i];\n\n    return ans;\n  }\n};\n", "2286": "struct SegmentTreeNode {\n  int lo;\n  int hi;\n  std::unique_ptr<SegmentTreeNode> left;\n  std::unique_ptr<SegmentTreeNode> right;\n  int mx;\n  long sum;\n  SegmentTreeNode(int lo, int hi, std::unique_ptr<SegmentTreeNode>&& left,\n                  std::unique_ptr<SegmentTreeNode>&& right, int mx, long sum)\n      : lo(lo),\n        hi(hi),\n        left(std::move(left)),\n        right(std::move(right)),\n        mx(mx),\n        sum(sum) {}\n};\n\nclass SegmentTree {\n public:\n  explicit SegmentTree(int n, int m) : m(m), root(std::move(build(0, n - 1))) {}\n\n  vector<int> maxRange(int k, int maxRow) {\n    return maxRange(root, k, maxRow);\n  }\n\n  long sumRange(int maxRow) {\n    return sumRange(root, 0, maxRow);\n  }\n\n  // Substracts k from the seats row.\n  void substract(int row, int k) {\n    substract(root, row, k);\n  }\n\n private:\n  const int m;\n  std::unique_ptr<SegmentTreeNode> root;\n\n  std::unique_ptr<SegmentTreeNode> build(int l, int r) {\n    if (l == r)\n      return make_unique<SegmentTreeNode>(l, r, nullptr, nullptr, m, m);\n    const int mid = (l + r) / 2;\n    std::unique_ptr<SegmentTreeNode> left = build(l, mid);\n    std::unique_ptr<SegmentTreeNode> right = build(mid + 1, r);\n    return make_unique<SegmentTreeNode>(l, r, std::move(left), std::move(right),\n                                        max(left->mx, right->mx),\n                                        left->sum + right->sum);\n  }\n\n  vector<int> maxRange(std::unique_ptr<SegmentTreeNode>& root, int k,\n                       int maxRow) {\n    if (root->lo == root->hi) {\n      if (root->sum < k || root->lo > maxRow)\n        return {};\n      return {root->lo, m - static_cast<int>(root->sum)};  // {row, col}\n    }\n    // Greedily search the left subtree\n    if (root->left->mx >= k)\n      return maxRange(root->left, k, maxRow);\n    return maxRange(root->right, k, maxRow);\n  }\n\n  long sumRange(std::unique_ptr<SegmentTreeNode>& root, int i, int j) {\n    if (root->lo == i && root->hi == j)\n      return root->sum;\n    const int mid = (root->lo + root->hi) / 2;\n    if (j <= mid)\n      return sumRange(root->left, i, j);\n    if (i > mid)\n      return sumRange(root->right, i, j);\n    return sumRange(root->left, i, mid) + sumRange(root->right, mid + 1, j);\n  }\n\n  void substract(std::unique_ptr<SegmentTreeNode>& root, int row, int k) {\n    if (root == nullptr)\n      return;\n    if (root->lo == root->hi && root->hi == row) {\n      root->mx -= k;\n      root->sum -= k;\n      return;\n    }\n    const int mid = (root->lo + root->hi) / 2;\n    if (row <= mid)\n      substract(root->left, row, k);\n    else\n      substract(root->right, row, k);\n    root->mx = max(root->left->mx, root->right->mx);\n    root->sum = root->left->sum + root->right->sum;\n  }\n};\n\nclass BookMyShow {\n public:\n  BookMyShow(int n, int m) : tree(n, m), seats(n, m) {}\n\n  vector<int> gather(int k, int maxRow) {\n    const vector<int> res = tree.maxRange(k, maxRow);\n    if (res.size() == 2) {\n      const int row = res[0];\n      tree.substract(row, k);\n      seats[row] -= k;\n    }\n    return res;\n  }\n\n  bool scatter(int k, int maxRow) {\n    if (tree.sumRange(maxRow) < k)\n      return false;\n\n    while (k > 0)\n      if (seats[minVacantRow] >= k) {\n        tree.substract(minVacantRow, k);\n        seats[minVacantRow] -= k;\n        k = 0;\n      } else {\n        tree.substract(minVacantRow, seats[minVacantRow]);\n        k -= seats[minVacantRow];\n        seats[minVacantRow] = 0;\n        ++minVacantRow;\n      }\n\n    return true;\n  }\n\n private:\n  SegmentTree tree;\n  vector<int> seats;  // the remaining seats at each row\n  int minVacantRow = 0;\n};\n", "2287": "class Solution {\n public:\n  int rearrangeCharacters(string s, string target) {\n    int ans = s.length();\n    vector<int> countS(128);\n    vector<int> countT(128);\n\n    for (const char c : s)\n      ++countS[c];\n\n    for (const char c : target)\n      ++countT[c];\n\n    for (const char c : target)\n      ans = min(ans, countS[c] / countT[c]);\n\n    return ans;\n  }\n};\n", "2288": "class Solution {\n public:\n  string discountPrices(string sentence, int discount) {\n    constexpr int kPrecision = 2;\n    string ans;\n    istringstream iss(sentence);\n\n    for (string word; iss >> word;)\n      if (word[0] == '$' && word.length() > 1) {\n        const string digits = word.substr(1);\n        if (ranges::all_of(digits,\n                           [](const char digit) { return isdigit(digit); })) {\n          const double val = stold(digits) * (100 - discount) / 100;\n          const string s = to_string(val);\n          const string trimmed = s.substr(0, s.find(\".\") + kPrecision + 1);\n          ans += \"$\" + trimmed + \" \";\n        } else {\n          ans += word + \" \";\n        }\n      } else {\n        ans += word + \" \";\n      }\n\n    ans.pop_back();\n    return ans;\n  }\n};\n", "2289": "class Solution {\n public:\n  int totalSteps(vector<int>& nums) {\n    // dp[i] := the number of steps to remove nums[i]\n    vector<int> dp(nums.size());\n    stack<int> stack;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      int step = 1;\n      while (!stack.empty() && nums[stack.top()] <= nums[i])\n        step = max(step, dp[stack.top()] + 1), stack.pop();\n      if (!stack.empty())\n        dp[i] = step;\n      stack.push(i);\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "229": "class Solution {\n public:\n  vector<int> majorityElement(vector<int>& nums) {\n    vector<int> ans;\n    int candidate1 = 0;\n    int candidate2 = 1;   // any number different from candidate1\n    int countSoFar1 = 0;  // the number of candidate1 so far\n    int countSoFar2 = 0;  // the number of candidate2 so far\n\n    for (const int num : nums)\n      if (num == candidate1) {\n        ++countSoFar1;\n      } else if (num == candidate2) {\n        ++countSoFar2;\n      } else if (countSoFar1 == 0) {  // Assign the new candidate.\n        candidate1 = num;\n        ++countSoFar1;\n      } else if (countSoFar2 == 0) {  // Assign the new candidate.\n        candidate2 = num;\n        ++countSoFar2;\n      } else {  // Meet a new number, so pair with the previous counts.\n        --countSoFar1;\n        --countSoFar2;\n      }\n\n    const int count1 = ranges::count(nums, candidate1);\n    const int count2 = ranges::count(nums, candidate2);\n\n    if (count1 > nums.size() / 3)\n      ans.push_back(candidate1);\n    if (count2 > nums.size() / 3)\n      ans.push_back(candidate2);\n    return ans;\n  }\n};\n", "2290": "class Solution {\n public:\n  int minimumObstacles(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    using T = tuple<int, int, int>;  // (d, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n\n    minHeap.emplace(grid[0][0], 0, 0);\n    dist[0][0] = grid[0][0];\n\n    while (!minHeap.empty()) {\n      const auto [d, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return d;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int newDist = d + grid[i][j];\n        if (newDist < dist[x][y]) {\n          dist[x][y] = newDist;\n          minHeap.emplace(newDist, x, y);\n        }\n      }\n    }\n\n    return dist[m - 1][n - 1];\n  }\n};\n", "2291": "class Solution {\n public:\n  int maximumProfit(vector<int>& present, vector<int>& future, int budget) {\n    const int n = present.size();\n    // dp[i] := the maximum profit of buying present so far with i budget\n    vector<int> dp(budget + 1);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = budget; j >= present[i]; --j)\n        dp[j] = max(dp[j], future[i] - present[i] + dp[j - present[i]]);\n\n    return dp[budget];\n  }\n};\n", "2293": "class Solution {\n public:\n  int minMaxGame(vector<int>& nums) {\n    if (nums.size() == 1)\n      return nums[0];\n\n    vector<int> nextNums;\n    for (int i = 0; i < nums.size() / 2; ++i)\n      nextNums.push_back(i % 2 == 0 ? min(nums[2 * i], nums[2 * i + 1])\n                                    : max(nums[2 * i], nums[2 * i + 1]));\n    return minMaxGame(nextNums);\n  }\n};\n", "2294": "class Solution {\n public:\n  int partitionArray(vector<int>& nums, int k) {\n    ranges::sort(nums);\n\n    int ans = 1;\n    int mn = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (mn + k < nums[i]) {\n        ++ans;\n        mn = nums[i];\n      }\n\n    return ans;\n  }\n};\n", "2295": "class Solution {\n public:\n  vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < nums.size(); ++i)\n      numToIndex[nums[i]] = i;\n\n    for (const vector<int>& o : operations) {\n      const int original = o[0];\n      const int replaced = o[1];\n      const int index = numToIndex[original];\n      nums[index] = replaced;\n      numToIndex.erase(original);\n      numToIndex[replaced] = index;\n    }\n\n    return nums;\n  }\n};\n", "2296": "class TextEditor {\n public:\n  void addText(string text) {\n    s += text;\n  }\n\n  int deleteText(int k) {\n    const int numDeleted = min(k, static_cast<int>(s.length()));\n    for (int i = 0; i < numDeleted; ++i)\n      s.pop_back();\n    return numDeleted;\n  }\n\n  string cursorLeft(int k) {\n    while (!s.empty() && k--)\n      stack.push(s.back()), s.pop_back();\n    return getString();\n  }\n\n  string cursorRight(int k) {\n    while (!stack.empty() && k--)\n      s += stack.top(), stack.pop();\n    return getString();\n  }\n\n  string getString() {\n    if (s.length() < 10)\n      return s;\n    return s.substr(s.length() - 10);\n  }\n\n private:\n  string s;\n  stack<char> stack;\n};\n", "2297": "class Solution {\n public:\n  long long minCost(vector<int>& nums, vector<int>& costs) {\n    const int n = nums.size();\n    // dp[i] := the minimum cost to jump to i\n    vector<long> dp(n, LONG_MAX);\n    stack<int> maxStack;\n    stack<int> minStack;\n\n    dp[0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n      while (!maxStack.empty() && nums[i] >= nums[maxStack.top()])\n        dp[i] = min(dp[i], dp[maxStack.top()] + costs[i]), maxStack.pop();\n      while (!minStack.empty() && nums[i] < nums[minStack.top()])\n        dp[i] = min(dp[i], dp[minStack.top()] + costs[i]), minStack.pop();\n      maxStack.push(i);\n      minStack.push(i);\n    }\n\n    return dp.back();\n  }\n};\n", "2299": "class Solution {\n public:\n  bool strongPasswordCheckerII(string password) {\n    if (password.length() < 8)\n      return false;\n\n    const bool hasLowerCase =\n        ranges::any_of(password, [](const char c) { return islower(c); });\n    if (!hasLowerCase)\n      return false;\n\n    const bool hasUpperCase =\n        ranges::any_of(password, [](const char c) { return isupper(c); });\n    if (!hasUpperCase)\n      return false;\n\n    const bool hasDigit =\n        ranges::any_of(password, [](const char c) { return isdigit(c); });\n    if (!hasDigit)\n      return false;\n\n    const bool hasSpecial = ranges::any_of(password, [](const char c) {\n      return string(\"!@#$%^&*()-+\").find(c) != string::npos;\n    });\n    if (!hasSpecial)\n      return false;\n\n    for (int i = 1; i < password.length(); ++i)\n      if (password[i] == password[i - 1])\n        return false;\n    return true;\n  }\n};\n", "23": "class Solution {\n public:\n  ListNode* mergeKLists(vector<ListNode*>& lists) {\n    ListNode dummy(0);\n    ListNode* curr = &dummy;\n    auto compare = [](ListNode* a, ListNode* b) { return a->val > b->val; };\n    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> minHeap(\n        compare);\n\n    for (ListNode* list : lists)\n      if (list != nullptr)\n        minHeap.push(list);\n\n    while (!minHeap.empty()) {\n      ListNode* minNode = minHeap.top();\n      minHeap.pop();\n      if (minNode->next)\n        minHeap.push(minNode->next);\n      curr->next = minNode;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "230": "class Solution {\n public:\n  int kthSmallest(TreeNode* root, int k) {\n    int ans = -1;\n    int rank = 0;\n    traverse(root, k, rank, ans);\n    return ans;\n  }\n\n private:\n  void traverse(TreeNode* root, int k, int& rank, int& ans) {\n    if (root == nullptr)\n      return;\n\n    traverse(root->left, k, rank, ans);\n    if (++rank == k) {\n      ans = root->val;\n      return;\n    }\n    traverse(root->right, k, rank, ans);\n  }\n};\n", "2300": "class Solution {\n public:\n  vector<int> successfulPairs(vector<int>& spells, vector<int>& potions,\n                              long long success) {\n    vector<int> ans;\n    ranges::sort(potions);\n\n    for (const int spell : spells)\n      ans.push_back(potions.size() -\n                    firstIndexSuccess(spell, potions, success));\n\n    return ans;\n  }\n\n private:\n  // Returns the first index i s.t. spell * potions[i] >= success.\n  int firstIndexSuccess(int spell, const vector<int>& potions, long success) {\n    int l = 0;\n    int r = potions.size();\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (static_cast<long>(spell) * potions[m] >= success)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n};\n", "2301": "class Solution {\n public:\n  bool matchReplacement(string s, string sub, vector<vector<char>>& mappings) {\n    vector<vector<bool>> isMapped(128, vector<bool>(128));\n\n    for (const vector<char>& m : mappings) {\n      const char old = m[0];\n      const char _new = m[1];\n      isMapped[old][_new] = true;\n    }\n\n    for (int i = 0; i < s.length(); ++i)\n      if (canTransform(s, i, sub, isMapped))\n        return true;\n\n    return false;\n  }\n\n private:\n  bool canTransform(const string& s, int start, const string& sub,\n                    const vector<vector<bool>>& isMapped) {\n    if (start + sub.length() > s.length())\n      return false;\n\n    for (int i = 0; i < sub.length(); ++i) {\n      const char a = sub[i];\n      const char b = s[start + i];\n      if (a != b && !isMapped[a][b])\n        return false;\n    }\n\n    return true;\n  }\n};\n", "2302": "class Solution {\n public:\n  long long countSubarrays(vector<int>& nums, long long k) {\n    long ans = 0;\n    long sum = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      sum += nums[r];\n      while (sum * (r - l + 1) >= k)\n        sum -= nums[l++];\n      ans += r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "2303": "class Solution {\n public:\n  double calculateTax(vector<vector<int>>& brackets, int income) {\n    double ans = 0;\n    int prev = 0;\n\n    for (const vector<int>& b : brackets) {\n      const int upper = b[0];\n      const int percent = b[1];\n      if (income < upper)\n        return ans + (income - prev) * percent / 100.0;\n      ans += (upper - prev) * percent / 100.0;\n      prev = upper;\n    }\n\n    return ans;\n  }\n};\n", "2304": "class Solution {\n public:\n  int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dp[i][j] := the minimum cost to reach grid[i][j]\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\n    dp[0] = grid[0];\n\n    for (int i = 1; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int k = 0; k < n; ++k)\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] + moveCost[grid[i - 1][k]][j] +\n                                       grid[i][j]);\n\n    return ranges::min(dp.back());\n  }\n};\n", "2305": "class Solution {\n public:\n  int distributeCookies(vector<int>& cookies, int k) {\n    int ans = INT_MAX;\n    dfs(cookies, 0, k, vector<int>(k), ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& cookies, int s, int k, vector<int>&& children,\n           int& ans) {\n    if (s == cookies.size()) {\n      ans = min(ans, ranges::max(children));\n      return;\n    }\n\n    for (int i = 0; i < k; ++i) {\n      children[i] += cookies[s];\n      dfs(cookies, s + 1, k, std::move(children), ans);\n      children[i] -= cookies[s];\n    }\n  }\n};\n", "2306": "class Solution {\n public:\n  long long distinctNames(vector<string>& ideas) {\n    long ans = 0;\n    // suffixes[i] := the set of strings omitting the first letter, where the\n    // first letter is ('a' + i)\n    vector<unordered_set<string>> suffixes(26);\n\n    for (const string& idea : ideas)\n      suffixes[idea[0] - 'a'].insert(idea.substr(1));\n\n    for (int i = 0; i < 25; ++i)\n      for (int j = i + 1; j < 26; ++j) {\n        int count = 0;\n        for (const string& suffix : suffixes[i])\n          if (suffixes[j].contains(suffix))\n            ++count;\n        ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);\n      }\n\n    return ans;\n  }\n};\n", "2307": "class Solution {\n public:\n  bool checkContradictions(vector<vector<string>>& equations,\n                           vector<double>& values) {\n    // Convert `string` to `int` for a better perfermance.\n    unordered_map<string, int> strToInt;\n\n    for (const vector<string>& equation : equations) {\n      const string& u = equation[0];\n      const string& v = equation[1];\n      if (!strToInt.contains(u))\n        strToInt[u] = strToInt.size();\n      if (!strToInt.contains(v))\n        strToInt[v] = strToInt.size();\n    }\n\n    vector<vector<pair<int, double>>> graph(strToInt.size());\n    vector<double> seen(graph.size());\n\n    for (int i = 0; i < equations.size(); ++i) {\n      const int u = strToInt.at(equations[i][0]);\n      const int v = strToInt.at(equations[i][1]);\n      graph[u].emplace_back(v, values[i]);\n      graph[v].emplace_back(u, 1 / values[i]);\n    }\n\n    for (int i = 0; i < graph.size(); ++i)\n      if (!seen[i] && dfs(graph, i, seen, 1.0))\n        return true;\n\n    return false;\n  }\n\n private:\n  bool dfs(const vector<vector<pair<int, double>>>& graph, int u,\n           vector<double>& seen, double val) {\n    if (seen[u])\n      return abs(val / seen[u] - 1) > 1e-5;\n\n    seen[u] = val;\n    for (const auto& [v, w] : graph[u])\n      if (dfs(graph, v, seen, val / w))\n        return true;\n\n    return false;\n  }\n};\n", "2309": "class Solution {\n public:\n  string greatestLetter(string s) {\n    vector<bool> seen(128);\n\n    for (const char c : s)\n      seen[c] = true;\n\n    for (int i = 25; i >= 0; --i)\n      if (seen['a' + i] && seen['A' + i])\n        return string(1, 'A' + i);\n\n    return \"\";\n  }\n};\n", "231": "class Solution {\n public:\n  bool isPowerOfTwo(int n) {\n    return n >= 0 && __builtin_popcount(n) == 1;\n  }\n};\n", "2310": "class Solution {\n public:\n  int minimumNumbers(int num, int k) {\n    if (num == 0)\n      return 0;\n\n    // Assume the size of the set is n, and the numbers in the set are X1, X2,\n    // ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    // N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    // the n s.t. n * k % 10 = num % 10\n    for (int i = 1; i <= 10 && i * k <= num; ++i)\n      if (i * k % 10 == num % 10)\n        return i;\n\n    return -1;\n  }\n};\n", "2311": "class Solution {\n public:\n  int longestSubsequence(string s, int k) {\n    int oneCount = 0;\n    int num = 0;\n    int pow = 1;\n\n    // Take as many 1s as possible from the right.\n    for (int i = s.length() - 1; i >= 0 && num + pow <= k; --i) {\n      if (s[i] == '1') {\n        ++oneCount;\n        num += pow;\n      }\n      pow *= 2;\n    }\n\n    return ranges::count(s, '0') + oneCount;\n  }\n};\n", "2312": "class Solution {\n public:\n  long long sellingWood(int m, int n, vector<vector<int>>& prices) {\n    // dp[i][j] := the maximum money of cutting i x j piece of wood\n    vector<vector<long>> dp(m + 1, vector<long>(n + 1));\n\n    for (const vector<int>& p : prices) {\n      const int h = p[0];\n      const int w = p[1];\n      const int price = p[2];\n      dp[h][w] = price;\n    }\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j) {\n        for (int h = 1; h <= i / 2; ++h)\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);\n        for (int w = 1; w <= j / 2; ++w)\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w]);\n      }\n\n    return dp[m][n];\n  }\n};\n", "2313": "class Solution {\n public:\n  int minimumFlips(TreeNode* root, bool result) {\n    return dp(root, result);\n  }\n\n private:\n  struct PairHash {\n    template <class T1, class T2>\n    std::size_t operator()(const std::pair<T1, T2>& p) const {\n      return std::hash<T1>{}(p.first) ^ std::hash<T2>{}(p.second);\n    }\n  };\n\n  unordered_map<pair<TreeNode*, bool>, int, PairHash> mem;\n\n  // Returns the minimum flips to make the subtree become the target.\n  int dp(TreeNode* root, bool target) {\n    const pair<TreeNode*, bool> key{root, target};\n    if (const auto it = mem.find(key); it != mem.cend())\n      return it->second;\n    if (root->val == 0 || root->val == 1)  // the leaf\n      return root->val == target ? 0 : 1;\n    if (root->val == 5)  // NOT\n      return dp(root->left == nullptr ? root->right : root->left, !target);\n\n    vector<pair<int, int>> nextTargets;\n    if (root->val == 2)  // OR\n      nextTargets = target ? vector<pair<int, int>>{{0, 1}, {1, 0}, {1, 1}}\n                           : vector<pair<int, int>>{{0, 0}};\n    else if (root->val == 3)  // AND\n      nextTargets = target ? vector<pair<int, int>>{{1, 1}}\n                           : vector<pair<int, int>>{{0, 0}, {0, 1}, {1, 0}};\n    else  // root.val == 4 (XOR)\n      nextTargets = target ? vector<pair<int, int>>{{0, 1}, {1, 0}}\n                           : vector<pair<int, int>>{{0, 0}, {1, 1}};\n\n    int ans = INT_MAX;\n    for (const auto& [leftTarget, rightTarget] : nextTargets)\n      ans = min(ans, dp(root->left, leftTarget) + dp(root->right, rightTarget));\n    return mem[key] = ans;\n  }\n};\n", "2315": "class Solution {\n public:\n  int countAsterisks(string s) {\n    int ans = 0;\n    int bars = 0;\n\n    for (const char c : s) {\n      if (c == '|')\n        ++bars;\n      else if (c == '*' && bars % 2 == 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2316": "class Solution {\n public:\n  long long countPairs(int n, vector<vector<int>>& edges) {\n    long ans = 0;\n    vector<vector<int>> graph(n);\n    vector<bool> seen(n);\n    int unreached = n;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      const int reached = dfs(graph, i, seen);\n      unreached -= reached;\n      ans += static_cast<long>(unreached) * reached;\n    }\n    return ans;\n  }\n\n private:\n  int dfs(const vector<vector<int>>& graph, int u, vector<bool>& seen) {\n    if (seen[u])\n      return 0;\n    seen[u] = true;\n    return accumulate(graph[u].begin(), graph[u].end(), 1, [&](int acc, int v) {\n      return acc + dfs(graph, v, seen);\n    });\n  }\n};\n", "2317": "class Solution {\n public:\n  int maximumXOR(vector<int>& nums) {\n    // 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    //    nums[i] since x is arbitrary.\n    // 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    //    for an odd number of elements.\n    // 3. Therefore, the question is equivalent to: if you can convert any digit\n    //    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    // 4. The maximum we can get is of course to make every digit of the answer\n    //    to be 1 if possible\n    // 5. Therefore, OR(nums[i]) is an approach.\n    return reduce(nums.begin(), nums.end(), 0, bit_or());\n  }\n};\n", "2318": "class Solution {\n public:\n  int distinctSequences(int n) {\n    vector<vector<vector<int>>> mem(n + 1,\n                                    vector<vector<int>>(7, vector<int>(7)));\n    return distinctSequences(n, 0, 0, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of distinct sequences for n dices with `prev` and\n  // `prevPrev`.\n  int distinctSequences(int n, int prev, int prevPrev,\n                        vector<vector<vector<int>>>& mem) {\n    if (n == 0)\n      return 1;\n    if (mem[n][prev][prevPrev] > 0)\n      return mem[n][prev][prevPrev];\n\n    for (int dice = 1; dice <= 6; ++dice)\n      if (dice != prev && dice != prevPrev &&\n          (prev == 0 || gcd(dice, prev) == 1)) {\n        mem[n][prev][prevPrev] += distinctSequences(n - 1, dice, prev, mem);\n        mem[n][prev][prevPrev] %= kMod;\n      }\n\n    return mem[n][prev][prevPrev];\n  }\n};\n", "2319": "class Solution {\n public:\n  bool checkXMatrix(vector<vector<int>>& grid) {\n    const int n = grid.size();\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i == j || i + j == n - 1) {  // in diagonal\n          if (grid[i][j] == 0)\n            return false;\n        } else if (grid[i][j]) {  // not in diagonal\n          return false;\n        }\n\n    return true;\n  }\n};\n", "232": "class MyQueue {\n public:\n  void push(int x) {\n    input.push(x);\n  }\n\n  int pop() {\n    peek();\n    const int val = output.top();\n    output.pop();\n    return val;\n  }\n\n  int peek() {\n    if (output.empty())\n      while (!input.empty())\n        output.push(input.top()), input.pop();\n    return output.top();\n  }\n\n  bool empty() {\n    return input.empty() && output.empty();\n  }\n\n private:\n  stack<int> input;\n  stack<int> output;\n};\n", "2320": "class Solution {\n public:\n  int countHousePlacements(int n) {\n    constexpr int kMod = 1'000'000'007;\n    int house = 1;  // the number of ways ending in a house\n    int space = 1;  // the number of ways ending in a space\n    int total = house + space;\n\n    for (int i = 2; i <= n; ++i) {\n      house = space;\n      space = total;\n      total = (house + space) % kMod;\n    }\n\n    return static_cast<long>(total) * total % kMod;\n  }\n};\n", "2321": "class Solution {\n public:\n  int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\n    return max(kadane(nums1, nums2), kadane(nums2, nums1));\n  }\n\n private:\n  // Returns the maximum gain of swapping some numbers in `nums1` with some\n  // numbers in `nums2`.\n  int kadane(const vector<int>& nums1, const vector<int>& nums2) {\n    int gain = 0;\n    int maxGain = 0;\n\n    for (int i = 0; i < nums1.size(); ++i) {\n      gain = max(0, gain + nums2[i] - nums1[i]);\n      maxGain = max(maxGain, gain);\n    }\n\n    return maxGain + accumulate(nums1.begin(), nums1.end(), 0);\n  }\n};\n", "2322": "class Solution {\n public:\n  int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\n    const int n = nums.size();\n    const int xors = reduce(nums.begin(), nums.end(), 0, bit_xor());\n    vector<int> subXors(nums);\n    vector<vector<int>> tree(n);\n    vector<unordered_set<int>> children(n);\n\n    for (int i = 0; i < n; ++i)\n      children[i].insert(i);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, -1, subXors, children);\n\n    int ans = INT_MAX;\n\n    for (int i = 0; i < edges.size(); ++i) {\n      int a = edges[i][0];\n      int b = edges[i][1];\n      if (children[a].contains(b))\n        swap(a, b);\n      for (int j = 0; j < i; ++j) {\n        int c = edges[j][0];\n        int d = edges[j][1];\n        if (children[c].contains(d))\n          swap(c, d);\n        vector<int> cands;\n        if (a != c && children[a].contains(c))\n          cands = {subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]};\n        else if (a != c && children[c].contains(a))\n          cands = {subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]};\n        else\n          cands = {subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]};\n        ans = min(ans, ranges::max(cands) - ranges::min(cands));\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  pair<int, unordered_set<int>> dfs(const vector<vector<int>>& tree, int u,\n                                    int prev, vector<int>& subXors,\n                                    vector<unordered_set<int>>& children) {\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      const auto& [vXor, vChildren] = dfs(tree, v, u, subXors, children);\n      subXors[u] ^= vXor;\n      children[u].insert(vChildren.begin(), vChildren.end());\n    }\n    return {subXors[u], children[u]};\n  }\n};\n", "2323": "class Solution {\n public:\n  int minimumTime(vector<int>& jobs, vector<int>& workers) {\n    int ans = 0;\n\n    ranges::sort(jobs);\n    ranges::sort(workers);\n\n    for (int i = 0; i < jobs.size(); ++i)\n      ans = max(ans, (jobs[i] - 1) / workers[i] + 1);\n\n    return ans;\n  }\n};\n", "2325": "class Solution {\n public:\n  string decodeMessage(string key, string message) {\n    vector<char> keyToActual(128);\n    keyToActual[' '] = ' ';\n    char currChar = 'a';\n\n    for (const char c : key)\n      keyToActual[c] = keyToActual[c] ?: currChar++;\n\n    transform(message.cbegin(), message.cend(), message.begin(),\n              [&](char c) { return keyToActual[c]; });\n\n    return message;\n  }\n};\n", "2326": "class Solution {\n public:\n  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> ans(m, vector<int>(n, -1));\n    int x = 0;  // the current x position\n    int y = 0;  // the current y position\n    int d = 0;\n\n    for (ListNode* curr = head; curr; curr = curr->next) {\n      ans[x][y] = curr->val;\n      if (x + kDirs[d][0] < 0 || x + kDirs[d][0] == m || y + kDirs[d][1] < 0 ||\n          y + kDirs[d][1] == n || ans[x + kDirs[d][0]][y + kDirs[d][1]] != -1)\n        d = (d + 1) % 4;\n      x += kDirs[d][0];\n      y += kDirs[d][1];\n    }\n\n    return ans;\n  }\n};\n", "2327": "class Solution {\n public:\n  int peopleAwareOfSecret(int n, int delay, int forget) {\n    constexpr int kMod = 1'000'000'007;\n    long share = 0;\n    // dp[i] := the number of people know the secret at day i\n    vector<int> dp(n);  // Maps day i to i + 1.\n    dp[0] = 1;\n\n    for (int i = 1; i < n; ++i) {\n      if (i - delay >= 0)\n        share += dp[i - delay];\n      if (i - forget >= 0)\n        share -= dp[i - forget];\n      share += kMod;\n      share %= kMod;\n      dp[i] = share;\n    }\n\n    // People before day `n - forget - 1` already forget the secret.\n    return accumulate(dp.end() - forget, dp.end(), 0,\n                      [&](int acc, int d) { return (acc + d) % kMod; });\n  }\n};\n", "2328": "class Solution {\n public:\n  int countPaths(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    vector<vector<int>> mem(m, vector<int>(n, -1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        ans += countPaths(grid, i, j, mem);\n        ans %= kMod;\n      }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  // Returns the number of increasing paths starting from (i, j).\n  int countPaths(const vector<vector<int>>& grid, int i, int j,\n                 vector<vector<int>>& mem) {\n    if (mem[i][j] != -1)\n      return mem[i][j];\n\n    mem[i][j] = 1;  // The current cell contributes 1 length.\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())\n        continue;\n      if (grid[x][y] <= grid[i][j])\n        continue;\n      mem[i][j] += countPaths(grid, x, y, mem);\n      mem[i][j] %= kMod;\n    }\n\n    return mem[i][j];\n  }\n};\n", "233": "class Solution {\n public:\n  int countDigitOne(int n) {\n    int ans = 0;\n\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\n      const long divisor = pow10 * 10;\n      const int quotient = n / divisor;\n      const int remainder = n % divisor;\n      if (quotient > 0)\n        ans += quotient * pow10;\n      if (remainder >= pow10)\n        ans += min(remainder - pow10 + 1, pow10);\n    }\n\n    return ans;\n  }\n};\n", "2330": "class Solution {\n public:\n  bool makePalindrome(string s) {\n    int change = 0;\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      if (s[l] != s[r] && ++change > 2)\n        return false;\n      ++l;\n      --r;\n    }\n\n    return true;\n  }\n};\n", "2331": "class Solution {\n public:\n  bool evaluateTree(TreeNode* root) {\n    if (root->val < 2)\n      return root->val;\n    if (root->val == 2)  // OR\n      return evaluateTree(root->left) || evaluateTree(root->right);\n    // AND\n    return evaluateTree(root->left) && evaluateTree(root->right);\n  }\n};\n", "2332": "class Solution {\n public:\n  int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers,\n                            int capacity) {\n    ranges::sort(buses);\n    ranges::sort(passengers);\n\n    if (passengers.front() > buses.back())\n      return buses.back();\n\n    int ans = passengers[0] - 1;\n    int i = 0;  // buses' index\n    int j = 0;  // passengers' index\n\n    while (i < buses.size()) {\n      // Greedily make passengers catch `buses[i]`.\n      int arrived = 0;\n      while (arrived < capacity && j < passengers.size() &&\n             passengers[j] <= buses[i]) {\n        if (j > 0 && passengers[j] != passengers[j - 1] + 1)\n          ans = passengers[j] - 1;\n        ++j;\n        ++arrived;\n      }\n      // There's room for `buses[i]` to carry a passenger arriving at\n      // `buses[i]`.\n      if (arrived < capacity && j > 0 && passengers[j - 1] != buses[i])\n        ans = buses[i];\n      ++i;\n    }\n\n    return ans;\n  }\n};\n", "2333": "class Solution {\n public:\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1,\n                             int k2) {\n    const vector<int> diff = getDiff(nums1, nums2);\n    int k = k1 + k2;\n    if (accumulate(diff.begin(), diff.end(), 0L) <= k)\n      return 0;\n\n    unordered_map<int, int> count;\n    priority_queue<pair<int, int>> maxHeap;  // (num, freq)\n\n    for (const int d : diff)\n      if (d != 0)\n        ++count[d];\n\n    for (const auto& [num, freq] : count)\n      maxHeap.emplace(num, freq);\n\n    while (k > 0) {\n      const auto [maxNum, maxNumFreq] = maxHeap.top();\n      maxHeap.pop();\n      // Buck decrease in this turn\n      const int numDecreased = min(k, maxNumFreq);\n      k -= numDecreased;\n      if (maxNumFreq > numDecreased)\n        maxHeap.emplace(maxNum, maxNumFreq - numDecreased);\n      if (!maxHeap.empty() && maxHeap.top().first + 1 == maxNum) {\n        const auto [secondMaxNum, secondMaxNumFreq] = maxHeap.top();\n        maxHeap.pop();\n        maxHeap.emplace(secondMaxNum, secondMaxNumFreq + numDecreased);\n      } else if (maxNum > 1) {\n        maxHeap.emplace(maxNum - 1, numDecreased);\n      }\n    }\n\n    long ans = 0;\n    while (!maxHeap.empty()) {\n      const auto [num, freq] = maxHeap.top();\n      maxHeap.pop();\n      ans += static_cast<long>(num) * num * freq;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getDiff(const vector<int>& nums1, const vector<int>& nums2) {\n    vector<int> diff;\n    for (int i = 0; i < nums1.size(); ++i)\n      diff.push_back(abs(nums1[i] - nums2[i]));\n    return diff;\n  }\n};\n", "2334": "class Solution {\n public:\n  // Similar to 907. Sum of Subarray Minimums\n  int validSubarraySize(vector<int>& nums, int threshold) {\n    const int n = nums.size();\n    // prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    vector<int> prev(n, -1);\n    // next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    vector<int> next(n, n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && nums[stack.top()] > nums[i]) {\n        const int index = stack.top();\n        stack.pop();\n        next[index] = i;\n      }\n      if (!stack.empty())\n        prev[i] = stack.top();\n      stack.push(i);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      // the number of `nums` in subarray containing nums[i] >= nums[i]\n      const int k = (i - prev[i]) + (next[i] - i) - 1;\n      if (nums[i] > threshold / static_cast<double>(k))\n        return k;\n    }\n\n    return -1;\n  }\n};\n", "2335": "class Solution {\n public:\n  int fillCups(vector<int>& amount) {\n    const int mx = ranges::max(amount);\n    const int sum = accumulate(amount.begin(), amount.end(), 0);\n    return max(mx, (sum + 1) / 2);\n  }\n};\n", "2336": "class SmallestInfiniteSet {\n public:\n  int popSmallest() {\n    if (added.empty())\n      return curr++;\n    const int mn = *added.begin();\n    added.erase(added.begin());\n    return mn;\n  }\n\n  void addBack(int num) {\n    if (num < curr)\n      added.insert(num);\n  }\n\n private:\n  int curr = 1;\n  set<int> added;\n};\n", "2337": "class Solution {\n public:\n  bool canChange(string start, string target) {\n    const int n = start.length();\n    int i = 0;  // start's index\n    int j = 0;  // target's index\n\n    while (i <= n && j <= n) {\n      while (i < n && start[i] == '_')\n        ++i;\n      while (j < n && target[j] == '_')\n        ++j;\n      if (i == n || j == n)\n        return i == n && j == n;\n      if (start[i] != target[j])\n        return false;\n      if (start[i] == 'R' && i > j)\n        return false;\n      if (start[i] == 'L' && i < j)\n        return false;\n      ++i;\n      ++j;\n    }\n\n    return true;\n  }\n};\n", "2338": "class Solution {\n public:\n  int idealArrays(int n, int maxValue) {\n    // Since 2^14 > 10^4, the longest strictly increasing array is [1, 2, 4,\n    // ..., 2^13]\n    const int maxLength = min(14, n);\n    const vector<vector<int>> factors = getFactors(maxValue);\n    // dp[i][j] := the number of strictly increasing ideal arrays of length i\n    // ending in j\n    // dp[i][j] := sum(dp[i - 1][k]), where j % k == 0\n    // dp[i][0] := sum(dp[i][j]) where 1 <= j <= maxValue\n    vector<vector<long>> dp(maxLength + 1, vector<long>(maxValue + 1));\n    vector<vector<long>> mem(n, vector<long>(maxLength, -1));\n    long ans = 0;\n\n    for (int j = 1; j <= maxValue; ++j)\n      dp[1][j] = 1;\n\n    for (int i = 2; i <= maxLength; ++i)\n      for (int j = 1; j <= maxValue; ++j)\n        for (const int k : factors[j]) {\n          dp[i][j] += dp[i - 1][k];\n          dp[i][j] %= kMod;\n        }\n\n    for (int i = 1; i <= maxLength; ++i)\n      for (int j = 1; j <= maxValue; ++j) {\n        dp[i][0] += dp[i][j];\n        dp[i][0] %= kMod;\n      }\n\n    for (int i = 1; i <= maxLength; ++i) {\n      // nCk(n - 1, i - 1) := the number of ways to create an ideal array of\n      // length n from a strictly increasing array of length i\n      ans += dp[i][0] * nCk(n - 1, i - 1, mem);\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  vector<vector<int>> getFactors(int maxValue) {\n    vector<vector<int>> factors(maxValue + 1);\n    for (int i = 1; i <= maxValue; ++i)\n      // Start from i * 2 because of strictly increasing.\n      for (int j = i * 2; j <= maxValue; j += i)\n        factors[j].push_back(i);\n    return factors;\n  }\n\n  long nCk(int n, int k, vector<vector<long>>& mem) {\n    if (k == 0)\n      return 1;\n    if (n == k)\n      return 1;\n    if (mem[n][k] != -1)\n      return mem[n][k];\n    return mem[n][k] = (nCk(n - 1, k, mem) + nCk(n - 1, k - 1, mem)) % kMod;\n  }\n};\n", "234": "class Solution {\n public:\n  bool isPalindrome(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    if (fast != nullptr)\n      slow = slow->next;\n    slow = reverseList(slow);\n\n    while (slow != nullptr) {\n      if (slow->val != head->val)\n        return false;\n      slow = slow->next;\n      head = head->next;\n    }\n\n    return true;\n  }\n\n private:\n  ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    while (head != nullptr) {\n      ListNode* next = head->next;\n      head->next = prev;\n      prev = head;\n      head = next;\n    }\n    return prev;\n  }\n};\n", "2340": "class Solution {\n public:\n  int minimumSwaps(vector<int>& nums) {\n    const int minIndex = getLeftmostMinIndex(nums);\n    const int maxIndex = getRightmostMaxIndex(nums);\n    const int swaps = minIndex + (nums.size() - 1 - maxIndex);\n    return minIndex <= maxIndex ? swaps : swaps - 1;\n  }\n\n private:\n  int getLeftmostMinIndex(const vector<int>& nums) {\n    int mn = nums.front();\n    int minIndex = 0;\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] < mn) {\n        mn = nums[i];\n        minIndex = i;\n      }\n    return minIndex;\n  }\n\n  int getRightmostMaxIndex(const vector<int>& nums) {\n    int mx = nums.back();\n    int maxIndex = nums.size() - 1;\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] > mx) {\n        mx = nums[i];\n        maxIndex = i;\n      }\n    return maxIndex;\n  }\n};\n", "2341": "class Solution {\n public:\n  vector<int> numberOfPairs(vector<int>& nums) {\n    constexpr int kMax = 100;\n    vector<int> ans(2);\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = 0; i <= kMax; ++i) {\n      ans[0] += count[i] / 2;\n      ans[1] += count[i] & 1;\n    }\n\n    return ans;\n  }\n};\n", "2342": "class Solution {\n public:\n  int maximumSum(vector<int>& nums) {\n    constexpr int kMax = 9 * 9;  // 999,999,999\n    int ans = -1;\n    vector<vector<int>> count(kMax + 1);\n\n    for (const int num : nums)\n      count[getDigitSum(num)].push_back(num);\n\n    for (vector<int>& groupNums : count) {\n      if (groupNums.size() < 2)\n        continue;\n      ranges::sort(groupNums, greater<>());\n      ans = max(ans, groupNums[0] + groupNums[1]);\n    }\n\n    return ans;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "2343": "class Solution {\n public:\n  vector<int> smallestTrimmedNumbers(vector<string>& nums,\n                                     vector<vector<int>>& queries) {\n    vector<int> ans;\n    for (const vector<int>& query : queries)\n      ans.push_back(getKSmallestIndex(nums, query[0], query[1]));\n    return ans;\n  }\n\n private:\n  int getKSmallestIndex(const vector<string>& nums, int k, int trim) {\n    const int startIndex = nums[0].length() - trim;\n    vector<pair<string, int>> trimmed;  // (num, index)\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const string& num = nums[i];\n      trimmed.push_back({num.substr(startIndex), i});\n    }\n\n    ranges::sort(trimmed);\n    return trimmed[k - 1].second;\n  }\n};\n", "2344": "class Solution {\n public:\n  int minOperations(vector<int>& nums, vector<int>& numsDivide) {\n    const int gcd = getGCD(numsDivide);\n\n    ranges::sort(nums);\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (gcd % nums[i] == 0)\n        return i;\n\n    return -1;\n  }\n\n private:\n  int getGCD(const vector<int>& nums) {\n    int gcd = nums[0];\n    for (const int num : nums)\n      gcd = __gcd(gcd, num);\n    return gcd;\n  }\n};\n", "2345": "class Solution {\n public:\n  int visibleMountains(vector<vector<int>>& peaks) {\n    int ans = 0;\n    int maxRightFoot = 0;\n\n    ranges::sort(peaks, ranges::less{}, [](const vector<int>& peak) {\n      return pair<int, int>(peak[0] - peak[1], -peak[0]);\n    });\n\n    for (int i = 0; i < peaks.size(); ++i) {\n      const bool overlapWithNext =\n          i + 1 < peaks.size() && peaks[i] == peaks[i + 1];\n      const int currRightFoot = peaks[i][0] + peaks[i][1];\n      if (currRightFoot > maxRightFoot) {\n        if (!overlapWithNext)\n          ++ans;\n        maxRightFoot = currRightFoot;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2347": "class Solution {\n public:\n  string bestHand(vector<int>& ranks, vector<char>& suits) {\n    if (ranges::all_of(suits,\n                       [&suits](const char suit) { return suit == suits[0]; }))\n      return \"Flush\";\n\n    constexpr int kMax = 13;\n    vector<int> count(kMax + 1);\n\n    for (const int rank : ranks)\n      ++count[rank];\n\n    const int mx = ranges::max(count);\n    if (mx > 2)\n      return \"Three of a Kind\";\n    if (mx == 2)\n      return \"Pair\";\n    return \"High Card\";\n  }\n};\n", "2348": "class Solution {\n public:\n  long long zeroFilledSubarray(vector<int>& nums) {\n    long ans = 0;\n    int indexBeforeZero = -1;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i])\n        indexBeforeZero = i;\n      else\n        ans += i - indexBeforeZero;\n\n    return ans;\n  }\n};\n", "2349": "class NumberContainers {\n public:\n  void change(int index, int number) {\n    const auto it = indexToNumber.find(index);\n    if (it != indexToNumber.cend()) {\n      const int originalNumber = it->second;\n      auto& indices = numberToIndices[originalNumber];\n      indices.erase(index);\n      if (indices.empty())\n        numberToIndices.erase(originalNumber);\n    }\n    numberToIndices[number].insert(index);\n  }\n\n  int find(int number) {\n    const auto it = numberToIndices.find(number);\n    if (it == numberToIndices.cend())\n      return -1;\n    const auto& indices = it->second;\n    return *indices.begin();\n  }\n\n private:\n  unordered_map<int, int> indexToNumber;\n  unordered_map<int, set<int>> numberToIndices;\n};\n", "235": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root->val > max(p->val, q->val))\n      return lowestCommonAncestor(root->left, p, q);\n    if (root->val < min(p->val, q->val))\n      return lowestCommonAncestor(root->right, p, q);\n    return root;\n  }\n};\n", "2350": "class Solution {\n public:\n  int shortestSequence(vector<int>& rolls, int k) {\n    int ans = 1;  // the the next target length\n    unordered_set<int> seen;\n\n    for (const int roll : rolls) {\n      seen.insert(roll);\n      if (seen.size() == k) {\n        // Have all combinations that form `ans` length, and we are going to\n        // extend the sequence to `ans + 1` length.\n        ++ans;\n        seen.clear();\n      }\n    }\n\n    return ans;\n  }\n};\n", "2351": "class Solution {\n public:\n  char repeatedCharacter(string s) {\n    vector<bool> seen(26);\n\n    for (const char c : s) {\n      if (seen[c - 'a'])\n        return c;\n      seen[c - 'a'] = true;\n    }\n\n    throw;\n  }\n};\n", "2352": "class Solution {\n public:\n  int equalPairs(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        int k = 0;\n        for (; k < n; ++k)\n          if (grid[i][k] != grid[k][j])\n            break;\n        if (k == n)  // R[i] == C[j]\n          ++ans;\n      }\n\n    return ans;\n  }\n};\n", "2353": "class FoodRatings {\n public:\n  FoodRatings(vector<string>& foods, vector<string>& cuisines,\n              vector<int>& ratings) {\n    for (int i = 0; i < foods.size(); ++i) {\n      cuisineToRatingAndFoods[cuisines[i]].insert({-ratings[i], foods[i]});\n      foodToCuisine[foods[i]] = cuisines[i];\n      foodToRating[foods[i]] = ratings[i];\n    }\n  }\n\n  void changeRating(string food, int newRating) {\n    const string cuisine = foodToCuisine[food];\n    const int oldRating = foodToRating[food];\n    auto& ratingAndFoods = cuisineToRatingAndFoods[cuisine];\n    ratingAndFoods.erase({-oldRating, food});\n    ratingAndFoods.insert({-newRating, food});\n    foodToRating[food] = newRating;\n  }\n\n  string highestRated(string cuisine) {\n    return cuisineToRatingAndFoods[cuisine].begin()->second;\n  }\n\n private:\n  // {cuisine: {(-rating, food)}} stores negative rating for smarter comparison\n  unordered_map<string, set<pair<int, string>>> cuisineToRatingAndFoods;\n  unordered_map<string, string> foodToCuisine;\n  unordered_map<string, int> foodToRating;\n};\n", "2354": "class Solution {\n public:\n  long long countExcellentPairs(vector<int>& nums, int k) {\n    constexpr int kMaxBit = 30;\n    // bits(num1 | num2) + bits(num1 & num2) = bits(num1) + bits(num2)\n    long ans = 0;\n    vector<long> count(kMaxBit);\n\n    for (const unsigned num : unordered_set<int>(nums.begin(), nums.end()))\n      ++count[popcount(num)];\n\n    for (int i = 0; i < kMaxBit; ++i)\n      for (int j = 0; j < kMaxBit; ++j)\n        if (i + j >= k)\n          ans += count[i] * count[j];\n\n    return ans;\n  }\n};\n", "2355": "class Solution {\n public:\n  long long maximumBooks(vector<int>& books) {\n    // dp[i] := the maximum number of books we can take from books[0..i] with\n    // taking all of books[i]\n    vector<long> dp(books.size());\n    stack<int> stack;  // the possible indices we can reach\n\n    for (int i = 0; i < books.size(); ++i) {\n      // We may take all of books[j], where books[j] < books[i] - (i - j).\n      while (!stack.empty() &&\n             books[stack.top()] >= books[i] - (i - stack.top()))\n        stack.pop();\n      // We can now take books[j + 1..i].\n      const int j = stack.empty() ? -1 : stack.top();\n      const int lastTook = books[i] - (i - j) + 1;\n      if (lastTook > 1)\n        // books[i] + (books[i] - 1) + ... + (books[i] - (i - j) + 1)\n        dp[i] = static_cast<long>(books[i] + lastTook) * (i - j) / 2;\n      else\n        // 1 + 2 + ... + books[i]\n        dp[i] = static_cast<long>(books[i]) * (books[i] + 1) / 2;\n      if (j >= 0)\n        dp[i] += dp[j];\n      stack.push(i);\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "2357": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    unordered_set<int> seen(nums.begin(), nums.end());\n    return seen.size() - seen.contains(0);\n  }\n};\n", "2358": "class Solution {\n public:\n  int maximumGroups(vector<int>& grades) {\n    // Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    // 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    // size. So, we can rephrase the problem into:\n    //   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    //  1 + 2 + 3 + ... + k <= n\n    //         k(k + 1) / 2 <= n\n    //              k^2 + k <= 2n\n    //   (k + 0.5)^2 - 0.25 <= 2n\n    //          (k + 0.5)^2 <= 2n + 0.25\n    //                    k <= sqrt(2n + 0.25) - 0.5\n    return sqrt(grades.size() * 2 + 0.25) - 0.5;\n  }\n};\n", "2359": "class Solution {\n public:\n  int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n    constexpr int kMax = 10000;\n    const vector<int> dist1 = getDist(edges, node1);\n    const vector<int> dist2 = getDist(edges, node2);\n    int minDist = kMax;\n    int ans = -1;\n\n    for (int i = 0; i < edges.size(); ++i)\n      if (min(dist1[i], dist2[i]) >= 0) {\n        const int maxDist = max(dist1[i], dist2[i]);\n        if (maxDist < minDist) {\n          minDist = maxDist;\n          ans = i;\n        }\n      }\n\n    return ans;\n  }\n\n private:\n  vector<int> getDist(const vector<int>& edges, int u) {\n    vector<int> dist(edges.size(), -1);\n    int d = 0;\n    while (u != -1 && dist[u] == -1) {\n      dist[u] = d++;\n      u = edges[u];\n    }\n    return dist;\n  }\n};\n", "236": "class Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    queue<TreeNode*> q_{{root}};\n    unordered_map<TreeNode*, TreeNode*> parent{{root, nullptr}};\n    unordered_set<TreeNode*> ancestors;  // p's ancestors\n\n    // Iterate until we find both p and q.\n    while (!parent.contains(p) || !parent.contains(q)) {\n      root = q_.front(), q_.pop();\n      if (root->left) {\n        parent[root->left] = root;\n        q_.push(root->left);\n      }\n      if (root->right) {\n        parent[root->right] = root;\n        q_.push(root->right);\n      }\n    }\n\n    // Insert all the p's ancestors.\n    while (p != nullptr) {\n      ancestors.insert(p);\n      p = parent[p];  // `p` becomes nullptr in the end.\n    }\n\n    // Go up from q until we meet any of p's ancestors.\n    while (!ancestors.contains(q))\n      q = parent[q];\n\n    return q;\n  }\n};\n", "2360": "class Solution {\n public:\n  int longestCycle(vector<int>& edges) {\n    int ans = -1;\n    int time = 1;\n    vector<int> timeVisited(edges.size());\n\n    for (int i = 0; i < edges.size(); ++i) {\n      if (timeVisited[i])\n        continue;\n      const int startTime = time;\n      int u = i;\n      while (u != -1 && !timeVisited[u]) {\n        timeVisited[u] = time++;\n        u = edges[u];  // Move to the next node.\n      }\n      if (u != -1 && timeVisited[u] >= startTime)\n        ans = max(ans, time - timeVisited[u]);\n    }\n\n    return ans;\n  }\n};\n", "2361": "class Solution {\n public:\n  vector<long long> minimumCosts(vector<int>& regular, vector<int>& express,\n                                 int expressCost) {\n    const int n = regular.size();\n    vector<long long> ans(n);\n    // the minimum cost to reach the current stop in a regular route\n    long dpReg = 0;\n    // the minimum cost to reach the current stop in an express route\n    long dpExp = expressCost;\n\n    for (int i = 0; i < n; ++i) {\n      const long prevReg = dpReg;\n      const long prevExp = dpExp;\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i]);\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i]);\n      ans[i] = min(dpReg, dpExp);\n    }\n\n    return ans;\n  }\n};\n", "2363": "class Solution {\n public:\n  vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1,\n                                        vector<vector<int>>& items2) {\n    constexpr int kMax = 1000;\n    vector<vector<int>> ans;\n    vector<int> count(kMax + 1);\n\n    for (const vector<int>& item : items1)\n      count[item[0]] += item[1];\n\n    for (const vector<int>& item : items2)\n      count[item[0]] += item[1];\n\n    for (int i = 1; i <= kMax; ++i)\n      if (count[i])\n        ans.push_back({i, count[i]});\n\n    return ans;\n  }\n};\n", "2364": "class Solution {\n public:\n  long long countBadPairs(vector<int>& nums) {\n    long ans = 0;\n    unordered_map<int, int> count;  // (nums[i] - i)\n\n    for (int i = 0; i < nums.size(); ++i)\n      //     count[nums[i] - i] := the number of good pairs\n      // i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[nums[i] - i]++;\n\n    return ans;\n  }\n};\n", "2365": "class Solution {\n public:\n  long long taskSchedulerII(vector<int>& tasks, int space) {\n    unordered_map<int, long> taskToNextAvailable;\n    long ans = 0;\n\n    for (const int task : tasks) {\n      ans = max(ans + 1, taskToNextAvailable[task]);\n      taskToNextAvailable[task] = ans + space + 1;\n    }\n\n    return ans;\n  }\n};\n", "2366": "class Solution {\n public:\n  long long minimumReplacement(vector<int>& nums) {\n    long ans = 0;\n    int mx = nums.back();\n\n    for (int i = nums.size() - 2; i >= 0; --i) {\n      const int ops = (nums[i] - 1) / mx;\n      ans += ops;\n      mx = nums[i] / (ops + 1);\n    }\n\n    return ans;\n  }\n};\n", "2367": "class Solution {\n public:\n  int arithmeticTriplets(vector<int>& nums, int diff) {\n    constexpr int kMax = 200;\n    int ans = 0;\n    vector<bool> count(kMax + 1);\n\n    for (const int num : nums) {\n      if (num >= 2 * diff && count[num - diff] && count[num - 2 * diff])\n        ++ans;\n      count[num] = true;\n    }\n\n    return ans;\n  }\n};\n", "2368": "class Solution {\n public:\n  int reachableNodes(int n, vector<vector<int>>& edges,\n                     vector<int>& restricted) {\n    vector<vector<int>> tree(n);\n    vector<bool> seen(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    for (const int r : restricted)\n      seen[r] = true;\n\n    return dfs(tree, 0, seen);\n  }\n\n private:\n  int dfs(const vector<vector<int>>& tree, int u, vector<bool>& seen) {\n    if (seen[u])\n      return 0;\n\n    seen[u] = true;\n    int ans = 1;\n\n    for (const int v : tree[u])\n      ans += dfs(tree, v, seen);\n\n    return ans;\n  }\n};\n", "2369": "class Solution {\n public:\n  bool validPartition(vector<int>& nums) {\n    const int n = nums.size();\n    // dp[i] := true if there's a valid partition for the first i numbers\n    vector<bool> dp(n + 1);\n    dp[0] = true;\n    dp[2] = nums[0] == nums[1];\n\n    for (int i = 3; i <= n; ++i)\n      dp[i] = (dp[i - 2] && nums[i - 2] == nums[i - 1]) ||\n              (dp[i - 3] &&\n               ((nums[i - 3] == nums[i - 2] && nums[i - 2] == nums[i - 1]) ||\n                (nums[i - 3] + 1 == nums[i - 2] &&\n                 nums[i - 2] + 1 == nums[i - 1])));\n\n    return dp[n];\n  }\n};\n", "237": "class Solution {\n public:\n  void deleteNode(ListNode* node) {\n    node->val = node->next->val;\n    node->next = node->next->next;\n  }\n};\n", "2370": "class Solution {\n public:\n  int longestIdealString(string s, int k) {\n    // dp[i] := the longest subsequence that ends in ('a' + i)\n    vector<int> dp(26);\n\n    for (const char c : s) {\n      const int i = c - 'a';\n      dp[i] = 1 + getMaxReachable(dp, i, k);\n    }\n\n    return ranges::max(dp);\n  }\n\n private:\n  int getMaxReachable(const vector<int>& dp, int i, int k) {\n    const int first = max(0, i - k);\n    const int last = min(25, i + k);\n    int maxReachable = 0;\n    for (int j = first; j <= last; ++j)\n      maxReachable = max(maxReachable, dp[j]);\n    return maxReachable;\n  }\n};\n", "2371": "class Solution {\n public:\n  vector<vector<int>> minScore(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n    vector<array<int, 3>> valAndIndices;\n    vector<int> rows(m);  // rows[i] := the maximum used number so far\n    vector<int> cols(n);  // cols[j] := the maximum used number so far\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        valAndIndices.push_back({grid[i][j], i, j});\n\n    ranges::sort(valAndIndices);\n\n    for (const auto& [_, i, j] : valAndIndices) {\n      const int nextAvailable = max(rows[i], cols[j]) + 1;\n      ans[i][j] = nextAvailable;\n      rows[i] = nextAvailable;\n      cols[j] = nextAvailable;\n    }\n\n    return ans;\n  }\n};\n", "2373": "class Solution {\n public:\n  vector<vector<int>> largestLocal(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    vector<vector<int>> ans(n - 2, vector<int>(n - 2));\n\n    for (int i = 0; i < n - 2; ++i)\n      for (int j = 0; j < n - 2; ++j)\n        for (int x = i; x < i + 3; ++x)\n          for (int y = j; y < j + 3; ++y)\n            ans[i][j] = max(ans[i][j], grid[x][y]);\n\n    return ans;\n  }\n};\n", "2374": "class Solution {\n public:\n  int edgeScore(vector<int>& edges) {\n    vector<long> scores(edges.size());\n    for (int i = 0; i < edges.size(); ++i)\n      scores[edges[i]] += i;\n    return ranges::max_element(scores) - scores.begin();\n  }\n};\n", "2375": "class Solution {\n public:\n  string smallestNumber(string pattern) {\n    string ans;\n    stack<char> stack{{'1'}};\n\n    for (const char c : pattern) {\n      char maxSorFar = stack.top();\n      if (c == 'I')\n        while (!stack.empty()) {\n          maxSorFar = max(maxSorFar, stack.top());\n          ans += stack.top(), stack.pop();\n        }\n      stack.push(maxSorFar + 1);\n    }\n\n    while (!stack.empty())\n      ans += stack.top(), stack.pop();\n\n    return ans;\n  }\n};\n", "2376": "class Solution {\n public:\n  // Same as 1012. Numbers With Repeated Digits\n  int countSpecialNumbers(int n) {\n    const int digitSize = log10(n) + 1;\n    vector<vector<vector<int>>> mem(\n        digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));\n    return count(to_string(n), 0, 0, true, mem) - 1;  // - 0;\n  }\n\n private:\n  // Returns the number of special integers, considering the i-th digit, where\n  // `used` is the bitmask of the used digits, and `tight` indicates if the\n  // current digit is tightly bound.\n  int count(const string& s, int i, int used, bool tight,\n            vector<vector<vector<int>>>& mem) {\n    if (i == s.length())\n      return 1;\n    if (mem[i][used][tight] != -1)\n      return mem[i][used][tight];\n\n    int res = 0;\n    const int maxDigit = tight ? s[i] - '0' : 9;\n\n    for (int d = 0; d <= maxDigit; ++d) {\n      // `d` is used.\n      if (used >> d & 1)\n        continue;\n      // Use `d` now.\n      const bool nextTight = tight && (d == maxDigit);\n      if (used == 0 && d == 0)  // Don't count leading 0s as used.\n        res += count(s, i + 1, used, nextTight, mem);\n      else\n        res += count(s, i + 1, used | 1 << d, nextTight, mem);\n    }\n\n    return mem[i][used][tight] = res;\n  }\n};\n", "2378": "class Solution {\n public:\n  long long maxScore(vector<vector<int>>& edges) {\n    const int n = edges.size();\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (int i = 0; i < n; ++i) {\n      const int parent = edges[i][0];\n      const int weight = edges[i][1];\n      if (parent != -1)\n        graph[parent].emplace_back(i, weight);\n    }\n\n    const auto [takeRoot, notTakeRoot] = dfs(graph, 0);\n    return max(takeRoot, notTakeRoot);\n  }\n\n private:\n  // Returns (the maximum sum at u if we take one u->v edge,\n  //          the maximum sum at u if we don't take any child edge).\n  pair<long, long> dfs(const vector<vector<pair<int, int>>>& graph, int u) {\n    long bestEdge = 0;\n    long notTakeU = 0;\n\n    for (const auto& [v, w] : graph[u]) {\n      const auto [takeV, notTakeV] = dfs(graph, v);\n      bestEdge = max(bestEdge, w + notTakeV - takeV);\n      notTakeU += takeV;\n    }\n\n    return {bestEdge + notTakeU, notTakeU};\n  }\n};\n", "2379": "class Solution {\n public:\n  int minimumRecolors(string blocks, int k) {\n    int countB = 0;\n    int maxCountB = 0;\n\n    for (int i = 0; i < blocks.length(); ++i) {\n      if (blocks[i] == 'B')\n        ++countB;\n      if (i >= k && blocks[i - k] == 'B')\n        --countB;\n      maxCountB = max(maxCountB, countB);\n    }\n\n    return k - maxCountB;\n  }\n};\n", "238": "class Solution {\n public:\n  vector<int> productExceptSelf(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n, 1);\n\n    // Use ans as the prefix product array.\n    for (int i = 1; i < n; ++i)\n      ans[i] = ans[i - 1] * nums[i - 1];\n\n    int suffix = 1;  // suffix product\n    for (int i = n - 1; i >= 0; --i) {\n      ans[i] *= suffix;\n      suffix *= nums[i];\n    }\n\n    return ans;\n  }\n};\n", "2380": "class Solution {\n public:\n  int secondsToRemoveOccurrences(string s) {\n    int ans = 0;\n    int zeros = 0;\n\n    for (const char c : s)\n      if (c == '0')\n        ++zeros;\n      else if (zeros > 0)  // c == '1'\n        ans = max(ans + 1, zeros);\n\n    return ans;\n  }\n};\n", "2381": "class Solution {\n public:\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\n    int currShift = 0;\n    vector<int> line(s.length() + 1);\n\n    for (const vector<int>& shift : shifts) {\n      const int start = shift[0];\n      const int end = shift[1];\n      const int direction = shift[2];\n      const int diff = direction ? 1 : -1;\n      line[start] += diff;\n      line[end + 1] -= diff;\n    }\n\n    for (int i = 0; i < s.length(); ++i) {\n      currShift = (currShift + line[i]) % 26;\n      const int num = (s[i] - 'a' + currShift + 26) % 26;\n      s[i] = 'a' + num;\n    }\n\n    return s;\n  }\n};\n", "2382": "class Solution {\n public:\n  vector<long long> maximumSegmentSum(vector<int>& nums,\n                                      vector<int>& removeQueries) {\n    const int n = nums.size();\n    long maxSum = 0;\n    vector<long long> ans(n);\n    // For the segment [l, r], record its sum in sum[l] and sum[r]\n    vector<long long> sum(n);\n    // For the segment [l, r], record its count in count[l] and count[r]\n    vector<int> count(n);\n\n    for (int i = n - 1; i >= 0; --i) {\n      ans[i] = maxSum;\n      const int j = removeQueries[i];\n\n      // Calculate `segmentSum`.\n      const long leftSum = j > 0 ? sum[j - 1] : 0;\n      const long rightSum = j + 1 < n ? sum[j + 1] : 0;\n      const long segmentSum = nums[j] + leftSum + rightSum;\n\n      // Calculate `segmentCount`.\n      const int leftCount = j > 0 ? count[j - 1] : 0;\n      const int rightCount = j + 1 < n ? count[j + 1] : 0;\n      const int segmentCount = 1 + leftCount + rightCount;\n\n      // Update the sum and count of the segment [l, r].\n      const int l = j - leftCount;\n      const int r = j + rightCount;\n      sum[l] = segmentSum;\n      sum[r] = segmentSum;\n      count[l] = segmentCount;\n      count[r] = segmentCount;\n      maxSum = max(maxSum, segmentSum);\n    }\n\n    return ans;\n  }\n};\n", "2383": "class Solution {\n public:\n  int minNumberOfHours(int initialEnergy, int initialExperience,\n                       vector<int>& energy, vector<int>& experience) {\n    return getRequiredEnergy(initialEnergy, energy) +\n           getRequiredExperience(initialExperience, experience);\n  }\n\n private:\n  int getRequiredEnergy(int initialEnergy, const vector<int>& energy) {\n    return max(0,\n               accumulate(energy.begin(), energy.end(), 0) + 1 - initialEnergy);\n  }\n\n  int getRequiredExperience(int currentExperience,\n                            const vector<int>& experience) {\n    int requiredExperience = 0;\n    for (const int e : experience) {\n      if (e >= currentExperience) {\n        requiredExperience += e + 1 - currentExperience;\n        currentExperience += e + 1 - currentExperience;\n      }\n      currentExperience += e;\n    }\n    return requiredExperience;\n  }\n};\n", "2384": "class Solution {\n public:\n  string largestPalindromic(string num) {\n    unordered_map<char, int> count;\n\n    for (const char c : num)\n      ++count[c];\n\n    const string firstHalf = getFirstHalf(count);\n    const string mid = getMid(count);\n    const string ans = firstHalf + mid + reversed(firstHalf);\n    return ans.empty() ? \"0\" : ans;\n  }\n\n private:\n  string getFirstHalf(const unordered_map<char, int>& count) {\n    string firstHalf;\n    for (char c = '9'; c >= '0'; --c) {\n      const auto it = count.find(c);\n      if (it == count.cend())\n        continue;\n      const int freq = it->second;\n      firstHalf += string(freq / 2, c);\n    }\n    const int index = firstHalf.find_first_not_of('0');\n    return index == string::npos ? \"\" : firstHalf.substr(index);\n  }\n\n  string getMid(const unordered_map<char, int>& count) {\n    for (char c = '9'; c >= '0'; --c) {\n      const auto it = count.find(c);\n      if (it == count.cend())\n        continue;\n      const int freq = it->second;\n      if (freq % 2 == 1)\n        return string(1, c);\n    }\n    return \"\";\n  }\n\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n};\n", "2385": "class Solution {\n public:\n  int amountOfTime(TreeNode* root, int start) {\n    int ans = -1;\n    const unordered_map<int, vector<int>> graph = getGraph(root);\n    queue<int> q{{start}};\n    unordered_set<int> seen{start};\n\n    for (; !q.empty(); ++ans) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        if (!graph.contains(u))\n          continue;\n        for (const int v : graph.at(u)) {\n          if (seen.contains(v))\n            continue;\n          q.push(v);\n          seen.insert(v);\n        }\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  unordered_map<int, vector<int>> getGraph(TreeNode* root) {\n    unordered_map<int, vector<int>> graph;\n    queue<pair<TreeNode*, int>> q{{{root, -1}}};  // (node, parent)\n\n    while (!q.empty()) {\n      const auto [node, parent] = q.front();\n      q.pop();\n      if (parent != -1) {\n        graph[parent].push_back(node->val);\n        graph[node->val].push_back(parent);\n      }\n      if (node->left)\n        q.emplace(node->left, node->val);\n      if (node->right)\n        q.emplace(node->right, node->val);\n    }\n\n    return graph;\n  }\n};\n", "2386": "class Solution {\n public:\n  long long kSum(vector<int>& nums, int k) {\n    const long long maxSum = getMaxSum(nums);\n    const vector<int> absNums = getAbsNums(nums);\n    long long ans = maxSum;\n    // (the next maximum sum, the next index i)\n    using P = pair<long long, int>;\n    priority_queue<P> maxHeap;\n    maxHeap.emplace(maxSum - absNums[0], 0);\n\n    for (int j = 0; j < k - 1; ++j) {\n      const auto [nextMaxSum, i] = maxHeap.top();\n      maxHeap.pop();\n      ans = nextMaxSum;\n      if (i + 1 < absNums.size()) {\n        maxHeap.emplace(nextMaxSum - absNums[i + 1], i + 1);\n        maxHeap.emplace(nextMaxSum - absNums[i + 1] + absNums[i], i + 1);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  long long getMaxSum(const vector<int>& nums) {\n    long long maxSum = 0;\n    for (const int num : nums)\n      if (num > 0)\n        maxSum += num;\n    return maxSum;\n  }\n\n  vector<int> getAbsNums(const vector<int>& nums) {\n    vector<int> absNums;\n    for (const int num : nums)\n      absNums.push_back(abs(num));\n    ranges::sort(absNums);\n    return absNums;\n  }\n};\n", "2387": "class Solution {\n public:\n  int matrixMedian(vector<vector<int>>& grid) {\n    const int noGreaterThanMedianCount = grid.size() * grid[0].size() / 2 + 1;\n    int l = 1;\n    int r = 1'000'000;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numsNoGreaterThan(grid, m) >= noGreaterThanMedianCount)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numsNoGreaterThan(const vector<vector<int>>& grid, int m) {\n    int count = 0;\n    for (const vector<int>& row : grid)\n      count += ranges::upper_bound(row, m) - row.begin();\n    return count;\n  }\n};\n", "2389": "class Solution {\n public:\n  vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n    vector<int> ans;\n\n    ranges::sort(nums);\n\n    for (const int query : queries)\n      ans.push_back(numOfElementsLessThan(nums, query));\n\n    return ans;\n  }\n\n private:\n  int numOfElementsLessThan(const vector<int>& nums, int query) {\n    int sum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      sum += nums[i];\n      if (sum > query)\n        return i;\n    }\n    return nums.size();\n  }\n};\n", "239": "class Solution {\n public:\n  vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    vector<int> ans;\n    deque<int> maxQ;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      while (!maxQ.empty() && maxQ.back() < nums[i])\n        maxQ.pop_back();\n      maxQ.push_back(nums[i]);\n      if (i >= k && nums[i - k] == maxQ.front())  // out-of-bounds\n        maxQ.pop_front();\n      if (i >= k - 1)\n        ans.push_back(maxQ.front());\n    }\n\n    return ans;\n  }\n};\n", "2390": "class Solution {\n public:\n  string removeStars(string s) {\n    string ans;\n    for (const char c : s)\n      if (c == '*')\n        ans.pop_back();\n      else\n        ans.push_back(c);\n    return ans;\n  }\n};\n", "2391": "class Solution {\n public:\n  int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n    vector<int> prefix(travel.size());\n    partial_sum(travel.begin(), travel.end(), prefix.begin());\n    const int timeM = getTime(garbage, prefix, 'M');\n    const int timeP = getTime(garbage, prefix, 'P');\n    const int timeG = getTime(garbage, prefix, 'G');\n    return timeM + timeP + timeG;\n  }\n\n private:\n  int getTime(const vector<string>& garbage, const vector<int>& prefix,\n              char c) {\n    int characterCount = 0;\n    int lastIndex = -1;\n    for (int i = 0; i < garbage.size(); ++i) {\n      const string& s = garbage[i];\n      if (ranges::any_of(s, [c](const char g) { return g == c; }))\n        lastIndex = i;\n      characterCount += std::ranges::count(s, c);\n    }\n    return characterCount + (lastIndex <= 0 ? 0 : prefix[lastIndex - 1]);\n  }\n};\n", "2392": "class Solution {\n public:\n  vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions,\n                                  vector<vector<int>>& colConditions) {\n    const vector<int> rowOrder = topologicalSort(rowConditions, k);\n    if (rowOrder.empty())\n      return {};\n\n    const vector<int> colOrder = topologicalSort(colConditions, k);\n    if (colOrder.empty())\n      return {};\n\n    vector<vector<int>> ans(k, vector<int>(k));\n    vector<int> nodeToRowIndex(k + 1);\n\n    for (int i = 0; i < k; ++i)\n      nodeToRowIndex[rowOrder[i]] = i;\n\n    for (int j = 0; j < k; ++j) {\n      const int node = colOrder[j];\n      const int i = nodeToRowIndex[node];\n      ans[i][j] = node;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> topologicalSort(const vector<vector<int>>& conditions, int n) {\n    vector<int> order;\n    vector<vector<int>> graph(n + 1);\n    vector<int> inDegrees(n + 1);\n    queue<int> q;\n\n    // Build the graph.\n    for (const vector<int>& condition : conditions) {\n      const int u = condition[0];\n      const int v = condition[1];\n      graph[u].push_back(v);\n      ++inDegrees[v];\n    }\n\n    // Perform topological sorting.\n    for (int i = 1; i <= n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      order.push_back(u);\n      for (const int v : graph[u])\n        if (--inDegrees[v] == 0)\n          q.push(v);\n    }\n\n    return order.size() == n ? order : vector<int>();\n  }\n};\n", "2393": "class Solution {\n public:\n  long long countSubarrays(vector<int>& nums) {\n    long long ans = 0;\n\n    for (int i = 0, j = -1; i < nums.size(); ++i) {\n      if (i > 0 && nums[i] <= nums[i - 1])\n        j = i - 1;\n      ans += i - j;\n    }\n\n    return ans;\n  }\n};\n", "2395": "class Solution {\n public:\n  bool findSubarrays(vector<int>& nums) {\n    unordered_set<int> seen;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (!seen.insert(nums[i - 1] + nums[i]).second)\n        return true;\n\n    return false;\n  }\n};\n", "2396": "class Solution {\n public:\n  bool isStrictlyPalindromic(int n) {\n    return false;\n  }\n};\n", "2397": "class Solution {\n public:\n  int maximumRows(vector<vector<int>>& matrix, int numSelect) {\n    int ans = 0;\n    dfs(matrix, /*colIndex=*/0, numSelect, /*mask=*/0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& matrix, int colIndex, int leftColsCount,\n           int mask, int& ans) {\n    if (leftColsCount == 0) {\n      ans = max(ans, getAllZerosRowCount(matrix, mask));\n      return;\n    }\n    if (colIndex == matrix[0].size())\n      return;\n\n    // Choose this column.\n    dfs(matrix, colIndex + 1, leftColsCount - 1, mask | 1 << colIndex, ans);\n    // Don't choose this column.\n    dfs(matrix, colIndex + 1, leftColsCount, mask, ans);\n  }\n\n  int getAllZerosRowCount(const vector<vector<int>>& matrix, int mask) {\n    int count = 0;\n    for (const vector<int>& row : matrix) {\n      bool isAllZeros = true;\n      for (int i = 0; i < row.size(); ++i) {\n        if (row[i] == 1 && (mask >> i & 1) == 0) {\n          isAllZeros = false;\n          break;\n        }\n      }\n      if (isAllZeros)\n        ++count;\n    }\n    return count;\n  }\n};\n", "2398": "class Solution {\n public:\n  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts,\n                    long long budget) {\n    long cost = 0;\n    deque<int> maxQ;  // Stores `chargeTimes[i]`.\n\n    int j = 0;  // window's range := [i..j], so k = i - j + 1\n    for (int i = 0; i < chargeTimes.size(); ++i) {\n      cost += runningCosts[i];\n      while (!maxQ.empty() && maxQ.back() < chargeTimes[i])\n        maxQ.pop_back();\n      maxQ.push_back(chargeTimes[i]);\n      if (maxQ.front() + (i - j + 1) * cost > budget) {\n        if (maxQ.front() == chargeTimes[j])\n          maxQ.pop_front();\n        cost -= runningCosts[j++];\n      }\n    }\n\n    return chargeTimes.size() - j;\n  }\n};\n", "2399": "class Solution {\n public:\n  bool checkDistances(string s, vector<int>& distance) {\n    vector<int> firstSeenIndex(26, -1);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int j = s[i] - 'a';\n      int& prevIndex = firstSeenIndex[j];\n      if (prevIndex != -1 && i - prevIndex - 1 != distance[j])\n        return false;\n      prevIndex = i;\n    }\n\n    return true;\n  }\n};\n", "24": "class Solution {\n public:\n  ListNode* swapPairs(ListNode* head) {\n    const int length = getLength(head);\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n    ListNode* curr = head;\n\n    for (int i = 0; i < length / 2; ++i) {\n      ListNode* next = curr->next;\n      curr->next = next->next;\n      next->next = prev->next;\n      prev->next = next;\n      prev = curr;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n\n private:\n  int getLength(ListNode* head) {\n    int length = 0;\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n};\n", "240": "class Solution {\n public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int r = 0;\n    int c = matrix[0].size() - 1;\n\n    while (r < matrix.size() && c >= 0) {\n      if (matrix[r][c] == target)\n        return true;\n      if (matrix[r][c] > target)\n        --c;\n      else\n        ++r;\n    }\n\n    return false;\n  }\n};\n", "2400": "class Solution {\n public:\n  int numberOfWays(int startPos, int endPos, int k) {\n    // leftStep + rightStep = k\n    // rightStep - leftStep = endPos - startPos\n    //        2 * rightStep = k + endPos - startPos\n    //            rightStep = (k + endPos - startPos) / 2\n    const int val = k + endPos - startPos;\n    if (val < 0 || val % 2 == 1)\n      return 0;\n    const int rightStep = val / 2;\n    const int leftStep = k - rightStep;\n    if (leftStep < 0)\n      return 0;\n    return nCk(leftStep + rightStep, min(leftStep, rightStep));\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  int nCk(int n, int k) {\n    // dp[i] := C(n so far, i)\n    vector<int> dp(k + 1);\n    dp[0] = 1;\n\n    while (n-- > 0)  // Calculate n times.\n      for (int j = k; j > 0; --j) {\n        dp[j] += dp[j - 1];\n        dp[j] %= kMod;\n      }\n\n    return dp[k];\n  }\n};\n", "2401": "class Solution {\n public:\n  int longestNiceSubarray(vector<int>& nums) {\n    int ans = 0;\n    int used = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      while (used & nums[r])\n        used ^= nums[l++];\n      used |= nums[r];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "2402": "struct T {\n  long endTime;\n  int roomId;\n};\n\nclass Solution {\n public:\n  int mostBooked(int n, vector<vector<int>>& meetings) {\n    vector<int> count(n);\n\n    ranges::sort(meetings);\n\n    auto compare = [](const T& a, const T& b) {\n      return a.endTime == b.endTime ? a.roomId > b.roomId\n                                    : a.endTime > b.endTime;\n    };\n    priority_queue<T, vector<T>, decltype(compare)> occupied(compare);\n    priority_queue<int, vector<int>, greater<>> availableRoomIds;\n\n    for (int i = 0; i < n; ++i)\n      availableRoomIds.push(i);\n\n    for (const vector<int>& meeting : meetings) {\n      const int start = meeting[0];\n      const int end = meeting[1];\n      // Push meetings ending before this `meeting` in occupied to the\n      // `availableRoomsIds`.\n      while (!occupied.empty() && occupied.top().endTime <= start)\n        availableRoomIds.push(occupied.top().roomId), occupied.pop();\n      if (availableRoomIds.empty()) {\n        const auto [newStart, roomId] = occupied.top();\n        occupied.pop();\n        ++count[roomId];\n        occupied.push({newStart + (end - start), roomId});\n      } else {\n        const int roomId = availableRoomIds.top();\n        availableRoomIds.pop();\n        ++count[roomId];\n        occupied.push({end, roomId});\n      }\n    }\n\n    return ranges::max_element(count) - count.begin();\n  }\n};\n", "2403": "class Solution {\n public:\n  long long minimumTime(vector<int>& power) {\n    const int n = power.size();\n    const int maxMask = 1 << n;\n    // dp[i] := the minimum number of days needed to defeat the monsters, where\n    // i is the bitmask of the monsters\n    vector<long> dp(maxMask, LONG_MAX);\n    dp[0] = 0;\n\n    for (unsigned mask = 1; mask < maxMask; ++mask) {\n      const int currentGain = popcount(mask);\n      for (int i = 0; i < n; ++i)\n        if (mask >> i & 1)\n          dp[mask] =\n              min(dp[mask],\n                  dp[mask & ~(1 << i)] +\n                      static_cast<int>(ceil(power[i] * 1.0 / currentGain)));\n    }\n\n    return dp.back();\n  }\n};\n", "2404": "class Solution {\n public:\n  int mostFrequentEven(vector<int>& nums) {\n    int ans = -1;\n    unordered_map<int, int> count;\n\n    for (const int num : nums) {\n      if (num % 2 == 1)\n        continue;\n      const int newCount = ++count[num];\n      const int maxCount = count[ans];\n      if (newCount > maxCount || newCount == maxCount && num < ans)\n        ans = num;\n    }\n\n    return ans;\n  }\n};\n", "2405": "class Solution {\n public:\n  int partitionString(string s) {\n    int ans = 1;\n    int used = 0;\n\n    for (const char c : s) {\n      const int i = c - 'a';\n      if (used >> i & 1) {\n        used = 1 << i;\n        ++ans;\n      } else {\n        used |= 1 << i;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2406": "class Solution {\n public:\n  // Similar to 253. Meeting Rooms II\n  int minGroups(vector<vector<int>>& intervals) {\n    // Stores `right`s.\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    ranges::sort(intervals);\n\n    for (const vector<int>& interval : intervals) {\n      // There's no overlap, so we can reuse the same group.\n      if (!minHeap.empty() && interval[0] > minHeap.top())\n        minHeap.pop();\n      minHeap.push(interval[1]);\n    }\n\n    return minHeap.size();\n  }\n};\n", "2407": "struct SegmentTreeNode {\n  int lo;\n  int hi;\n  int maxLength;\n  std::unique_ptr<SegmentTreeNode> left;\n  std::unique_ptr<SegmentTreeNode> right;\n  // maxLength := the maximum length of LIS ending in [lo..hi]\n  SegmentTreeNode(int lo, int hi, int maxLength,\n                  std::unique_ptr<SegmentTreeNode> left = nullptr,\n                  std::unique_ptr<SegmentTreeNode> right = nullptr)\n      : lo(lo),\n        hi(hi),\n        maxLength(maxLength),\n        left(std::move(left)),\n        right(std::move(right)) {}\n};\n\nclass SegmentTree {\n public:\n  explicit SegmentTree() : root(make_unique<SegmentTreeNode>(0, 1e5 + 1, 0)) {}\n\n  void updateRange(int i, int j, int maxLength) {\n    update(root, i, j, maxLength);\n  }\n\n  // Returns the maximum length of LIS ending in [i..j].\n  int queryRange(int i, int j) {\n    return query(root, i, j);\n  }\n\n private:\n  std::unique_ptr<SegmentTreeNode> root;\n\n  void update(std::unique_ptr<SegmentTreeNode>& root, int i, int j,\n              int maxLength) {\n    if (root->lo == i && root->hi == j) {\n      root->maxLength = maxLength;\n      root->left = nullptr;\n      root->right = nullptr;\n      return;\n    }\n    const int mid = root->lo + (root->hi - root->lo) / 2;\n    if (root->left == nullptr) {\n      root->left = make_unique<SegmentTreeNode>(root->lo, mid, root->maxLength);\n      root->right =\n          make_unique<SegmentTreeNode>(mid + 1, root->hi, root->maxLength);\n    }\n    if (j <= mid)\n      update(root->left, i, j, maxLength);\n    else if (i > mid)\n      update(root->right, i, j, maxLength);\n    else {\n      update(root->left, i, mid, maxLength);\n      update(root->right, mid + 1, j, maxLength);\n    }\n    root->maxLength = merge(root->left->maxLength, root->right->maxLength);\n  }\n\n  int query(std::unique_ptr<SegmentTreeNode>& root, int i, int j) {\n    if (root->left == nullptr)\n      return root->maxLength;\n    if (root->lo == i && root->hi == j)\n      return root->maxLength;\n    const int mid = root->lo + (root->hi - root->lo) / 2;\n    if (j <= mid)\n      return query(root->left, i, j);\n    if (i > mid)\n      return query(root->right, i, j);\n    return merge(query(root->left, i, mid), query(root->right, mid + 1, j));\n  }\n\n  int merge(int left, int right) const {\n    return max(left, right);\n  };\n};\n\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums, int k) {\n    int ans = 1;\n    SegmentTree tree;\n\n    for (const int num : nums) {\n      const int left = max(1, num - k);\n      const int right = num - 1;\n      // the maximum length of LIS ending in [left..right] + the current number\n      const int maxLength = tree.queryRange(left, right) + 1;\n      ans = max(ans, maxLength);\n      tree.updateRange(num, num, maxLength);\n    }\n\n    return ans;\n  }\n};\n", "2408": "class SQL {\n public:\n  void insertRow(string name, vector<string> row) {\n    db[name].push_back(row);\n  }\n\n  void deleteRow(string name, int rowId) {}\n\n  string selectCell(string name, int rowId, int columnId) {\n    return db[name][rowId - 1][columnId - 1];\n  }\n\n private:\n  unordered_map<string, vector<vector<string>>> db;\n};\n", "2409": "class Solution {\n public:\n  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob,\n                        string leaveBob) {\n    const int arriveA = toDays(arriveAlice);\n    const int leaveA = toDays(leaveAlice);\n    const int arriveB = toDays(arriveBob);\n    const int leaveB = toDays(leaveBob);\n    int ans = 0;\n\n    for (int day = 1; day <= 365; ++day)\n      if (arriveA <= day && day <= leaveA && arriveB <= day && day <= leaveB)\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  const vector<int> days{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n  int toDays(const string& s) {\n    const int month = (s[0] - '0') * 10 + (s[1] - '0');\n    const int day = (s[3] - '0') * 10 + (s[4] - '0');\n    int prevDays = 0;\n    for (int m = 1; m < month; ++m)\n      prevDays += days[m];\n    return prevDays + day;\n  }\n};\n", "241": "class Solution {\n public:\n  vector<int> diffWaysToCompute(string expression) {\n    return ways(expression, {});\n  }\n\n private:\n  vector<int> ways(const string& s, unordered_map<string, vector<int>>&& mem) {\n    if (const auto it = mem.find(s); it != mem.cend())\n      return it->second;\n\n    vector<int> ans;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (ispunct(s[i]))\n        for (const int a : ways(s.substr(0, i), std::move(mem)))\n          for (const int b : ways(s.substr(i + 1), std::move(mem)))\n            if (s[i] == '+')\n              ans.push_back(a + b);\n            else if (s[i] == '-')\n              ans.push_back(a - b);\n            else\n              ans.push_back(a * b);\n\n    return mem[s] = (ans.empty() ? vector<int>{stoi(s)} : ans);\n  }\n};\n", "2410": "class Solution {\n public:\n  int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\n    int ans = 0;\n\n    ranges::sort(players);\n    ranges::sort(trainers);\n\n    for (int i = 0; i < trainers.size(); ++i)\n      if (players[ans] <= trainers[i] && ++ans == players.size())\n        return ans;\n\n    return ans;\n  }\n};\n", "2411": "class Solution {\n public:\n  vector<int> smallestSubarrays(vector<int>& nums) {\n    constexpr int kMaxBit = 30;\n    vector<int> ans(nums.size(), 1);\n    // closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    vector<int> closest(kMaxBit);\n\n    for (int i = nums.size() - 1; i >= 0; --i)\n      for (int j = 0; j < kMaxBit; ++j) {\n        if (nums[i] >> j & 1)\n          closest[j] = i;\n        ans[i] = max(ans[i], closest[j] - i + 1);\n      }\n\n    return ans;\n  }\n};\n", "2412": "class Solution {\n public:\n  long long minimumMoney(vector<vector<int>>& transactions) {\n    long ans = 0;\n    long losses = 0;\n\n    // Before picking the final transaction, perform any transaction that raises\n    // the required money.\n    for (const vector<int>& t : transactions) {\n      const int cost = t[0];\n      const int cashback = t[1];\n      losses += max(0, cost - cashback);\n    }\n\n    // Now, pick a transaction to be the final one.\n    for (const vector<int>& t : transactions) {\n      const int cost = t[0];\n      const int cashback = t[1];\n      if (cost > cashback)\n        // The losses except this transaction: losses - (cost - cashback), so\n        // add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback);\n      else\n        // The losses except this transaction: losses, so add the cost of this\n        // transaction = losses + cost.\n        ans = max(ans, losses + cost);\n    }\n\n    return ans;\n  }\n};\n", "2413": "class Solution {\n public:\n  int smallestEvenMultiple(int n) {\n    return n * (n % 2 + 1);\n  }\n};\n", "2414": "class Solution {\n public:\n  int longestContinuousSubstring(string s) {\n    int ans = 1;\n    int runningLen = 1;\n\n    for (int i = 1; i < s.length(); ++i)\n      if (s[i] == s[i - 1] + 1)\n        ans = max(ans, ++runningLen);\n      else\n        runningLen = 1;\n\n    return ans;\n  }\n};\n", "2415": "class Solution {\n public:\n  TreeNode* reverseOddLevels(TreeNode* root) {\n    dfs(root->left, root->right, true);\n    return root;\n  }\n\n private:\n  void dfs(TreeNode* left, TreeNode* right, bool isOddLevel) {\n    if (left == nullptr)\n      return;\n    if (isOddLevel)\n      swap(left->val, right->val);\n    dfs(left->left, right->right, !isOddLevel);\n    dfs(left->right, right->left, !isOddLevel);\n  }\n};\n", "2416": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int count = 0;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  vector<int> sumPrefixScores(vector<string>& words) {\n    vector<int> ans;\n\n    for (const string& word : words)\n      insert(word);\n\n    for (const string& word : words)\n      ans.push_back(getScore(word));\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      ++node->count;\n    }\n  }\n\n  int getScore(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    int score = 0;\n    for (const char c : word) {\n      node = node->children[c - 'a'];\n      score += node->count;\n    }\n    return score;\n  }\n};\n", "2417": "class Solution {\n public:\n  int closestFair(int n) {\n    const int digitsCount = to_string(n).length();\n    return digitsCount % 2 == 0 ? getEvenDigits(n) : getOddDigits(digitsCount);\n  }\n\n private:\n  long getOddDigits(int digitsCount) {\n    const int zeros = (digitsCount + 1) / 2;\n    const int ones = (digitsCount - 1) / 2;\n    return stoi('1' + string(zeros, '0') + string(ones, '1'));\n  }\n\n  int getEvenDigits(int n) {\n    const int digitsCount = to_string(n).length();\n    const long maxNum = stol('1' + string(digitsCount, '0'));\n    for (long num = n; num < maxNum; ++num)\n      if (isValidNum(num))\n        return num;\n    return getOddDigits(digitsCount + 1);\n  }\n\n  bool isValidNum(long num) {\n    int count = 0;\n    for (const char c : to_string(num))\n      count += (c - '0') % 2 == 0 ? 1 : -1;\n    return count == 0;\n  }\n};\n", "2418": "class Solution {\n public:\n  vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\n    vector<string> ans;\n    vector<pair<int, string>> heightAndNames;\n\n    for (int i = 0; i < names.size(); ++i)\n      heightAndNames.emplace_back(heights[i], names[i]);\n\n    ranges::sort(heightAndNames, greater<>());\n\n    for (const auto& [_, name] : heightAndNames)\n      ans.push_back(name);\n\n    return ans;\n  }\n};\n", "2419": "class Solution {\n public:\n  int longestSubarray(vector<int>& nums) {\n    int ans = 0;\n    int maxIndex = 0;\n    int sameNumLength = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == nums[maxIndex]) {\n        ans = max(ans, ++sameNumLength);\n      } else if (nums[i] > nums[maxIndex]) {\n        maxIndex = i;\n        sameNumLength = 1;\n        ans = 1;\n      } else {\n        sameNumLength = 0;\n      }\n\n    return ans;\n  }\n};\n", "242": "class Solution {\n public:\n  bool isAnagram(string s, string t) {\n    if (s.length() != t.length())\n      return false;\n\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : t) {\n      if (count[c - 'a'] == 0)\n        return false;\n      --count[c - 'a'];\n    }\n\n    return true;\n  }\n};\n", "2420": "class Solution {\n public:\n  // Same as 2100. Find Good Days to Rob the Bank\n  vector<int> goodIndices(vector<int>& nums, int k) {\n    const int n = nums.size();\n    vector<int> ans;\n    // dec[i] := 1 + the number of continuous decreasing numbers before i\n    vector<int> dec(n, 1);\n    // inc[i] := 1 + the number of continuous increasing numbers after i\n    vector<int> inc(n, 1);\n\n    for (int i = 1; i < n; ++i)\n      if (nums[i - 1] >= nums[i])\n        dec[i] = dec[i - 1] + 1;\n\n    for (int i = n - 2; i >= 0; --i)\n      if (nums[i] <= nums[i + 1])\n        inc[i] = inc[i + 1] + 1;\n\n    for (int i = k; i < n - k; ++i)\n      if (dec[i - 1] >= k && inc[i + 1] >= k)\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "2421": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n    const int n = vals.size();\n    int ans = n;\n    UnionFind uf(n);\n    vector<vector<int>> tree(n);\n    map<int, vector<int>> valToNodes;\n\n    for (int i = 0; i < vals.size(); ++i)\n      valToNodes[vals[i]].push_back(i);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      if (vals[v] <= vals[u])\n        tree[u].push_back(v);\n      if (vals[u] <= vals[v])\n        tree[v].push_back(u);\n    }\n\n    for (const auto& [val, nodes] : valToNodes) {\n      for (const int u : nodes)\n        for (const int v : tree[u])\n          uf.unionByRank(u, v);\n      unordered_map<int, int> rootCount;\n      for (const int u : nodes)\n        ++rootCount[uf.find(u)];\n      // For each group, C(count, 2) := count * (count - 1) / 2\n      for (const auto& [_, count] : rootCount)\n        ans += count * (count - 1) / 2;\n    }\n\n    return ans;\n  }\n};\n", "2422": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    int ans = 0;\n    int l = 0;\n    int r = nums.size() - 1;\n    long leftSum = nums.front();\n    long rightSum = nums.back();\n\n    while (l < r)\n      if (leftSum < rightSum) {\n        leftSum += nums[++l];\n        ++ans;\n      } else if (leftSum > rightSum) {\n        rightSum += nums[--r];\n        ++ans;\n      } else {  // leftSum == rightSum\n        leftSum = nums[++l];\n        rightSum = nums[--r];\n      }\n\n    return ans;\n  }\n};\n", "2423": "class Solution {\n public:\n  bool equalFrequency(string word) {\n    vector<int> count(26);\n\n    for (const char c : word)\n      ++count[c - 'a'];\n\n    // Try to remove each letter, then check if the frequency of all the letters\n    // in `word` are equal.\n    for (const char c : word) {\n      --count[c - 'a'];\n      if (equalFreq(count))\n        return true;\n      ++count[c - 'a'];\n    }\n\n    return false;\n  }\n\n private:\n  static constexpr int kMax = 101;\n\n  bool equalFreq(const vector<int>& count) {\n    int minfreq = kMax;\n    int maxfreq = 0;\n    for (const int freq : count)\n      if (freq > 0) {\n        minfreq = min(minfreq, freq);\n        maxfreq = max(maxfreq, freq);\n      }\n    return minfreq == maxfreq;\n  }\n};\n", "2424": "class LUPrefix {\n public:\n  LUPrefix(int n) {}\n\n  void upload(int video) {\n    seen.insert(video);\n    while (seen.contains(longestPrefix + 1))\n      ++longestPrefix;\n  }\n\n  int longest() {\n    return longestPrefix;\n  }\n\n private:\n  unordered_set<int> seen;\n  int longestPrefix = 0;\n};\n", "2425": "class Solution {\n public:\n  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\n    // If the size of nums1 is m and the size of nums2 is n, then each number in\n    // nums1 is repeated n times and each number in nums2 is repeated m times.\n    const int xors1 = accumulate(nums1.begin(), nums1.end(), 0, bit_xor<>());\n    const int xors2 = accumulate(nums2.begin(), nums2.end(), 0, bit_xor<>());\n    return (nums1.size() % 2 * xors2) ^ (nums2.size() % 2 * xors1);\n  }\n};\n", "2426": "class Solution {\n public:\n  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\n    // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\n    // nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\n    // Define arr[i] := nums1[i] - nums2[i] -> arr[i] <= arr[j] + diff\n    vector<int> arr;\n\n    for (int i = 0; i < nums1.size(); ++i)\n      arr.push_back(nums1[i] - nums2[i]);\n\n    long ans = 0;\n    mergeSort(arr, 0, arr.size() - 1, diff, ans);\n    return ans;\n  }\n\n private:\n  void mergeSort(vector<int>& arr, int l, int r, int diff, long& ans) {\n    if (l >= r)\n      return;\n\n    const int m = (l + r) / 2;\n    mergeSort(arr, l, m, diff, ans);\n    mergeSort(arr, m + 1, r, diff, ans);\n    merge(arr, l, m, r, diff, ans);\n  }\n\n  void merge(vector<int>& arr, int l, int m, int r, int diff, long& ans) {\n    const int lo = m + 1;\n    int hi = m + 1;  // the first index s.t. arr[i] <= arr[hi] + diff\n\n    // For each index i in the range [l, m], add `r - hi + 1` to `ans`.\n    for (int i = l; i <= m; ++i) {\n      while (hi <= r && arr[i] > arr[hi] + diff)\n        ++hi;\n      ans += r - hi + 1;\n    }\n\n    vector<int> sorted(r - l + 1);\n    int k = 0;      // sorted's index\n    int i = l;      // left's index\n    int j = m + 1;  // right's index\n\n    while (i <= m && j <= r)\n      if (arr[i] < arr[j])\n        sorted[k++] = arr[i++];\n      else\n        sorted[k++] = arr[j++];\n\n    // Put the possible remaining left part into the sorted array.\n    while (i <= m)\n      sorted[k++] = arr[i++];\n\n    // Put the possible remaining right part into the sorted array.\n    while (j <= r)\n      sorted[k++] = arr[j++];\n\n    copy(sorted.begin(), sorted.end(), arr.begin() + l);\n  }\n};\n", "2427": "class Solution {\n public:\n  int commonFactors(int a, int b) {\n    int ans = 1;\n    const int gcd = __gcd(a, b);\n    for (int i = 2; i <= gcd; ++i)\n      if (a % i == 0 && b % i == 0)\n        ++ans;\n    return ans;\n  }\n};\n", "2428": "class Solution {\n public:\n  int maxSum(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 1; i + 1 < grid.size(); ++i)\n      for (int j = 1; j + 1 < grid[0].size(); ++j)\n        ans =\n            max(ans, grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] +\n                         grid[i][j] + grid[i + 1][j - 1] + grid[i + 1][j] +\n                         grid[i + 1][j + 1]);\n\n    return ans;\n  }\n};\n", "2429": "class Solution {\n public:\n  int minimizeXor(unsigned num1, unsigned num2) {\n    constexpr int kMaxBit = 30;\n    int bits = popcount(num2);\n    // Can turn off all the bits in `num1`.\n    if (popcount(num1) == bits)\n      return num1;\n\n    int ans = 0;\n\n    // Turn off the MSB if we have `bits` quota.\n    for (int i = kMaxBit; i >= 0; --i)\n      if (num1 >> i & 1) {\n        ans |= 1 << i;\n        if (--bits == 0)\n          return ans;\n      }\n\n    // Turn on the LSB if we still have `bits`.\n    for (int i = 0; i < kMaxBit; ++i)\n      if ((num1 >> i & 1) == 0) {\n        ans |= 1 << i;\n        if (--bits == 0)\n          return ans;\n      }\n\n    return ans;\n  }\n};\n", "243": "class Solution {\n public:\n  int shortestDistance(vector<string>& wordsDict, string word1, string word2) {\n    int ans = wordsDict.size();\n    int index1 = -1;  // wordsDict[index1] == word1\n    int index2 = -1;  // wordsDict[index2] == word2\n\n    for (int i = 0; i < wordsDict.size(); ++i) {\n      if (wordsDict[i] == word1) {\n        index1 = i;\n        if (index2 != -1)\n          ans = min(ans, index1 - index2);\n      }\n      if (wordsDict[i] == word2) {\n        index2 = i;\n        if (index1 != -1)\n          ans = min(ans, index2 - index1);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2430": "class Solution {\n public:\n  int deleteString(string s) {\n    const int n = s.length();\n    // lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    vector<vector<int>> lcs(n + 1, vector<int>(n + 1));\n    // dp[i] := the maximum number of operations needed to delete s[i..n)\n    vector<int> dp(n, 1);\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i + 1; j < n; ++j) {\n        if (s[i] == s[j])\n          lcs[i][j] = lcs[i + 1][j + 1] + 1;\n        if (lcs[i][j] >= j - i)\n          dp[i] = max(dp[i], dp[j] + 1);\n      }\n\n    return dp[0];\n  }\n};\n", "2431": "class Solution {\n public:\n  int maxTastiness(vector<int>& price, vector<int>& tastiness, int maxAmount,\n                   int maxCoupons) {\n    // dp[j][k] := the maximum tastiness of price so far with j amount of money\n    // and k coupons\n    vector<vector<int>> dp(maxAmount + 1, vector<int>(maxCoupons + 1));\n\n    for (int i = 0; i < price.size(); ++i)\n      for (int j = maxAmount; j >= price[i] / 2; --j)\n        for (int k = maxCoupons; k >= 0; --k) {\n          const int buyWithCoupon =\n              k == 0 ? 0 : dp[j - price[i] / 2][k - 1] + tastiness[i];\n          const int buyWithoutCoupon =\n              j < price[i] ? 0 : dp[j - price[i]][k] + tastiness[i];\n          dp[j][k] = max({dp[j][k], buyWithCoupon, buyWithoutCoupon});\n        }\n\n    return dp[maxAmount][maxCoupons];\n  }\n};\n", "2432": "class Solution {\n public:\n  int hardestWorker(int n, vector<vector<int>>& logs) {\n    int ans = logs[0][0];\n    int maxWorkingTime = logs[0][1];\n\n    for (int i = 1; i < logs.size(); ++i) {\n      const int id = logs[i][0];\n      const int workingTime = logs[i][1] - logs[i - 1][1];\n      if (workingTime > maxWorkingTime) {\n        ans = id;\n        maxWorkingTime = workingTime;\n      } else if (workingTime == maxWorkingTime) {\n        ans = min(ans, id);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2433": "class Solution {\n public:\n  vector<int> findArray(vector<int>& pref) {\n    vector<int> ans(pref.size());\n\n    ans[0] = pref[0];\n    for (int i = 1; i < ans.size(); ++i)\n      ans[i] = pref[i] ^ pref[i - 1];\n\n    return ans;\n  }\n};\n", "2434": "class Solution {\n public:\n  string robotWithString(string s) {\n    string ans;\n    vector<int> count(26);\n    stack<char> stack;\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : s) {\n      stack.push(c);\n      --count[c - 'a'];\n      const char minChar = getMinChar(count);\n      while (!stack.empty() && stack.top() <= minChar)\n        ans += stack.top(), stack.pop();\n    }\n\n    while (!stack.empty())\n      ans += stack.top(), stack.pop();\n\n    return ans;\n  }\n\n private:\n  char getMinChar(const vector<int>& count) {\n    for (int i = 0; i < 26; ++i)\n      if (count[i])\n        return 'a' + i;\n    return 'a';\n  }\n};\n", "2435": "class Solution {\n public:\n  int numberOfPaths(vector<vector<int>>& grid, int k) {\n    constexpr int kMod = 1'000'000'007;\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dp[i][j][sum] : = the number of paths to(i, j), where the sum / k == sum\n    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k)));\n    dp[0][0][grid[0][0] % k] = 1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int sum = 0; sum < k; ++sum) {\n          const int newSum = (sum + grid[i][j]) % k;\n          if (i > 0)\n            dp[i][j][newSum] += dp[i - 1][j][sum];\n          if (j > 0)\n            dp[i][j][newSum] += dp[i][j - 1][sum];\n          dp[i][j][newSum] %= kMod;\n        }\n\n    return dp[m - 1][n - 1][0];\n  }\n};\n", "2436": "class Solution {\n public:\n  int minimumSplits(vector<int>& nums) {\n    int ans = 1;\n    int gcd = nums[0];\n\n    for (const int num : nums) {\n      const int newGcd = __gcd(gcd, num);\n      if (newGcd > 1) {\n        gcd = newGcd;\n      } else {\n        gcd = num;\n        ++ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2437": "class Solution {\n public:\n  int countTime(string time) {\n    int ans = 1;\n    if (time[3] == '?')\n      ans *= 6;\n    if (time[4] == '?')\n      ans *= 10;\n\n    if (time[0] == '?' && time[1] == '?')\n      return ans * 24;\n    if (time[0] == '?')\n      return time[1] < '4' ? ans * 3 : ans * 2;\n    if (time[1] == '?')\n      return time[0] == '2' ? ans * 4 : ans * 10;\n    return ans;\n  }\n};\n", "2438": "class Solution {\n public:\n  vector<int> productQueries(int n, vector<vector<int>>& queries) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMaxBit = 30;\n    vector<int> ans;\n    vector<int> pows;\n\n    for (int i = 0; i < kMaxBit; ++i)\n      if (n >> i & 1)\n        pows.push_back(1 << i);\n\n    for (const vector<int>& query : queries) {\n      const int left = query[0];\n      const int right = query[1];\n      long prod = 1;\n      for (int i = left; i <= right; ++i) {\n        prod *= pows[i];\n        prod %= kMod;\n      }\n      ans.push_back(prod);\n    }\n\n    return ans;\n  }\n};\n", "2439": "class Solution {\n public:\n  int minimizeArrayValue(vector<int>& nums) {\n    long ans = 0;\n    long prefix = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      const long prefixAvg = ceil(prefix / static_cast<double>(i + 1));\n      ans = max(ans, prefixAvg);\n    }\n\n    return ans;\n  }\n};\n", "244": "class WordDistance {\n public:\n  WordDistance(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i)\n      wordToIndices[words[i]].push_back(i);\n  }\n\n  int shortest(string word1, string word2) {\n    const vector<int> indices1 = wordToIndices[word1];\n    const vector<int> indices2 = wordToIndices[word2];\n    int ans = INT_MAX;\n\n    for (int i = 0, j = 0; i < indices1.size() && j < indices2.size();) {\n      ans = min(ans, abs(indices1[i] - indices2[j]));\n      if (indices1[i] < indices2[j])\n        ++i;\n      else\n        ++j;\n    }\n\n    return ans;\n  }\n\n private:\n  unordered_map<string, vector<int>> wordToIndices;\n};\n", "2440": "class Solution {\n public:\n  int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\n    const int n = nums.size();\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    vector<vector<int>> tree(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    for (int i = n; i > 1; --i)\n      // Split the tree into i parts, i.e. delete (i - 1) edges.\n      if (sum % i == 0 && dfs(nums, tree, 0, sum / i, vector<bool>(n)) == 0)\n        return i - 1;\n\n    return 0;\n  }\n\n private:\n  static constexpr int kMax = 1'000'000'000;\n\n  // Returns the sum of the subtree rooted at u substracting the sum of the\n  // deleted subtrees.\n  int dfs(const vector<int>& nums, const vector<vector<int>>& tree, int u,\n          int target, vector<bool>&& seen) {\n    int sum = nums[u];\n    seen[u] = true;\n\n    for (const int v : tree[u]) {\n      if (seen[v])\n        continue;\n      sum += dfs(nums, tree, v, target, std::move(seen));\n      if (sum > target)\n        return kMax;\n    }\n\n    // Delete the tree that has sum == target.\n    if (sum == target)\n      return 0;\n    return sum;\n  }\n};\n", "2441": "class Solution {\n public:\n  int findMaxK(vector<int>& nums) {\n    int ans = -1;\n    unordered_set<int> seen;\n\n    for (const int num : nums)\n      if (seen.contains(-num))\n        ans = max(ans, abs(num));\n      else\n        seen.insert(num);\n\n    return ans;\n  }\n};\n", "2442": "class Solution {\n public:\n  int countDistinctIntegers(vector<int>& nums) {\n    unordered_set<int> numsSet{nums.begin(), nums.end()};\n\n    for (const int num : nums)\n      numsSet.insert(reversed(num));\n\n    return numsSet.size();\n  }\n\n private:\n  int reversed(int num) {\n    int ans = 0;\n    while (num > 0) {\n      ans = ans * 10 + num % 10;\n      num /= 10;\n    }\n    return ans;\n  }\n};\n", "2443": "class Solution {\n public:\n  bool sumOfNumberAndReverse(int num) {\n    for (int i = num / 2; i <= num; ++i)\n      if (num == i + reversed(i))\n        return true;\n    return false;\n  }\n\n private:\n  int reversed(int num) {\n    int ans = 0;\n    while (num > 0) {\n      ans = ans * 10 + num % 10;\n      num /= 10;\n    }\n    return ans;\n  }\n};\n", "2444": "class Solution {\n public:\n  long long countSubarrays(vector<int>& nums, int minK, int maxK) {\n    long ans = 0;\n    int j = -1;\n    int prevMinKIndex = -1;\n    int prevMaxKIndex = -1;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] < minK || nums[i] > maxK)\n        j = i;\n      if (nums[i] == minK)\n        prevMinKIndex = i;\n      if (nums[i] == maxK)\n        prevMaxKIndex = i;\n      // Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      // start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);\n    }\n\n    return ans;\n  }\n};\n", "2445": "class Solution {\n public:\n  int numberOfNodes(int n, vector<int>& queries) {\n    // flipped[i] := true if we should flip all the values in the subtree rooted\n    // at i\n    vector<bool> flipped(n + 1);\n\n    for (const int query : queries)\n      flipped[query] = flipped[query] ^ true;\n\n    return dfs(1, 0, n, flipped);\n  }\n\n private:\n  int dfs(int label, int value, int n, const vector<bool>& flipped) {\n    if (label > n)\n      return 0;\n    value ^= flipped[label];\n    return value +  //\n           dfs(label * 2, value, n, flipped) +\n           dfs(label * 2 + 1, value, n, flipped);\n  }\n};\n", "2446": "class Solution {\n public:\n  bool haveConflict(vector<string>& event1, vector<string>& event2) {\n    return event1[0] <= event2[1] && event2[0] <= event1[1];\n  }\n};\n", "2447": "class Solution {\n public:\n  int subarrayGCD(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, int> gcds;\n\n    for (const int num : nums)\n      if (num % k == 0) {\n        unordered_map<int, int> nextGcds{{num, 1}};\n        for (const auto& [prevGcd, count] : gcds)\n          nextGcds[gcd(prevGcd, num)] += count;\n        ans += nextGcds[k];\n        gcds = std::move(nextGcds);\n      } else {\n        // The GCD streak stops, so fresh start from the next number.\n        gcds.clear();\n      }\n\n    return ans;\n  }\n};\n", "2448": "class Solution {\n public:\n  long long minCost(vector<int>& nums, vector<int>& cost) {\n    long ans = 0;\n    int l = ranges::min(nums);\n    int r = ranges::max(nums);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const long cost1 = getCost(nums, cost, m);\n      const long cost2 = getCost(nums, cost, m + 1);\n      ans = min(cost1, cost2);\n      if (cost1 < cost2)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  long getCost(const vector<int>& nums, const vector<int>& cost, int target) {\n    long res = 0;\n    for (int i = 0; i < nums.size(); ++i)\n      res += static_cast<long>(abs(nums[i] - target)) * cost[i];\n    return res;\n  }\n};\n", "2449": "class Solution {\n public:\n  long long makeSimilar(vector<int>& nums, vector<int>& target) {\n    long ans = 0;\n    vector<vector<int>> A(2);  // A[0] := even nums, A[1] := odd nums\n    vector<vector<int>> B(2);  // B[0] := even target, B[1] := odd nums\n\n    for (const int num : nums)\n      A[num % 2].push_back(num);\n\n    for (const int num : target)\n      B[num % 2].push_back(num);\n\n    ranges::sort(A[0]);\n    ranges::sort(A[1]);\n    ranges::sort(B[0]);\n    ranges::sort(B[1]);\n\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < A[i].size(); ++j)\n        ans += abs(A[i][j] - B[i][j]) / 2;\n\n    return ans / 2;\n  }\n};\n", "245": "class Solution {\n public:\n  int shortestWordDistance(vector<string>& words, string word1, string word2) {\n    const bool isSame = word1 == word2;\n    int ans = INT_MAX;\n    // If word1 == word2, index1 is the newest index.\n    int index1 = words.size();\n    // If word1 == word2, index2 is the previous index.\n    int index2 = -words.size();\n\n    for (int i = 0; i < words.size(); ++i) {\n      if (words[i] == word1) {\n        if (isSame)\n          index2 = index1;\n        index1 = i;\n      } else if (words[i] == word2) {\n        index2 = i;\n      }\n      ans = min(ans, abs(index1 - index2));\n    }\n\n    return ans;\n  }\n};\n", "2450": "class Solution {\n public:\n  int countDistinctStrings(string s, int k) {\n    // Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    // flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return modPow(2, s.length() - k + 1);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2451": "class Solution {\n public:\n  string oddString(vector<string>& words) {\n    const vector<pair<string, string>> wordAndDiffStrs =\n        getWordAndDiffStrs(words);\n    unordered_map<string, int> diffStrCount;\n\n    for (const auto& [_, diffStr] : wordAndDiffStrs)\n      ++diffStrCount[diffStr];\n\n    for (const auto& [word, diffStr] : wordAndDiffStrs)\n      if (diffStrCount[diffStr] == 1)\n        return word;\n\n    throw;\n  }\n\n private:\n  // Returns the pairs of the word and its corresponding difference string.\n  // e.g. [(\"adc\", \"3#-1#\"), (\"wzy\", \"3#-1#\"), (\"abc\", \"1#1#\")]\n  vector<pair<string, string>> getWordAndDiffStrs(const vector<string>& words) {\n    vector<pair<string, string>> wordAndDiffStrs;\n    for (const string& word : words)\n      wordAndDiffStrs.emplace_back(word, getDiffStr(word));\n    return wordAndDiffStrs;\n  }\n\n  // Returns the difference string of `s`.\n  // e.g. getDiffStr(\"adc\") -> \"3#-1#\"\n  string getDiffStr(const string& s) {\n    string diffStr;\n    for (int i = 1; i < s.length(); ++i)\n      diffStr += to_string(s[i] - s[i - 1]) + \"#\";\n    return diffStr;\n  }\n};\n", "2452": "class Solution {\n public:\n  vector<string> twoEditWords(vector<string>& queries,\n                              vector<string>& dictionary) {\n    vector<string> ans;\n\n    for (const string& query : queries)\n      for (const string& word : dictionary)\n        if (inner_product(query.begin(), query.end(), word.begin(), 0, plus<>(),\n                          not_equal_to<char>()) < 3) {\n          ans.push_back(q);\n          break;\n        }\n\n    return ans;\n  }\n};\n", "2453": "class Solution {\n public:\n  int destroyTargets(vector<int>& nums, int space) {\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num % space];\n\n    return *ranges::max_element(nums, [&count, space](int a, int b) {\n      const int countA = count[a % space];\n      const int countB = count[b % space];\n      return countA == countB ? a > b : countA < countB;\n    });\n  }\n};\n", "2454": "class Solution {\n public:\n  vector<int> secondGreaterElement(vector<int>& nums) {\n    vector<int> ans(nums.size(), -1);\n    // a decreasing stack that stores indices that met the first greater number\n    stack<int> prevStack;\n    // a decreasing stack that stores indices\n    stack<int> currStack;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      // Indices in `prevStack` meet the second greater number.\n      while (!prevStack.empty() && nums[prevStack.top()] < nums[i])\n        ans[prevStack.top()] = nums[i], prevStack.pop();\n      // Push indices that meet the first greater number from `currStack` to\n      // `prevStack`. We need a temporary array to make the indices in the\n      // `prevStack` increasing.\n      stack<int> decreasingIndices;\n      while (!currStack.empty() && nums[currStack.top()] < nums[i])\n        decreasingIndices.push(currStack.top()), currStack.pop();\n      while (!decreasingIndices.empty())\n        prevStack.push(decreasingIndices.top()), decreasingIndices.pop();\n      currStack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "2455": "class Solution {\n public:\n  int averageValue(vector<int>& nums) {\n    int sum = 0;\n    int count = 0;\n\n    for (const int num : nums)\n      if (num % 6 == 0) {\n        sum += num;\n        ++count;\n      }\n\n    return count == 0 ? 0 : sum / count;\n  }\n};\n", "2456": "struct Creator {\n  long popularity;  // the popularity sum\n  string videoId;   // the video id that has the maximum view\n  int maxView;      // the maximum view of the creator\n};\n\nclass Solution {\n public:\n  vector<vector<string>> mostPopularCreator(vector<string>& creators,\n                                            vector<string>& ids,\n                                            vector<int>& views) {\n    vector<vector<string>> ans;\n    unordered_map<string, Creator> nameToCreator;\n    long maxPopularity = 0;\n\n    for (int i = 0; i < creators.size(); ++i) {\n      if (!nameToCreator.contains(creators[i])) {\n        nameToCreator[creators[i]] = Creator{\n            .popularity = views[i],\n            .videoId = ids[i],\n            .maxView = views[i],\n        };\n        maxPopularity = max(maxPopularity, static_cast<long>(views[i]));\n        continue;\n      }\n      Creator& creator = nameToCreator[creators[i]];\n      creator.popularity += views[i];\n      maxPopularity = max(maxPopularity, static_cast<long>(creator.popularity));\n      if (creator.maxView < views[i] ||\n          creator.maxView == views[i] && creator.videoId > ids[i]) {\n        creator.videoId = ids[i];\n        creator.maxView = views[i];\n      }\n    }\n\n    for (const auto& [name, creator] : nameToCreator)\n      if (creator.popularity == maxPopularity)\n        ans.push_back({name, creator.videoId});\n\n    return ans;\n  }\n};\n", "2457": "class Solution {\n public:\n  long long makeIntegerBeautiful(long long n, int target) {\n    long ans = 0;\n    long power = 1;\n\n    // e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    // Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while (sum(n) > target) {\n      // the cost to turn off the last digit\n      ans += power * (10 - n % 10);\n      n = n / 10 + 1;\n      power *= 10;\n    }\n\n    return ans;\n  }\n\n private:\n  int sum(long n) {\n    int res = 0;\n    while (n > 0) {\n      res += n % 10;\n      n /= 10;\n    }\n    return res;\n  }\n};\n", "2458": "class Solution {\n public:\n  vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\n    vector<int> ans;\n\n    dfs(root, 0, 0);\n\n    for (const int query : queries)\n      ans.push_back(valToMaxHeight[query]);\n\n    return ans;\n  }\n\n private:\n  // valToMaxHeight[val] := the maximum height without the node with `val`\n  unordered_map<int, int> valToMaxHeight;\n  // valToHeight[val] := the height of the node with `val`\n  unordered_map<int, int> valToHeight;\n\n  int height(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    if (const auto it = valToHeight.find(root->val); it != valToHeight.cend())\n      return it->second;\n    return valToHeight[root->val] =\n               (1 + max(height(root->left), height(root->right)));\n  }\n\n  // maxHeight := the maximum height without the current node `root`\n  void dfs(TreeNode* root, int depth, int maxHeight) {\n    if (root == nullptr)\n      return;\n    valToMaxHeight[root->val] = maxHeight;\n    dfs(root->left, depth + 1, max(maxHeight, depth + height(root->right)));\n    dfs(root->right, depth + 1, max(maxHeight, depth + height(root->left)));\n  }\n};\n", "246": "class Solution {\n public:\n  bool isStrobogrammatic(string num) {\n    const vector<char> rotated{'0', '1', 'x', 'x', 'x',\n                               'x', '9', 'x', '8', '6'};\n    int l = 0;\n    int r = num.length() - 1;\n\n    while (l <= r)\n      if (num[l++] != rotated[num[r--] - '0'])\n        return false;\n\n    return true;\n  }\n};\n", "2460": "class Solution {\n public:\n  vector<int> applyOperations(vector<int>& nums) {\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\n      if (i + 1 < nums.size() && nums[i] == nums[i + 1]) {\n        nums[i] *= 2;\n        nums[i + 1] = 0;\n      }\n      if (nums[i] > 0)\n        swap(nums[i], nums[j++]);\n    }\n    return nums;\n  }\n};\n", "2461": "class Solution {\n public:\n  long long maximumSubarraySum(vector<int>& nums, int k) {\n    long ans = 0;\n    long sum = 0;\n    int distinct = 0;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      sum += nums[i];\n      if (++count[nums[i]] == 1)\n        ++distinct;\n      if (i >= k) {\n        if (--count[nums[i - k]] == 0)\n          --distinct;\n        sum -= nums[i - k];\n      }\n      if (i >= k - 1 && distinct == k)\n        ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};\n", "2462": "class Solution {\n public:\n  long long totalCost(vector<int>& costs, int k, int candidates) {\n    long ans = 0;\n    int i = 0;\n    int j = costs.size() - 1;\n    priority_queue<int, vector<int>, greater<>> minHeapL;\n    priority_queue<int, vector<int>, greater<>> minHeapR;\n\n    for (int hired = 0; hired < k; ++hired) {\n      while (minHeapL.size() < candidates && i <= j)\n        minHeapL.push(costs[i++]);\n      while (minHeapR.size() < candidates && i <= j)\n        minHeapR.push(costs[j--]);\n      if (minHeapL.empty())\n        ans += minHeapR.top(), minHeapR.pop();\n      else if (minHeapR.empty())\n        ans += minHeapL.top(), minHeapL.pop();\n      // Both `minHeapL` and `minHeapR` are not empty.\n      else if (minHeapL.top() <= minHeapR.top())\n        ans += minHeapL.top(), minHeapL.pop();\n      else\n        ans += minHeapR.top(), minHeapR.pop();\n    }\n\n    return ans;\n  }\n};\n", "2463": "class Solution {\n public:\n  long long minimumTotalDistance(vector<int>& robot,\n                                 vector<vector<int>>& factory) {\n    ranges::sort(robot);\n    ranges::sort(factory);\n    vector<vector<vector<long>>> mem(\n        robot.size(),\n        vector<vector<long>>(factory.size(), vector<long>(robot.size())));\n    return minimumTotalDistance(robot, factory, 0, 0, 0, mem);\n  }\n\n private:\n  // Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n  // factory[j] already fixed k robots.\n  long minimumTotalDistance(const vector<int>& robot,\n                            const vector<vector<int>>& factory, int i, int j,\n                            int k, vector<vector<vector<long>>>& mem) {\n    if (i == robot.size())\n      return 0;\n    if (j == factory.size())\n      return LONG_MAX;\n    if (mem[i][j][k] > 0)\n      return mem[i][j][k];\n    const long skipFactory =\n        minimumTotalDistance(robot, factory, i, j + 1, 0, mem);\n    const int position = factory[j][0];\n    const int limit = factory[j][1];\n    const long useFactory =\n        limit > k ? minimumTotalDistance(robot, factory, i + 1, j, k + 1, mem) +\n                        abs(robot[i] - position)\n                  : LONG_MAX / 2;\n    return mem[i][j][k] = min(skipFactory, useFactory);\n  }\n};\n", "2464": "class Solution {\n public:\n  int validSubarraySplit(vector<int>& nums) {\n    constexpr int kMax = INT_MAX / 2;\n    // dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    vector<int> dp(nums.size(), kMax);\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = 0; j <= i; ++j)\n        if (__gcd(nums[j], nums[i]) > 1)\n          dp[i] = min(dp[i], j == 0 ? 1 : dp[j - 1] + 1);\n\n    return dp.back() == kMax ? -1 : dp.back();\n  }\n};\n", "2465": "class Solution {\n public:\n  int distinctAverages(vector<int>& nums) {\n    const int n = nums.size();\n    unordered_set<int> sums;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i < n / 2; ++i)\n      sums.insert(nums[i] + nums[n - 1 - i]);\n\n    return sums.size();\n  }\n};\n", "2466": "class Solution {\n public:\n  int countGoodStrings(int low, int high, int zero, int one) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    // dp[i] := the number of good strings with length i\n    vector<int> dp(high + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= high; ++i) {\n      if (i >= zero)\n        dp[i] = (dp[i] + dp[i - zero]) % kMod;\n      if (i >= one)\n        dp[i] = (dp[i] + dp[i - one]) % kMod;\n      if (i >= low)\n        ans = (ans + dp[i]) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "2467": "class Solution {\n public:\n  int mostProfitablePath(vector<vector<int>>& edges, int bob,\n                         vector<int>& amount) {\n    const int n = amount.size();\n    vector<vector<int>> tree(n);\n    vector<int> parent(n);\n    vector<int> aliceDist(n, -1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, -1, 0, parent, aliceDist);\n\n    // Modify the amount along the path from node Bob to node 0.\n    // For each node,\n    //   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    //   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    for (int u = bob, bobDist = 0; u != 0; u = parent[u], ++bobDist)\n      if (bobDist < aliceDist[u])\n        amount[u] = 0;\n      else if (bobDist == aliceDist[u])\n        amount[u] /= 2;\n\n    return getMoney(tree, 0, -1, amount);\n  }\n\n private:\n  // Fills `parent` and `dist`.\n  void dfs(const vector<vector<int>>& tree, int u, int prev, int d,\n           vector<int>& parent, vector<int>& dist) {\n    parent[u] = prev;\n    dist[u] = d;\n    for (const int v : tree[u]) {\n      if (dist[v] == -1)\n        dfs(tree, v, u, d + 1, parent, dist);\n    }\n  }\n\n  int getMoney(const vector<vector<int>>& tree, int u, int prev,\n               const vector<int>& amount) {\n    // a leaf node\n    if (tree[u].size() == 1 && tree[u][0] == prev)\n      return amount[u];\n\n    int maxPath = INT_MIN;\n    for (const int v : tree[u])\n      if (v != prev)\n        maxPath = max(maxPath, getMoney(tree, v, u, amount));\n\n    return amount[u] + maxPath;\n  }\n};\n", "2468": "class Solution {\n public:\n  vector<string> splitMessage(string message, int limit) {\n    const int kMessageLength = message.length();\n    int b = 1;\n    // the total length of a: initialized with the length of \"1\"\n    int aLength = sz(1);\n\n    // the total length of b := b * sz(b)\n    // The total length of \"</>\" := b * 3\n    while (b * limit < b * (sz(b) + 3) + aLength + kMessageLength) {\n      // If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      // then it's impossible that the length of \"*<b/b>\" <= limit.\n      if (sz(b) * 2 + 3 >= limit)\n        return {};\n      aLength += sz(++b);\n    }\n\n    vector<string> ans;\n\n    for (int i = 0, a = 1; a <= b; ++a) {\n      // the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      const int j = limit - (sz(a) + sz(b) + 3);\n      ans.push_back(message.substr(i, j) + \"<\" + to_string(a) + \"/\" +\n                    to_string(b) + \">\");\n      i += j;\n    }\n\n    return ans;\n  }\n\n private:\n  int sz(int num) {\n    return to_string(num).length();\n  }\n};\n", "2469": "class Solution {\n public:\n  vector<double> convertTemperature(double celsius) {\n    return {celsius + 273.15, celsius * 1.8 + 32};\n  }\n};\n", "247": "class Solution {\n public:\n  vector<string> findStrobogrammatic(int n) {\n    return helper(n, n);\n  }\n\n private:\n  vector<string> helper(int n, int k) {\n    if (n == 0)\n      return {\"\"};\n    if (n == 1)\n      return {\"0\", \"1\", \"8\"};\n\n    vector<string> ans;\n\n    for (const string& inner : helper(n - 2, k)) {\n      if (n < k)\n        ans.push_back(\"0\" + inner + \"0\");\n      ans.push_back(\"1\" + inner + \"1\");\n      ans.push_back(\"6\" + inner + \"9\");\n      ans.push_back(\"8\" + inner + \"8\");\n      ans.push_back(\"9\" + inner + \"6\");\n    }\n\n    return ans;\n  }\n};\n", "2470": "class Solution {\n public:\n  int subarrayLCM(vector<int>& nums, int k) {\n    int ans = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      int runningLcm = nums[i];\n      for (int j = i; j < nums.size(); ++j) {\n        runningLcm = std::lcm(runningLcm, nums[j]);\n        if (runningLcm > k)\n          break;\n        if (runningLcm == k)\n          ++ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2471": "class Solution {\n public:\n  int minimumOperations(TreeNode* root) {\n    int ans = 0;\n    queue<TreeNode*> q{{root}};\n\n    // e.g. vals = [7, 6, 8, 5]\n    // [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    // [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    // [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while (!q.empty()) {\n      vector<int> vals;\n      vector<int> ids(q.size());\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        vals.push_back(node->val);\n        if (node->left != nullptr)\n          q.push(node->left);\n        if (node->right != nullptr)\n          q.push(node->right);\n      }\n      iota(ids.begin(), ids.end(), 0);\n      ranges::sort(ids, [&vals](int i, int j) { return vals[i] < vals[j]; });\n      for (int i = 0; i < ids.size(); ++i)\n        for (; ids[i] != i; ++ans)\n          swap(ids[i], ids[ids[i]]);\n    }\n\n    return ans;\n  }\n};\n", "2472": "class Solution {\n public:\n  int maxPalindromes(string s, int k) {\n    const int n = s.length();\n    // dp[i] := the maximum number of substrings in the first i chars of s\n    vector<int> dp(n + 1);\n\n    // If a palindrome is a substring of another palindrome, then considering\n    // the longer palindrome won't increase the number of non-overlapping\n    // palindromes. So, we only need to consider the shorter one. Also,\n    // considering palindromes with both k length and k + 1 length ensures that\n    // we look for both even and odd length palindromes.\n    for (int i = k; i <= n; ++i) {\n      dp[i] = dp[i - 1];\n      // Consider palindrome with length k.\n      if (isPalindrome(s, i - k, i - 1))\n        dp[i] = max(dp[i], 1 + dp[i - k]);\n      // Consider palindrome with length k + 1.\n      if (isPalindrome(s, i - k - 1, i - 1))\n        dp[i] = max(dp[i], 1 + dp[i - k - 1]);\n    }\n\n    return dp[n];\n  }\n\n private:\n  // Returns true is s[i..j) is a palindrome.\n  bool isPalindrome(const string& s, int l, int r) {\n    if (l < 0)\n      return false;\n    while (l < r)\n      if (s[l++] != s[r--])\n        return false;\n    return true;\n  }\n};\n", "2473": "class Solution {\n public:\n  vector<long long> minCost(int n, vector<vector<int>>& roads,\n                            vector<int>& appleCost, int k) {\n    vector<long long> ans;\n    vector<vector<pair<int, long>>> graph(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0] - 1;\n      const int v = road[1] - 1;\n      const int w = road[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans.push_back(dijkstra(graph, i, appleCost, k));\n\n    return ans;\n  }\n\n private:\n  long dijkstra(const vector<vector<pair<int, long>>>& graph, int src,\n                const vector<int>& appleCost, int k) {\n    long ans = LONG_MAX;\n    vector<long> dist(graph.size(), LONG_MAX);\n\n    dist[src] = 0;\n    using P = pair<long, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      ans = min(ans, appleCost[u] + (k + 1) * d);\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return ans;\n  }\n};\n", "2475": "// Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n//\n// What we want is:\n//   cnt[a] * cnt[b] * cnt[c]\n//   cnt[a] * cnt[b] * cnt[d]\n//   cnt[a] * cnt[c] * cnt[d]\n//   cnt[b] * cnt[c] * cnt[d]\n//\n// The above combinations can be reduced as:\n//\n// prev                       | curr   | next\n// ----------------------------------------------------------------\n// (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n// (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n// (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n// (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution {\n public:\n  int unequalTriplets(vector<int>& nums) {\n    int ans = 0;\n    int prev = 0;\n    int next = nums.size();\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [_, freq] : count) {\n      next -= freq;\n      ans += prev * freq * next;\n      prev += freq;\n    }\n\n    return ans;\n  }\n};\n", "2476": "class Solution {\n public:\n  vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n    vector<vector<int>> ans;\n    vector<int> sortedVals;\n\n    inorder(root, sortedVals);\n\n    for (const int query : queries) {\n      const auto it = ranges::lower_bound(sortedVals, query);\n      // query is presented in the tree, so just use {query, query}.\n      if (it != sortedVals.cend() && *it == query)\n        ans.push_back({query, query});\n      // query isn't presented in the tree, so find the cloest one if possible.\n      else\n        ans.push_back({it == sortedVals.cbegin() ? -1 : *prev(it),\n                       it == sortedVals.cend() ? -1 : *it});\n    }\n\n    return ans;\n  }\n\n private:\n  // Walks the BST to collect the sorted numbers.\n  void inorder(TreeNode* root, vector<int>& sortedVals) {\n    if (root == nullptr)\n      return;\n    inorder(root->left, sortedVals);\n    sortedVals.push_back(root->val);\n    inorder(root->right, sortedVals);\n  }\n};\n", "2477": "class Solution {\n public:\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n    long ans = 0;\n    vector<vector<int>> tree(roads.size() + 1);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, -1, seats, ans);\n    return ans;\n  }\n\n private:\n  int dfs(const vector<vector<int>>& tree, int u, int prev, int seats,\n          long& ans) {\n    int people = 1;\n    for (const int v : tree[u])\n      if (v != prev)\n        people += dfs(tree, v, u, seats, ans);\n    if (u > 0)\n      // the number of cars needed = ceil(people / seats)\n      ans += (people + seats - 1) / seats;\n    return people;\n  }\n};\n", "2478": "class Solution {\n public:\n  int beautifulPartitions(string s, int k, int minLength) {\n    if (!isPrime(s.front()) || isPrime(s.back()))\n      return 0;\n    vector<vector<int>> mem(s.length(), vector<int>(k, -1));\n    return beautifulPartitions(s, minLength, k - 1, minLength, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of beautiful partitions of s[i..n) with k bars (|) left.\n  int beautifulPartitions(const string& s, int i, int k, int minLength,\n                          vector<vector<int>>& mem) {\n    if (i <= s.length() && k == 0)\n      return 1;\n    if (i >= s.length())\n      return 0;\n    if (mem[i][k] != -1)\n      return mem[i][k];\n\n    // Don't split between s[i - 1] and s[i].\n    int res = beautifulPartitions(s, i + 1, k, minLength, mem) % kMod;\n\n    // Split between s[i - 1] and s[i].\n    if (isPrime(s[i]) && !isPrime(s[i - 1]))\n      res += beautifulPartitions(s, i + minLength, k - 1, minLength, mem);\n\n    return mem[i][k] = res % kMod;\n  }\n\n  bool isPrime(char c) {\n    return c == '2' || c == '3' || c == '5' || c == '7';\n  }\n};\n", "2479": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(long num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n    }\n  }\n\n  long getMaxXor(long num) {\n    long maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      const int toggleBit = bit ^ 1;\n      if (node->children[toggleBit] != nullptr) {\n        maxXor = maxXor | 1L << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values) {\n    long ans = 0;\n    vector<vector<int>> tree(n);\n    vector<long> treeSums(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    getTreeSum(tree, 0, -1, treeSums, values);\n    const long maxSubTreeSum =\n        *max_element(treeSums.begin() + 1, treeSums.end());\n    const int maxBit = static_cast<int>(log2(maxSubTreeSum));\n    // Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(tree, 0, -1, treeSums, BitTrie(maxBit), ans);\n    return ans;\n  }\n\n private:\n  // Gets the tree sum rooted at node u.\n  long getTreeSum(const vector<vector<int>>& tree, int u, int prev,\n                  vector<long>& treeSums, const vector<int>& values) {\n    long treeSum = values[u];\n    for (const int v : tree[u])\n      if (v != prev)\n        treeSum += getTreeSum(tree, v, u, treeSums, values);\n    treeSums[u] = treeSum;\n    return treeSum;\n  }\n\n  void dfs(const vector<vector<int>>& tree, int u, int prev,\n           const vector<long>& treeSums, BitTrie&& bitTrie, long& ans) {\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      // Preorder to get the ans.\n      ans = max(ans, bitTrie.getMaxXor(treeSums[v]));\n      // Recursively call on the subtree rooted at node v.\n      dfs(tree, v, u, treeSums, std::move(bitTrie), ans);\n      // Postorder insert the tree sum rooted at node v.\n      bitTrie.insert(treeSums[v]);\n    }\n  }\n};\n", "248": "class Solution {\n public:\n  int strobogrammaticInRange(string low, string high) {\n    int ans = 0;\n\n    for (int n = low.length(); n <= high.length(); ++n) {\n      string s(n, ' ');\n      dfs(low, high, s, 0, n - 1, ans);\n    }\n\n    return ans;\n  }\n\n private:\n  const vector<pair<char, char>> pairs{\n      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n  void dfs(const string& low, const string& high, string& s, int l, int r,\n           int& ans) {\n    if (l > r) {\n      if (s.length() == low.length() && s < low)\n        return;\n      if (s.length() == high.length() && s > high)\n        return;\n      ++ans;\n      return;\n    }\n\n    for (const auto& [leftDigit, rightDigit] : pairs) {\n      if (l == r && leftDigit != rightDigit)\n        continue;\n      s[l] = leftDigit;\n      s[r] = rightDigit;\n      if (s.length() > 1 && s[0] == '0')\n        continue;\n      dfs(low, high, s, l + 1, r - 1, ans);\n    }\n  }\n};\n", "2481": "class Solution {\n public:\n  int numberOfCuts(int n) {\n    if (n == 1)\n      return 0;\n    return n % 2 == 0 ? n / 2 : n;\n  }\n};\n", "2482": "class Solution {\n public:\n  vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n    vector<int> onesRow;\n    vector<int> onesCol;\n\n    for (const vector<int>& row : grid)\n      onesRow.push_back(ranges::count(row, 1));\n\n    for (int j = 0; j < n; ++j) {\n      int ones = 0;\n      for (int i = 0; i < m; ++i)\n        ones += grid[i][j];\n      onesCol.push_back(ones);\n    }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        ans[i][j] =\n            onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);\n\n    return ans;\n  }\n};\n", "2483": "class Solution {\n public:\n  int bestClosingTime(string customers) {\n    // Instead of computing the minimum penalty, we can compute the maximum\n    // profit.\n    int ans = 0;\n    int profit = 0;\n    int maxProfit = 0;\n\n    for (int i = 0; i < customers.length(); ++i) {\n      profit += customers[i] == 'Y' ? 1 : -1;\n      if (profit > maxProfit) {\n        maxProfit = profit;\n        ans = i + 1;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2484": "class Solution {\n public:\n  int countPalindromes(string s) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kPatternSize = 5;\n    long ans = 0;\n\n    for (char a = '0'; a <= '9'; ++a)\n      for (char b = '0'; b <= '9'; ++b) {\n        const vector<char> pattern{a, b, '.', b, a};\n        // dp[i] := the number of subsequences of pattern[i..n) in s, where\n        // pattern[2] can be any character\n        vector<long> dp(kPatternSize + 1);\n        dp.back() = 1;\n        for (const char c : s)\n          for (int i = 0; i < kPatternSize; ++i)\n            if (pattern[i] == '.' || pattern[i] == c)\n              dp[i] += dp[i + 1];\n        ans += dp[0];\n        ans %= kMod;\n      }\n\n    return ans;\n  }\n};\n", "2485": "class Solution {\n public:\n  int pivotInteger(int n) {\n    // 1 + 2 + ... + x = x + ... + n\n    // (1 + x) * x / 2 = (x + n) * (n - x + 1) / 2\n    //         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    //         2 * x^2 = n^2 + n\n    //               x = sqrt((n^2 + n) / 2)\n    const int y = (n * n + n) / 2;\n    const int x = sqrt(y);\n    return x * x == y ? x : -1;\n  }\n};\n", "2486": "class Solution {\n public:\n  int appendCharacters(string s, string t) {\n    int i = 0;  // t's index\n\n    for (const char c : s)\n      if (c == t[i])\n        if (++i == t.length())\n          return 0;\n\n    return t.length() - i;\n  }\n};\n", "2487": "class Solution {\n public:\n  ListNode* removeNodes(ListNode* head) {\n    if (head == nullptr)\n      return nullptr;\n    head->next = removeNodes(head->next);\n    return head->next != nullptr && head->val < head->next->val ? head->next\n                                                                : head;\n  }\n};\n", "2488": "class Solution {\n public:\n  int countSubarrays(vector<int>& nums, int k) {\n    const int kIndex = find(nums.begin(), nums.end(), k) - nums.begin();\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int i = kIndex, balance = 0; i >= 0; --i) {\n      if (nums[i] < k)\n        --balance;\n      else if (nums[i] > k)\n        ++balance;\n      ++count[balance];\n    }\n\n    for (int i = kIndex, balance = 0; i < nums.size(); ++i) {\n      if (nums[i] < k)\n        --balance;\n      else if (nums[i] > k)\n        ++balance;\n      // The subarray that has balance == 0 or 1 having median equal to k.\n      // So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance];\n    }\n\n    return ans;\n  }\n};\n", "2489": "class Solution {\n public:\n  long long fixedRatio(string s, int num1, int num2) {\n    // Let x := the number of 0s and y := the number of 1s in the subarray.\n    // We want x : y = num1 : num2, so our goal is to find number of subarrays\n    // with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    // map to record the count of the running x * num2 - y * num1. If the\n    // running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    // `ans`.\n    long ans = 0;\n    long prefix = 0;\n    unordered_map<long, int> prefixCount{{0, 1}};\n\n    for (const char c : s) {\n      if (c == '0')\n        prefix += num2;\n      else  // c == '1'\n        prefix -= num1;\n      ans += prefixCount[prefix];\n      ++prefixCount[prefix];\n    }\n\n    return ans;\n  }\n};\n", "249": "class Solution {\n public:\n  vector<vector<string>> groupStrings(vector<string>& strings) {\n    vector<vector<string>> ans;\n    unordered_map<string, vector<string>> keyToStrings;\n\n    for (const string& s : strings)\n      keyToStrings[getKey(s)].push_back(s);\n\n    for (const auto& [_, strings] : keyToStrings)\n      ans.push_back(strings);\n\n    return ans;\n  }\n\n private:\n  // Returns the key of 's' by pairwise calculation of differences.\n  // e.g. getKey(\"abc\") -> \"1,1\" because diff(a, b) = 1 and diff(b, c) = 1.\n  string getKey(const string& s) {\n    string key;\n\n    for (int i = 1; i < s.length(); ++i) {\n      const int diff = (s[i] - s[i - 1] + 26) % 26;\n      key += to_string(diff) + \",\";\n    }\n\n    return key;\n  }\n};\n", "2490": "class Solution {\n public:\n  bool isCircularSentence(string sentence) {\n    for (int i = 0; i < sentence.length(); ++i)\n      if (sentence[i] == ' ' && sentence[i - 1] != sentence[i + 1])\n        return false;\n    return sentence.front() == sentence.back();\n  }\n};\n", "2491": "class Solution {\n public:\n  long long dividePlayers(vector<int>& skill) {\n    const int n = skill.size();\n    const int teamSkill = accumulate(skill.begin(), skill.end(), 0) / (n / 2);\n    long ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int s : skill)\n      ++count[s];\n\n    for (const auto& [s, freq] : count) {\n      const int requiredSkill = teamSkill - s;\n      if (const auto it = count.find(requiredSkill);\n          it == count.cend() || it->second != freq)\n        return -1;\n      ans += static_cast<long>(s) * requiredSkill * freq;\n    }\n\n    return ans / 2;\n  }\n};\n", "2492": "class Solution {\n public:\n  int minScore(int n, vector<vector<int>>& roads) {\n    int ans = INT_MAX;\n    vector<vector<pair<int, int>>> graph(n);  // graph[u] := [(v, distance)]\n    queue<int> q{{0}};\n    vector<bool> seen(n);\n    seen[0] = true;\n\n    for (const vector<int>& r : roads) {\n      const int u = r[0] - 1;\n      const int v = r[1] - 1;\n      const int distance = r[2];\n      graph[u].emplace_back(v, distance);\n      graph[v].emplace_back(u, distance);\n    }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const auto& [v, d] : graph[u]) {\n        ans = min(ans, d);\n        if (seen[v])\n          continue;\n        q.push(v);\n        seen[v] = true;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2493": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int magnificentSets(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> graph(n);\n    UnionFind uf(n);\n    unordered_map<int, int> rootToGroupSize;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0] - 1;\n      const int v = edge[1] - 1;\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n      uf.unionByRank(u, v);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      const int newGroupSize = bfs(graph, i);\n      if (newGroupSize == -1)\n        return -1;\n      const int root = uf.find(i);\n      auto& groupSize = rootToGroupSize[root];\n      groupSize = max(groupSize, newGroupSize);\n    }\n\n    int ans = 0;\n    for (const auto& [_, groupSize] : rootToGroupSize)\n      ans += groupSize;\n\n    return ans;\n  }\n\n private:\n  int bfs(const vector<vector<int>>& graph, int u) {\n    int step = 0;\n    queue<int> q{{u}};\n    unordered_map<int, int> nodeToStep{{u, 1}};\n\n    while (!q.empty()) {\n      ++step;\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u]) {\n          if (!nodeToStep.contains(v)) {\n            q.push(v);\n            nodeToStep[v] = step + 1;\n          } else if (nodeToStep[v] == step) {\n            // There is an odd number of edges in the cycle.\n            return -1;\n          }\n        }\n      }\n    }\n\n    return step;\n  }\n};\n", "2495": "class Solution {\n public:\n  long long evenProduct(vector<int>& nums) {\n    long ans = 0;\n    int numsBeforeEven = 0;  // inclusively\n\n    // e.g. nums = [1, 0, 1, 1, 0].\n    // After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    // between index 1 to index 3 (the one before next 0) will contribute 2 to\n    // `ans`.\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] % 2 == 0)\n        numsBeforeEven = i + 1;\n      ans += numsBeforeEven;\n    }\n\n    return ans;\n  }\n};\n", "2496": "class Solution {\n public:\n  int maximumValue(vector<string>& strs) {\n    int ans = 0;\n    for (const string& s : strs)\n      ans = max(ans, ranges::any_of(s, [](char c) { return isalpha(c); })\n                         ? static_cast<int>(s.length())\n                         : stoi(s));\n    return ans;\n  }\n};\n", "2497": "class Solution {\n public:\n  int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {\n    const int n = vals.size();\n    int ans = INT_MIN;\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, vals[v]);\n      graph[v].emplace_back(u, vals[u]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      priority_queue<int> maxHeap;\n      for (const auto& [_, val] : graph[i])\n        if (val > 0)\n          maxHeap.push(val);\n      int starSum = vals[i];\n      for (int j = 0; j < k && !maxHeap.empty(); ++j)\n        starSum += maxHeap.top(), maxHeap.pop();\n      ans = max(ans, starSum);\n    }\n\n    return ans;\n  }\n};\n", "2498": "class Solution {\n public:\n  int maxJump(vector<int>& stones) {\n    // Let's denote the forwarding path as F and the backwarding path as B.\n    // \"F1 B2 B1 F2\" is no better than \"F1 B2 F2 B1\" since the distance between\n    // F1 and F2 increase, resulting a larger `ans`.\n    int ans = stones[1] - stones[0];  // If there're only two stones.\n    for (int i = 2; i < stones.size(); ++i)\n      ans = max(ans, stones[i] - stones[i - 2]);\n    return ans;\n  }\n};\n", "2499": "class Solution {\n public:\n  long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n    const int n = nums1.size();\n    long ans = 0;\n    int maxFreq = 0;\n    int maxFreqNum = 0;\n    int shouldBeSwapped = 0;\n    vector<int> conflictedNumCount(n + 1);\n\n    // Collect the indices i s.t. nums1[i] == nums2[i] and record their\n    // `maxFreq` and `maxFreqNum`.\n    for (int i = 0; i < n; ++i)\n      if (nums1[i] == nums2[i]) {\n        const int conflictedNum = nums1[i];\n        if (++conflictedNumCount[conflictedNum] > maxFreq) {\n          maxFreq = conflictedNumCount[conflictedNum];\n          maxFreqNum = conflictedNum;\n        }\n        ++shouldBeSwapped;\n        ans += i;\n      }\n\n    // Collect the indices with nums1[i] != nums2[i] that contribute less cost.\n    // This can be greedily achieved by iterating from 0 to n - 1.\n    for (int i = 0; i < n; ++i) {\n      // Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      // successfully distributed, so no need to collectextra spaces.\n      if (maxFreq * 2 <= shouldBeSwapped)\n        break;\n      if (nums1[i] == nums2[i])\n        continue;\n      // The numbers == `maxFreqNum` worsen the result since they increase the\n      // `maxFreq`.\n      if (nums1[i] == maxFreqNum || nums2[i] == maxFreqNum)\n        continue;\n      ++shouldBeSwapped;\n      ans += i;\n    }\n\n    return maxFreq * 2 > shouldBeSwapped ? -1 : ans;\n  }\n};\n", "25": "class Solution {\n public:\n  ListNode* reverseKGroup(ListNode* head, int k) {\n    if (!head || k == 1)\n      return head;\n\n    const int length = getLength(head);\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n    ListNode* curr = head;\n\n    for (int i = 0; i < length / k; ++i) {\n      for (int j = 0; j < k - 1; ++j) {\n        ListNode* next = curr->next;\n        curr->next = next->next;\n        next->next = prev->next;\n        prev->next = next;\n      }\n      prev = curr;\n      curr = curr->next;\n    }\n\n    return dummy.next;\n  }\n\n private:\n  int getLength(ListNode* head) {\n    int length = 0;\n    for (ListNode* curr = head; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n};\n", "250": "class Solution {\n public:\n  int countUnivalSubtrees(TreeNode* root) {\n    int ans = 0;\n    isUnival(root, INT_MAX, ans);\n    return ans;\n  }\n\n private:\n  bool isUnival(TreeNode* root, int val, int& ans) {\n    if (root == nullptr)\n      return true;\n\n    if (isUnival(root->left, root->val, ans) &\n        isUnival(root->right, root->val, ans)) {\n      ++ans;\n      return root->val == val;\n    }\n\n    return false;\n  }\n};\n", "2500": "class Solution {\n public:\n  int deleteGreatestValue(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (vector<int>& row : grid)\n      ranges::sort(row);\n\n    for (int j = 0; j < grid[0].size(); ++j) {\n      int maxOfColumn = 0;\n      for (int i = 0; i < grid.size(); ++i)\n        maxOfColumn = max(maxOfColumn, grid[i][j]);\n      ans += maxOfColumn;\n    }\n\n    return ans;\n  }\n};\n", "2501": "class Solution {\n public:\n  int longestSquareStreak(vector<int>& nums) {\n    nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\n    ranges::sort(nums, greater<>());\n\n    const int maxNum = ranges::max(nums);\n    // dp[i] := the longest square streak starts with i\n    vector<int> dp(maxNum + 1);\n\n    for (const int num : nums) {\n      dp[num] = 1;\n      const long squaredNum = static_cast<long>(num) * num;\n      if (squaredNum <= maxNum)\n        dp[num] += dp[squaredNum];\n    }\n\n    const int ans = ranges::max(dp);\n    return ans < 2 ? -1 : ans;\n  }\n};\n", "2502": "class Allocator {\n public:\n  Allocator(int n) : memory(n), mIDToIndices(1001) {}\n\n  int allocate(int size, int mID) {\n    int consecutiveFree = 0;\n    for (int i = 0; i < memory.size(); ++i) {\n      consecutiveFree = memory[i] == 0 ? consecutiveFree + 1 : 0;\n      if (consecutiveFree == size) {\n        for (int j = i - consecutiveFree + 1; j <= i; ++j) {\n          memory[j] = mID;\n          mIDToIndices[mID].push_back(j);\n        }\n        return i - consecutiveFree + 1;\n      }\n    }\n    return -1;\n  }\n\n  int free(int mID) {\n    vector<int>& indices = mIDToIndices[mID];\n    const int freedUnits = indices.size();\n    for (const int index : indices)\n      memory[index] = 0;\n    indices.clear();\n    return freedUnits;\n  }\n\n private:\n  vector<int> memory;\n  vector<vector<int>> mIDToIndices;\n};\n", "2503": "struct IndexedQuery {\n  int queryIndex;\n  int query;\n};\n\nstruct T {\n  int i;\n  int j;\n  int val;  // grid[i][j]\n};\n\nclass Solution {\n public:\n  vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> ans(queries.size());\n    auto compare = [](const T& a, const T& b) { return a.val > b.val; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    minHeap.emplace(0, 0, grid[0][0]);\n    seen[0][0] = true;\n    int accumulate = 0;\n\n    for (const auto& [queryIndex, query] : getIndexedQueries(queries)) {\n      while (!minHeap.empty()) {\n        const auto [i, j, val] = minHeap.top();\n        minHeap.pop();\n        if (val >= query) {\n          // The smallest neighbor is still larger than `query`, so no need to\n          // keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          minHeap.emplace(i, j, val);\n          break;\n        }\n        ++accumulate;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (seen[x][y])\n            continue;\n          minHeap.emplace(x, y, grid[x][y]);\n          seen[x][y] = true;\n        }\n      }\n      ans[queryIndex] = accumulate;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<IndexedQuery> getIndexedQueries(const vector<int>& queries) {\n    vector<IndexedQuery> indexedQueries;\n    for (int i = 0; i < queries.size(); ++i)\n      indexedQueries.push_back({i, queries[i]});\n    ranges::sort(\n        indexedQueries, ranges::less{},\n        [](const IndexedQuery& indexedQuery) { return indexedQuery.query; });\n    return indexedQueries;\n  }\n};\n", "2505": "class Solution {\n public:\n  long long subsequenceSumOr(vector<int>& nums) {\n    long ans = 0;\n    long prefix = 0;\n\n    for (const int num : nums) {\n      prefix += num;\n      ans |= num | prefix;\n    }\n\n    return ans;\n  }\n};\n", "2506": "class Solution {\n public:\n  int similarPairs(vector<string>& words) {\n    int ans = 0;\n    vector<int> masks;\n\n    for (const string& word : words)\n      masks.push_back(getMask(word));\n\n    for (int i = 0; i < masks.size(); ++i)\n      for (int j = i + 1; j < masks.size(); ++j)\n        if (masks[i] == masks[j])\n          ++ans;\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& word) {\n    int mask = 0;\n    for (const char c : word)\n      mask |= 1 << c - 'a';\n    return mask;\n  }\n};\n", "2507": "class Solution {\n public:\n  int smallestValue(int n) {\n    int primeSum = getPrimeSum(n);\n    while (n != primeSum) {\n      n = primeSum;\n      primeSum = getPrimeSum(n);\n    }\n    return n;\n  }\n\n private:\n  int getPrimeSum(int n) {\n    int primeSum = 0;\n    for (int i = 2; i <= n; ++i)\n      while (n % i == 0) {\n        n /= i;\n        primeSum += i;\n      }\n    return primeSum;\n  }\n};\n", "2508": "class Solution {\n public:\n  bool isPossible(int n, vector<vector<int>>& edges) {\n    vector<unordered_set<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0] - 1;\n      const int v = edge[1] - 1;\n      graph[u].insert(v);\n      graph[v].insert(u);\n    }\n\n    const vector<int> oddNodes = getOddNodes(graph);\n    if (oddNodes.empty())\n      return true;\n    if (oddNodes.size() == 2) {\n      const int a = oddNodes[0];\n      const int b = oddNodes[1];\n      for (int i = 0; i < n; ++i)\n        // Can connect i with a and i with b.\n        if (!graph[i].contains(a) && !graph[i].contains(b))\n          return true;\n    }\n    if (oddNodes.size() == 4) {\n      const int a = oddNodes[0];\n      const int b = oddNodes[1];\n      const int c = oddNodes[2];\n      const int d = oddNodes[3];\n      return (!graph[a].contains(b) && !graph[c].contains(d)) ||\n             (!graph[a].contains(c) && !graph[b].contains(d)) ||\n             (!graph[a].contains(d) && !graph[b].contains(c));\n    }\n    return false;\n  }\n\n private:\n  vector<int> getOddNodes(const vector<unordered_set<int>>& graph) {\n    vector<int> oddNodes;\n    for (int i = 0; i < graph.size(); ++i)\n      if (graph[i].size() % 2 == 1)\n        oddNodes.push_back(i);\n    return oddNodes;\n  }\n};\n", "2509": "class Solution {\n public:\n  vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      ans.push_back(1);\n      int a = query[0];\n      int b = query[1];\n      while (a != b) {\n        if (a > b)\n          a /= 2;\n        else\n          b /= 2;\n        ++ans.back();\n      }\n    }\n\n    return ans;\n  }\n};\n", "251": "class Vector2D {\n public:\n  Vector2D(vector<vector<int>>& v) {\n    i = v.begin();\n    iEnd = v.end();\n  }\n\n  int next() {\n    moveIterator();\n    return (*i)[j++];\n  }\n\n  bool hasNext() {\n    moveIterator();\n    return i != iEnd;\n  }\n\n private:\n  // (*i)[j] := the current pointed value\n  vector<vector<int>>::iterator i, iEnd;\n  int j = 0;\n\n  void moveIterator() {\n    while (i != iEnd && j == (*i).size())\n      ++i, j = 0;\n  }\n};\n", "2510": "class Solution {\n public:\n  bool isThereAPath(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // Map negative (the number of 0s - the number of 1s) to non-negative one.\n    const int cells = m + n - 1;\n    if (cells % 2 == 1)\n      return false;\n    vector<vector<vector<int>>> mem(\n        m, vector<vector<int>>(n, vector<int>(cells * 2 + 1, -1)));\n    return isThereAPath(grid, 0, 0, 0, cells, mem);\n  }\n\n private:\n  // Returns 1 if there's a path to grid[i][j]\n  // s.t. `sum` = (the number of 0s - the number of 1s).\n  bool isThereAPath(const vector<vector<int>>& grid, int i, int j, int sum,\n                    const int& cells, vector<vector<vector<int>>>& mem) {\n    if (i == grid.size() || j == grid[0].size())\n      return false;\n    sum += grid[i][j] == 0 ? 1 : -1;\n    if (i == grid.size() - 1 && j == grid[0].size() - 1)\n      return sum == 0;\n    const int k = cells + sum;\n    if (mem[i][j][k] != -1)\n      return mem[i][j][k];\n    return mem[i][j][k] = isThereAPath(grid, i + 1, j, sum, cells, mem) ||\n                          isThereAPath(grid, i, j + 1, sum, cells, mem);\n  }\n};\n", "2511": "class Solution {\n public:\n  int captureForts(vector<int>& forts) {\n    int ans = 0;\n\n    for (int i = 0, j = 0; i < forts.size(); ++i)\n      if (forts[i] != 0) {  // -1 or 1\n        if (forts[i] == -forts[j])\n          ans = max(ans, i - j - 1);\n        j = i;\n      }\n\n    return ans;\n  }\n};\n", "2512": "class Solution {\n public:\n  vector<int> topStudents(vector<string>& positive_feedback,\n                          vector<string>& negative_feedback,\n                          vector<string>& report, vector<int>& student_id,\n                          int k) {\n    vector<int> ans;\n    vector<pair<int, int>> scoreAndIds;\n    unordered_set<string> pos{positive_feedback.begin(),\n                              positive_feedback.end()};\n    unordered_set<string> neg{negative_feedback.begin(),\n                              negative_feedback.end()};\n\n    for (int i = 0; i < report.size(); ++i) {\n      int score = 0;\n      istringstream iss(report[i]);\n      for (string word; iss >> word;) {\n        if (pos.contains(word))\n          score += 3;\n        if (neg.contains(word))\n          score -= 1;\n      }\n      scoreAndIds.emplace_back(-score, student_id[i]);\n    }\n\n    partial_sort(scoreAndIds.begin(), scoreAndIds.begin() + k,\n                 scoreAndIds.end());\n    transform(\n        scoreAndIds.begin(), scoreAndIds.begin() + k, back_inserter(ans),\n        [](const pair<int, int>& scoreAndId) { return scoreAndId.second; });\n    return ans;\n  }\n};\n", "2513": "class Solution {\n public:\n  int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\n    const long divisorLcm = std::lcm(static_cast<long>(divisor1), divisor2);\n    long l = 0;\n    long r = INT_MAX;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (isPossible(m, divisorLcm, divisor1, divisor2, uniqueCnt1, uniqueCnt2))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if we can take uniqueCnt1 integers from [1..m] to arr1 and\n  // take uniqueCnt2 integers from [1..m] to arr2.\n  bool isPossible(long m, long divisorLcm, int divisor1, int divisor2,\n                  int uniqueCnt1, int uniqueCnt2) {\n    const long cnt1 = m - m / divisor1;\n    const long cnt2 = m - m / divisor2;\n    const long totalCnt = m - m / divisorLcm;\n    return cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&\n           totalCnt >= uniqueCnt1 + uniqueCnt2;\n  }\n};\n", "2514": "class Solution {\n public:\n  int countAnagrams(string s) {\n    const int n = s.length();\n    const auto [fact, invFact] = getFactAndInvFact(n);\n    int ans = 1;\n    istringstream iss(s);\n\n    for (string word; iss >> word;) {\n      ans = ans * fact[word.length()] % kMod;\n      vector<int> count(26);\n      for (const char c : word)\n        ++count[c - 'a'];\n      for (const int freq : count)\n        ans = ans * invFact[freq] % kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n};\n", "2515": "class Solution {\n public:\n  int closetTarget(vector<string>& words, string target, int startIndex) {\n    const int n = words.size();\n\n    for (int i = 0; i < n; ++i) {\n      if (words[(startIndex + i + n) % n] == target)\n        return i;\n      if (words[(startIndex - i + n) % n] == target)\n        return i;\n    }\n\n    return -1;\n  }\n};\n", "2516": "class Solution {\n public:\n  int takeCharacters(string s, int k) {\n    const int n = s.length();\n    int ans = n;\n    vector<int> count(3);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    if (count[0] < k || count[1] < k || count[2] < k)\n      return -1;\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      --count[s[r] - 'a'];\n      while (count[s[r] - 'a'] < k)\n        ++count[s[l++] - 'a'];\n      ans = min(ans, n - (r - l + 1));\n    }\n\n    return ans;\n  }\n};\n", "2517": "class Solution {\n public:\n  int maximumTastiness(vector<int>& price, int k) {\n    ranges::sort(price);\n\n    int l = 0;\n    int r = ranges::max(price) - ranges::min(price) + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numBaskets(price, m) < k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l - 1;\n  }\n\n private:\n  // Returns the number of baskets we can pick for m tastiness.\n  int numBaskets(const vector<int>& price, int m) {\n    int baskets = 0;\n    int prevPrice = -m;\n    for (const int p : price)\n      if (p >= prevPrice + m) {\n        prevPrice = p;\n        ++baskets;\n      }\n    return baskets;\n  }\n};\n", "2518": "class Solution {\n public:\n  int countPartitions(vector<int>& nums, int k) {\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    long ans = modPow(2, nums.size());\n    vector<long> dp(k + 1);\n    dp[0] = 1;\n\n    for (const int num : nums)\n      for (int i = k; i >= num; --i) {\n        dp[i] += dp[i - num];\n        dp[i] %= kMod;\n      }\n\n    // Substract the cases that're not satisfied.\n    for (int i = 0; i < k; ++i)\n      if (sum - i < k)  // Both group1 and group2 < k.\n        ans -= dp[i];\n      else\n        ans -= dp[i] * 2;\n\n    return (ans % kMod + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2519": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int kBigIndices(vector<int>& nums, int k) {\n    const int n = nums.size();\n    int ans = 0;\n    FenwickTree leftTree(n);\n    FenwickTree rightTree(n);\n    // left[i] := the number of `nums` < nums[i] with index < i\n    vector<int> left(n);\n    // right[i] := the number of `nums` < nums[i] with index > i\n    vector<int> right(n);\n\n    for (int i = 0; i < n; ++i) {\n      left[i] = leftTree.get(nums[i] - 1);\n      leftTree.add(nums[i], 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      right[i] = rightTree.get(nums[i] - 1);\n      rightTree.add(nums[i], 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (left[i] >= k && right[i] >= k)\n        ++ans;\n\n    return ans;\n  }\n};\n", "252": "class Solution {\n public:\n  bool canAttendMeetings(vector<vector<int>>& intervals) {\n    ranges::sort(intervals);\n\n    for (int i = 1; i < intervals.size(); ++i)\n      if (intervals[i - 1][1] > intervals[i][0])\n        return false;\n\n    return true;\n  }\n};\n", "2520": "class Solution {\n public:\n  int countDigits(int num) {\n    int ans = 0;\n\n    for (int n = num; n > 0; n /= 10)\n      if (num % (n % 10) == 0)\n        ++ans;\n\n    return ans;\n  }\n};\n", "2521": "class Solution {\n public:\n  int distinctPrimeFactors(vector<int>& nums) {\n    unordered_set<int> primes;\n\n    for (const int num : nums)\n      addPrimeFactors(primes, num);\n\n    return primes.size();\n  }\n\n private:\n  void addPrimeFactors(unordered_set<int>& primes, int num) {\n    for (int divisor = 2; divisor <= num; ++divisor)\n      if (num % divisor == 0) {\n        primes.insert(divisor);\n        while (num % divisor == 0)\n          num /= divisor;\n      }\n  }\n};\n", "2522": "class Solution {\n public:\n  int minimumPartition(string s, int k) {\n    int ans = 1;\n    long curr = 0;\n\n    for (const char c : s) {\n      curr = curr * 10 + c - '0';\n      if (curr > k) {\n        curr = c - '0';\n        ++ans;\n      }\n      if (curr > k)\n        return -1;\n    }\n\n    return ans;\n  }\n};\n", "2523": "class Solution {\n public:\n  vector<int> closestPrimes(int left, int right) {\n    const vector<bool> isPrime = sieveEratosthenes(right + 1);\n    vector<int> primes;\n\n    for (int i = left; i <= right; ++i)\n      if (isPrime[i])\n        primes.push_back(i);\n\n    if (primes.size() < 2)\n      return {-1, -1};\n\n    int minDiff = INT_MAX;\n    int num1 = -1;\n    int num2 = -1;\n\n    for (int i = 1; i < primes.size(); ++i) {\n      const int diff = primes[i] - primes[i - 1];\n      if (diff < minDiff) {\n        minDiff = diff;\n        num1 = primes[i - 1];\n        num2 = primes[i];\n      }\n    }\n\n    return {num1, num2};\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "2524": "class Solution {\n public:\n  int maxFrequencyScore(vector<int>& nums, int k) {\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < k; ++i)\n      ++count[nums[i]];\n\n    int sum = getInitialSum(count);\n    int ans = sum;\n\n    for (int i = k; i < nums.size(); ++i) {\n      // Remove the leftmost number that's out-of-window.\n      const int leftNum = nums[i - k];\n      sum = (sum - modPow(leftNum, count[leftNum]) + kMod) % kMod;\n      // After decreasing its frequency, if it's still > 0, then add it back.\n      if (--count[leftNum] > 0)\n        sum = (sum + modPow(leftNum, count[leftNum])) % kMod;\n      // Otherwise, remove it from the count map.\n      else\n        count.erase(leftNum);\n      // Add the current number. Similarly, remove the current score like above.\n      const int rightNum = nums[i];\n      if (count[rightNum] > 0)\n        sum = (sum - modPow(rightNum, count[rightNum]) + kMod) % kMod;\n      sum = (sum + modPow(rightNum, ++count[rightNum])) % kMod;\n      ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  int getInitialSum(const unordered_map<int, int>& count) {\n    long sum = 0;\n    for (const auto& [num, freq] : count)\n      sum = (sum + modPow(num, freq)) % kMod;\n    return sum;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2525": "class Solution {\n public:\n  string categorizeBox(int length, int width, int height, int mass) {\n    const bool isBulky =\n        length >= 10000 || width >= 10000 || height >= 10000 ||\n        static_cast<long>(length) * width * height >= 1'000'000'000;\n    const bool isHeavy = mass >= 100;\n    if (isBulky && isHeavy)\n      return \"Both\";\n    if (isBulky)\n      return \"Bulky\";\n    if (isHeavy)\n      return \"Heavy\";\n    return \"Neither\";\n  }\n};\n", "2526": "class DataStream {\n public:\n  DataStream(int value, int k) : value(value), k(k) {}\n\n  bool consec(int num) {\n    if (q.size() == k) {\n      if (q.front() == value)\n        --count;\n      q.pop();\n    }\n    if (num == value)\n      ++count;\n    q.push(num);\n    return count == k;\n  }\n\n private:\n  const int value;\n  const int k;\n  queue<int> q;\n  int count = 0;\n};\n", "2527": "class Solution {\n public:\n  int xorBeauty(vector<int>& nums) {\n    return accumulate(nums.begin(), nums.end(), 0, bit_xor<>());\n  }\n};\n", "2528": "class Solution {\n public:\n  long long maxPower(vector<int>& stations, int r, int k) {\n    long left = ranges::min(stations);\n    long right = accumulate(stations.begin(), stations.end(), 0L) + k + 1;\n\n    while (left < right) {\n      const long mid = (left + right) / 2;\n      if (check(stations, r, k, mid))\n        left = mid + 1;\n      else\n        right = mid;\n    }\n\n    return left - 1;\n  }\n\n private:\n  // Returns true if each city can have at least `minPower`.\n  bool check(vector<int> stations, int r, int additionalStations,\n             long minPower) {\n    const int n = stations.size();\n    // Initilaize `power` as the 0-th city's power - stations[r].\n    long power = accumulate(stations.begin(), stations.begin() + r, 0L);\n\n    for (int i = 0; i < n; ++i) {\n      if (i + r < n)\n        power += stations[i + r];  // `power` = sum(stations[i - r..i + r]).\n      if (power < minPower) {\n        const long requiredPower = minPower - power;\n        // There're not enough stations to plant.\n        if (requiredPower > additionalStations)\n          return false;\n        // Greedily plant `requiredPower` power stations in the farthest place\n        // to cover as many cities as possible.\n        stations[min(n - 1, i + r)] += requiredPower;\n        additionalStations -= requiredPower;\n        power += requiredPower;\n      }\n      if (i - r >= 0)\n        power -= stations[i - r];\n    }\n\n    return true;\n  }\n};\n", "2529": "class Solution {\n public:\n  int maximumCount(vector<int>& nums) {\n    return max(ranges::count_if(nums, [](int num) { return num > 0; }),\n               ranges::count_if(nums, [](int num) { return num < 0; }));\n  }\n};\n", "253": "class Solution {\n public:\n  int minMeetingRooms(vector<vector<int>>& intervals) {\n    const int n = intervals.size();\n    int ans = 0;\n    vector<int> starts;\n    vector<int> ends;\n\n    for (const vector<int>& interval : intervals) {\n      starts.push_back(interval[0]);\n      ends.push_back(interval[1]);\n    }\n\n    ranges::sort(starts);\n    ranges::sort(ends);\n\n    for (int i = 0, j = 0; i < n; ++i)\n      if (starts[i] < ends[j])\n        ++ans;\n      else\n        ++j;\n\n    return ans;\n  }\n};\n", "2530": "class Solution {\n public:\n  long long maxKelements(vector<int>& nums, int k) {\n    long ans = 0;\n    priority_queue<int> maxHeap;\n\n    for (const int num : nums)\n      maxHeap.push(num);\n\n    for (int i = 0; i < k; ++i) {\n      const int num = maxHeap.top();\n      maxHeap.pop();\n      ans += num;\n      maxHeap.push((num + 2) / 3);\n    }\n\n    return ans;\n  }\n};\n", "2531": "class Solution {\n public:\n  bool isItPossible(string word1, string word2) {\n    const vector<int> count1 = getCount(word1);\n    const vector<int> count2 = getCount(word2);\n    const int distinct1 = getDistinct(count1);\n    const int distinct2 = getDistinct(count2);\n\n    for (int i = 0; i < 26; ++i)\n      for (int j = 0; j < 26; ++j) {\n        if (count1[i] == 0 || count2[j] == 0)\n          continue;\n        if (i == j) {\n          // Swapping the same letters won't change the number of distinct\n          // letters in each string, so just check if `distinct1 == distinct2`.\n          if (distinct1 == distinct2)\n            return true;\n          continue;\n        }\n        // The calculation is meaningful only when i != j.\n        // Swap ('a' + i) in word1 with ('a' + j) in word2.\n        const int distinctAfterSwap1 =\n            distinct1 - (count1[i] == 1) + (count1[j] == 0);\n        const int distinctAfterSwap2 =\n            distinct2 - (count2[j] == 1) + (count2[i] == 0);\n        if (distinctAfterSwap1 == distinctAfterSwap2)\n          return true;\n      }\n\n    return false;\n  }\n\n private:\n  vector<int> getCount(const string& s) {\n    vector<int> count(26);\n    for (const char c : s)\n      ++count[c - 'a'];\n    return count;\n  }\n\n  int getDistinct(const vector<int>& count) {\n    return ranges::count_if(count, [](const int c) { return c > 0; });\n  }\n};\n", "2532": "class Solution {\n public:\n  int findCrossingTime(int n, int k, vector<vector<int>>& time) {\n    int ans = 0;\n    using P = pair<int, int>;\n    // (leftToRight + rightToLeft, i)\n    priority_queue<P> leftBridgeQueue;\n    priority_queue<P> rightBridgeQueue;\n    // (time to be idle, i)\n    priority_queue<P, vector<P>, greater<>> leftWorkers;\n    priority_queue<P, vector<P>, greater<>> rightWorkers;\n\n    for (int i = 0; i < k; ++i)\n      leftBridgeQueue.emplace(\n          /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);\n\n    while (n > 0 || !rightBridgeQueue.empty() || !rightWorkers.empty()) {\n      // Idle left workers get on the left bridge.\n      while (!leftWorkers.empty() && leftWorkers.top().first <= ans) {\n        const int i = leftWorkers.top().second;\n        leftWorkers.pop();\n        leftBridgeQueue.emplace(\n            /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);\n      }\n      // Idle right workers get on the right bridge.\n      while (!rightWorkers.empty() && rightWorkers.top().first <= ans) {\n        const int i = rightWorkers.top().second;\n        rightWorkers.pop();\n        rightBridgeQueue.emplace(\n            /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);\n      }\n\n      if (!rightBridgeQueue.empty()) {\n        // If the bridge is free, the worker waiting on the right side of the\n        // bridge gets to cross the bridge. If more than one worker is waiting\n        // on the right side, the one with the lowest efficiency crosses first.\n        const int i = rightBridgeQueue.top().second;\n        rightBridgeQueue.pop();\n        ans += /*rightToLeft*/ time[i][2];\n        leftWorkers.emplace(ans + /*putNew*/ time[i][3], i);\n      } else if (!leftBridgeQueue.empty() && n > 0) {\n        // If the bridge is free and no worker is waiting on the right side, and\n        // at least one box remains at the old warehouse, the worker on the left\n        // side of the river gets to cross the bridge. If more than one worker\n        // is waiting on the left side, the one with the lowest efficiency\n        // crosses first.\n        const int i = leftBridgeQueue.top().second;\n        leftBridgeQueue.pop();\n        ans += /*leftToRight*/ time[i][0];\n        rightWorkers.emplace(ans + /*pickOld*/ time[i][1], i);\n        --n;\n      } else {\n        // Advance the time of the last crossing worker.\n        ans = min(\n            !leftWorkers.empty() && n > 0 ? leftWorkers.top().first : INT_MAX,\n            !rightWorkers.empty() ? rightWorkers.top().first : INT_MAX);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2533": "class Solution {\n public:\n  int goodBinaryStrings(int minLength, int maxLength, int oneGroup,\n                        int zeroGroup) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i] := the number of good binary strings with length i\n    vector<int> dp(maxLength + 1);\n    dp[0] = 1;  // \"\"\n\n    for (int i = 0; i <= maxLength; ++i)\n      // There are good binary strings with length i, so we can append\n      // consecutive 0s or 1s after it.\n      if (dp[i] > 0) {\n        const int appendZeros = i + zeroGroup;\n        if (appendZeros <= maxLength) {\n          dp[appendZeros] += dp[i];\n          dp[appendZeros] %= kMod;\n        }\n        const int appendOnes = i + oneGroup;\n        if (appendOnes <= maxLength) {\n          dp[appendOnes] += dp[i];\n          dp[appendOnes] %= kMod;\n        }\n      }\n\n    return accumulate(dp.begin() + minLength, dp.end(), 0L) % kMod;\n  }\n};\n", "2534": "class Solution {\n public:\n  vector<int> timeTaken(vector<int>& arrival, vector<int>& state) {\n    const int n = arrival.size();\n    vector<int> ans(n);\n    vector<queue<int>> qs(2);  // qs[0] := enter queue, qs[1] := exit queue\n    int time = 0;\n    int d = 1;  // 0 := enter, 1 := exit\n\n    for (int i = 0; i < n; ++i) {\n      popQueues(time, d, arrival[i], qs, ans);\n      // If the door was not used in the previous second, then the person who\n      // wants to exit goes first.\n      if (arrival[i] > time) {\n        time = arrival[i];  // Forward `time` to now.\n        d = 1;\n      }\n      qs[state[i]].push(i);\n    }\n\n    popQueues(time, d, 200'000, qs, ans);\n    return ans;\n  }\n\n private:\n  void popQueues(int& time, int& d, int arrivalTime, vector<queue<int>>& qs,\n                 vector<int>& ans) {\n    while (arrivalTime > time && (!qs[0].empty() || !qs[1].empty())) {\n      if (qs[d].empty())\n        d ^= 1;\n      ans[qs[d].front()] = time++, qs[d].pop();\n    }\n  }\n};\n", "2535": "class Solution {\n public:\n  int differenceOfSum(vector<int>& nums) {\n    const int elementSum = accumulate(nums.begin(), nums.end(), 0);\n    const int allDigitSum = getAllDigitSum(nums);\n    return abs(elementSum - allDigitSum);\n  }\n\n private:\n  int getAllDigitSum(const vector<int>& nums) {\n    int allDigitSum = 0;\n    for (const int num : nums)\n      allDigitSum += getDigitSum(num);\n    return allDigitSum;\n  }\n\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "2536": "class Solution {\n public:\n  vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n    vector<vector<int>> ans(n, vector<int>(n));\n    vector<vector<int>> prefix(n, vector<int>(n + 1));\n\n    for (const vector<int>& query : queries) {\n      const int row1 = query[0];\n      const int col1 = query[1];\n      const int row2 = query[2];\n      const int col2 = query[3];\n      for (int i = row1; i <= row2; ++i) {\n        ++prefix[i][col1];\n        --prefix[i][col2 + 1];\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      int sum = 0;\n      for (int j = 0; j < n; ++j) {\n        sum += prefix[i][j];\n        ans[i][j] = sum;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2537": "class Solution {\n public:\n  long long countGood(vector<int>& nums, int k) {\n    long ans = 0;\n    int pairs = 0;\n    unordered_map<int, int> count;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      // Since there're count[r] nums[r]s, including nums[r] to the window will\n      // increase the number of good subarrays by count[r].\n      pairs += count[nums[r]]++;\n      while (pairs >= k)\n        pairs -= --count[nums[l++]];\n      // nums[0..r], nums[1..r], ..., nums[l - 1..r] are good subarrays, so add\n      // l to `ans`.\n      ans += l;\n    }\n\n    return ans;\n  }\n};\n", "2538": "class Solution {\n public:\n  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n    int ans = 0;\n    vector<vector<int>> tree(n);\n    // maxSums[i] := the maximum the sum of path rooted at i\n    vector<int> maxSums(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    // Precalculate `maxSums`.\n    maxSum(tree, 0, /*prev=*/-1, maxSums, price);\n    reroot(tree, 0, /*prev=*/-1, /*parentSum=*/0, maxSums, price, ans);\n    return ans;\n  }\n\n private:\n  int maxSum(const vector<vector<int>>& tree, int u, int prev,\n             vector<int>& maxSums, const vector<int>& price) {\n    int maxChildSum = 0;\n    for (const int v : tree[u])\n      if (v != prev)\n        maxChildSum = max(maxChildSum, maxSum(tree, v, u, maxSums, price));\n    return maxSums[u] = price[u] + maxChildSum;\n  }\n\n  void reroot(const vector<vector<int>>& tree, int u, int prev, int parentSum,\n              const vector<int>& maxSums, const vector<int>& price, int& ans) {\n    // Get the top two subtree sums and the top one node index.\n    int maxSubtreeSum1 = 0;\n    int maxSubtreeSum2 = 0;\n    int maxNode = -1;\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      if (maxSums[v] > maxSubtreeSum1) {\n        maxSubtreeSum2 = maxSubtreeSum1;\n        maxSubtreeSum1 = maxSums[v];\n        maxNode = v;\n      } else if (maxSums[v] > maxSubtreeSum2) {\n        maxSubtreeSum2 = maxSums[v];\n      }\n    }\n\n    if (tree[u].size() == 1)\n      ans = max({ans, parentSum, maxSubtreeSum1});\n\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      const int nextParentSum =\n          (v == maxNode ? price[u] + max(parentSum, maxSubtreeSum2)\n                        : price[u] + max(parentSum, maxSubtreeSum1));\n      reroot(tree, v, u, nextParentSum, maxSums, price, ans);\n    }\n  }\n};\n", "2539": "class Solution {\n public:\n  int countGoodSubsequences(string s) {\n    // For each frequency f in [1, max(freq)], start with \"\" and calculate how\n    // many subsequences can be constructed with each letter's frequency = f.\n    //\n    // e.g. s = \"abb\", so f = max(freq) = 2.\n    //\n    // For f = 1, with 1 way to build \"\", choose any 'a' to construct a good\n    // subseq, so # of good subsequences = 1 + 1 * (1, 1) = 2 (\"\", \"a\"). Next,\n    // add 'b' and # of good subsequences = 2 + 2 * (2, 1) = 6 (\"\", \"a\", \"b1\",\n    // \"b2\", \"ab1\", \"ab2\"). So, the number of good subsequences for f = 1 is 5\n    // since we need to exclude \"\".\n    //\n    // For f = 2, with 1 way to build \"\", choose any two 'b's to construct a\n    // good subseq, so # of good subsequences = 1 + 1 * (2, 2) is 2 (\"\", \"bb\").\n    // So, the number of good subsequences for f = 2 = 1 since we need to\n    // exclude \"\".\n    //\n    // Therefore, the number of good subsequences for \"aab\" = 5 + 1 = 6.\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    const int maxFreq = ranges::max(count);\n    const auto [fact, invFact] = getFactAndInvFact(maxFreq);\n\n    for (int freq = 1; freq <= maxFreq; ++freq) {\n      long numSubseqs = 1;  // \"\"\n      for (const int charFreq : count)\n        if (charFreq >= freq)\n          numSubseqs = (numSubseqs +  //\n                        numSubseqs * nCk(charFreq, freq, fact, invFact)) %\n                       kMod;\n      ans += numSubseqs - 1;  // Minus \"\".\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {\n    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;\n  }\n};\n", "254": "class Solution {\n public:\n  vector<vector<int>> getFactors(int n) {\n    vector<vector<int>> ans;\n    dfs(n, 2, {}, ans);  // The minimum factor is 2.\n    return ans;\n  }\n\n private:\n  void dfs(int n, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (n <= 1) {\n      if (path.size() > 1)\n        ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i <= n; ++i)\n      if (n % i == 0) {\n        path.push_back(i);\n        dfs(n / i, i, std::move(path), ans);\n        path.pop_back();\n      }\n  }\n};\n", "2540": "class Solution {\n public:\n  int getCommon(vector<int>& nums1, vector<int>& nums2) {\n    int i = 0;  // nums1's index\n    int j = 0;  // nums2's index\n\n    while (i < nums1.size() && j < nums2.size()) {\n      if (nums1[i] == nums2[j])\n        return nums1[i];\n      if (nums1[i] < nums2[j])\n        ++i;\n      else\n        ++j;\n    }\n\n    return -1;\n  }\n};\n", "2541": "class Solution {\n public:\n  long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\n    if (k == 0)\n      return nums1 == nums2 ? 0 : -1;\n\n    long ans = 0;\n    // the number of increments - the number of decrements\n    long opsDiff = 0;\n\n    for (int i = 0; i < nums1.size(); ++i) {\n      const int diff = nums1[i] - nums2[i];\n      if (diff == 0)\n        continue;\n      if (diff % k != 0)\n        return -1;\n      const int ops = diff / k;\n      opsDiff += ops;\n      ans += abs(ops);\n    }\n\n    return opsDiff == 0 ? ans / 2 : -1;\n  }\n};\n", "2542": "class Solution {\n public:\n  // Same as 1383. Maximum Performance of a Team\n  long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    long ans = 0;\n    long sum = 0;\n    // (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    vector<pair<int, int>> A;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (int i = 0; i < nums1.size(); ++i)\n      A.emplace_back(nums2[i], nums1[i]);\n\n    ranges::sort(A, greater<>());\n\n    for (const auto& [num2, num1] : A) {\n      minHeap.push(num1);\n      sum += num1;\n      if (minHeap.size() > k)\n        sum -= minHeap.top(), minHeap.pop();\n      if (minHeap.size() == k)\n        ans = max(ans, sum * num2);\n    }\n\n    return ans;\n  }\n};\n", "2543": "class Solution {\n public:\n  bool isReachable(unsigned targetX, unsigned targetY) {\n    return popcount(gcd(targetX, targetY)) == 1;\n  }\n};\n", "2544": "class Solution {\n public:\n  int alternateDigitSum(int n) {\n    int ans = 0;\n    int sign = 1;\n\n    for (; n > 0; n /= 10) {\n      sign *= -1;\n      ans += sign * n % 10;\n    }\n\n    return sign * ans;\n  }\n};\n", "2545": "class Solution {\n public:\n  vector<vector<int>> sortTheStudents(vector<vector<int>>& score, int k) {\n    ranges::sort(score, [k](const vector<int>& a, const vector<int>& b) {\n      return a[k] > b[k];\n    });\n    return score;\n  }\n};\n", "2546": "class Solution {\n public:\n  bool makeStringsEqual(string s, string target) {\n    return (s.find('1') != string::npos) == (target.find('1') != string::npos);\n  }\n};\n", "2547": "class Solution {\n public:\n  int minCost(vector<int>& nums, int k) {\n    constexpr int kMax = 1001;\n    const int n = nums.size();\n    // trimmedLength[i][j] := trimmed(nums[i..j]).length\n    vector<vector<int>> trimmedLength(n, vector<int>(n));\n    // dp[i] := the minimum cost to split nums[i..n)\n    vector<int> dp(n + 1, INT_MAX / 2);\n\n    for (int i = 0; i < n; ++i) {\n      int length = 0;\n      vector<int> count(kMax);\n      for (int j = i; j < n; ++j) {\n        if (++count[nums[j]] == 2)\n          length += 2;\n        else if (count[nums[j]] > 2)\n          ++length;\n        trimmedLength[i][j] = length;\n      }\n    }\n\n    dp[n] = 0;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i; j < n; ++j)\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1]);\n\n    return dp[0];\n  }\n};\n", "2548": "class Solution {\n public:\n  double maxPrice(vector<vector<int>>& items, int capacity) {\n    double ans = 0;\n\n    // Sort items based on price/weight.\n    ranges::sort(items, ranges::greater{}, [](const vector<int>& item) {\n      return static_cast<double>(item[0]) / item[1];\n    });\n\n    for (const vector<int>& item : items) {\n      const int price = item[0];\n      const int weight = item[1];\n      // The bag is filled.\n      if (capacity <= weight)\n        return ans + price * capacity / static_cast<double>(weight);\n      ans += price;\n      capacity -= weight;\n    }\n\n    return -1;\n  }\n};\n", "2549": "class Solution {\n public:\n  int distinctIntegers(int n) {\n    return max(n - 1, 1);\n  }\n};\n", "255": "class Solution {\n public:\n  bool verifyPreorder(vector<int>& preorder) {\n    int low = INT_MIN;\n    stack<int> stack;\n\n    for (const int p : preorder) {\n      if (p < low)\n        return false;\n      while (!stack.empty() && stack.top() < p)\n        low = stack.top(), stack.pop();\n      stack.push(p);\n    }\n\n    return true;\n  }\n};\n", "2550": "class Solution {\n public:\n  int monkeyMove(int n) {\n    const int res = modPow(2, n) - 2;\n    return res < 0 ? res + kMod : res;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2551": "class Solution {\n public:\n  long long putMarbles(vector<int>& weights, int k) {\n    // To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    // cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    // the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    // be counted. So, the goal is to find the max/min k - 1 weights[i] +\n    // weights[i + 1].\n    vector<int> arr;  // weights[i] + weights[i + 1]\n    long mn = 0;\n    long mx = 0;\n\n    for (int i = 0; i + 1 < weights.size(); ++i)\n      arr.push_back(weights[i] + weights[i + 1]);\n\n    ranges::sort(arr);\n\n    for (int i = 0; i < k - 1; ++i) {\n      mn += arr[i];\n      mx += arr[arr.size() - 1 - i];\n    }\n\n    return mx - mn;\n  }\n};\n", "2552": "class Solution {\n public:\n  long long countQuadruplets(vector<int>& nums) {\n    long ans = 0;\n    // dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] <\n    // nums[k] < nums[j]. Keep this information for l to use later.\n    vector<int> dp(nums.size());\n\n    // k can be treated as l.\n    for (int k = 2; k < nums.size(); ++k)\n      // j can be treated as i.\n      for (int j = 0, numLessThanK = 0; j < k; ++j)\n        if (nums[j] < nums[k]) {\n          ++numLessThanK;  // nums[i] < nums[k]\n          // nums[j] < nums[l], so we should add dp[j] since we find a new\n          // quadruplets for (i, j, k, l).\n          ans += dp[j];\n\n        } else if (nums[j] > nums[k]) {\n          dp[j] += numLessThanK;\n        }\n\n    return ans;\n  }\n};\n", "2553": "class Solution {\n public:\n  vector<int> separateDigits(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums)\n      for (const char c : to_string(num))\n        ans.push_back(c - '0');\n\n    return ans;\n  }\n};\n", "2554": "class Solution {\n public:\n  int maxCount(vector<int>& banned, int n, int maxSum) {\n    int ans = 0;\n    int sum = 0;\n    const unordered_set<int> bannedSet{banned.begin(), banned.end()};\n\n    for (int i = 1; i <= n; ++i)\n      if (!bannedSet.contains(i) && sum + i <= maxSum) {\n        ++ans;\n        sum += i;\n      }\n\n    return ans;\n  }\n};\n", "2555": "class Solution {\n public:\n  int maximizeWin(vector<int>& prizePositions, int k) {\n    int ans = 0;\n    // dp[i] := the maximum number of prizes to choose the first i\n    // `prizePositions`\n    vector<int> dp(prizePositions.size() + 1);\n\n    for (int i = 0, j = 0; i < prizePositions.size(); ++i) {\n      while (prizePositions[i] - prizePositions[j] > k)\n        ++j;\n      const int covered = i - j + 1;\n      dp[i + 1] = max(dp[i], covered);\n      ans = max(ans, dp[j] + covered);\n    }\n\n    return ans;\n  }\n};\n", "2556": "class Solution {\n public:\n  bool isPossibleToCutPath(vector<vector<int>>& grid) {\n    if (!hasPath(grid, 0, 0))\n      return true;\n    // Reassign (0, 0) as 1.\n    grid[0][0] = 1;\n    return !hasPath(grid, 0, 0);\n  }\n\n private:\n  // Returns true is there's a path from (0, 0) to (m - 1, n - 1).\n  // Also marks the visited path as 0 except (m - 1, n - 1).\n  bool hasPath(vector<vector<int>>& grid, int i, int j) {\n    if (i == grid.size() || j == grid[0].size())\n      return false;\n    if (i == grid.size() - 1 && j == grid[0].size() - 1)\n      return true;\n    if (grid[i][j] == 0)\n      return false;\n\n    grid[i][j] = 0;\n    // Go down first. Since we use OR logic, we'll only mark one path.\n    return hasPath(grid, i + 1, j) || hasPath(grid, i, j + 1);\n  }\n};\n", "2557": "class Solution {\n public:\n  int maxCount(vector<int>& banned, int n, long long maxSum) {\n    const unordered_set<int> bannedSet{banned.begin(), banned.end()};\n    int l = 1;\n    int r = n;\n\n    while (l < r) {\n      const int m = (l + r + 1) / 2;\n      if (getSum(bannedSet, m) > maxSum)\n        r = m - 1;\n      else\n        l = m;\n    }\n\n    return l - ranges::count_if(bannedSet, [l](const int b) { return b <= l; });\n  }\n\n private:\n  // Returns sum([1..m]) - sum(bannedSet).\n  long getSum(const unordered_set<int>& bannedSet, long m) {\n    long sum = m * (m + 1) / 2;  // sum([1..m])\n    for (const int b : bannedSet)\n      if (b <= m)\n        sum -= b;\n    return sum;\n  }\n};\n", "2558": "class Solution {\n public:\n  long long pickGifts(vector<int>& gifts, int k) {\n    long ans = 0;\n    priority_queue<int> maxHeap;\n\n    for (const int gift : gifts)\n      maxHeap.push(gift);\n\n    for (int i = 0; i < k; ++i) {\n      const int squaredMax = sqrt(maxHeap.top());\n      maxHeap.pop();\n      maxHeap.push(squaredMax);\n    }\n\n    while (!maxHeap.empty())\n      ans += maxHeap.top(), maxHeap.pop();\n\n    return ans;\n  }\n};\n", "2559": "class Solution {\n public:\n  vector<int> vowelStrings(vector<string>& words,\n                           vector<vector<int>>& queries) {\n    vector<int> ans;\n    // prefix[i] := the number of the first i words that start with and end in a\n    // vowel\n    vector<int> prefix(words.size() + 1);\n\n    for (int i = 0; i < words.size(); ++i)\n      prefix[i + 1] += prefix[i] + startsAndEndsWithVowel(words[i]);\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      ans.push_back(prefix[r + 1] - prefix[l]);\n    }\n\n    return ans;\n  }\n\n private:\n  bool startsAndEndsWithVowel(const string& word) {\n    return isVowel(word.front()) && isVowel(word.back());\n  }\n\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "256": "class Solution {\n public:\n  int minCost(vector<vector<int>>& costs) {\n    for (int i = 1; i < costs.size(); ++i) {\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n\n    return ranges::min(costs.back());\n  }\n};\n", "2560": "class Solution {\n public:\n  int minCapability(vector<int>& nums, int k) {\n    int l = ranges::min(nums);\n    int r = ranges::max(nums);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numStolenHouses(nums, m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numStolenHouses(const vector<int>& nums, int capacity) {\n    int stolenHouses = 0;\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] <= capacity) {\n        ++stolenHouses;\n        ++i;\n      }\n    return stolenHouses;\n  }\n};\n", "2561": "class Solution {\n public:\n  long long minCost(vector<int>& basket1, vector<int>& basket2) {\n    vector<int> swapped;\n    unordered_map<int, int> count;\n\n    for (const int b : basket1)\n      ++count[b];\n\n    for (const int b : basket2)\n      --count[b];\n\n    for (const auto& [num, freq] : count) {\n      if (freq % 2 != 0)\n        return -1;\n      for (int i = 0; i < abs(freq) / 2; ++i)\n        swapped.push_back(num);\n    }\n\n    const int minNum = min(ranges::min(basket1), ranges::min(basket2));\n    const auto midIt = swapped.begin() + swapped.size() / 2;\n    nth_element(swapped.begin(), midIt, swapped.end());\n    return accumulate(swapped.begin(), midIt, 0L, [minNum](long acc, int num) {\n      return acc + min(2 * minNum, num);\n    });\n  }\n};\n", "2562": "class Solution {\n public:\n  long long findTheArrayConcVal(vector<int>& nums) {\n    long ans = 0;\n\n    for (int i = 0, j = nums.size() - 1; i <= j; ++i, --j) {\n      ans += nums[j];\n      if (i < j)\n        ans += nums[i] * pow(10, static_cast<int>(log10(nums[j])) + 1);\n    }\n\n    return ans;\n  }\n};\n", "2563": "class Solution {\n public:\n  long long countFairPairs(vector<int>& nums, int lower, int upper) {\n    // nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    // degrades to i != j and we can sort the array.\n    ranges::sort(nums);\n    return countLess(nums, upper) - countLess(nums, lower - 1);\n  }\n\n private:\n  long countLess(const vector<int>& nums, int sum) {\n    long res = 0;\n    for (int i = 0, j = nums.size() - 1; i < j; ++i) {\n      while (i < j && nums[i] + nums[j] > sum)\n        --j;\n      res += j - i;\n    }\n    return res;\n  }\n};\n", "2564": "class Solution {\n public:\n  vector<vector<int>> substringXorQueries(string s,\n                                          vector<vector<int>>& queries) {\n    constexpr int kMaxBit = 30;\n    vector<vector<int>> ans;\n    // {val: (left, right)} := s[left..right]'s decimal value = val\n    unordered_map<int, pair<int, int>> valToLeftAndRight;\n\n    for (int left = 0; left < s.length(); ++left) {\n      int val = 0;\n      if (s[left] == '0') {\n        // edge case: Save the index of the first 0.\n        if (!valToLeftAndRight.contains(0))\n          valToLeftAndRight[0] = {left, left};\n        continue;\n      }\n      const int maxRight = min(static_cast<int>(s.length()), left + kMaxBit);\n      for (int right = left; right < maxRight; ++right) {\n        val = val * 2 + s[right] - '0';\n        if (!valToLeftAndRight.contains(val))\n          valToLeftAndRight[val] = {left, right};\n      }\n    }\n\n    for (const vector<int>& query : queries) {\n      const int first = query[0];\n      const int second = query[1];\n      const int val = first ^ second;\n      const auto it = valToLeftAndRight.find(val);\n      if (it == valToLeftAndRight.cend()) {\n        ans.push_back({-1, -1});\n      } else {\n        const auto [left, right] = it->second;\n        ans.push_back({left, right});\n      }\n    }\n\n    return ans;\n  }\n};\n", "2566": "class Solution {\n public:\n  int minMaxDifference(int num) {\n    const string s = to_string(num);\n    const char to9 = s[firstNotNineIndex(s)];\n    const char to0 = s[0];\n    return getMax(s, to9) - getMin(s, to0);\n  }\n\n private:\n  int firstNotNineIndex(const string& s) {\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] != '9')\n        return i;\n    return 0;\n  }\n\n  int getMax(string s, char to9) {\n    for (char& c : s)\n      if (c == to9)\n        c = '9';\n    return stoi(s);\n  }\n\n  int getMin(string s, char to0) {\n    for (char& c : s)\n      if (c == to0)\n        c = '0';\n    return stoi(s);\n  }\n};\n", "2567": "class Solution {\n public:\n  int minimizeSum(vector<int>& nums) {\n    ranges::sort(nums);\n    // Can always change the number to any other number in `nums`, so `low`\n    // becomes 0. Thus, rephrase the problem as finding the minimum `high`.\n    const int n = nums.size();\n    const int highOfChangingTwoMins = nums.back() - nums[2];\n    const int highOfChangingTwoMaxs = nums[n - 3] - nums[0];\n    const int highOfChangingMinAndMax = nums[n - 2] - nums[1];\n    return min({highOfChangingTwoMins, highOfChangingTwoMaxs,\n                highOfChangingMinAndMax});\n  }\n};\n", "2568": "class Solution {\n public:\n  int minImpossibleOR(vector<int>& nums) {\n    int ans = 1;\n    const unordered_set<int> numsSet{nums.begin(), nums.end()};\n\n    while (numsSet.contains(ans))\n      ans <<= 1;\n\n    return ans;\n  }\n};\n", "2569": "class LazySegmentTree {\n public:\n  explicit LazySegmentTree(const vector<int>& nums) {\n    const int n = nums.size();\n    tree.resize(4 * n);\n    lazy.resize(4 * n);\n    build(nums, 0, 0, n - 1);\n  }\n\n  //            i := index of the current node\n  // [start, end] := range of the current node\n  //       [l, r] := range of the query\n  void updateRange(int i, int start, int end, int l, int r) {\n    if (lazy[i])\n      propogate(i, start, end);\n    if (start > r || end < l)\n      return;\n    if (start >= l && end <= r) {\n      flip(i, start, end);\n      return;\n    }\n    const int mid = (start + end) / 2;\n    updateRange(i * 2 + 1, start, mid, l, r);\n    updateRange(i * 2 + 2, mid + 1, end, l, r);\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\n  }\n\n  int getTreeSum() const {\n    return tree[0];\n  }\n\n private:\n  vector<int> tree;\n  vector<bool> lazy;\n\n  void build(const vector<int>& nums, int i, int start, int end) {\n    if (start == end) {\n      tree[i] = nums[start];\n      return;\n    }\n    const int mid = (start + end) / 2;\n    build(nums, 2 * i + 1, start, mid);\n    build(nums, 2 * i + 2, mid + 1, end);\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\n  }\n\n  void propogate(int i, int start, int end) {\n    flip(i, start, end);\n    lazy[i] = false;\n  }\n\n  void flip(int i, int start, int end) {\n    tree[i] = (end - start + 1) - tree[i];  // Flip 0/1.\n    if (start < end) {\n      lazy[2 * i + 1] = !lazy[2 * i + 1];\n      lazy[2 * i + 2] = !lazy[2 * i + 2];\n    }\n  }\n};\n\nclass Solution {\n public:\n  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,\n                                vector<vector<int>>& queries) {\n    vector<long long> ans;\n    LazySegmentTree tree(nums1);\n    long sumNums2 = accumulate(nums2.begin(), nums2.end(), 0L);\n\n    for (const vector<int>& query : queries) {\n      const int type = query[0];\n      const int l = query[1];\n      const int r = query[2];\n      if (type == 1) {\n        tree.updateRange(0, 0, nums1.size() - 1, l, r);\n      } else if (type == 2) {\n        sumNums2 += static_cast<long>(l) * tree.getTreeSum();\n      } else {  // type == 3\n        ans.push_back(sumNums2);\n      }\n    }\n\n    return ans;\n  }\n};\n", "257": "class Solution {\n public:\n  vector<string> binaryTreePaths(TreeNode* root) {\n    vector<string> ans;\n    dfs(root, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, vector<string>&& path, vector<string>& ans) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      ans.push_back(join(path) + to_string(root->val));\n      return;\n    }\n\n    path.push_back(to_string(root->val) + \"->\");\n    dfs(root->left, std::move(path), ans);\n    dfs(root->right, std::move(path), ans);\n    path.pop_back();\n  }\n\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  }\n};\n", "2570": "class Solution {\n public:\n  vector<vector<int>> mergeArrays(vector<vector<int>>& nums1,\n                                  vector<vector<int>>& nums2) {\n    constexpr int kMax = 1000;\n    vector<vector<int>> ans;\n    vector<int> count(kMax + 1);\n\n    addCount(nums1, count);\n    addCount(nums2, count);\n\n    for (int i = 1; i <= kMax; ++i)\n      if (count[i] > 0)\n        ans.push_back({i, count[i]});\n\n    return ans;\n  }\n\n private:\n  void addCount(const vector<vector<int>>& nums, vector<int>& count) {\n    for (const vector<int>& idAndVal : nums) {\n      const int id = idAndVal[0];\n      const int val = idAndVal[1];\n      count[id] += val;\n    }\n  }\n};\n", "2571": "class Solution {\n public:\n  int minOperations(int n) {\n    // The strategy is that when the end of n is\n    //   1. consecutive 1s, add 1 (2^0).\n    //   2. single 1, substract 1 (2^0).\n    //   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    //\n    // e.g.\n    //\n    //         n = 0b101\n    // n -= 2^0 -> 0b100\n    // n -= 2^2 -> 0b0\n    //         n = 0b1011\n    // n += 2^0 -> 0b1100\n    // n -= 2^2 -> 0b1000\n    // n -= 2^3 -> 0b0\n    int ans = 0;\n\n    while (n > 0)\n      if ((n & 3) == 3) {\n        ++n;\n        ++ans;\n      } else if (n % 2 == 1) {\n        --n;\n        ++ans;\n      } else {\n        n >>= 1;\n      }\n\n    return ans;\n  }\n};\n", "2572": "class Solution {\n public:\n  int squareFreeSubsets(vector<int>& nums) {\n    vector<vector<int>> mem(nums.size(),\n                            vector<int>(1 << (kPrimesCount + 1), -1));\n    vector<int> masks;\n\n    for (const int num : nums)\n      masks.push_back(getMask(num));\n\n    // -1 means that we take no number.\n    // `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (squareFreeSubsets(masks, 0, /*used=*/1, mem) - 1 + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  static constexpr int kPrimesCount = 10;\n  static constexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n  int squareFreeSubsets(const vector<int>& masks, int i, int used,\n                        vector<vector<int>>& mem) {\n    if (i == masks.size())\n      return 1;\n    if (mem[i][used] != -1)\n      return mem[i][used];\n    const int pick = (masks[i] & used) == 0\n                         ? squareFreeSubsets(masks, i + 1, used | masks[i], mem)\n                         : 0;\n    const int skip = squareFreeSubsets(masks, i + 1, used, mem);\n    return mem[i][used] = (pick + skip) % kMod;\n  }\n\n  // e.g. num = 10 = 2 * 5, so mask = 0b101 -> 0b1010 (append a 0)\n  //      num = 15 = 3 * 5, so mask = 0b110 -> 0b1100 (append a 0)\n  //      num = 25 = 5 * 5, so mask =  0b-1 -> 0b1..1 (invalid)\n  int getMask(int num) {\n    int mask = 0;\n    for (int i = 0; i < sizeof(primes) / sizeof(int); ++i) {\n      int rootCount = 0;\n      while (num % primes[i] == 0) {\n        num /= primes[i];\n        ++rootCount;\n      }\n      if (rootCount >= 2)\n        return -1;\n      if (rootCount == 1)\n        mask |= 1 << i;\n    }\n    return mask << 1;\n  }\n};\n", "2573": "class Solution {\n public:\n  string findTheString(vector<vector<int>>& lcp) {\n    const int n = lcp.size();\n    constexpr char nonLetter = 'a' - 1;\n    char c = nonLetter;\n    vector<char> word(n, nonLetter);\n\n    for (int i = 0; i < n; ++i) {\n      if (word[i] != nonLetter)  // There's a candidate already.\n        continue;\n      if (++c > 'z')  // Run out of letters, so return \"\".\n        return \"\";\n      // No need to consider [0..i - 1] since they were considered.\n      for (int j = i; j < n; ++j)\n        if (lcp[i][j] > 0)\n          word[j] = c;\n    }\n\n    // Check if `word` is valid.\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        const int nextLcp = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\n        const int currLcp = word[i] == word[j] ? 1 + nextLcp : 0;\n        if (lcp[i][j] != currLcp)\n          return \"\";\n      }\n\n    string ans;\n    for (const char c : word)\n      ans += c;\n    return ans;\n  }\n};\n", "2574": "class Solution {\n public:\n  vector<int> leftRigthDifference(vector<int>& nums) {\n    vector<int> ans;\n    int leftSum = 0;\n    int rightSum = accumulate(nums.begin(), nums.end(), 0);\n\n    for (const int num : nums) {\n      rightSum -= num;\n      ans.push_back(abs(leftSum - rightSum));\n      leftSum += num;\n    }\n\n    return ans;\n  }\n};\n", "2575": "class Solution {\n public:\n  vector<int> divisibilityArray(string word, int m) {\n    vector<int> ans;\n    long prevRemainder = 0;\n\n    for (const char c : word) {\n      const long remainder = (prevRemainder * 10 + (c - '0')) % m;\n      ans.push_back(remainder == 0 ? 1 : 0);\n      prevRemainder = remainder;\n    }\n\n    return ans;\n  }\n};\n", "2576": "class Solution {\n public:\n  int maxNumOfMarkedIndices(vector<int>& nums) {\n    ranges::sort(nums);\n\n    int i = 0;\n    for (int j = nums.size() / 2; j < nums.size(); ++j)\n      if (2 * nums[i] <= nums[j] && ++i == nums.size() / 2)\n        break;\n\n    return i * 2;\n  }\n};\n", "2577": "class Solution {\n public:\n  int minimumTime(vector<vector<int>>& grid) {\n    if (grid[0][1] > 1 && grid[1][0] > 1)\n      return -1;\n\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    using T = tuple<int, int, int>;  // (time, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    minHeap.emplace(0, 0, 0);\n    seen[0][0] = true;\n\n    while (!minHeap.empty()) {\n      const auto [time, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return time;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        const int extraWait = (grid[x][y] - time) % 2 == 0 ? 1 : 0;\n        const int nextTime = max(time + 1, grid[x][y] + extraWait);\n        minHeap.emplace(nextTime, x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    throw;\n  }\n};\n", "2578": "class Solution {\n public:\n  int splitNum(int num) {\n    string num1;\n    string num2;\n    string s = to_string(num);\n\n    ranges::sort(s);\n\n    for (int i = 0; i < s.length(); ++i)\n      if (i % 2 == 0)\n        num1 += s[i];\n      else\n        num2 += s[i];\n\n    return stoi(num1) + stoi(num2);\n  }\n};\n", "2579": "class Solution {\n public:\n  long long coloredCells(int n) {\n    return static_cast<long>(n) * n + static_cast<long>(n - 1) * (n - 1);\n  }\n};\n", "258": "class Solution {\n public:\n  int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n  }\n};\n", "2580": "class Solution {\n public:\n  int countWays(vector<vector<int>>& ranges) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 1;\n    int prevEnd = -1;\n\n    ranges::sort(ranges);\n\n    for (const vector<int>& range : ranges) {\n      const int start = range[0];\n      const int end = range[1];\n      if (start > prevEnd)\n        ans = ans * 2 % kMod;\n      prevEnd = max(prevEnd, end);\n    }\n\n    return ans;\n  }\n};\n", "2581": "class Solution {\n public:\n  int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses,\n                int k) {\n    int ans = 0;\n    const int n = edges.size() + 1;\n    vector<vector<int>> graph(n);\n    vector<unordered_set<int>> guessGraph(n);\n    vector<int> parent(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (const vector<int>& guess : guesses) {\n      const int u = guess[0];\n      const int v = guess[1];\n      guessGraph[u].insert(v);\n    }\n\n    // Precalculate `parent`.\n    dfs(graph, 0, /*prev=*/-1, parent);\n\n    // Calculate `correctGuess` for tree rooted at 0.\n    int correctGuess = 0;\n    for (int i = 1; i < n; ++i)\n      if (guessGraph[parent[i]].contains(i))\n        ++correctGuess;\n\n    reroot(graph, 0, /*prev=*/-1, correctGuess, guessGraph, k, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, int prev,\n           vector<int>& parent) {\n    parent[u] = prev;\n    for (const int v : graph[u])\n      if (v != prev)\n        dfs(graph, v, u, parent);\n  }\n\n  void reroot(const vector<vector<int>>& graph, int u, int prev,\n              int correctGuess, const vector<unordered_set<int>>& guessGraph,\n              const int& k, int& ans) {\n    if (u != 0) {\n      // The tree is rooted at u, so a guess edge (u, prev) will match the new\n      // `parent` relationship.\n      if (guessGraph[u].contains(prev))\n        ++correctGuess;\n      // A guess edge (prev, u) matching the old `parent` relationship will no\n      // longer be true.\n      if (guessGraph[prev].contains(u))\n        --correctGuess;\n    }\n    if (correctGuess >= k)\n      ++ans;\n    for (const int v : graph[u])\n      if (v != prev)\n        reroot(graph, v, u, correctGuess, guessGraph, k, ans);\n  }\n};\n", "2582": "class Solution {\n public:\n  int passThePillow(int n, int time) {\n    // Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2;\n    if (time < n)  // Go forward from 1.\n      return 1 + time;\n    return n - (time - (n - 1));  // Go backward from n.\n  }\n};\n", "2583": "class Solution {\n public:\n  long long kthLargestLevelSum(TreeNode* root, int k) {\n    vector<long> levelSums;\n    dfs(root, 0, levelSums);\n    if (levelSums.size() < k)\n      return -1;\n\n    nth_element(levelSums.begin(), levelSums.begin() + k - 1, levelSums.end(),\n                greater<>());\n    return levelSums[k - 1];\n  }\n\n private:\n  void dfs(TreeNode* root, int level, vector<long>& levelSums) {\n    if (root == nullptr)\n      return;\n    if (levelSums.size() == level)\n      levelSums.push_back(0);\n    levelSums[level] += root->val;\n    dfs(root->left, level + 1, levelSums);\n    dfs(root->right, level + 1, levelSums);\n  }\n};\n", "2584": "class Solution {\n public:\n  int findValidSplit(vector<int>& nums) {\n    unordered_map<int, int> leftPrimeFactors;\n    unordered_map<int, int> rightPrimeFactors;\n\n    for (const int num : nums)\n      for (const int primeFactor : getPrimeFactors(num))\n        ++rightPrimeFactors[primeFactor];\n\n    for (int i = 0; i < nums.size() - 1; ++i) {\n      for (const int primeFactor : getPrimeFactors(nums[i])) {\n        if (--rightPrimeFactors[primeFactor] == 0) {\n          // rightPrimeFactors[primeFactor] == 0, so no need to track\n          // leftPrimeFactors[primeFactor].\n          rightPrimeFactors.erase(primeFactor);\n          leftPrimeFactors.erase(primeFactor);\n        } else {\n          // Otherwise, need to track leftPrimeFactors[primeFactor].\n          ++leftPrimeFactors[primeFactor];\n        }\n      }\n      if (leftPrimeFactors.empty())\n        return i;\n    }\n\n    return -1;\n  }\n\n private:\n  // Gets the prime factors under sqrt(10^6).\n  vector<int> getPrimeFactors(int num) {\n    vector<int> primeFactors;\n    for (int divisor = 2; divisor <= min(1000, num); ++divisor)\n      if (num % divisor == 0) {\n        primeFactors.push_back(divisor);\n        while (num % divisor == 0)\n          num /= divisor;\n      }\n    // Handle the case that `num` contains a prime factor > 1000.\n    if (num > 1)\n      primeFactors.push_back(num);\n    return primeFactors;\n  }\n};\n", "2585": "class Solution {\n public:\n  int waysToReachTarget(int target, vector<vector<int>>& types) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[j] := the number of ways to earn j points with the types so far\n    vector<int> dp(target + 1);\n    dp[0] = 1;\n\n    for (const vector<int>& type : types) {\n      const int count = type[0];\n      const int mark = type[1];\n      for (int j = target; j >= 0; --j)\n        for (int solved = 1; solved <= count; ++solved)\n          if (j - solved * mark >= 0) {\n            dp[j] += dp[j - solved * mark];\n            dp[j] %= kMod;\n          }\n    }\n\n    return dp[target];\n  }\n};\n", "2586": "class Solution {\n public:\n  int vowelStrings(vector<string>& words, int left, int right) {\n    return count_if(words.begin() + left, words.begin() + right + 1,\n                    [this](const string& word) {\n      return isVowel(word.front()) && isVowel(word.back());\n    });\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "2587": "class Solution {\n public:\n  int maxScore(vector<int>& nums) {\n    long prefix = 0;\n\n    ranges::sort(nums, greater<>());\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      if (prefix <= 0)\n        return i;\n    }\n\n    return nums.size();\n  }\n};\n", "2588": "class Solution {\n public:\n  long long beautifulSubarrays(vector<int>& nums) {\n    // A subarray is beautiful if xor(subarray) = 0.\n    long ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> prefixCount{{0, 1}};\n\n    for (const int num : nums) {\n      prefix ^= num;\n      ans += prefixCount[prefix]++;\n    }\n\n    return ans;\n  }\n};\n", "2589": "class Solution {\n public:\n  int findMinimumTime(vector<vector<int>>& tasks) {\n    constexpr int kMax = 2000;\n    vector<bool> running(kMax + 1);\n\n    // Sort tasks by end.\n    sort(\n        tasks.begin(), tasks.end(),\n        [](const vector<int>& a, const vector<int>& b) { return a[1] < b[1]; });\n\n    for (const vector<int>& task : tasks) {\n      const int start = task[0];\n      const int end = task[1];\n      const int duration = task[2];\n      int neededDuration = duration - count(running.begin() + start,\n                                            running.begin() + end + 1, true);\n      // Greedily run the task as late as possible so that later tasks can run\n      // simultaneously.\n      for (int i = end; neededDuration > 0; --i) {\n        if (!running[i]) {\n          running[i] = true;\n          --neededDuration;\n        }\n      }\n    }\n\n    return ranges::count(running, true);\n  }\n};\n", "259": "class Solution {\n public:\n  int threeSumSmaller(vector<int>& nums, int target) {\n    if (nums.size() < 3)\n      return 0;\n\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i + 2 < nums.size(); ++i) {\n      int l = i + 1;\n      int r = nums.size() - 1;\n      while (l < r)\n        if (nums[i] + nums[l] + nums[r] < target) {\n          // (nums[i], nums[l], nums[r])\n          // (nums[i], nums[l], nums[r - 1])\n          // ...,\n          // (nums[i], nums[l], nums[l + 1])\n          ans += r - l;\n          ++l;\n        } else {\n          --r;\n        }\n    }\n\n    return ans;\n  }\n};\n", "2590": "struct Task {\n  // int taskId;\n  string taskDescription;\n  int dueDate;\n  unordered_set<string> tags;\n\n  bool operator<(const Task& other) const {\n    return dueDate < other.dueDate;\n  }\n};\n\nclass TodoList {\n public:\n  int addTask(int userId, string taskDescription, int dueDate,\n              vector<string> tags) {\n    userIdToTaskIdToTasks[userId][++taskId] =\n        Task{.taskDescription = taskDescription,\n             .dueDate = dueDate,\n             .tags = {tags.begin(), tags.end()}};\n    taskIds.insert(taskId);\n    return taskId;\n  }\n\n  vector<string> getAllTasks(int userId) {\n    vector<string> res;\n    for (const Task& task : getTasksSortedByDueDate(userId))\n      res.push_back(task.taskDescription);\n    return res;\n  }\n\n  vector<string> getTasksForTag(int userId, string tag) {\n    vector<string> res;\n    for (const Task& task : getTasksSortedByDueDate(userId))\n      if (task.tags.contains(tag))\n        res.push_back(task.taskDescription);\n    return res;\n  }\n\n  void completeTask(int userId, int taskId) {\n    if (!taskIds.contains(taskId))\n      return;\n    const auto it = userIdToTaskIdToTasks.find(userId);\n    if (it == userIdToTaskIdToTasks.cend())\n      return;\n    auto& taskIdToTasks = it->second;\n    if (!taskIdToTasks.contains(taskId))\n      return;\n    taskIdToTasks.erase(taskId);\n  }\n\n private:\n  int taskId = 0;\n  unordered_set<int> taskIds;\n  // {userId: {taskId: tasks}}\n  unordered_map<int, unordered_map<int, Task>> userIdToTaskIdToTasks;\n\n  vector<Task> getTasksSortedByDueDate(int userId) {\n    const auto it = userIdToTaskIdToTasks.find(userId);\n    if (it == userIdToTaskIdToTasks.cend())\n      return {};\n    set<Task> tasks;\n    for (const auto& [_, task] : it->second)\n      tasks.insert(task);\n    return {tasks.begin(), tasks.end()};\n  }\n};\n", "2591": "class Solution {\n public:\n  int distMoney(int money, int children) {\n    // Everyone must receive at least 1 dollar.\n    money -= children;\n    if (money < 0)\n      return -1;\n\n    const int count7 = money / 7;\n    const int remaining = money % 7;\n\n    // Distribute 8 dollars to every child.\n    if (count7 == children && remaining == 0)\n      return count7;\n\n    // Need to move 1 dollar from the last child with 4 dollars to one of other\n    // children. That's why we need to substract 1.\n    if (count7 == children - 1 && remaining == 3)\n      return count7 - 1;\n\n    // Though there might be child with 4 dollars, since count7 < children - 1,\n    // we have \"extra\" spot to move money to if needed.\n    return min(children - 1, count7);\n  }\n};\n", "2592": "class Solution {\n public:\n  int maximizeGreatness(vector<int>& nums) {\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (const int num : nums)\n      if (num > nums[ans])\n        ++ans;\n\n    return ans;\n  }\n};\n", "2593": "class Solution {\n public:\n  long long findScore(vector<int>& nums) {\n    long ans = 0;\n    set<pair<int, int>> numAndIndexes;\n    vector<bool> seen(nums.size());\n\n    for (int i = 0; i < nums.size(); ++i)\n      numAndIndexes.insert({nums[i], i});\n\n    for (const auto& [num, i] : numAndIndexes) {\n      if (seen[i])\n        continue;\n      if (i > 0)\n        seen[i - 1] = true;\n      if (i + 1 < nums.size())\n        seen[i + 1] = true;\n      seen[i] = true;\n      ans += num;\n    }\n\n    return ans;\n  }\n};\n", "2594": "class Solution {\n public:\n  long long repairCars(vector<int>& ranks, int cars) {\n    long l = 0;\n    long r = static_cast<long>(ranges::min(ranks)) * cars * cars;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (numCarsFixed(ranks, m) >= cars)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  long numCarsFixed(const vector<int>& ranks, long minutes) {\n    long carsFixed = 0;\n    //    r * n^2 = minutes\n    // -> n = sqrt(minutes / r)\n    for (const int rank : ranks)\n      carsFixed += sqrt(minutes / rank);\n    return carsFixed;\n  }\n};\n", "2595": "class Solution {\n public:\n  vector<int> evenOddBit(int n) {\n    vector<int> ans(2);\n    int i = 0;  // 0 := even, 1 := odd\n\n    while (n > 0) {\n      ans[i] += n & 1;\n      n >>= 1;\n      i ^= 1;\n    }\n\n    return ans;\n  }\n};\n", "2596": "class Solution {\n public:\n  bool checkValidGrid(vector<vector<int>>& grid) {\n    if (grid[0][0] != 0)\n      return false;\n\n    const int n = grid.size();\n    int i = 0;\n    int j = 0;\n\n    for (int target = 1; target < n * n; ++target) {\n      const auto [x, y] = nextGrid(grid, i, j, target);\n      if (x == -1 && y == -1)\n        return false;\n      // Move (x, y) to (i, j).\n      i = x;\n      j = y;\n    }\n\n    return true;\n  }\n\n private:\n  static constexpr int kDirs[8][2] = {{-2, 1}, {-1, 2}, {1, 2},   {2, 1},\n                                      {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\n\n  // Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n  pair<int, int> nextGrid(const vector<vector<int>>& grid, int i, int j,\n                          int target) {\n    const int n = grid.size();\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x >= n || y < 0 || y >= n)\n        continue;\n      if (grid[x][y] == target)\n        return {x, y};\n    }\n    return {-1, -1};\n  }\n};\n", "2597": "// e.g. nums = [2, 3, 4, 4], k = 2\n//\n// subset[0] = [2, 4, 4']\n// subset[1] = [1]\n// count = {2: 1, 4: 2, 1: 1}\n//\n// Initially, skip = len([]) = 0, pick = len([]) = 0\n//\n// * For values in subset[0]:\n//   After 2:\n//     skip = skip + pick = len([]) = 0\n//     pick = (2^count[2] - 1) * (1 + skip + pick)\n//          = len([[2]]) * len([[]])\n//          = len([[2]]) = 1\n//   After 4:\n//     skip = skip + pick = len([[2]]) = 1\n//     pick = (2^count[4] - 1) * (1 + skip)\n//          = len([[4], [4'], [4, 4']]) * len([[]])\n//          = len([[4], [4'], [4, 4']]) = 3\n//\n// * For values in subset[1]:\n//   After 1:\n//     skip = skip + pick\n//          = len([[2], [4], [4'], [4, 4']]) = 4\n//     pick = (2^count[1] - 1) * (1 + skip + pick)\n//          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n//          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n//\n// So, ans = skip + pick = 9\n\nclass Solution {\n public:\n  int beautifulSubsets(vector<int>& nums, int k) {\n    constexpr int kMax = 1000;\n    vector<int> count(kMax + 1);\n    unordered_map<int, set<int>> modToSubset;\n\n    for (const int num : nums) {\n      ++count[num];\n      modToSubset[num % k].insert(num);\n    }\n\n    int prevNum = -k;\n    int skip = 0;\n    int pick = 0;\n\n    for (const auto& [_, subset] : modToSubset)\n      for (const int num : subset) {\n        const int nonEmptyCount = pow(2, count[num]) - 1;\n        const int cacheSkip = skip;\n        skip += pick;\n        pick =\n            nonEmptyCount * (1 + cacheSkip + (num - prevNum == k ? 0 : pick));\n        prevNum = num;\n      }\n\n    return skip + pick;\n  }\n};\n", "2598": "class Solution {\n public:\n  int findSmallestInteger(vector<int>& nums, int value) {\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[(num % value + value) % value];\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (--count[i % value] < 0)\n        return i;\n\n    return nums.size();\n  }\n};\n", "2599": "class Solution {\n public:\n  int makePrefSumNonNegative(vector<int>& nums) {\n    int ans = 0;\n    long prefix = 0;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (const int num : nums) {\n      prefix += num;\n      if (num < 0)\n        minHeap.push(num);\n      while (prefix < 0) {\n        prefix -= minHeap.top(), minHeap.pop();\n        ++ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "26": "class Solution {\n public:\n  int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (i < 1 || num > nums[i - 1])\n        nums[i++] = num;\n\n    return i;\n  }\n};\n", "260": "class Solution {\n public:\n  vector<int> singleNumber(vector<int>& nums) {\n    const int xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<>());\n    const int lowbit = xors & -xors;\n    vector<int> ans(2);\n\n    // Seperate `nums` into two groups by `lowbit`.\n    for (const int num : nums)\n      if (num & lowbit)\n        ans[0] ^= num;\n      else\n        ans[1] ^= num;\n\n    return ans;\n  }\n};\n", "2600": "class Solution {\n public:\n  int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\n    if (k <= numOnes)\n      return k;\n    if (k <= numOnes + numZeros)\n      return numOnes;\n    return numOnes - (k - numOnes - numZeros);\n  }\n};\n", "2601": "class Solution {\n public:\n  bool primeSubOperation(vector<int>& nums) {\n    constexpr int kMax = 1000;\n    const vector<int> primes = sieveEratosthenes(kMax);\n\n    int prevNum = 0;\n    for (int num : nums) {\n      // Make nums[i] the smallest as possible and still > nums[i - 1].\n      const auto it = ranges::lower_bound(primes, num - prevNum);\n      if (it != primes.begin())\n        num -= *prev(it);\n      if (num <= prevNum)\n        return false;\n      prevNum = num;\n    }\n\n    return true;\n  }\n\n  vector<int> sieveEratosthenes(int n) {\n    vector<int> primes;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    for (int i = 2; i < n; ++i)\n      if (isPrime[i])\n        primes.push_back(i);\n    return primes;\n  }\n};\n", "2602": "class Solution {\n public:\n  vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\n    const int n = nums.size();\n    vector<long long> ans;\n    vector<long long> prefix{0};\n\n    ranges::sort(nums);\n\n    for (int i = 0; i < n; ++i)\n      prefix.push_back(prefix.back() + nums[i]);\n\n    for (const long query : queries) {\n      const int i = ranges::upper_bound(nums, query) - nums.begin();\n      // Since nums[0..i) <= query, nums[i..n) > `query`, we should\n      // - increase each num in nums[0..i) to `query` and\n      // - decrease each num in nums[i..n) to `query`.\n      const long inc = query * i - prefix[i];\n      const long dec = prefix[n] - prefix[i] - query * (n - i);\n      ans.push_back(inc + dec);\n    }\n\n    return ans;\n  }\n};\n", "2603": "class Solution {\n public:\n  int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n    const int n = coins.size();\n    vector<unordered_set<int>> tree(n);\n    queue<int> leavesToBeRemoved;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].insert(v);\n      tree[v].insert(u);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      int u = i;\n      // Remove the leaves that don't have coins.\n      while (tree[u].size() == 1 && coins[u] == 0) {\n        const int v = *tree[u].begin();\n        tree[u].clear();\n        tree[v].erase(u);\n        u = v;  // Walk up to its parent.\n      }\n      // After trimming leaves without coins, leaves with coins may satisfy\n      // `leavesToBeRemoved`.\n      if (tree[u].size() == 1)\n        leavesToBeRemoved.push(u);\n    }\n\n    // Remove each remaining leaf node and its parent. The remaining nodes are\n    // the ones that must be visited.\n    for (int i = 0; i < 2; ++i)\n      for (int sz = leavesToBeRemoved.size(); sz > 0; --sz) {\n        const int u = leavesToBeRemoved.front();\n        leavesToBeRemoved.pop();\n        if (!tree[u].empty()) {\n          const int v = *tree[u].begin();\n          tree[u].clear();\n          tree[v].erase(u);\n          if (tree[v].size() == 1)\n            leavesToBeRemoved.push(v);\n        }\n      }\n\n    return accumulate(tree.begin(), tree.end(), 0,\n                      [](int acc, const unordered_set<int>& children) {\n      return acc + children.size();\n    });\n  }\n};\n", "2604": "class Solution {\n public:\n  int minimumTime(vector<int>& hens, vector<int>& grains) {\n    ranges::sort(hens);\n    ranges::sort(grains);\n\n    const int maxPosition = max(ranges::max(hens), ranges::max(grains));\n    const int minPosition = min(ranges::min(hens), ranges::min(grains));\n    int l = 0;\n    int r = 1.5 * (maxPosition - minPosition);\n\n    while (l < r) {\n      const int m = (l + static_cast<long>(r)) / 2;\n      if (canEat(hens, grains, m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if `hens` can eat all `grains` within `time`.\n  bool canEat(const vector<int>& hens, const vector<int>& grains, int time) {\n    int i = 0;  // grains[i] := next grain to be ate\n    for (const int hen : hens) {\n      int moves = time;\n      if (grains[i] < hen) {\n        // `hen` needs go back to eat `grains[i]`.\n        const int leftMoves = hen - grains[i];\n        if (leftMoves > time)\n          return false;\n        const int leftThenRight = time - 2 * leftMoves;\n        const int rightThenLeft = (time - leftMoves) / 2;\n        moves = max({0, leftThenRight, rightThenLeft});\n      }\n      i = ranges::upper_bound(grains, hen + moves) - grains.begin();\n      if (i == grains.size())\n        return true;\n    }\n    return false;\n  }\n};\n", "2605": "class Solution {\n public:\n  int minNumber(vector<int>& nums1, vector<int>& nums2) {\n    int ans = 89;  // the largest num we can have\n    for (const int a : nums1)\n      for (const int b : nums2)\n        ans = min(ans, a == b ? a : min(a, b) * 10 + max(a, b));\n    return ans;\n  }\n};\n", "2606": "class Solution {\n public:\n  int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n    int ans = 0;\n    int cost = 0;\n    vector<int> costs(26);  // costs[i] := the cost of 'a' + i\n\n    iota(costs.begin(), costs.end(), 1);\n\n    for (int i = 0; i < chars.size(); ++i)\n      costs[chars[i] - 'a'] = vals[i];\n\n    for (const char c : s) {\n      cost = max(0, cost + costs[c - 'a']);\n      ans = max(ans, cost);\n    }\n\n    return ans;\n  }\n};\n", "2607": "class Solution {\n public:\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\n    // If the sum of each subarray of length k is equal, then `arr` must have a\n    // repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    // arr[(i + k) % n] for every i.\n    const int n = arr.size();\n    long ans = 0;\n    vector<bool> seen(n);\n\n    for (int i = 0; i < n; ++i) {\n      vector<int> groups;\n      int j = i;\n      while (!seen[j]) {\n        groups.push_back(arr[j]);\n        seen[j] = true;\n        j = (j + k) % n;\n      }\n      nth_element(groups.begin(), groups.begin() + groups.size() / 2,\n                  groups.end());\n      for (const int num : groups)\n        ans += abs(num - groups[groups.size() / 2]);\n    }\n\n    return ans;\n  }\n};\n", "2608": "class Solution {\n public:\n  int findShortestCycle(int n, vector<vector<int>>& edges) {\n    int ans = kInf;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans = min(ans, bfs(graph, i));\n\n    return ans == kInf ? -1 : ans;\n  }\n\n private:\n  static constexpr int kInf = 1001;\n\n  // Returns the length of the minimum cycle by starting BFS from node `i`.\n  // Returns `kInf` if there's no cycle.\n  int bfs(const vector<vector<int>>& graph, int i) {\n    vector<int> dist(graph.size(), kInf);\n    queue<int> q{{i}};\n    dist[i] = 0;\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u]) {\n        if (dist[v] == kInf) {\n          dist[v] = dist[u] + 1;\n          q.push(v);\n        } else if (dist[v] + 1 != dist[u]) {  // v is not a parent u.\n          return dist[v] + dist[u] + 1;\n        }\n      }\n    }\n    return kInf;\n  }\n};\n", "2609": "class Solution {\n public:\n  int findTheLongestBalancedSubstring(string s) {\n    int ans = 0;\n    int zeros = 0;\n    int ones = 0;\n\n    for (const char c : s) {\n      if (c == '0') {\n        zeros = ones > 0 ? 1 : zeros + 1;\n        ones = 0;\n      } else {  // c == '1'\n        ++ones;\n      }\n      if (zeros >= ones)\n        ans = max(ans, ones);\n    }\n\n    return ans * 2;\n  }\n};\n", "261": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  bool validTree(int n, vector<vector<int>>& edges) {\n    if (n == 0 || edges.size() != n - 1)\n      return false;\n\n    UnionFind uf(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      uf.unionByRank(u, v);\n    }\n\n    return uf.getCount() == 1;\n  }\n};\n", "2610": "class Solution {\n public:\n  vector<vector<int>> findMatrix(vector<int>& nums) {\n    // The number of rows we need equals the maximum frequency.\n    vector<vector<int>> ans;\n    vector<int> count(nums.size() + 1);\n\n    for (const int num : nums) {\n      // Construct `ans` on demand.\n      if (++count[num] > ans.size())\n        ans.push_back({});\n      ans[count[num] - 1].push_back(num);\n    }\n\n    return ans;\n  }\n};\n", "2611": "class Solution {\n public:\n  int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\n    // diffs[i] := reward1[i] - reward2[i].\n    vector<int> diffs;\n\n    for (int i = 0; i < reward1.size(); ++i)\n      diffs.push_back(reward1[i] - reward2[i]);\n\n    nth_element(diffs.begin(), diffs.begin() + k, diffs.end(), greater<>());\n    return accumulate(reward2.begin(), reward2.end(), 0) +\n           accumulate(diffs.begin(), diffs.begin() + k, 0);\n  }\n};\n", "2612": "class Solution {\n public:\n  vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\n    const unordered_set<int> bannedSet{banned.begin(), banned.end()};\n    vector<int> ans(n, -1);\n    // unseen[i] := the unseen numbers that % 2 == i\n    vector<set<int>> unseen(2);\n\n    for (int num = 0; num < n; ++num)\n      if (num != p && !bannedSet.contains(num))\n        unseen[num % 2].insert(num);\n\n    // Perform BFS from `p`.\n    queue<int> q{{p}};\n    ans[p] = 0;\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      const int lo = max(u - k + 1, k - 1 - u);\n      const int hi = min(u + k - 1, n - 1 - (u - (n - k)));\n      // Choose the correct set of numbers.\n      set<int>& nums = unseen[lo % 2];\n      for (auto it = nums.lower_bound(lo); it != nums.end() && *it <= hi;) {\n        ans[*it] = ans[u] + 1;\n        q.push(*it);\n        it = nums.erase(it);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2613": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums)\n      : maxNum(nums.size()), nums(std::move(nums)), tree(4 * maxNum, -1) {}\n\n  // Updates the value of the node to be the index of the smaller number between\n  // the old value stored at the node and the new value `index`, where `i` is\n  // the index of the element in the `nums` array.\n  void update(int i, int numIndex) {\n    update(0, 0, maxNum, i, numIndex);\n  }\n\n  // Returns the index k s.t. `nums[k]` is maximum number in the range [i, j].\n  int query(int i, int j) const {\n    return query(0, 0, maxNum, i, j);\n  }\n\n private:\n  // default node value for non-overlapping queries\n  static constexpr int kDefaultValue = -1;\n  const int maxNum;\n  const vector<int> nums;  // nums2 + nums1 or nums2 - nums1\n  vector<int> tree;        // tree[i] := the minimum index stored in this node\n\n  void update(int treeIndex, int lo, int hi, int i, int numIndex) {\n    if (lo == hi) {\n      tree[treeIndex] = merge(tree[treeIndex], numIndex);\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, numIndex);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, numIndex);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return kDefaultValue;\n    const int mid = (lo + hi) / 2;\n    return merge(query(2 * treeIndex + 1, lo, mid, i, j),\n                 query(2 * treeIndex + 2, mid + 1, hi, i, j));\n  }\n\n  // Returns the better index. Index i is better than index j if\n  // (nums[i] > nums[j]) or (nums[i] == nums[j] && i < j).\n  int merge(const int& i, const int& j) const {\n    if (i == -1)\n      return j;\n    if (j == -1)\n      return i;\n    if (nums[i] > nums[j])\n      return i;\n    if (nums[j] > nums[i])\n      return j;\n    return min(i, j);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> beautifulPair(vector<int>& nums1, vector<int>& nums2) {\n    // The goal is to find the lexicographically smallest beautiful pair (i, j)\n    // s.t. |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest.\n    //\n    // Sort `nums2` and store the order in `indices`.\n    // To minimize |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|, since we\n    // already have sorted `nums2`, we can always have nums2[i] > nums2[j] while\n    // iterating the array. So we only need to consider the following 2 cases:\n    //\n    // * nums1[i] >= nums1[j]:\n    //   The value will be nums1[i] - nums1[j] + nums2[i] - nums2[j]\n    //                   = (nums2[i] + nums1[i]) - (nums2[j] + nums1[j])\n    //   Just find max (nums2[j] + nums1[j]) s.t. 0 <= nums1[j] <= nums1[i].\n    //\n    // * nums1[i] <= nums1[j]:\n    //   The value will be nums1[j] - nums1[i] + nums2[i] - nums2[j]\n    //                   = (nums2[i] - nums1[i]) - (nums2[j] - nums1[j])\n    //   Just find max (nums2[j] - nums1[j]) s.t. nums1[i] <= nums1[j] <= n.\n    constexpr int kInf = 1'000'000'000;\n    const int n = nums1.size();\n    vector<int> ans(2, n);\n    vector<int> nums2PlusNums1;\n    vector<int> nums2MinusNums1;\n    vector<int> indices;\n    int minBeauty = INT_MAX;\n\n    for (int i = 0; i < n; ++i) {\n      nums2PlusNums1.push_back(nums2[i] + nums1[i]);\n      nums2MinusNums1.push_back(nums2[i] - nums1[i]);\n      indices.push_back(i);\n    }\n\n    ranges::sort(indices,\n                 [&nums2](int i, int j) { return nums2[i] < nums2[j]; });\n\n    SegmentTree tree1(nums2PlusNums1);\n    SegmentTree tree2(nums2MinusNums1);\n\n    for (const int i : indices) {\n      const int num = nums1[i];\n      // For case nums1[i] >= nums1[j], find index j s.t. (nums2[j] + nums1[j])\n      // is the maximum in the range [0, nums1[i]].\n      int j = tree1.query(0, num);\n      if (j >= 0)\n        updateAns(nums2PlusNums1, i, j, minBeauty, ans);\n      tree1.update(num, i);\n      // For case nums1[i] <= nums1[j], find index j s.t. (nums2[j] - nums1[j])\n      // is the maximum in the range [nums1[i], n].\n      j = tree2.query(num, n);\n      if (j >= 0)\n        updateAns(nums2MinusNums1, i, j, minBeauty, ans);\n      tree2.update(num, i);\n    }\n\n    return ans;\n  }\n\n private:\n  void updateAns(const vector<int>& nums, int i, int j, int& minBeauty,\n                 vector<int>& ans) {\n    // beauty := |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|\n    const int beauty = nums[i] - nums[j];\n    const vector<int> nextAns = {min(i, j), max(i, j)};\n    if (beauty < minBeauty) {\n      minBeauty = beauty;\n      ans = nextAns;\n    } else if (beauty == minBeauty) {\n      ans = min(ans, nextAns);\n    }\n  }\n};\n", "2614": "class Solution {\n public:\n  int diagonalPrime(vector<vector<int>>& nums) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      const int a = nums[i][i];\n      const int b = nums[i][nums.size() - i - 1];\n      if (isPrime(a))\n        ans = max(ans, a);\n      if (isPrime(b))\n        ans = max(ans, b);\n    }\n    return ans;\n  }\n\n private:\n  bool isPrime(int n) {\n    if (n <= 1)\n      return false;\n    for (int i = 2; i * i <= n; ++i)\n      if (n % i == 0)\n        return false;\n    return true;\n  }\n};\n", "2615": "class Solution {\n public:\n  vector<long long> distance(vector<int>& nums) {\n    vector<long long> ans(nums.size());\n    unordered_map<int, vector<int>> numToIndices;\n\n    for (int i = 0; i < nums.size(); ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    for (const auto& [_, indices] : numToIndices) {\n      const int n = indices.size();\n      if (n == 1)\n        continue;\n      long sumSoFar = accumulate(indices.begin(), indices.end(), 0L);\n      int prevIndex = 0;\n      for (int i = 0; i < n; ++i) {\n        sumSoFar += (i - 1) * (indices[i] - prevIndex);\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex);\n        ans[indices[i]] = sumSoFar;\n        prevIndex = indices[i];\n      }\n    }\n\n    return ans;\n  }\n};\n", "2616": "class Solution {\n public:\n  int minimizeMax(vector<int>& nums, int p) {\n    ranges::sort(nums);\n\n    int l = 0;\n    int r = nums.back() - nums.front();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numPairs(nums, m) >= p)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the number of pairs that can be obtained if the difference between\n  // each pair <= `maxDiff`.\n  int numPairs(const vector<int>& nums, int maxDiff) {\n    int pairs = 0;\n    for (int i = 1; i < nums.size(); ++i)\n      // Greedily pair nums[i] with nums[i - 1].\n      if (nums[i] - nums[i - 1] <= maxDiff) {\n        ++pairs;\n        ++i;\n      }\n    return pairs;\n  }\n};\n", "2617": "class SegmentTree {\n public:\n  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns min(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int kInf;    // the invalid value\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return kInf;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return min(left, right);\n  }\n};\n\nclass Solution {\n public:\n  int minimumVisitedCells(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int kInf = (m + n) * 2 - 1;\n    vector<SegmentTree> rows(m, SegmentTree(n, kInf));\n    vector<SegmentTree> cols(n, SegmentTree(m, kInf));\n\n    // The min # cells to visit (m - 1, n - 1) from (m - 1, n - 1) is 1.\n    rows[m - 1].update(n - 1, 1);\n    cols[n - 1].update(m - 1, 1);\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        // There's no k s.t. j < k <= 0 + j.\n        // There's no k s.t. i < k <= 0 + i.\n        if (grid[i][j] == 0)\n          continue;\n        const int moveRight = rows[i].query(j + 1, grid[i][j] + j);\n        const int moveDown = cols[j].query(i + 1, grid[i][j] + i);\n        const int minMove = min(kInf, min(moveRight, moveDown) + 1);\n        rows[i].update(j, minMove);\n        cols[j].update(i, minMove);\n      }\n\n    const int res = rows[0].query(0, 0);\n    return res == kInf ? -1 : res;\n  }\n};\n", "263": "class Solution {\n public:\n  bool isUgly(int n) {\n    if (n == 0)\n      return false;\n\n    for (const int prime : {2, 3, 5})\n      while (n % prime == 0)\n        n /= prime;\n\n    return n == 1;\n  }\n};\n", "2638": "class Solution {\n public:\n  // Similar to 2597. The Number of Beautiful Subsets\n  long long countTheNumOfKFreeSubsets(vector<int>& nums, int k) {\n    unordered_map<int, set<int>> modToSubset;\n\n    for (const int num : nums)\n      modToSubset[num % k].insert(num);\n\n    int prevNum = -k;\n    long skip = 0;\n    long pick = 0;\n\n    for (const auto& [_, subset] : modToSubset)\n      for (const int num : subset) {\n        const long cacheSkip = skip;\n        skip += pick;\n        pick = 1 + cacheSkip + (num - prevNum == k ? 0 : pick);\n        prevNum = num;\n      }\n\n    return 1 + skip + pick;\n  }\n};\n", "2639": "class Solution {\n public:\n  vector<int> findColumnWidth(vector<vector<int>>& grid) {\n    vector<int> ans;\n\n    for (int j = 0; j < grid[0].size(); ++j) {\n      ans.push_back(0);\n      for (int i = 0; i < grid.size(); ++i)\n        ans[j] = max(ans[j], static_cast<int>(to_string(grid[i][j]).length()));\n    }\n\n    return ans;\n  }\n};\n", "264": "class Solution {\n public:\n  int nthUglyNumber(int n) {\n    vector<int> uglyNums{1};\n    int i2 = 0;\n    int i3 = 0;\n    int i5 = 0;\n\n    while (uglyNums.size() < n) {\n      const int next2 = uglyNums[i2] * 2;\n      const int next3 = uglyNums[i3] * 3;\n      const int next5 = uglyNums[i5] * 5;\n      const int next = min({next2, next3, next5});\n      if (next == next2)\n        ++i2;\n      if (next == next3)\n        ++i3;\n      if (next == next5)\n        ++i5;\n      uglyNums.push_back(next);\n    }\n\n    return uglyNums.back();\n  }\n};\n", "2640": "class Solution {\n public:\n  vector<long long> findPrefixScore(vector<int>& nums) {\n    vector<long long> ans;\n    long prefix = 0;\n    int mx = 0;\n\n    for (const int num : nums) {\n      mx = max(mx, num);\n      prefix += num + mx;\n      ans.push_back(prefix);\n    }\n\n    return ans;\n  }\n};\n", "2641": "class Solution {\n public:\n  TreeNode* replaceValueInTree(TreeNode* root) {\n    vector<int> levelSums;\n    dfs(root, 0, levelSums);\n    return replace(root, 0, new TreeNode(0), levelSums);\n  }\n\n private:\n  void dfs(TreeNode* root, int level, vector<int>& levelSums) {\n    if (root == nullptr)\n      return;\n    if (levelSums.size() == level)\n      levelSums.push_back(0);\n    levelSums[level] += root->val;\n    dfs(root->left, level + 1, levelSums);\n    dfs(root->right, level + 1, levelSums);\n  }\n\n  TreeNode* replace(TreeNode* root, int level, TreeNode* curr,\n                    const vector<int>& levelSums) {\n    const int nextLevel = level + 1;\n    const int nextLevelCousinsSum =\n        nextLevel >= levelSums.size()\n            ? 0\n            : levelSums[nextLevel] -\n                  (root->left == nullptr ? 0 : root->left->val) -\n                  (root->right == nullptr ? 0 : root->right->val);\n    if (root->left != nullptr) {\n      curr->left = new TreeNode(nextLevelCousinsSum);\n      replace(root->left, level + 1, curr->left, levelSums);\n    }\n    if (root->right != nullptr) {\n      curr->right = new TreeNode(nextLevelCousinsSum);\n      replace(root->right, level + 1, curr->right, levelSums);\n    }\n    return curr;\n  }\n};\n", "2642": "class Graph {\n public:\n  Graph(int n, vector<vector<int>>& edges) {\n    graph.resize(n);\n    for (const vector<int>& edge : edges)\n      addEdge(edge);\n  }\n\n  void addEdge(vector<int> edge) {\n    const int u = edge[0];\n    const int v = edge[1];\n    const int w = edge[2];\n    graph[u].emplace_back(v, w);\n  }\n\n  int shortestPath(int node1, int node2) {\n    vector<int> dist(graph.size(), INT_MAX);\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    dist[node1] = 0;\n    minHeap.emplace(dist[node1], node1);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (u == node2)\n        return d;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return -1;\n  }\n\n private:\n  vector<vector<pair<int, int>>> graph;\n};\n", "2643": "class Solution {\n public:\n  vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\n    vector<int> ans{0, 0};\n\n    for (int i = 0; i < mat.size(); ++i) {\n      const int ones = ranges::count(mat[i], 1);\n      if (ones > ans[1]) {\n        ans[0] = i;\n        ans[1] = ones;\n      }\n    }\n\n    return ans;\n  }\n};\n", "2644": "class Solution {\n public:\n  int maxDivScore(vector<int>& nums, vector<int>& divisors) {\n    int ans = -1;\n    int maxScore = -1;\n\n    for (const int divisor : divisors) {\n      const int score = ranges::count_if(\n          nums, [divisor](const int num) { return num % divisor == 0; });\n      if (score > maxScore) {\n        ans = divisor;\n        maxScore = score;\n      } else if (score == maxScore) {\n        ans = min(ans, divisor);\n      }\n    }\n\n    return ans;\n  }\n};\n", "2645": "class Solution {\n public:\n  int addMinimum(string word) {\n    const string letters = \"abc\";\n    int ans = 0;\n    int i = 0;\n\n    while (i < word.length())\n      for (const char c : letters) {\n        if (i < word.length() && word[i] == c)\n          ++i;\n        else\n          ++ans;\n      }\n\n    return ans;\n  }\n};\n", "2646": "class Solution {\n public:\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price,\n                        vector<vector<int>>& trips) {\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    // count[i] := the number of times node i is traversed\n    vector<int> count(n);\n\n    for (const vector<int>& trip : trips) {\n      const int start = trip[0];\n      const int end = trip[1];\n      vector<int> path;\n      dfsCount(graph, start, /*prev=*/-1, end, count, path);\n    }\n\n    vector<vector<int>> mem(n, vector<int>(2, -1));\n    return dfs(graph, 0, -1, price, count, false, mem);\n  }\n\n private:\n  void dfsCount(const vector<vector<int>>& graph, int u, int prev, int end,\n                vector<int>& count, vector<int>& path) {\n    path.push_back(u);\n    if (u == end) {\n      for (const int i : path)\n        ++count[i];\n      return;\n    }\n    for (const int v : graph[u])\n      if (v != prev)\n        dfsCount(graph, v, u, end, count, path);\n    path.pop_back();\n  }\n\n  // Returns the minimum price sum for the i-th node, where its parent is\n  // halved parent or not halved not.\n  int dfs(const vector<vector<int>>& graph, int u, int prev,\n          const vector<int>& price, const vector<int>& count, int parentHalved,\n          vector<vector<int>>& mem) {\n    if (mem[u][parentHalved] != -1)\n      return mem[u][parentHalved];\n\n    int sumWithFullNode = price[u] * count[u];\n    for (const int v : graph[u])\n      if (v != prev)\n        sumWithFullNode += dfs(graph, v, u, price, count, false, mem);\n\n    if (parentHalved)  // Can't halve this node if its parent was halved.\n      return mem[u][parentHalved] = sumWithFullNode;\n\n    int sumWithHalvedNode = (price[u] / 2) * count[u];\n    for (const int v : graph[u])\n      if (v != prev)\n        sumWithHalvedNode += dfs(graph, v, u, price, count, true, mem);\n\n    return mem[u][parentHalved] = min(sumWithFullNode, sumWithHalvedNode);\n  }\n};\n", "2647": "class Solution {\n public:\n  vector<vector<int>> colorRed(int n) {\n    vector<vector<int>> ans;\n    const int tipSize = n % 4;\n\n    // The tip of the triangle is always painted red.\n    if (tipSize >= 1)\n      ans.push_back({1, 1});\n\n    // Paint the rightmost and the leftmost elements at the following rows.\n    for (int i = 2; i <= tipSize; ++i) {\n      ans.push_back({i, 1});\n      ans.push_back({i, 2 * i - 1});\n    }\n\n    // Paint the 4-row chunks.\n    for (int i = tipSize + 1; i < n; i += 4) {\n      // Fill the first row of the chunk.\n      ans.push_back({i, 1});\n      // Fill the second row.\n      for (int j = 1; j <= i; ++j)\n        ans.push_back({i + 1, 2 * j + 1});\n      // Fill the third row.\n      ans.push_back({i + 2, 2});\n      // Fill the fourth row.\n      for (int j = 0; j <= i + 2; ++j)\n        ans.push_back({i + 3, 2 * j + 1});\n    }\n\n    return ans;\n  }\n};\n", "265": "class Solution {\n public:\n  int minCostII(vector<vector<int>>& costs) {\n    int prevIndex = -1;  // the previous minimum index\n    int prevMin1 = 0;    // the minimum cost so far\n    int prevMin2 = 0;    // the second minimum cost so far\n\n    for (const vector<int>& cost : costs) {  // O(n)\n      // the painted index that will achieve the minimum cost after painting the\n      // current house\n      int index = -1;\n      // the minimum cost after painting the current house\n      int min1 = INT_MAX;\n      // the second minimum cost after painting the current house\n      int min2 = INT_MAX;\n      for (int i = 0; i < cost.size(); ++i) {  // O(k)\n        const int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);\n        if (theCost < min1) {\n          index = i;\n          min2 = min1;\n          min1 = theCost;\n        } else if (theCost < min2) {  // min1 <= theCost < min2\n          min2 = theCost;\n        }\n      }\n      prevIndex = index;\n      prevMin1 = min1;\n      prevMin2 = min2;\n    }\n\n    return prevMin1;\n  }\n};\n", "2651": "class Solution {\n public:\n  int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n    return (arrivalTime + delayedTime) % 24;\n  }\n};\n", "2652": "class Solution {\n public:\n  int sumOfMultiples(int n) {\n    // Returns the sum of multiples of value in [1, n].\n    auto sumOfMultiples = [n](int value) {\n      const int lo = value;\n      const int hi = n / value * value;\n      const int count = (hi - lo) / value + 1;\n      return (lo + hi) * count / 2;\n    };\n    return sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n           (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n           sumOfMultiples(105);\n  }\n};\n", "2653": "class Solution {\n public:\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\n    vector<int> ans;\n    vector<int> count(50);  // count[i] := the frequency of (i + 50)\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] < 0)\n        ++count[nums[i] + 50];\n      if (i - k >= 0 && nums[i - k] < 0)\n        --count[nums[i - k] + 50];\n      if (i + 1 >= k)\n        ans.push_back(getXthSmallestNum(count, x));\n    }\n\n    return ans;\n  }\n\n private:\n  int getXthSmallestNum(const vector<int>& count, int x) {\n    int prefix = 0;\n    for (int i = 0; i < 50; ++i) {\n      prefix += count[i];\n      if (prefix >= x)\n        return i - 50;\n    }\n    return 0;\n  }\n};\n", "2654": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    const int n = nums.size();\n    const int ones = ranges::count(nums, 1);\n    if (ones > 0)\n      return n - ones;\n\n    // the minimum operations to make the shortest subarray with a gcd == 1\n    int minOps = INT_MAX;\n\n    for (int i = 0; i < n; ++i) {\n      int g = nums[i];\n      for (int j = i + 1; j < n; ++j) {\n        g = __gcd(g, nums[j]);\n        if (g == 1) {  // gcd(nums[i..j]) == 1\n          minOps = min(minOps, j - i);\n          break;\n        }\n      }\n    }\n\n    // After making the shortest subarray with `minOps`, need additional n - 1\n    // operations to make the other numbers to 1.\n    return minOps == INT_MAX ? -1 : minOps + n - 1;\n  }\n};\n", "2655": "class Solution {\n public:\n  vector<vector<int>> findMaximalUncoveredRanges(int n,\n                                                 vector<vector<int>>& ranges) {\n    vector<vector<int>> ans;\n    int start = 0;\n\n    ranges::sort(ranges);\n\n    for (const vector<int>& range : ranges) {\n      const int l = range[0];\n      const int r = range[1];\n      if (start < l)\n        ans.push_back({start, l - 1});\n      if (start <= r)\n        start = r + 1;\n    }\n\n    if (start < n)\n      ans.push_back({start, n - 1});\n\n    return ans;\n  }\n};\n", "2656": "class Solution {\n public:\n  int maximizeSum(vector<int>& nums, int k) {\n    // If x = max(nums), ans = x + (x + 1) + .. + (x + k - 1).\n    const int x = ranges::max(nums);\n    return x * k + k * (k - 1) / 2;\n  }\n};\n", "2657": "class Solution {\n public:\n  vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\n    const int n = A.size();\n    int prefixCommon = 0;\n    vector<int> ans;\n    vector<int> count(n + 1);\n\n    for (int i = 0; i < A.size(); ++i) {\n      if (++count[A[i]] == 2)\n        ++prefixCommon;\n      if (++count[B[i]] == 2)\n        ++prefixCommon;\n      ans.push_back(prefixCommon);\n    }\n\n    return ans;\n  }\n};\n", "2658": "class Solution {\n public:\n  int findMaxFish(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] > 0)\n          ans = max(ans, dfs(grid, i, j));\n\n    return ans;\n  }\n\n private:\n  int dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return 0;\n    if (grid[i][j] == 0)\n      return 0;\n    int caughtFish = grid[i][j];\n    grid[i][j] = 0;                                     // Mark 0 as visited\n    return caughtFish +                                 //\n           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //\n           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);\n  }\n};\n", "2659": "class Solution {\n public:\n  long long countOperationsToEmptyArray(vector<int>& nums) {\n    const int n = nums.size();\n    long ans = n;\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < n; ++i)\n      numToIndex[nums[i]] = i;\n\n    ranges::sort(nums);\n\n    for (int i = 1; i < n; ++i)\n      // On the i-th step we've already removed the i - 1 smallest numbers and\n      // can ignore them. If an element nums[i] has smaller index in origin\n      // array than nums[i - 1], we should rotate the whole left array n - i\n      // times to set nums[i] element on the first position.\n      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\n        ans += n - i;\n\n    return ans;\n  }\n};\n", "266": "class Solution {\n public:\n  bool canPermutePalindrome(string s) {\n    unordered_set<char> seen;\n\n    for (const char c : s)\n      if (!seen.insert(c).second)\n        seen.erase(c);\n\n    return seen.size() <= 1;\n  }\n};\n", "2660": "class Solution {\n public:\n  int isWinner(vector<int>& player1, vector<int>& player2) {\n    const int score1 = getScore(player1);\n    const int score2 = getScore(player2);\n    if (score1 > score2)\n      return 1;\n    if (score2 > score1)\n      return 2;\n    return 0;\n  }\n\n private:\n  int getScore(const vector<int>& player) {\n    constexpr int kInvalid = -3;\n    int score = 0;\n    int last10 = kInvalid;\n    for (int i = 0; i < player.size(); ++i) {\n      score += i - last10 > 2 ? player[i] : player[i] * 2;\n      if (player[i] == 10)\n        last10 = i;\n    }\n    return score;\n  }\n};\n", "2661": "class Solution {\n public:\n  int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    // rows[i] := the number of painted grid in the i-th row\n    vector<int> rows(m);\n    // cols[j] := the number of painted grid in the j-th column\n    vector<int> cols(n);\n    // numToRow[num] := the i-th row of `num` in `mat`\n    vector<int> numToRow(m * n + 1);\n    // numToCol[num] := the j-th column of `num` in `mat`\n    vector<int> numToCol(m * n + 1);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        numToRow[mat[i][j]] = i;\n        numToCol[mat[i][j]] = j;\n      }\n\n    for (int i = 0; i < arr.size(); ++i) {\n      if (++rows[numToRow[arr[i]]] == n)\n        return i;\n      if (++cols[numToCol[arr[i]]] == m)\n        return i;\n    }\n\n    throw;\n  }\n};\n", "2662": "class Solution {\n public:\n  int minimumCost(vector<int>& start, vector<int>& target,\n                  vector<vector<int>>& specialRoads) {\n    return dijkstra(specialRoads, start[0], start[1], target[0], target[1]);\n  }\n\n private:\n  int dijkstra(const vector<vector<int>>& specialRoads, int srcX, int srcY,\n               int dstX, int dstY) {\n    const int n = specialRoads.size();\n    // dist[i] := the minimum distance of (srcX, srcY) to\n    // specialRoads[i](x2, y2)\n    vector<int> dist(specialRoads.size(), INT_MAX);\n    using P = pair<int, int>;  // (d, u), where u := the i-th specialRoads\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    // (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for (int u = 0; u < n; ++u) {\n      const int x1 = specialRoads[u][0];\n      const int y1 = specialRoads[u][1];\n      const int cost = specialRoads[u][4];\n      const int d = abs(x1 - srcX) + abs(y1 - srcY) + cost;\n      dist[u] = d;\n      minHeap.emplace(dist[u], u);\n    }\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      const int ux2 = specialRoads[u][2];\n      const int uy2 = specialRoads[u][3];\n      for (int v = 0; v < n; ++v) {\n        if (v == u)\n          continue;\n        const int vx1 = specialRoads[v][0];\n        const int vy1 = specialRoads[v][1];\n        const int vcost = specialRoads[v][4];\n        // (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        const int newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost;\n        if (newDist < dist[v]) {\n          dist[v] = newDist;\n          minHeap.emplace(dist[v], v);\n        }\n      }\n    }\n\n    int ans = abs(dstX - srcX) + abs(dstY - srcY);\n    for (int u = 0; u < n; ++u) {\n      const int x2 = specialRoads[u][2];\n      const int y2 = specialRoads[u][3];\n      // (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2));\n    }\n    return ans;\n  }\n};\n", "2663": "class Solution {\n public:\n  string smallestBeautifulString(string s, int k) {\n    for (int i = s.length() - 1; i >= 0; --i) {\n      do {\n        ++s[i];\n      } while (containsPalindrome(s, i));\n      if (s[i] < 'a' + k)\n        // If s[i] is among the first k letters, then change the letters after\n        // s[i] to the smallest ones that don't form any palindrome substring.\n        return changeSuffix(s, i + 1);\n    }\n\n    return \"\";\n  }\n\n private:\n  // Returns true if s[0..i] contains any palindrome.\n  bool containsPalindrome(const string& s, int i) {\n    return (i > 0 && s[i] == s[i - 1]) || (i > 1 && s[i] == s[i - 2]);\n  }\n\n  // Returns a string, where replacing s[i..n) with the smallest possible\n  // letters don't form any palindrome substring.\n  string changeSuffix(string& s, int i) {\n    for (int j = i; j < s.length(); ++j)\n      for (s[j] = 'a'; containsPalindrome(s, j); ++s[j])\n        ;\n    return s;\n  }\n};\n", "2664": "class Solution {\n public:\n  vector<vector<int>> tourOfKnight(int m, int n, int r, int c) {\n    vector<vector<int>> ans(m, vector<int>(n, -1));\n    dfs(m, n, r, c, 0, ans);\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},\n                                      {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\n\n  bool dfs(int m, int n, int i, int j, int step, vector<vector<int>>& ans) {\n    if (step == m * n)\n      return true;\n    if (i < 0 || i >= m || j < 0 || j >= n)\n      return false;\n    if (ans[i][j] != -1)\n      return false;\n    ans[i][j] = step;\n    for (const auto& [dx, dy] : kDirs)\n      if (dfs(m, n, i + dx, j + dy, step + 1, ans))\n        return true;\n    ans[i][j] = -1;\n    return false;\n  }\n};\n", "267": "class Solution {\n public:\n  vector<string> generatePalindromes(string s) {\n    int odd = 0;\n    unordered_map<char, int> count;\n\n    for (const char c : s)\n      ++count[c];\n\n    // Count odd ones.\n    for (const auto& [_, value] : count)\n      if (value % 2 == 1)\n        ++odd;\n\n    // Can't form any palindrome.\n    if (odd > 1)\n      return {};\n\n    vector<string> ans;\n    vector<char> candidates;\n    string mid;\n\n    // Get the mid and the candidates characters.\n    for (const auto& [key, value] : count) {\n      if (value % 2 == 1)\n        mid += key;\n      for (int i = 0; i < value / 2; ++i)\n        candidates.push_back(key);\n    }\n\n    // Backtrack to generate the ans strings.\n    dfs(candidates, mid, vector<bool>(candidates.size()), \"\", ans);\n    return ans;\n  }\n\n private:\n  // Generates all the unique palindromes from the candidates.\n  void dfs(const vector<char>& candidates, const string& mid,\n           vector<bool>&& used, string&& path, vector<string>& ans) {\n    if (path.length() == candidates.size()) {\n      string secondHalf = path;\n      ranges::reverse(secondHalf);\n      ans.push_back(path + mid + secondHalf);\n      return;\n    }\n\n    for (int i = 0; i < candidates.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.push_back(candidates[i]);\n      dfs(candidates, mid, std::move(used), std::move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n};\n", "2670": "class Solution {\n public:\n  vector<int> distinctDifferenceArray(vector<int>& nums) {\n    constexpr int kMax = 50;\n    vector<int> ans;\n    vector<int> prefixCount(kMax + 1);\n    vector<int> suffixCount(kMax + 1);\n    int distinctPrefix = 0;\n    int distinctSuffix = 0;\n\n    for (const int num : nums)\n      if (++suffixCount[num] == 1)\n        ++distinctSuffix;\n\n    for (const int num : nums) {\n      if (++prefixCount[num] == 1)\n        ++distinctPrefix;\n      if (--suffixCount[num] == 0)\n        --distinctSuffix;\n      ans.push_back(distinctPrefix - distinctSuffix);\n    }\n\n    return ans;\n  }\n};\n", "2671": "class FrequencyTracker {\n public:\n  void add(int number) {\n    if (count[number] > 0)\n      --freqCount[count[number]];\n    ++count[number];\n    ++freqCount[count[number]];\n  }\n\n  void deleteOne(int number) {\n    if (count[number] == 0)\n      return;\n    --freqCount[count[number]];\n    --count[number];\n    ++freqCount[count[number]];\n  }\n\n  bool hasFrequency(int frequency) {\n    return freqCount[frequency] > 0;\n  }\n\n private:\n  unordered_map<int, int> count;\n  unordered_map<int, int> freqCount;\n};\n", "2672": "class Solution {\n public:\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> arr(n);\n    int sameColors = 0;\n\n    for (const vector<int>& query : queries) {\n      const int i = query[0];\n      const int color = query[1];\n      if (i + 1 < n) {\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\n          --sameColors;\n        if (arr[i + 1] == color)\n          ++sameColors;\n      }\n      if (i > 0) {\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\n          --sameColors;\n        if (arr[i - 1] == color)\n          ++sameColors;\n      }\n      arr[i] = color;\n      ans.push_back(sameColors);\n    }\n\n    return ans;\n  }\n};\n", "2673": "class Solution {\n public:\n  int minIncrements(int n, vector<int>& cost) {\n    int ans = 0;\n\n    for (int i = n / 2 - 1; i >= 0; --i) {\n      const int l = i * 2 + 1;\n      const int r = i * 2 + 2;\n      ans += abs(cost[l] - cost[r]);\n      // Record the information in the parent from the children. So, there's\n      // need to actually update the values in the children.\n      cost[i] += max(cost[l], cost[r]);\n    }\n\n    return ans;\n  }\n};\n", "2674": "class Solution {\n public:\n  vector<ListNode*> splitCircularLinkedList(ListNode* list) {\n    ListNode* slow = list;\n    ListNode* fast = list;\n\n    // Point `slow` to the last node in the first half.\n    while (fast->next != list && fast->next->next != list) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    // Circle back the second half.\n    ListNode* secondHead = slow->next;\n    if (fast->next == list)\n      fast->next = secondHead;\n    else\n      fast->next->next = secondHead;\n\n    // Circle back the first half.\n    slow->next = list;\n\n    return {list, secondHead};\n  }\n};\n", "2678": "class Solution {\n public:\n  int countSeniors(vector<string>& details) {\n    return ranges::count_if(details, [](const string& detail) {\n      return stoi(detail.substr(11, 2)) > 60;\n    });\n  }\n};\n", "2679": "class Solution {\n public:\n  int matrixSum(vector<vector<int>>& nums) {\n    int ans = 0;\n\n    for (vector<int>& row : nums)\n      ranges::sort(row);\n\n    for (int j = 0; j < nums[0].size(); ++j) {\n      int mx = 0;\n      for (int i = 0; i < nums.size(); ++i)\n        mx = max(mx, nums[i][j]);\n      ans += mx;\n    }\n\n    return ans;\n  }\n};\n", "268": "class Solution {\n public:\n  int missingNumber(vector<int>& nums) {\n    int ans = nums.size();\n\n    for (int i = 0; i < nums.size(); ++i)\n      ans ^= i ^ nums[i];\n\n    return ans;\n  }\n};\n", "2680": "class Solution {\n public:\n  long long maximumOr(vector<int>& nums, int k) {\n    const int n = nums.size();\n    long ans = 0;\n    // prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    vector<long> prefix(n);\n    // suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    vector<long> suffix(n);\n\n    for (int i = 1; i < n; ++i)\n      prefix[i] = prefix[i - 1] | nums[i - 1];\n\n    for (int i = n - 2; i >= 0; --i)\n      suffix[i] = suffix[i + 1] | nums[i + 1];\n\n    // For each num, greedily shift it left by k bits.\n    for (int i = 0; i < n; ++i)\n      ans = max(ans, prefix[i] | static_cast<long>(nums[i]) << k | suffix[i]);\n\n    return ans;\n  }\n};\n", "2681": "class Solution {\n public:\n  int sumOfPower(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    long ans = 0;\n    long sum = 0;\n\n    ranges::sort(nums);\n\n    for (const int num : nums) {\n      ans = (ans + (num + sum) * num % kMod * num % kMod) % kMod;\n      sum = (sum * 2 + num) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "2682": "class Solution {\n public:\n  vector<int> circularGameLosers(int n, int k) {\n    vector<int> ans;\n    vector<bool> seen(n);\n\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex];) {\n      seen[friendIndex] = true;\n      friendIndex += turn++ * k;\n      friendIndex %= n;\n    }\n\n    for (int friendIndex = 0; friendIndex < n; ++friendIndex)\n      if (!seen[friendIndex])\n        ans.push_back(friendIndex + 1);\n\n    return ans;\n  }\n};\n", "2683": "class Solution {\n public:\n  bool doesValidArrayExist(vector<int>& derived) {\n    //      original = [O[0], O[1], ..., O[n - 1]]\n    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]\n    // XOR(derivedd) = 0\n    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;\n  }\n};\n", "2684": "class Solution {\n public:\n  int maxMoves(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    // dp[i][j] := the maximum number of moves you can perform from (i, j)\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int j = n - 2; j >= 0; --j)\n      for (int i = 0; i < m; ++i) {\n        if (grid[i][j + 1] > grid[i][j])\n          dp[i][j] = 1 + dp[i][j + 1];\n        if (i > 0 && grid[i - 1][j + 1] > grid[i][j])\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1]);\n        if (i + 1 < m && grid[i + 1][j + 1] > grid[i][j])\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1]);\n      }\n\n    for (int i = 0; i < m; ++i)\n      ans = max(ans, dp[i][0]);\n\n    return ans;\n  }\n};\n", "2685": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n), nodeCount(n, 1), edgeCount(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    ++edgeCount[i];\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n      edgeCount[j] += edgeCount[i];\n      nodeCount[j] += nodeCount[i];\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n      edgeCount[i] += edgeCount[j];\n      nodeCount[i] += nodeCount[j];\n    } else {\n      id[i] = j;\n      edgeCount[j] += edgeCount[i];\n      nodeCount[j] += nodeCount[i];\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n  bool isComplete(int u) {\n    return nodeCount[u] * (nodeCount[u] - 1) / 2 == edgeCount[u];\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n  vector<int> nodeCount;\n  vector<int> edgeCount;\n};\n\nclass Solution {\n public:\n  int countCompleteComponents(int n, vector<vector<int>>& edges) {\n    int ans = 0;\n    UnionFind uf(n);\n    unordered_set<int> parents;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      uf.unionByRank(u, v);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      const int parent = uf.find(i);\n      if (parents.insert(parent).second && uf.isComplete(parent))\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2689": "class Solution {\n public:\n  char getKthCharacter(RopeTreeNode* root, int k) {\n    while (root->len > 0) {\n      const int leftLen = root->left == nullptr\n                              ? 0\n                              : max(root->left->len,\n                                    static_cast<int>(root->left->val.length()));\n      if (leftLen >= k) {\n        root = root->left;\n      } else {\n        root = root->right;\n        k -= leftLen;\n      }\n    }\n    return root->val[k - 1];\n  }\n};\n", "269": "class Solution {\n public:\n  string alienOrder(vector<string>& words) {\n    unordered_map<char, unordered_set<char>> graph;\n    vector<int> inDegrees(26);\n    buildGraph(graph, words, inDegrees);\n    return topology(graph, inDegrees);\n  }\n\n private:\n  void buildGraph(unordered_map<char, unordered_set<char>>& graph,\n                  const vector<string>& words, vector<int>& inDegrees) {\n    // Create a node for each character in each word.\n    for (const string& word : words)\n      for (const char c : word)\n        if (!graph.contains(c))\n          graph[c] = unordered_set<char>();\n\n    for (int i = 1; i < words.size(); ++i) {\n      const string& first = words[i - 1];\n      const string& second = words[i];\n      const int length = min(first.length(), second.length());\n      for (int j = 0; j < length; ++j) {\n        const char u = first[j];\n        const char v = second[j];\n        if (u != v) {\n          if (!graph[u].contains(v)) {\n            graph[u].insert(v);\n            ++inDegrees[v - 'a'];\n          }\n          break;  // The order of characters after this are meaningless.\n        }\n        // e.g. first = \"ab\", second = \"a\" -> invalid\n        if (j == length - 1 && first.length() > second.length()) {\n          graph.clear();\n          return;\n        }\n      }\n    }\n  }\n\n  string topology(unordered_map<char, unordered_set<char>>& graph,\n                  vector<int>& inDegrees) {\n    string s;\n    queue<char> q;\n\n    for (const auto& [c, _] : graph)\n      if (inDegrees[c - 'a'] == 0)\n        q.push(c);\n\n    while (!q.empty()) {\n      const char u = q.front();\n      q.pop();\n      s += u;\n      for (const char v : graph[u])\n        if (--inDegrees[v - 'a'] == 0)\n          q.push(v);\n    }\n\n    // e.g. words = [\"z\", \"x\", \"y\", \"x\"]\n    return s.length() == graph.size() ? s : \"\";\n  }\n};\n", "2696": "class Solution {\n public:\n  int minLength(string s) {\n    stack<char> stack;\n\n    for (const char c : s)\n      if (c == 'B' && match(stack, 'A'))\n        stack.pop();\n      else if (c == 'D' && match(stack, 'C'))\n        stack.pop();\n      else\n        stack.push(c);\n\n    return stack.size();\n  }\n\n private:\n  bool match(const stack<char>& stack, int c) {\n    return !stack.empty() && stack.top() == c;\n  }\n};\n", "2697": "class Solution {\n public:\n  string makeSmallestPalindrome(string s) {\n    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n      const int minChar = min(s[i], s[j]);\n      s[i] = minChar;\n      s[j] = minChar;\n    }\n    return s;\n  }\n};\n", "2698": "class Solution {\n public:\n  int punishmentNumber(int n) {\n    int ans = 0;\n    for (int i = 1; i <= n; ++i)\n      if (isPossible(0, 0, to_string(i * i), 0, i))\n        ans += i * i;\n    return ans;\n  }\n\n private:\n  // Returns true if the sum of any split of `numChars` equals to the target.\n  bool isPossible(int accumulate, int running, const string& numChars, int s,\n                  int target) {\n    if (s == numChars.length())\n      return target == accumulate + running;\n    const int d = numChars[s] - '0';\n    return isPossible(accumulate, running * 10 + d, numChars, s + 1, target) ||\n           isPossible(accumulate + running, d, numChars, s + 1, target);\n  }\n};\n", "2699": "class Solution {\n public:\n  vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges,\n                                         int source, int destination,\n                                         int target) {\n    constexpr int kMax = 2'000'000'000;\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      if (w == -1)\n        continue;\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    int distToDestination = dijkstra(graph, source, destination);\n    if (distToDestination < target)\n      return {};\n    if (distToDestination == target) {\n      // Change the weights of negative edges to an impossible value.\n      for (vector<int>& edge : edges)\n        if (edge[2] == -1)\n          edge[2] = kMax;\n      return edges;\n    }\n\n    for (int i = 0; i < edges.size(); ++i) {\n      const int u = edges[i][0];\n      const int v = edges[i][1];\n      int& w = edges[i][2];\n      if (w != -1)\n        continue;\n      w = 1;\n      graph[u].emplace_back(v, 1);\n      graph[v].emplace_back(u, 1);\n      distToDestination = dijkstra(graph, source, destination);\n      if (distToDestination <= target) {\n        w += target - distToDestination;\n        // Change the weights of negative edges to an impossible value.\n        for (int j = i + 1; j < edges.size(); ++j)\n          if (edges[j][2] == -1)\n            edges[j][2] = kMax;\n        return edges;\n      }\n    }\n\n    return {};\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {\n    vector<int> dist(graph.size(), INT_MAX);\n\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return dist[dst];\n  }\n};\n", "27": "class Solution {\n public:\n  int removeElement(vector<int>& nums, int val) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (num != val)\n        nums[i++] = num;\n\n    return i;\n  }\n};\n", "270": "class Solution {\n public:\n  int closestValue(TreeNode* root, double target) {\n    // If target < root->val, search the left subtree.\n    if (target < root->val && root->left) {\n      const int left = closestValue(root->left, target);\n      if (abs(left - target) <= abs(root->val - target))\n        return left;\n    }\n\n    // If target > root->val, search the right subtree.\n    if (target > root->val && root->right) {\n      const int right = closestValue(root->right, target);\n      if (abs(right - target) < abs(root->val - target))\n        return right;\n    }\n\n    return root->val;\n  }\n};\n", "2702": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int x, int y) {\n    int l = 0;\n    int r = ranges::max(nums);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (isPossible(nums, x, y, m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if it's possible to make all `nums` <= 0 using m operations.\n  bool isPossible(const vector<int>& nums, int x, int y, int m) {\n    long additionalOps = 0;\n    // If we want m operations, first decrease all the numbers by y * m. Then,\n    // we have m operations to select indices to decrease them by x - y.\n    for (const int num : nums)\n      additionalOps +=\n          max(0L, (num - static_cast<long>(y) * m + x - y - 1) / (x - y));\n    return additionalOps <= m;\n  }\n};\n", "2706": "class Solution {\n public:\n  int buyChoco(vector<int>& prices, int money) {\n    int min1 = INT_MAX;\n    int min2 = INT_MAX;\n\n    for (const int price : prices)\n      if (price <= min1) {\n        min2 = min1;\n        min1 = price;\n      } else if (price < min2) {\n        min2 = price;\n      }\n\n    const int minCost = min1 + min2;\n    return minCost > money ? money : money - minCost;\n  }\n};\n", "2707": "class Solution {\n public:\n  // Similar to 139. Word Break\n  int minExtraChar(string s, vector<string>& dictionary) {\n    const int n = s.length();\n    const unordered_set<string> dictionarySet{dictionary.begin(),\n                                              dictionary.end()};\n    // dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    vector<int> dp(n + 1, n);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = 0; j < i; ++j)\n        // s[j..i) is in `dictionarySet`.\n        if (dictionarySet.contains(s.substr(j, i - j)))\n          dp[i] = min(dp[i], dp[j]);\n        // s[j..i) are extra letters.\n        else\n          dp[i] = min(dp[i], dp[j] + i - j);\n\n    return dp[n];\n  }\n};\n", "2708": "class Solution {\n public:\n  long long maxStrength(vector<int>& nums) {\n    long posProd = 1;\n    long negProd = 1;\n    int maxNeg = INT_MIN;\n    int negCount = 0;\n    bool hasPos = false;\n    bool hasZero = false;\n\n    for (const int num : nums)\n      if (num > 0) {\n        posProd *= num;\n        hasPos = true;\n      } else if (num < 0) {\n        negProd *= num;\n        maxNeg = max(maxNeg, num);\n        ++negCount;\n      } else {  // num == 0\n        hasZero = true;\n      }\n\n    if (negCount == 0 && !hasPos)\n      return 0;\n    if (negCount % 2 == 0)\n      return negProd * posProd;\n    if (negCount >= 3)\n      return negProd / maxNeg * posProd;\n    if (hasPos)\n      return posProd;\n    if (hasZero)\n      return 0;\n    return maxNeg;\n  }\n};\n", "2709": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), sz(n, 1) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionBySize(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (sz[i] < sz[j]) {\n      sz[j] += sz[i];\n      id[i] = j;\n    } else {\n      sz[i] += sz[j];\n      id[j] = i;\n    }\n  }\n\n  int getSize(int i) {\n    return sz[i];\n  }\n\n private:\n  vector<int> id;\n  vector<int> sz;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  bool canTraverseAllPairs(vector<int>& nums) {\n    const int n = nums.size();\n    const int mx = ranges::max(nums);\n    const vector<int> minPrimeFactors = sieveEratosthenes(mx + 1);\n    unordered_map<int, int> primeToFirstIndex;\n    UnionFind uf(n);\n\n    for (int i = 0; i < n; ++i)\n      for (const int primeFactor : getPrimeFactors(nums[i], minPrimeFactors))\n        // `primeFactor` already appeared in the previous indices.\n        if (const auto it = primeToFirstIndex.find(primeFactor);\n            it != primeToFirstIndex.cend())\n          uf.unionBySize(it->second, i);\n        else\n          primeToFirstIndex[primeFactor] = i;\n\n    for (int i = 0; i < n; ++i)\n      if (uf.getSize(i) == n)\n        return true;\n\n    return false;\n  }\n\n private:\n  // Gets the minimum prime factor of i, where 1 < i <= n.\n  vector<int> sieveEratosthenes(int n) {\n    vector<int> minPrimeFactors(n + 1);\n    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);\n    for (int i = 2; i * i < n; ++i)\n      if (minPrimeFactors[i] == i)  // `i` is prime.\n        for (int j = i * i; j < n; j += i)\n          minPrimeFactors[j] = min(minPrimeFactors[j], i);\n    return minPrimeFactors;\n  }\n\n  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactors) {\n    vector<int> primeFactors;\n    while (num > 1) {\n      const int divisor = minPrimeFactors[num];\n      primeFactors.push_back(divisor);\n      while (num % divisor == 0)\n        num /= divisor;\n    }\n    return primeFactors;\n  }\n};\n", "271": "class Codec {\n public:\n  // Encodes a list of strings to a single string.\n  string encode(vector<string>& strs) {\n    string encoded;\n\n    for (const string& s : strs)\n      encoded += to_string(s.length()) + '/' + s;\n\n    return encoded;\n  }\n\n  // Decodes a single string to a list of strings.\n  vector<string> decode(string s) {\n    vector<string> decoded;\n\n    for (int i = 0; i < s.length();) {\n      const int slash = s.find('/', i);\n      const int length = stoi(s.substr(i, slash - i));\n      i = slash + length + 1;\n      decoded.push_back(s.substr(slash + 1, i - slash - 1));\n    }\n\n    return decoded;\n  }\n};\n", "2710": "class Solution {\n public:\n  string removeTrailingZeros(string num) {\n    return regex_replace(num, regex(\"0+$\"), \"\");\n  }\n};\n", "2711": "class Solution {\n public:\n  vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      fillInDiagonal(grid, i, 0, ans);\n\n    for (int j = 1; j < n; ++j)\n      fillInDiagonal(grid, 0, j, ans);\n\n    return ans;\n  }\n\n private:\n  void fillInDiagonal(const vector<vector<int>>& grid, int i, int j,\n                      vector<vector<int>>& ans) {\n    unordered_set<int> topLeft;\n    unordered_set<int> bottomRight;\n\n    // Fill in the diagonal from the top-left to the bottom-right.\n    while (i < grid.size() && j < grid[0].size()) {\n      ans[i][j] = topLeft.size();\n      // Post-addition, so this information can be utilized in subsequent cells.\n      topLeft.insert(grid[i++][j++]);\n    }\n\n    --i;\n    --j;\n\n    // Fill in the diagonal from the bottom-right to the top-left.\n    while (i >= 0 && j >= 0) {\n      ans[i][j] = abs(ans[i][j] - static_cast<int>(bottomRight.size()));\n      // Post-addition, so this information can be utilized in subsequent cells.\n      bottomRight.insert(grid[i--][j--]);\n    }\n  }\n};\n", "2712": "class Solution {\n public:\n  long long minimumCost(string s) {\n    const int n = s.length();\n    long ans = 0;\n\n    for (int i = 1; i < n; ++i)\n      if (s[i] != s[i - 1])\n        // Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i);\n\n    return ans;\n  }\n};\n", "2713": "class Solution {\n public:\n  int maxIncreasingCells(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    // rows[i] := the maximum path length for the i-th row\n    vector<int> rows(m);\n    // cols[j] := the maximum path length for the j-th column\n    vector<int> cols(n);\n    unordered_map<int, vector<pair<int, int>>> valToIndices;\n    // maxPathLength[i][j] := the maximum path length from mat[i][j]\n    vector<vector<int>> maxPathLength(m, vector<int>(n));\n    // Sort all the unique values in the matrix in non-increasing order.\n    set<int, greater<>> decreasingSet;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        valToIndices[mat[i][j]].emplace_back(i, j);\n        decreasingSet.insert(mat[i][j]);\n      }\n\n    for (const int val : decreasingSet) {\n      for (const auto& [i, j] : valToIndices[val])\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1;\n      for (const auto& [i, j] : valToIndices[val]) {\n        rows[i] = max(rows[i], maxPathLength[i][j]);\n        cols[j] = max(cols[j], maxPathLength[i][j]);\n      }\n    }\n\n    return max(ranges::max(rows), ranges::max(cols));\n  }\n};\n", "2714": "class Solution {\n public:\n  // Similar to 787. Cheapest Flights Within K Stops\n  int shortestPathWithHops(int n, vector<vector<int>>& edges, int s, int d,\n                           int k) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dijkstra(graph, s, d, k);\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,\n               int k) {\n    vector<vector<int>> dist(graph.size(), vector<int>(k + 1, INT_MAX));\n\n    dist[src][k] = 0;\n    using T = tuple<int, int, int>;  // (d, u, hops)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.emplace(dist[src][k], src, k);\n\n    while (!minHeap.empty()) {\n      const auto [d, u, hops] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return d;\n      if (dist[u][hops] > d)\n        continue;\n      for (const auto& [v, w] : graph[u]) {\n        // Go from u -> v with w cost.\n        if (d + w < dist[v][hops]) {\n          dist[v][hops] = d + w;\n          minHeap.emplace(dist[v][hops], v, hops);\n        }\n        // Hop from u -> v with 0 cost.\n        if (hops > 0 && d < dist[v][hops - 1]) {\n          dist[v][hops - 1] = d;\n          minHeap.emplace(dist[v][hops - 1], v, hops - 1);\n        }\n      }\n    }\n\n    throw;\n  }\n};\n", "2716": "class Solution {\n public:\n  int minimizedStringLength(string s) {\n    return unordered_set(s.begin(), s.end()).size();\n  }\n};\n", "2717": "class Solution {\n public:\n  int semiOrderedPermutation(vector<int>& nums) {\n    const int n = nums.size();\n    const int index1 = find(nums.begin(), nums.end(), 1) - nums.begin();\n    const int indexN = find(nums.begin(), nums.end(), n) - nums.begin();\n    return index1 + (n - 1 - indexN) - (index1 > indexN ? 1 : 0);\n  }\n};\n", "2718": "class Solution {\n public:\n  long long matrixSumQueries(int n, vector<vector<int>>& queries) {\n    long ans = 0;\n    // seen[0] := row, seen[1] := col\n    vector<vector<bool>> seen(2, vector<bool>(n));\n    // notSet[0] = row, notSet[1] := col\n    vector<int> notSet(2, n);\n\n    // Later queries dominate.\n    for (int i = queries.size() - 1; i >= 0; --i) {\n      const int type = queries[i][0];\n      const int index = queries[i][1];\n      const int val = queries[i][2];\n      if (!seen[type][index]) {\n        ans += val * notSet[type ^ 1];\n        seen[type][index] = true;\n        --notSet[type];\n      }\n    }\n\n    return ans;\n  }\n};\n", "2719": "class Solution {\n public:\n  int count(string num1, string num2, int min_sum, int max_sum) {\n    const string num1WithLeadingZeros =\n        string(num2.length() - num1.length(), '0') + num1;\n    vector<vector<vector<vector<int>>>> mem(\n        num2.length(),\n        vector<vector<vector<int>>>(\n            max_sum + 1, vector<vector<int>>(2, vector<int>(2, -1))));\n    return (count(num1WithLeadingZeros, num2, 0, max_sum, true, true, mem) -\n            count(num1WithLeadingZeros, num2, 0, min_sum - 1, true, true, mem) +\n            kMod) %\n           kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of valid integers, considering the i-th digit, where\n  // `sum` is the maximum digit sum, `tight1` indicates if the current digit\n  // is tightly bound for `num1` and `tight2` indicates if the current digit\n  // is tightly bound for `num2`\n  int count(const string& num1, const string& num2, int i, int sum, bool tight1,\n            bool tight2, vector<vector<vector<vector<int>>>>& mem) {\n    if (sum < 0)\n      return 0;\n    if (i == num2.length())\n      return 1;\n    if (mem[i][sum][tight1][tight2] != -1)\n      return mem[i][sum][tight1][tight2];\n\n    int res = 0;\n\n    const int minDigit = tight1 ? num1[i] - '0' : 0;\n    const int maxDigit = tight2 ? num2[i] - '0' : 9;\n    for (int d = minDigit; d <= maxDigit; ++d) {\n      const bool nextTight1 = tight1 && (d == minDigit);\n      const bool nextTight2 = tight2 && (d == maxDigit);\n      res += count(num1, num2, i + 1, sum - d, nextTight1, nextTight2, mem);\n      res %= kMod;\n    }\n\n    return mem[i][sum][tight1][tight2] = res;\n  }\n};\n", "272": "class Solution {\n public:\n  vector<int> closestKValues(TreeNode* root, double target, int k) {\n    deque<int> dq;\n\n    inorder(root, dq);\n\n    while (dq.size() > k)\n      if (abs(dq.front() - target) > abs(dq.back() - target))\n        dq.pop_front();\n      else\n        dq.pop_back();\n\n    return {dq.begin(), dq.end()};\n  }\n\n private:\n  void inorder(TreeNode* root, deque<int>& dq) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left, dq);\n    dq.push_back(root->val);\n    inorder(root->right, dq);\n  }\n};\n", "2728": "/**\n * Definition for a street.\n * class Street {\n *  public:\n *   Street(vector<int> doors);\n *   void openDoor();\n *   void closeDoor();\n *   bool isDoorOpen();\n *   void moveRight();\n *   void moveLeft();\n * };\n */\n\nclass Solution {\n public:\n  int houseCount(Street* street, int k) {\n    for (int i = 0; i < k; ++i) {\n      if (street->isDoorOpen())\n        street->closeDoor();\n      street->moveRight();\n    }\n\n    for (int ans = 0;; ++ans) {\n      if (street->isDoorOpen())\n        return ans;\n      street->openDoor();\n      street->moveRight();\n    }\n\n    throw;\n  }\n};\n", "2729": "class Solution {\n public:\n  bool isFascinating(int n) {\n    string s = to_string(n) + to_string(2 * n) + to_string(3 * n);\n    ranges::sort(s);\n    return s == \"123456789\";\n  }\n};\n", "273": "class Solution {\n public:\n  string numberToWords(int num) {\n    if (num == 0)\n      return \"Zero\";\n    return helper(num);\n  }\n\n private:\n  const vector<string> belowTwenty{\n      \"\",        \"One\",     \"Two\",       \"Three\",    \"Four\",\n      \"Five\",    \"Six\",     \"Seven\",     \"Eight\",    \"Nine\",\n      \"Ten\",     \"Eleven\",  \"Twelve\",    \"Thirteen\", \"Fourteen\",\n      \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n  const vector<string> tens{\"\",      \"\",      \"Twenty\",  \"Thirty\", \"Forty\",\n                            \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\n  string helper(int num) {\n    string s;\n\n    if (num < 20)\n      s = belowTwenty.at(num);\n    else if (num < 100)\n      s = tens.at(num / 10) + \" \" + belowTwenty.at(num % 10);\n    else if (num < 1000)\n      s = helper(num / 100) + \" Hundred \" + helper(num % 100);\n    else if (num < 1000000)\n      s = helper(num / 1000) + \" Thousand \" + helper(num % 1000);\n    else if (num < 1000000000)\n      s = helper(num / 1000000) + \" Million \" + helper(num % 1000000);\n    else\n      s = helper(num / 1000000000) + \" Billion \" + helper(num % 1000000000);\n\n    trim(s);\n    return s;\n  }\n\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n};\n", "2730": "class Solution {\n public:\n  int longestSemiRepetitiveSubstring(string s) {\n    int ans = 1;\n    int prevStart = 0;\n    int start = 0;\n\n    for (int i = 1; i < s.length(); ++i) {\n      if (s[i] == s[i - 1]) {\n        if (prevStart > 0)\n          start = prevStart;\n        prevStart = i;\n      }\n      ans = max(ans, i - start + 1);\n    }\n\n    return ans;\n  }\n};\n", "2731": "class Solution {\n public:\n  int sumDistance(vector<int>& nums, string s, int d) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    int prefix = 0;\n    vector<int> pos;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (s[i] == 'L')\n        pos.push_back(nums[i] - d);\n      else\n        pos.push_back(nums[i] + d);\n\n    ranges::sort(pos);\n\n    for (int i = 0; i < n; ++i) {\n      ans =\n          ((ans + static_cast<long>(i) * pos[i] - prefix) % kMod + kMod) % kMod;\n      prefix = ((0L + prefix + pos[i]) % kMod + kMod) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "2732": "class Solution {\n public:\n  vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n    constexpr int kMaxBit = 30;\n    unordered_map<int, int> maskToIndex;\n\n    for (int i = 0; i < grid.size(); ++i) {\n      const int mask = getMask(grid[i]);\n      if (mask == 0)\n        return {i};\n      for (int prevMask = 1; prevMask < kMaxBit; ++prevMask)\n        if ((mask & prevMask) == 0 && maskToIndex.contains(prevMask))\n          return {maskToIndex[prevMask], i};\n      maskToIndex[mask] = i;\n    }\n\n    return {};\n  }\n\n private:\n  int getMask(const vector<int>& row) {\n    int mask = 0;\n    for (int i = 0; i < row.size(); ++i)\n      if (row[i] == 1)\n        mask |= 1 << i;\n    return mask;\n  }\n};\n", "2733": "class Solution {\n public:\n  int findNonMinOrMax(vector<int>& nums) {\n    if (nums.size() < 3)\n      return -1;\n    sort(nums.begin(), nums.begin() + 3);\n    return nums[1];\n  }\n};\n", "2734": "class Solution {\n public:\n  string smallestString(string s) {\n    const int n = s.length();\n    int i = 0;\n\n    while (i < n && s[i] == 'a')\n      ++i;\n    if (i == n) {\n      s[n - 1] = 'z';\n      return s;\n    }\n\n    while (i < n && s[i] != 'a')\n      --s[i++];\n\n    return s;\n  }\n};\n", "2735": "class Solution {\n public:\n  long long minCost(vector<int>& nums, long long x) {\n    const int n = nums.size();\n    long ans = LONG_MAX;\n    // minCost[i] := the minimum cost to collect the i-th type\n    vector<int> minCost(n, INT_MAX);\n\n    for (int rotate = 0; rotate < n; ++rotate) {\n      for (int i = 0; i < n; ++i)\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n]);\n      ans =\n          min(ans, accumulate(minCost.begin(), minCost.end(), 0L) + rotate * x);\n    }\n\n    return ans;\n  }\n};\n", "2736": "struct Pair {\n  int x;\n  int y;\n};\n\nstruct IndexedQuery {\n  int queryIndex;\n  int minX;\n  int minY;\n};\n\nclass Solution {\n public:\n  vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2,\n                                vector<vector<int>>& queries) {\n    const vector<Pair> pairs = getPairs(nums1, nums2);\n    vector<int> ans(queries.size());\n    vector<pair<int, int>> stack;  // [(y, x + y)]\n\n    int pairsIndex = 0;\n    for (const auto& [queryIndex, minX, minY] : getIndexedQueries(queries)) {\n      while (pairsIndex < pairs.size() && pairs[pairsIndex].x >= minX) {\n        const auto [x, y] = pairs[pairsIndex++];\n        // x + y is a better candidate. Given that x is decreasing, the\n        // condition \"x + y >= stack.back().second\" suggests that y is\n        // relatively larger, thereby making it a better candidate.\n        while (!stack.empty() && x + y >= stack.back().second)\n          stack.pop_back();\n        if (stack.empty() || y > stack.back().first)\n          stack.emplace_back(y, x + y);\n      }\n      const auto it = ranges::lower_bound(stack, pair<int, int>{minY, INT_MIN});\n      ans[queryIndex] = it == stack.end() ? -1 : it->second;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<Pair> getPairs(const vector<int>& nums1, const vector<int>& nums2) {\n    vector<Pair> pairs;\n    for (int i = 0; i < nums1.size(); ++i)\n      pairs.push_back({nums1[i], nums2[i]});\n    ranges::sort(pairs, ranges::greater{},\n                 [](const Pair& pair) { return pair.x; });\n    return pairs;\n  }\n\n  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {\n    vector<IndexedQuery> indexedQueries;\n    for (int i = 0; i < queries.size(); ++i)\n      indexedQueries.push_back({i, queries[i][0], queries[i][1]});\n    ranges::sort(indexedQueries,\n                 [](const IndexedQuery& a, const IndexedQuery& b) {\n      return a.minX > b.minX;\n    });\n    return indexedQueries;\n  }\n};\n", "2737": "class Solution {\n public:\n  int minimumDistance(int n, vector<vector<int>>& edges, int s,\n                      vector<int>& marked) {\n    int ans = INT_MAX;\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n    }\n\n    const vector<int> dist = dijkstra(graph, s);\n\n    for (const int u : marked)\n      ans = min(ans, dist[u]);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n    vector<int> dist(graph.size(), INT_MAX);\n\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return dist;\n  }\n};\n", "2739": "class Solution {\n public:\n  int distanceTraveled(int mainTank, int additionalTank) {\n    // M  M M M M  A  M M M M   A\n    // 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) / 4, additionalTank)) * 10;\n  }\n};\n", "274": "class Solution {\n public:\n  int hIndex(vector<int>& citations) {\n    const int n = citations.size();\n\n    ranges::sort(citations);\n\n    for (int i = 0; i < n; ++i)\n      if (citations[i] >= n - i)\n        return n - i;\n\n    return 0;\n  }\n};\n", "2740": "class Solution {\n public:\n  int findValueOfPartition(vector<int>& nums) {\n    int ans = INT_MAX;\n\n    sort(begin(nums), end(nums));\n\n    for (int i = 1; i < nums.size(); ++i)\n      ans = min(ans, nums[i] - nums[i - 1]);\n\n    return ans;\n  }\n};\n", "2741": "class Solution {\n public:\n  int specialPerm(vector<int>& nums) {\n    const int n = nums.size();\n    const int maxMask = 1 << n;\n    int ans = 0;\n    vector<vector<int>> mem(n, vector<int>(maxMask));\n\n    for (int i = 0; i < n; ++i) {\n      ans += specialPerm(nums, i, 1 << i, maxMask, mem);\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of special permutations, where the previous number is\n  // nums[i] and `mask` is the bitmask of the used numbers.\n  int specialPerm(const vector<int>& nums, int prev, int mask,\n                  const int& maxMask, vector<vector<int>>& mem) {\n    if (mask == maxMask - 1)\n      return 1;\n    if (mem[prev][mask] > 0)\n      return mem[prev][mask];\n\n    int res = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (mask >> i & 1)\n        continue;\n      if (nums[i] % nums[prev] == 0 || nums[prev] % nums[i] == 0) {\n        res += specialPerm(nums, i, mask | 1 << i, maxMask, mem);\n        res %= kMod;\n      }\n    }\n\n    return mem[prev][mask] = res;\n  }\n};\n", "2742": "class Solution {\n public:\n  int paintWalls(vector<int>& cost, vector<int>& time) {\n    constexpr int kMax = 500'000'000;\n    const int n = cost.size();\n    // dp[i] := the minimum cost to paint i walls by the painters so far\n    vector<int> dp(n + 1, kMax);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; ++i)\n      for (int walls = n; walls > 0; --walls)\n        dp[walls] = min(dp[walls], dp[max(walls - time[i] - 1, 0)] + cost[i]);\n\n    return dp[n];\n  }\n};\n", "2743": "class Solution {\n public:\n  int numberOfSpecialSubstrings(string s) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s[r] - 'a'];\n      while (count[s[r] - 'a'] == 2)\n        --count[s[l++] - 'a'];\n      ans += r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "2744": "class Solution {\n public:\n  int maximumNumberOfStringPairs(vector<string>& words) {\n    int ans = 0;\n    vector<bool> seen(26 * 26);\n\n    for (const string& word : words) {\n      if (seen[val(word[1]) * 26 + val(word[0])])\n        ++ans;\n      seen[val(word[0]) * 26 + val(word[1])] = true;\n    }\n\n    return ans;\n  }\n\n private:\n  constexpr int val(char c) {\n    return c - 'a';\n  }\n};\n", "2745": "class Solution {\n public:\n  int longestString(int x, int y, int z) {\n    //\"AB\" can always be easily appended within the string.\n    // Alternating \"AA\" and \"BB\" can be appended, creating a pattern like \"AABB\"\n    // If x == y, we repeat the pattern \"AABBAABB...AABB\".\n    // If x != y, the pattern becomes \"AABBAABB...AABBAA\" or \"BBAABBAABB...AABB\"\n    const int mn = min(x, y);\n    if (x == y)\n      return (mn * 2 + z) * 2;\n    return (mn * 2 + 1 + z) * 2;\n  }\n};\n", "2746": "class Solution {\n public:\n  int minimizeConcatenatedLength(vector<string>& words) {\n    vector<vector<vector<int>>> mem(words.size(),\n                                    vector<vector<int>>(26, vector<int>(26)));\n    return words[0].length() + minimizeConcatenatedLength(words, 1,\n                                                          words[0].front(),\n                                                          words[0].back(), mem);\n  }\n\n private:\n  // Returns the minimum concatenated length of the first i words starting with\n  // `first` and ending in `last`.\n  int minimizeConcatenatedLength(const vector<string>& words, int i, char first,\n                                 char last, vector<vector<vector<int>>>& mem) {\n    if (i == words.size())\n      return 0;\n    const int j = first - 'a';\n    const int k = last - 'a';\n    if (mem[i][j][k] > 0)\n      return mem[i][j][k];\n    const char nextFirst = words[i].front();\n    const char nextLast = words[i].back();\n    return mem[i][j][k] =  //\n           words[i].length() +\n           min(\n               // join(words[i - 1], words[i])\n               minimizeConcatenatedLength(words, i + 1, first, nextLast, mem) -\n                   (last == nextFirst ? 1 : 0),\n               // join(words[i], words[i - 1])\n               minimizeConcatenatedLength(words, i + 1, nextFirst, last, mem) -\n                   (first == nextLast ? 1 : 0));\n  }\n};\n", "2747": "struct IndexedQuery {\n  int queryIndex;\n  int query;\n};\n\nclass Solution {\n public:\n  vector<int> countServers(int n, vector<vector<int>>& logs, int x,\n                           vector<int>& queries) {\n    vector<int> ans(queries.size());\n    vector<int> count(n + 1);\n\n    ranges::sort(logs, ranges::less{},\n                 [](const vector<int>& log) { return log[1]; });\n\n    int i = 0;\n    int j = 0;\n    int servers = 0;\n\n    // For each query, we care about logs[i..j].\n    for (const auto& [queryIndex, query] : getIndexedQueries(queries)) {\n      for (; j < logs.size() && logs[j][1] <= query; ++j)\n        if (++count[logs[j][0]] == 1)\n          ++servers;\n      for (; i < logs.size() && logs[i][1] < query - x; ++i)\n        if (--count[logs[i][0]] == 0)\n          --servers;\n      ans[queryIndex] = n - servers;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<IndexedQuery> getIndexedQueries(const vector<int>& queries) {\n    vector<IndexedQuery> indexedQueries;\n    for (int i = 0; i < queries.size(); ++i)\n      indexedQueries.push_back({i, queries[i]});\n    ranges::sort(indexedQueries,\n                 [](const IndexedQuery& a, const IndexedQuery& b) {\n      return a.query < b.query;\n    });\n    return indexedQueries;\n  }\n};\n", "2748": "class Solution {\n public:\n  int countBeautifulPairs(vector<int>& nums) {\n    int ans = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = i + 1; j < nums.size(); ++j)\n        if (__gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1)\n          ++ans;\n\n    return ans;\n  }\n\n private:\n  int firstDigit(int num) {\n    return to_string(num)[0] - '0';\n  }\n\n  int lastDigit(int num) {\n    return num % 10;\n  }\n};\n", "2749": "class Solution {\n public:\n  int makeTheIntegerZero(int num1, int num2) {\n    // If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    // ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    // ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    // Note that for any number x, we can use \"x's bit count\" operations to make\n    // x equal to 0. Additionally, we can also use x operations to deduct x by\n    // 2^0 (x times), which also results in 0.\n\n    for (long ops = 0; ops <= 60; ++ops) {\n      const long target = num1 - ops * num2;\n      if (__builtin_popcountl(target) <= ops && ops <= target)\n        return ops;\n    }\n\n    return -1;\n  }\n};\n", "275": "class Solution {\n public:\n  int hIndex(vector<int>& citations) {\n    const int n = citations.size();\n    int l = 0;\n    int r = n;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (citations[m] + m >= n)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return n - l;\n  }\n};\n", "2750": "class Solution {\n public:\n  int numberOfGoodSubarraySplits(vector<int>& nums) {\n    if (ranges::count(nums, 1) == 0)\n      return 0;\n\n    constexpr int kMod = 1'000'000'007;\n    int prev = -1;  // the previous index of 1\n    int ans = 1;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == 1) {\n        if (prev != -1)\n          ans = static_cast<long>(ans) * (i - prev) % kMod;\n        prev = i;\n      }\n\n    return ans;\n  }\n};\n", "2751": "struct Robot {\n  int index;\n  int position;\n  int health;\n  char direction;\n};\n\nclass Solution {\n public:\n  vector<int> survivedRobotsHealths(vector<int>& positions,\n                                    vector<int>& healths, string directions) {\n    vector<int> ans;\n    vector<Robot> robots;\n    vector<Robot> stack;  // the runnnig robots\n\n    for (int i = 0; i < positions.size(); ++i)\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\n\n    ranges::sort(robots, ranges::less{},\n                 [](const Robot& robot) { return robot.position; });\n\n    for (Robot& robot : robots) {\n      if (robot.direction == 'R') {\n        stack.push_back(robot);\n        continue;\n      }\n      // Collide with robots going right if any.\n      while (!stack.empty() && stack.back().direction == 'R' &&\n             robot.health > 0) {\n        if (stack.back().health == robot.health) {\n          stack.pop_back();\n          robot.health = 0;\n        } else if (stack.back().health < robot.health) {\n          stack.pop_back();\n          robot.health -= 1;\n        } else {  // stack.back().health > robot.health\n          stack.back().health -= 1;\n          robot.health = 0;\n        }\n      }\n      if (robot.health > 0)\n        stack.push_back(robot);\n    }\n\n    ranges::sort(stack, ranges::less{},\n                 [](const Robot& robot) { return robot.index; });\n\n    for (const Robot& robot : stack)\n      ans.push_back(robot.health);\n\n    return ans;\n  }\n};\n", "2753": "/**\n * Definition for a street.\n * class Street {\n *  public:\n *   Street(vector<int> doors);\n *   void closeDoor();\n *   bool isDoorOpen();\n *   void moveRight();\n * };\n */\nclass Solution {\n public:\n  int houseCount(Street* street, int k) {\n    int ans = 0;\n\n    // Go to the first open door.\n    while (!street->isDoorOpen())\n      street->moveRight();\n\n    street->moveRight();\n\n    for (int count = 1; count <= k; ++count) {\n      // Each time we encounter an open door, there's a possibility that it's\n      // the first open door we intentionally left open.\n      if (street->isDoorOpen()) {\n        ans = count;\n        street->closeDoor();\n      }\n      street->moveRight();\n    }\n\n    return ans;\n  }\n};\n", "276": "class Solution {\n public:\n  int numWays(int n, int k) {\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return k;\n    if (n == 2)\n      return k * k;\n\n    // dp[i] := the number of ways to paint n posts with k colors\n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = k;\n    dp[2] = k * k;\n\n    for (int i = 3; i <= n; ++i)\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);\n\n    return dp[n];\n  }\n};\n", "2760": "class Solution {\n public:\n  int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n    int ans = 0;\n    int dp = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] > threshold)\n        dp = 0;\n      else if (i > 0 && dp > 0 && isOddEven(nums[i - 1], nums[i]))\n        // Increase the size of the subarray.\n        ++dp;\n      else\n        // Start a new subarray if the start is valid.\n        dp = nums[i] % 2 == 0 ? 1 : 0;\n      ans = max(ans, dp);\n    }\n\n    return ans;\n  }\n\n private:\n  bool isOddEven(int a, int b) {\n    return a % 2 != b % 2;\n  }\n};\n", "2761": "class Solution {\n public:\n  vector<vector<int>> findPrimePairs(int n) {\n    const vector<bool> isPrime = sieveEratosthenes(n + 1);\n    vector<vector<int>> ans;\n\n    for (int i = 2; i <= n / 2; ++i)\n      if (isPrime[i] && isPrime[n - i])\n        ans.push_back({i, n - i});\n\n    return ans;\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "2762": "class Solution {\n public:\n  long long continuousSubarrays(vector<int>& nums) {\n    long ans = 1;  // [nums[0]]\n    int left = nums[0] - 2;\n    int right = nums[0] + 2;\n    int l = 0;\n\n    // nums[l..r] is a valid window with range in [left, right].\n    for (int r = 1; r < nums.size(); r++) {\n      if (left <= nums[r] && nums[r] <= right) {\n        left = max(left, nums[r] - 2);\n        right = min(right, nums[r] + 2);\n      } else {\n        // nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2;\n        right = nums[r] + 2;\n        l = r;\n        // If we consistently move leftward in each iteration, it implies that\n        // the entire left subarray satisfies the given condition. For every\n        // subarray with l in the range [0, r], the condition is met, preventing\n        // the code from reaching the final \"else\" condition. Instead, it stops\n        // at the \"if\" condition.\n        while (nums[r] - 2 <= nums[l] && nums[l] <= nums[r] + 2) {\n          left = max(left, nums[l] - 2);\n          right = min(right, nums[l] + 2);\n          --l;\n        }\n        ++l;\n      }\n      // nums[l..r], nums[l + 1..r], ..., nums[r]\n      ans += r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "2763": "class Solution {\n public:\n  // If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  // of determining the number of gaps in each subarray, let's find out how many\n  // subarrays contain each gap.\n  int sumImbalanceNumbers(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // Note that to avoid double counting, only `left` needs to check nums[i].\n    // This adjustment ensures that i represents the position of the leftmost\n    // element of nums[i] within the subarray.\n\n    // left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    vector<int> left(n);\n    // right[i] := the minimum index r s.t. nums[r] = nums[i]\n    vector<int> right(n);\n\n    vector<int> numToIndex(n + 2, -1);\n    for (int i = 0; i < n; ++i) {\n      left[i] = max(numToIndex[nums[i]], numToIndex[nums[i] + 1]);\n      numToIndex[nums[i]] = i;\n    }\n\n    fill(numToIndex.begin(), numToIndex.end(), n);\n    for (int i = n - 1; i >= 0; --i) {\n      right[i] = numToIndex[nums[i] + 1];\n      numToIndex[nums[i]] = i;\n    }\n\n    // The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    // Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    // and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    // subarrays satisfying this condition.\n    for (int i = 0; i < n; ++i)\n      ans += (i - left[i]) * (right[i] - i);\n\n    // Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    // initially assumed to have a gap. This adjustment is necessary as the\n    // maximum element of every subarray does not have a gap.\n    return ans - n * (n + 1) / 2;\n  }\n};\n", "2764": "class Solution {\n public:\n  bool isPreorder(vector<vector<int>>& nodes) {\n    stack<int> stack;  // Stores `id`s.\n\n    for (const vector<int>& node : nodes) {\n      const int id = node[0];\n      const int parentId = node[1];\n      if (parentId == -1) {\n        stack.push(id);\n        continue;\n      }\n      while (!stack.empty() && stack.top() != parentId)\n        stack.pop();\n      if (stack.empty())\n        return false;\n      stack.push(id);\n    }\n\n    return true;\n  }\n};\n", "2765": "class Solution {\n public:\n  int alternatingSubarray(vector<int>& nums) {\n    int ans = 1;\n    int dp = 1;\n\n    for (int i = 1; i < nums.size(); ++i) {\n      const int targetDiff = dp % 2 == 0 ? -1 : 1;\n      // Append nums[i] to the current alternating subarray.\n      if (nums[i] - nums[i - 1] == targetDiff)\n        ++dp;\n      // Reset the alternating subarray to nums[i - 1..i].\n      else if (nums[i] - nums[i - 1] == 1)\n        dp = 2;\n      // Reset the alternating subarray to nums[i].\n      else\n        dp = 1;\n      ans = max(ans, dp);\n    }\n\n    return ans == 1 ? -1 : ans;\n  }\n};\n", "2766": "class Solution {\n public:\n  vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom,\n                              vector<int>& moveTo) {\n    set<int> numsSet{nums.begin(), nums.end()};\n\n    for (int i = 0; i < moveFrom.size(); ++i) {\n      numsSet.erase(numsSet.find(moveFrom[i]));\n      numsSet.insert(moveTo[i]);\n    }\n\n    return {numsSet.begin(), numsSet.end()};\n  }\n};\n", "2767": "class Solution {\n public:\n  int minimumBeautifulSubstrings(string s) {\n    const int n = s.length();\n    // dp[i] := the minimum number of beautiful substrings for the first i chars\n    vector<int> dp(n + 1, n + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n      if (s[i - 1] == '0')\n        continue;\n      int num = 0;  // num of s[i - 1..j - 1]\n      for (int j = i; j <= n; ++j) {\n        num = (num << 1) + s[j - 1] - '0';\n        if (isPowerOfFive(num))\n          dp[j] = min(dp[j], dp[i - 1] + 1);\n      }\n    }\n\n    return dp[n] == n + 1 ? -1 : dp[n];\n  }\n\n private:\n  bool isPowerOfFive(int num) {\n    while (num % 5 == 0)\n      num /= 5;\n    return num == 1;\n  }\n};\n", "2768": "class Solution {\n public:\n  vector<long long> countBlackBlocks(int m, int n,\n                                     vector<vector<int>>& coordinates) {\n    vector<long long> ans(5);\n    // count[i * n + j] := the number of black cells in\n    // (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    unordered_map<long, int> count;\n\n    for (const vector<int>& coordinate : coordinates) {\n      const int x = coordinate[0];\n      const int y = coordinate[1];\n      for (long i = x; i < x + 2; ++i)\n        for (long j = y; j < y + 2; ++j)\n          // 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          // current black cell (x, y).\n          if (i - 1 >= 0 && i < m && j - 1 >= 0 && j < n)\n            ++count[i * n + j];\n    }\n\n    for (const auto& [_, freq] : count)\n      ++ans[freq];\n\n    ans[0] = (m - 1L) * (n - 1) - accumulate(ans.begin(), ans.end(), 0L);\n    return ans;\n  }\n};\n", "2769": "class Solution {\n public:\n  int theMaximumAchievableX(int num, int t) {\n    return num + 2 * t;\n  }\n};\n", "277": "class Solution {\n public:\n  int findCelebrity(int n) {\n    int candidate = 0;\n\n    // Everyone knows the celebrity.\n    for (int i = 1; i < n; ++i)\n      if (knows(candidate, i))\n        candidate = i;\n\n    // The candidate knows nobody and everyone knows the celebrity.\n    for (int i = 0; i < n; ++i) {\n      if (i < candidate && knows(candidate, i) || !knows(i, candidate))\n        return -1;\n      if (i > candidate && !knows(i, candidate))\n        return -1;\n    }\n\n    return candidate;\n  }\n};\n", "2770": "class Solution {\n public:\n  int maximumJumps(vector<int>& nums, int target) {\n    const int n = nums.size();\n    // dp[i] := the maximum number of jumps to reach i from 0\n    vector<int> dp(n, -1);\n    dp[0] = 0;\n\n    for (int j = 1; j < n; ++j)\n      for (int i = 0; i < j; ++i)\n        if (dp[i] != -1 && abs(nums[j] - nums[i]) <= target)\n          dp[j] = max(dp[j], dp[i] + 1);\n\n    return dp[n - 1];\n  }\n};\n", "2771": "class Solution {\n public:\n  int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n    int ans = 1;\n    int dp1 = 1;  // the longest subarray that ends in nums1[i] so far\n    int dp2 = 1;  // the longest subarray that ends in nums2[i] so far\n\n    for (int i = 1; i < nums1.size(); ++i) {\n      const int dp11 = nums1[i - 1] <= nums1[i] ? dp1 + 1 : 1;\n      const int dp21 = nums2[i - 1] <= nums1[i] ? dp2 + 1 : 1;\n      const int dp12 = nums1[i - 1] <= nums2[i] ? dp1 + 1 : 1;\n      const int dp22 = nums2[i - 1] <= nums2[i] ? dp2 + 1 : 1;\n      dp1 = max(dp11, dp21);\n      dp2 = max(dp12, dp22);\n      ans = max({ans, dp1, dp2});\n    }\n\n    return ans;\n  }\n};\n", "2772": "class Solution {\n public:\n  bool checkArray(vector<int>& nums, int k) {\n    if (k == 1)\n      return true;\n\n    int needDecrease = 0;\n    // Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    deque<int> dq;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i >= k) {\n        needDecrease -= dq.front();\n        dq.pop_front();\n      }\n      if (nums[i] < needDecrease)\n        return false;\n      const int decreasedNum = nums[i] - needDecrease;\n      dq.push_back(decreasedNum);\n      needDecrease += decreasedNum;\n    }\n\n    return dq.back() == 0;\n  }\n};\n", "2773": "class Solution {\n public:\n  int heightOfTree(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    // a leaf node\n    if (root->left != nullptr && root->left->right == root)\n      return 0;\n    return 1 + max(heightOfTree(root->left), heightOfTree(root->right));\n  }\n};\n", "2778": "class Solution {\n public:\n  int sumOfSquares(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (n % (i + 1) == 0)\n        ans += nums[i] * nums[i];\n\n    return ans;\n  }\n};\n", "2779": "class Solution {\n public:\n  int maximumBeauty(vector<int>& nums, int k) {\n    // l and r track the maximum window instead of the valid window.\n    int l = 0;\n    int r = 0;\n\n    ranges::sort(nums);\n\n    for (r = 0; r < nums.size(); ++r)\n      if (nums[r] - nums[l] > 2 * k)\n        ++l;\n\n    return r - l;\n  }\n};\n", "278": "bool isBadVersion(int version);\n\nclass Solution {\n public:\n  int firstBadVersion(int n) {\n    int l = 1;\n    int r = n;\n\n    while (l < r) {\n      const int m = l + (r - l) / 2;\n      if (isBadVersion(m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n};\n", "2780": "class Solution {\n public:\n  int minimumIndex(vector<int>& nums) {\n    const int n = nums.size();\n    unordered_map<int, int> count1;\n    unordered_map<int, int> count2;\n\n    for (const int num : nums)\n      ++count2[num];\n\n    for (int i = 0; i < n; ++i) {\n      const int freq1 = ++count1[nums[i]];\n      const int freq2 = --count2[nums[i]];\n      if (freq1 * 2 > i + 1 && freq2 * 2 > n - 1 - i)\n        return i;\n    }\n\n    return -1;\n  }\n};\n", "2781": "struct TrieNode {\n public:\n  unordered_map<char, shared_ptr<TrieNode>> children;\n  bool isWord = false;\n};\n\nclass Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      if (node->children[c] == nullptr)\n        node->children[c] = make_shared<TrieNode>();\n      node = node->children[c];\n    }\n    node->isWord = true;\n  }\n\n  bool search(const string& word, int l, int r) {\n    shared_ptr<TrieNode> node = root;\n    for (int j = l; j <= r; ++j) {\n      const char c = word[j];\n      if (node->children[c] == nullptr)\n        return false;\n      node = node->children[c];\n    }\n    return node->isWord;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  int longestValidSubstring(string word, vector<string>& forbidden) {\n    int ans = 0;\n    Trie trie;\n\n    for (const string& s : forbidden)\n      trie.insert(s);\n\n    // r is the rightmost index to make word[l..r] a valid substring.\n    int r = word.length() - 1;\n    for (int l = word.length() - 1; l >= 0; --l) {\n      for (int end = l; end < min(l + 10, r + 1); ++end)\n        if (trie.search(word, l, end)) {\n          r = end - 1;\n          break;\n        }\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "2782": "/**\n * Definition for a category handler.\n * class CategoryHandler {\n *  public:\n *   CategoryHandler(vector<int> categories);\n *   bool haveSameCategory(int a, int b);\n * };\n */\n\nclass Solution {\n public:\n  int numberOfCategories(int n, CategoryHandler* categoryHandler) {\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (!haveSameCategoryPreviously(i, n, categoryHandler))\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  bool haveSameCategoryPreviously(int i, int n,\n                                  CategoryHandler* categoryHandler) {\n    for (int j = 0; j < i; ++j)\n      if (categoryHandler->haveSameCategory(i, j))\n        return true;\n    return false;\n  }\n};\n", "2784": "class Solution {\n public:\n  bool isGood(vector<int>& nums) {\n    constexpr int kMax = 200;\n    const int n = nums.size() - 1;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    return all_of(count.begin() + 1, count.begin() + n, [](int c) {\n      return c == 1;\n    }) && count[n] == 2;\n  }\n};\n", "2785": "class Solution {\n public:\n  string sortVowels(string s) {\n    string ans;\n    vector<char> vowels;\n\n    for (const char c : s)\n      if (isVowel(c))\n        vowels.push_back(c);\n\n    ranges::sort(vowels);\n\n    int i = 0;  // vowels' index\n    for (const char c : s)\n      ans += isVowel(c) ? vowels[i++] : c;\n\n    return ans;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "2786": "class Solution {\n public:\n  long long maxScore(vector<int>& nums, int x) {\n    // Note that we always need to take nums[0], so the initial definition might\n    // not hold true.\n\n    // dp0 := the maximum score so far with `nums` ending in an even number\n    long dp0 = nums[0] - (nums[0] % 2 == 1 ? x : 0);\n    // dp1 := the maximum score so far with `nums` ending in an odd number\n    long dp1 = nums[0] - (nums[0] % 2 == 0 ? x : 0);\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] % 2 == 0)\n        dp0 = nums[i] + max(dp0, dp1 - x);\n      else\n        dp1 = nums[i] + max(dp1, dp0 - x);\n\n    return max(dp0, dp1);\n  }\n};\n", "2787": "class Solution {\n public:\n  int numberOfWays(int n, int x) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i] := the number of ways to express i\n    vector<int> dp(n + 1);\n    int ax;  // a^x\n\n    dp[0] = 1;\n\n    for (int a = 1; (ax = pow(a, x)) <= n; ++a)\n      for (int i = n; i >= ax; --i) {\n        dp[i] += dp[i - ax];\n        dp[i] %= kMod;\n      }\n\n    return dp[n];\n  }\n};\n", "2788": "class Solution {\n public:\n  vector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n    vector<string> ans;\n\n    for (const string& word : words) {\n      istringstream iss(word);\n      for (string word; getline(iss, word, separator);)\n        if (!word.empty())\n          ans.push_back(word);\n    }\n\n    return ans;\n  }\n};\n", "2789": "class Solution {\n public:\n  long long maxArrayValue(vector<int>& nums) {\n    long ans = nums.back();\n\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] > ans)\n        ans = nums[i];\n      else\n        ans += nums[i];\n\n    return ans;\n  }\n};\n", "279": "class Solution {\n public:\n  int numSquares(int n) {\n    vector<int> dp(n + 1, n);  // 1^2 x n\n    dp[0] = 0;                 // no way\n    dp[1] = 1;                 // 1^2\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 1; j * j <= i; ++j)\n        dp[i] = min(dp[i], dp[i - j * j] + 1);\n\n    return dp[n];\n  }\n};\n", "2790": "class Solution {\n public:\n  int maxIncreasingGroups(vector<int>& usageLimits) {\n    int ans = 1;  // the next target length\n    long availableLimits = 0;\n\n    ranges::sort(usageLimits);\n\n    for (const int usageLimit : usageLimits) {\n      availableLimits += usageLimit;\n      // Can create groups 1, 2, ..., ans.\n      if (availableLimits >= static_cast<long>(ans) * (ans + 1) / 2)\n        ++ans;\n    }\n\n    return ans - 1;\n  }\n};\n", "2791": "class Solution {\n public:\n  long long countPalindromePaths(vector<int>& parent, string s) {\n    // A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    // frequency of a letter on the u-v path is equal to the sum of its\n    // frequencies on the root-u and root-v paths substract twice of its\n    // frequency on the root-LCA(u, v) path. Considering only the parity\n    // (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    // possible to calculate both parts easily using a simple DFS.\n    vector<vector<int>> tree(parent.size());\n\n    for (int i = 1; i < parent.size(); ++i)\n      tree[parent[i]].push_back(i);\n\n    return dfs(tree, 0, 0, s, {{0, 1}});\n  }\n\n private:\n  // mask := 26 bits that represent the parity of each character in the alphabet\n  // on the path from node 0 to node u\n  long dfs(const vector<vector<int>>& tree, int u, int mask, const string& s,\n           unordered_map<int, int>&& maskToCount) {\n    long res = 0;\n    if (u > 0) {\n      mask ^= 1 << (s[u] - 'a');\n      // Consider any u-v path with 1 bit set.\n      for (int i = 0; i < 26; ++i)\n        if (const auto it = maskToCount.find(mask ^ (1 << i));\n            it != maskToCount.cend())\n          res += it->second;\n      // Consider u-v path with 0 bit set.\n      res += maskToCount[mask ^ 0]++;\n    }\n    for (const int v : tree[u])\n      res += dfs(tree, v, mask, s, std::move(maskToCount));\n    return res;\n  }\n};\n", "2792": "class Solution {\n public:\n  int countGreatEnoughNodes(TreeNode* root, int k) {\n    int ans = 0;\n    dfs(root, k, ans);\n    return ans;\n  }\n\n private:\n  multiset<int> dfs(TreeNode* root, int k, int& ans) {\n    if (root == nullptr)\n      return {};\n\n    multiset<int> kSmallest = dfs(root->left, k, ans);\n    multiset<int> kSmallestRight = dfs(root->right, k, ans);\n    kSmallest.merge(kSmallestRight);\n\n    if (kSmallest.size() > k)\n      kSmallest.erase(next(kSmallest.begin(), k), kSmallest.end());\n    if (kSmallest.size() == k && root->val > *kSmallest.rbegin())\n      ++ans;\n\n    kSmallest.insert(root->val);\n    return kSmallest;\n  }\n};\n", "2798": "class Solution {\n public:\n  int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n    return ranges::count_if(hours,\n                            [target](int hour) { return hour >= target; });\n  }\n};\n", "2799": "class Solution {\n public:\n  int countCompleteSubarrays(vector<int>& nums) {\n    constexpr int kMax = 2000;\n    const int totalDistinct =\n        unordered_set<int>(nums.begin(), nums.end()).size();\n    int ans = 0;\n    int distinct = 0;\n    vector<int> count(kMax + 1);\n\n    int l = 0;\n    for (const int num : nums) {\n      if (++count[num] == 1)\n        ++distinct;\n      while (distinct == totalDistinct)\n        if (--count[nums[l++]] == 0)\n          --distinct;\n      // Assume nums[r] = num,\n      // nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l;\n    }\n\n    return ans;\n  }\n};\n", "28": "class Solution {\n public:\n  int strStr(string haystack, string needle) {\n    const int m = haystack.length();\n    const int n = needle.length();\n\n    for (int i = 0; i < m - n + 1; i++)\n      if (haystack.substr(i, n) == needle)\n        return i;\n\n    return -1;\n  }\n};\n", "280": "class Solution {\n public:\n  void wiggleSort(vector<int>& nums) {\n    // 1. If i is even, then nums[i] <= nums[i - 1].\n    // 2. If i is odd, then nums[i] >= nums[i - 1].\n    for (int i = 1; i < nums.size(); ++i)\n      if (i % 2 == 0 && nums[i] > nums[i - 1] ||\n          i % 2 == 1 && nums[i] < nums[i - 1])\n        swap(nums[i], nums[i - 1]);\n  }\n};\n", "2800": "class Solution {\n public:\n  string minimumString(string a, string b, string c) {\n    const string abc = merge(a, merge(b, c));\n    const string acb = merge(a, merge(c, b));\n    const string bac = merge(b, merge(a, c));\n    const string bca = merge(b, merge(c, a));\n    const string cab = merge(c, merge(a, b));\n    const string cba = merge(c, merge(b, a));\n    return getMin({abc, acb, bac, bca, cab, cba});\n  }\n\n private:\n  // Merges a and b.\n  string merge(const string& a, const string& b) {\n    if (b.find(a) != string::npos)  // a is a substring of b.\n      return b;\n    for (int i = 0; i < a.length(); ++i) {\n      const string aSuffix = a.substr(i);\n      const string bPrefix = b.substr(0, min(b.length(), aSuffix.length()));\n      if (aSuffix == bPrefix)\n        return a + b.substr(bPrefix.length());\n    }\n    return a + b;\n  }\n\n  // Returns the lexicographically smallest string.\n  string getMin(const vector<string>& words) {\n    string res = words[0];\n    for (int i = 1; i < words.size(); ++i)\n      res = getMin(res, words[i]);\n    return res;\n  }\n\n  // Returns the lexicographically smaller string.\n  string getMin(const string& a, const string& b) {\n    return (a.length() < b.length() || (a.length() == b.length() && a < b)) ? a\n                                                                            : b;\n  }\n};\n", "2801": "class Solution {\n public:\n  int countSteppingNumbers(string low, string high) {\n    const string lowWithLeadingZeros =\n        string(high.length() - low.length(), '0') + low;\n    vector<vector<vector<vector<int>>>> mem(\n        high.length(), vector<vector<vector<int>>>(\n                           11, vector<vector<int>>(2, vector<int>(2, -1))));\n    return count(lowWithLeadingZeros, high, 0, 10, /*isLeadingZero=*/true, true,\n                 true, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of valid integers, considering the i-th digit, where\n  // `prevDigit` is the previous digit, `tight1` indicates if the current\n  // digit is tightly bound for `low`, and `tight2` indicates if the current\n  // digit is tightly bound for `high`.\n  int count(const string& low, const string& high, int i, int prevDigit,\n            bool isLeadingZero, bool tight1, bool tight2,\n            vector<vector<vector<vector<int>>>>& mem) {\n    if (i == high.length())\n      return 1;\n    if (mem[i][prevDigit][tight1][tight2] != -1)\n      return mem[i][prevDigit][tight1][tight2];\n\n    int res = 0;\n    const int minDigit = tight1 ? low[i] - '0' : 0;\n    const int maxDigit = tight2 ? high[i] - '0' : 9;\n\n    for (int d = minDigit; d <= maxDigit; ++d) {\n      const bool nextTight1 = tight1 && (d == minDigit);\n      const bool nextTight2 = tight2 && (d == maxDigit);\n      if (isLeadingZero)\n        // Can place any digit in [minDigit, maxDigit].\n        res += count(low, high, i + 1, d, isLeadingZero && d == 0, nextTight1,\n                     nextTight2, mem);\n      else if (abs(d - prevDigit) == 1)\n        // Can only place prevDigit - 1 or prevDigit + 1.\n        res += count(low, high, i + 1, d, false, nextTight1, nextTight2, mem);\n      res %= kMod;\n    }\n\n    return mem[i][prevDigit][tight1][tight2] = res;\n  }\n};\n", "2802": "class Solution {\n public:\n  string kthLuckyNumber(int k) {\n    string ans;\n\n    for (int i = k + 1; i > 0; i /= 2)\n      ans += i % 2 == 0 ? '4' : '7';\n\n    ranges::reverse(ans);\n    return ans.substr(1);\n  }\n};\n", "2806": "class Solution {\n public:\n  int accountBalanceAfterPurchase(int purchaseAmount) {\n    return 100 - ((purchaseAmount + 5) / 10) * 10;\n  }\n};\n", "2807": "class Solution {\n public:\n  ListNode* insertGreatestCommonDivisors(ListNode* head) {\n    for (ListNode* curr = head; curr->next != nullptr;) {\n      ListNode* inserted =\n          new ListNode(__gcd(curr->val, curr->next->val), curr->next);\n      curr->next = inserted;\n      curr = inserted->next;\n    }\n    return head;\n  }\n};\n", "2808": "class Solution {\n public:\n  int minimumSeconds(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = n;\n    unordered_map<int, vector<int>> numToIndices;\n\n    for (int i = 0; i < n; ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    for (const auto& [_, indices] : numToIndices) {\n      int seconds = getSeconds(indices.front() + n, indices.back());\n      for (int i = 1; i < indices.size(); ++i)\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]));\n      ans = min(ans, seconds);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the number of seconds required to make nums[i..j] the same.\n  int getSeconds(int i, int j) {\n    return (i - j) / 2;\n  }\n};\n", "2809": "class Solution {\n public:\n  int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n    const int n = nums1.size();\n    const int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\n    const int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\n    // dp[j] := the maximum reduced value if we do j operations on the numbers\n    // so far\n    vector<int> dp(n + 1);\n    vector<pair<int, int>> sortedNums;\n\n    for (int i = 0; i < n; ++i)\n      sortedNums.emplace_back(nums2[i], nums1[i]);\n\n    ranges::sort(sortedNums);\n\n    for (int i = 1; i <= n; ++i) {\n      const auto [num2, num1] = sortedNums[i - 1];\n      for (int j = i; j > 0; --j)\n        dp[j] = max(\n            // the maximum reduced value if we do j operations on the first\n            // i - 1 numbers\n            dp[j],\n            // the maximum reduced value if we do j - 1 operations on the first\n            // i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            // j-th operation\n            dp[j - 1] + num2 * j + num1);\n    }\n\n    for (int op = 0; op <= n; ++op)\n      if (sum1 + sum2 * op - dp[op] <= x)\n        return op;\n\n    return -1;\n  }\n};\n", "281": "class ZigzagIterator {\n public:\n  ZigzagIterator(vector<int>& v1, vector<int>& v2) {\n    if (!v1.empty())\n      q.emplace(v1.begin(), v1.end());\n    if (!v2.empty())\n      q.emplace(v2.begin(), v2.end());\n  }\n\n  int next() {\n    const auto [it, endIt] = q.front();\n    q.pop();\n    if (it + 1 != endIt)\n      q.emplace(it + 1, endIt);\n    return *it;\n  }\n\n  bool hasNext() {\n    return !q.empty();\n  }\n\n private:\n  // {{ it, endIt }}\n  queue<pair<vector<int>::iterator, vector<int>::iterator>> q;\n};\n", "2810": "class Solution {\n public:\n  string finalString(string s) {\n    deque<char> dq;\n    bool inversed = false;\n\n    for (const char c : s)\n      if (c == 'i')\n        inversed = !inversed;\n      else if (inversed)\n        dq.push_front(c);\n      else\n        dq.push_back(c);\n\n    return inversed ? string{dq.rbegin(), dq.rend()}\n                    : string{dq.begin(), dq.end()};\n  }\n};\n", "2811": "class Solution {\n public:\n  bool canSplitArray(vector<int>& nums, int m) {\n    if (nums.size() < 3)\n      return true;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] + nums[i - 1] >= m)\n        return true;\n\n    return false;\n  }\n};\n", "2812": "class Solution {\n public:\n  int maximumSafenessFactor(vector<vector<int>>& grid) {\n    const vector<vector<int>> distToThief = getDistToThief(grid);\n    int l = 0;\n    int r = grid.size() * 2;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (hasValidPath(distToThief, m))\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l - 1;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  bool hasValidPath(const vector<vector<int>>& distToThief, int safeness) {\n    if (distToThief[0][0] < safeness)\n      return false;\n\n    const int n = distToThief.size();\n    queue<pair<int, int>> q{{{0, 0}}};\n    vector<vector<bool>> seen(n, vector<bool>(n));\n    seen[0][0] = true;\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      if (distToThief[i][j] < safeness)\n        continue;\n      if (i == n - 1 && j == n - 1)\n        return true;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == n || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        q.emplace(x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    return false;\n  }\n\n  vector<vector<int>> getDistToThief(const vector<vector<int>>& grid) {\n    const int n = grid.size();\n    vector<vector<int>> distToThief(n, vector<int>(n));\n    queue<pair<int, int>> q;\n    vector<vector<bool>> seen(n, vector<bool>(n));\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1) {\n          q.emplace(i, j);\n          seen[i][j] = true;\n        }\n\n    for (int dist = 0; !q.empty(); ++dist) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        distToThief[i][j] = dist;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == n || y < 0 || y == n)\n            continue;\n          if (seen[x][y])\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n    }\n\n    return distToThief;\n  }\n};\n", "2813": "class Solution {\n public:\n  long long findMaximumElegance(vector<vector<int>>& items, int k) {\n    long ans = 0;\n    long totalProfit = 0;\n    unordered_set<int> seenCategories;\n    stack<int> decreasingDuplicateProfits;\n\n    ranges::sort(items, greater<>());\n\n    for (int i = 0; i < k; i++) {\n      const int profit = items[i][0];\n      const int category = items[i][1];\n      totalProfit += profit;\n      if (seenCategories.contains(category))\n        decreasingDuplicateProfits.push(profit);\n      else\n        seenCategories.insert(category);\n    }\n\n    ans = totalProfit +\n          static_cast<long>(seenCategories.size()) * seenCategories.size();\n\n    for (int i = k; i < items.size(); ++i) {\n      const int profit = items[i][0];\n      const int category = items[i][1];\n      if (!seenCategories.contains(category) &&\n          !decreasingDuplicateProfits.empty()) {\n        // If this is a new category we haven't seen before, it's worth\n        // considering taking it and replacing the one with the least profit\n        // since it will increase the distinct_categories and potentially result\n        // in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.top(),\n            decreasingDuplicateProfits.pop();\n        totalProfit += profit;\n        seenCategories.insert(category);\n        ans = max(ans,\n                  static_cast<long>(totalProfit +\n                                    static_cast<long>(seenCategories.size()) *\n                                        seenCategories.size()));\n      }\n    }\n\n    return ans;\n  }\n};\n", "2814": "class Solution {\n public:\n  int minimumSeconds(vector<vector<string>>& land) {\n    const int m = land.size();\n    const int n = land[0].size();\n    const vector<vector<int>> floodDist = getFloodDist(land);\n    queue<pair<int, int>> q;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (land[i][j] == \"S\") {\n          q.emplace(i, j);\n          seen[i][j] = true;\n        }\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (land[x][y] == \"D\")\n            return step;\n          if (floodDist[x][y] <= step || land[x][y] == \"X\" || seen[x][y])\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  vector<vector<int>> getFloodDist(const vector<vector<string>>& land) {\n    const int m = land.size();\n    const int n = land[0].size();\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n    queue<pair<int, int>> q;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (land[i][j] == \"*\") {\n          q.emplace(i, j);\n          seen[i][j] = true;\n        }\n\n    for (int d = 0; !q.empty(); ++d)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        dist[i][j] = d;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (land[x][y] == \"X\" || land[x][y] == \"D\" || seen[x][y])\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n\n    return dist;\n  }\n};\n", "2815": "class Solution {\n public:\n  int maxSum(vector<int>& nums) {\n    int ans = 0;\n    // maxNum[i] := the maximum num we met so far with the maximum digit i\n    vector<int> maxNum(10);\n\n    for (const int num : nums) {\n      const int d = getMaxDigit(num);\n      if (maxNum[d] > 0)\n        ans = max(ans, num + maxNum[d]);\n      maxNum[d] = max(maxNum[d], num);\n    }\n\n    return ans == 0 ? -1 : ans;\n  }\n\n private:\n  int getMaxDigit(int num) {\n    int maxDigit = 0;\n    while (num > 0) {\n      maxDigit = max(maxDigit, num % 10);\n      num /= 10;\n    }\n    return maxDigit;\n  }\n};\n", "2816": "class Solution {\n public:\n  ListNode* doubleIt(ListNode* head) {\n    if (head->val >= 5)\n      head = new ListNode(0, head);\n\n    for (ListNode* curr = head; curr != nullptr; curr = curr->next) {\n      curr->val *= 2;\n      curr->val %= 10;\n      if (curr->next && curr->next->val >= 5)\n        ++curr->val;\n    }\n\n    return head;\n  }\n};\n", "2817": "class Solution {\n public:\n  int minAbsoluteDifference(vector<int>& nums, int x) {\n    int ans = INT_MAX;\n    set<int> seen;\n\n    for (int i = x; i < nums.size(); ++i) {\n      seen.insert(nums[i - x]);\n      // `upper_bound` works as well.\n      const auto it = seen.lower_bound(nums[i]);\n      if (it != seen.cend())\n        ans = min(ans, *it - nums[i]);\n      if (it != seen.cbegin())\n        ans = min(ans, nums[i] - *prev(it));\n    }\n\n    return ans;\n  }\n};\n", "2818": "class Solution {\n public:\n  int maximumScore(vector<int>& nums, int k) {\n    const int n = nums.size();\n    const int mx = ranges::max(nums);\n    const vector<int> minPrimeFactors = sieveEratosthenes(mx + 1);\n    const vector<int> primeScores = getPrimeScores(nums, minPrimeFactors);\n    int ans = 1;\n    // left[i] := the next index on the left (if any) s.t.\n    // primeScores[left[i]] >= primeScores[i]\n    vector<int> left(n, -1);\n    // right[i] := the next index on the right (if any) s.t.\n    // primeScores[right[i]] > primeScores[i]\n    vector<int> right(n, n);\n    stack<int> stack;\n\n    // Find the next indices on the left where `primeScores` are greater or\n    // equal.\n    for (int i = n - 1; i >= 0; --i) {\n      while (!stack.empty() && primeScores[stack.top()] <= primeScores[i])\n        left[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    stack = std::stack<int>();\n\n    // Find the next indices on the right where `primeScores` are greater.\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && primeScores[stack.top()] < primeScores[i])\n        right[stack.top()] = i, stack.pop();\n      stack.push(i);\n    }\n\n    vector<pair<int, int>> numAndIndexes;\n\n    for (int i = 0; i < n; ++i)\n      numAndIndexes.emplace_back(nums[i], i);\n\n    ranges::sort(numAndIndexes,\n                 [&](const pair<int, int>& a, const pair<int, int>& b) {\n      return a.first == b.first ? a.second < b.second : a.first > b.first;\n    });\n\n    for (const auto& [num, i] : numAndIndexes) {\n      // nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      // So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      // be chosen.\n      const long rangeCount = static_cast<long>(i - left[i]) * (right[i] - i);\n      const long actualCount = min(rangeCount, static_cast<long>(k));\n      k -= actualCount;\n      ans = static_cast<long>(ans) * modPow(num, actualCount) % kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n\n  // Gets the minimum prime factor of i, where 1 < i <= n.\n  vector<int> sieveEratosthenes(int n) {\n    vector<int> minPrimeFactors(n + 1);\n    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);\n    for (int i = 2; i * i < n; ++i)\n      if (minPrimeFactors[i] == i)  // `i` is prime.\n        for (int j = i * i; j < n; j += i)\n          minPrimeFactors[j] = min(minPrimeFactors[j], i);\n    return minPrimeFactors;\n  }\n\n  vector<int> getPrimeScores(const vector<int>& nums,\n                             const vector<int>& minPrimeFactors) {\n    vector<int> primeScores;\n    for (const int num : nums)\n      primeScores.push_back(getPrimeScore(num, minPrimeFactors));\n    return primeScores;\n  }\n\n  int getPrimeScore(int num, const vector<int>& minPrimeFactors) {\n    unordered_set<int> primeFactors;\n    while (num > 1) {\n      const int divisor = minPrimeFactors[num];\n      primeFactors.insert(divisor);\n      while (num % divisor == 0)\n        num /= divisor;\n    }\n    return primeFactors.size();\n  }\n};\n", "2819": "class Solution {\n public:\n  vector<long long> minimumRelativeLosses(vector<int>& prices,\n                                          vector<vector<int>>& queries) {\n    const int n = prices.size();\n    vector<long long> ans;\n    vector<long long> prefix{0};\n\n    ranges::sort(prices);\n\n    for (const int price : prices)\n      prefix.push_back(prefix.back() + price);\n\n    for (const vector<int>& query : queries) {\n      const int k = query[0];\n      const int m = query[1];\n      const int countFront = getCountFront(k, m, prices);\n      const int countBack = m - countFront;\n      ans.push_back(getRelativeLoss(countFront, countBack, k, prefix));\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n  // and the last `m - countFront` chocolates is optimal.\n  //\n  // Define loss[i] := the relative loss of picking `prices[i]`.\n  // 1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n  //    Thus, loss[i] = prices[i] - 0 = prices[i].\n  // 2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n  //    Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n  // By observation, we deduce that it is always better to pick from the front\n  // or the back since loss[i] is increasing for 1. and is decreasing for 2.\n  //\n  // Assume that picking `left` chocolates from the left and `right = m - left`\n  // chocolates from the right is optimal. Therefore, we are selecting\n  // chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n  //\n  // To determine the optimal `left` in each iteration, we simply compare\n  // `loss[left]` with `loss[n - right]`; if `loss[left] < loss[n - right]`,\n  // it's worth increasing `left`.\n  int getCountFront(int k, int m, const vector<int>& prices) {\n    const int n = prices.size();\n    const int countNoGreaterThanK =\n        ranges::upper_bound(prices, k) - prices.begin();\n    int l = 0;\n    int r = min(countNoGreaterThanK, m);\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      const int right = m - mid;\n      // Picking prices[mid] is better than picking prices[n - right].\n      if (prices[mid] < 2L * k - prices[n - right])\n        l = mid + 1;\n      else\n        r = mid;\n    }\n\n    return l;\n  }\n\n  // Returns the relative loss of picking `countFront` and `countBack`\n  // chocolates.\n  long getRelativeLoss(int countFront, int countBack, int k,\n                       const vector<long long>& prefix) {\n    const long lossFront = prefix[countFront];\n    const long lossBack =\n        2L * k * countBack -\n        (prefix.back() - prefix[prefix.size() - 1 - countBack]);\n    return lossFront + lossBack;\n  }\n};\n", "282": "class Solution {\n public:\n  vector<string> addOperators(string num, int target) {\n    vector<string> ans;\n    dfs(num, target, 0, 0, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  }\n\n  void dfs(const string& num, int target, int start, long prev, long eval,\n           vector<string>&& path, vector<string>& ans) {\n    if (start == num.length()) {\n      if (eval == target)\n        ans.push_back(join(path));\n      return;\n    }\n\n    for (int i = start; i < num.length(); ++i) {\n      if (i > start && num[start] == '0')\n        return;\n      const string& s = num.substr(start, i - start + 1);\n      const long curr = stol(s);\n      if (start == 0) {\n        path.push_back(s);\n        dfs(num, target, i + 1, curr, curr, std::move(path), ans);\n        path.pop_back();\n      } else {\n        for (const string& op : {\"+\", \"-\", \"*\"}) {\n          path.push_back(op + s);\n          if (op == \"+\")\n            dfs(num, target, i + 1, curr, eval + curr, std::move(path), ans);\n          else if (op == \"-\")\n            dfs(num, target, i + 1, -curr, eval - curr, std::move(path), ans);\n          else\n            dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr,\n                std::move(path), ans);\n          path.pop_back();\n        }\n      }\n    }\n  }\n};\n", "2824": "class Solution {\n public:\n  int countPairs(vector<int>& nums, int target) {\n    int ans = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = i + 1; j < nums.size(); ++j)\n        if (nums[i] + nums[j] < target)\n          ++ans;\n\n    return ans;\n  }\n};\n", "2825": "class Solution {\n public:\n  bool canMakeSubsequence(string str1, string str2) {\n    int i = 0;  // str2's index\n\n    for (const char c : str1)\n      if (c == str2[i] || ('a' + ((c - 'a' + 1) % 26)) == str2[i])\n        if (++i == str2.length())\n          return true;\n\n    return false;\n  }\n};\n", "2826": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    // dp[i] := the longest non-decreasing subsequence so far with numbers in\n    // [1..i]\n    vector<int> dp(4);\n\n    for (const int num : nums) {\n      ++dp[num];\n      dp[2] = max(dp[2], dp[1]);\n      dp[3] = max(dp[3], dp[2]);\n    }\n\n    return nums.size() - dp[3];\n  }\n};\n", "2827": "class Solution {\n public:\n  int numberOfBeautifulIntegers(int low, int high, int k) {\n    const string lowString = to_string(low);\n    const string highString = to_string(high);\n    const string lowWithLeadingZeros =\n        string(highString.length() - lowString.length(), '0') + lowString;\n    vector<vector<vector<vector<vector<vector<int>>>>>> mem(\n        highString.length(),\n        vector<vector<vector<vector<vector<int>>>>>(\n            10, vector<vector<vector<vector<int>>>>(\n                    10, vector<vector<vector<int>>>(\n                            k, vector<vector<int>>(2, vector<int>(2, -1))))));\n    return count(lowWithLeadingZeros, highString, k, 0, 0, 0, 0, true, true,\n                 true, mem);\n  }\n\n private:\n  // Returns the number of beautiful integers, considering the i-th digit with\n  // counts of even `even` digits and odd `odd` digits, where the current number\n  // modulo k equals remainder, `tight1` indicates if the current digit is\n  // tightly bound for `low` and `tight2` indicates if the current digit is\n  // tightly bound for `high`\n  int count(const string& low, const string& high, int k, int i, int even,\n            int odd, int remainder, bool isLeadingZero, bool tight1,\n            bool tight2,\n            vector<vector<vector<vector<vector<vector<int>>>>>>& mem) {\n    if (i == high.length())\n      return !isLeadingZero && even == odd && remainder == 0;\n    if (mem[i][even][odd][remainder][tight1][tight2] != -1)\n      return mem[i][even][odd][remainder][tight1][tight2];\n\n    int res = 0;\n    const int minDigit = tight1 ? low[i] - '0' : 0;\n    const int maxDigit = tight2 ? high[i] - '0' : 9;\n\n    for (int d = minDigit; d <= maxDigit; ++d) {\n      const int nextEven = even + ((!isLeadingZero || d > 0) && d % 2 == 0);\n      const int nextOdd = odd + (d % 2 == 1);\n      const int nextRemainder = (remainder * 10 + d) % k;\n      const bool nextTight1 = tight1 && (d == minDigit);\n      const bool nextTight2 = tight2 && (d == maxDigit);\n      res += count(low, high, k, i + 1, nextEven, nextOdd, nextRemainder,\n                   isLeadingZero && d == 0, nextTight1, nextTight2, mem);\n    }\n\n    return mem[i][even][odd][remainder][tight1][tight2] = res;\n  }\n};\n", "2828": "class Solution {\n public:\n  bool isAcronym(vector<string>& words, string s) {\n    if (words.size() != s.length())\n      return false;\n\n    for (int i = 0; i < words.size(); ++i)\n      if (words[i][0] != s[i])\n        return false;\n\n    return true;\n  }\n};\n", "2829": "class Solution {\n public:\n  int minimumSum(int n, int k) {\n    // These are the unique pairs that sum up to k:\n    // (1, k - 1), (2, k - 2), ..., (ceil(k / 2), floor(k / 2)).\n    // Our optimal strategy is to select 1, 2, ..., floor(k / 2), and then\n    // choose k, k + 1, ... if necessary, as selecting any number in the range\n    // [ceil(k / 2), k - 1] will result in a pair summing up to k.\n    const int mid = k / 2;  // floor(k / 2)\n    if (n <= mid)\n      return trapezoid(1, n);\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1));\n  }\n\n private:\n  // Returns sum(a..b).\n  int trapezoid(int a, int b) {\n    return (a + b) * (b - a + 1) / 2;\n  }\n};\n", "283": "class Solution {\n public:\n  void moveZeroes(vector<int>& nums) {\n    int i = 0;\n    for (const int num : nums)\n      if (num != 0)\n        nums[i++] = num;\n\n    while (i < nums.size())\n      nums[i++] = 0;\n  }\n};\n", "2830": "class Solution {\n public:\n  int maximizeTheProfit(int n, vector<vector<int>>& offers) {\n    // dp[i] := the maximum amount of gold of selling the first i houses\n    vector<int> dp(n + 1);\n    vector<vector<pair<int, int>>> endToStartAndGolds(n);\n\n    for (const vector<int>& offer : offers) {\n      const int start = offer[0];\n      const int end = offer[1];\n      const int gold = offer[2];\n      endToStartAndGolds[end].emplace_back(start, gold);\n    }\n\n    for (int end = 1; end <= n; ++end) {\n      // Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1];\n      for (const auto& [start, gold] : endToStartAndGolds[end - 1])\n        dp[end] = max(dp[end], dp[start] + gold);\n    }\n\n    return dp[n];\n  }\n};\n", "2831": "class Solution {\n public:\n  int longestEqualSubarray(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    // l and r track the maximum window instead of the valid window.\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      ans = max(ans, ++count[nums[r]]);\n      if (r - l + 1 - k > ans)\n        --count[nums[l++]];\n    }\n\n    return ans;\n  }\n};\n", "2832": "class Solution {\n public:\n  vector<int> maximumLengthOfRanges(vector<int>& nums) {\n    vector<int> ans(nums.size());\n    stack<int> stack;  // a decreasing stack\n\n    for (int i = 0; i <= nums.size(); ++i) {\n      while (!stack.empty() &&\n             (i == nums.size() || nums[stack.top()] < nums[i])) {\n        const int index = stack.top();\n        stack.pop();\n        const int left = stack.empty() ? -1 : stack.top();\n        ans[index] = i - left - 1;\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "2833": "class Solution {\n public:\n  int furthestDistanceFromOrigin(string moves) {\n    int countL = 0;\n    int countR = 0;\n    int countUnderline = 0;\n\n    for (const char c : moves)\n      if (c == 'L')\n        ++countL;\n      else if (c == 'R')\n        ++countR;\n      else  // c == '_'\n        ++countUnderline;\n\n    return abs(countL - countR) + countUnderline;\n  }\n};\n", "2834": "class Solution {\n public:\n  // Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  int minimumPossibleSum(int n, int target) {\n    // These are the unique pairs that sum up to target (k):\n    // (1, k - 1), (2, k - 2), ..., (ceil(k / 2), floor(k / 2)).\n    // Our optimal strategy is to select 1, 2, ..., floor(k / 2), and then\n    // choose k, k + 1, ... if necessary, as selecting any number in the range\n    // [ceil(k / 2), k - 1] will result in a pair summing up to k.\n    const int mid = target / 2;\n    if (n <= mid)\n      return trapezoid(1, n);\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) %\n           kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns sum(a..b).\n  long trapezoid(long a, long b) {\n    return (a + b) * (b - a + 1) / 2;\n  }\n};\n", "2835": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int target) {\n    constexpr int kNoMissingBit = 31;\n    constexpr int maxBit = 31;\n    int ans = 0;\n    int minMissingBit = kNoMissingBit;\n    // count[i] := the number of occurrences of 2^i\n    vector<int> count(maxBit + 1);\n\n    for (const int num : nums)\n      ++count[static_cast<int>(log2(num))];\n\n    for (int bit = 0; bit < maxBit; ++bit) {\n      // Check if `bit` is in the target.\n      if (target >> bit & 1) {\n        // If there are available bits, use one bit.\n        if (count[bit] > 0)\n          --count[bit];\n        else\n          minMissingBit = min(minMissingBit, bit);\n      }\n      // If we previously missed a bit and there are available bits.\n      if (minMissingBit != kNoMissingBit && count[bit] > 0) {\n        --count[bit];\n        // Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit;\n        minMissingBit = kNoMissingBit;\n      }\n      // Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] / 2;\n    }\n\n    // Check if all target bits have been covered, otherwise return -1.\n    return minMissingBit == kNoMissingBit ? ans : -1;\n  }\n};\n", "2836": "class Solution {\n public:\n  long long getMaxFunctionValue(vector<int>& receiver, long long k) {\n    const int n = receiver.size();\n    const int m = log2(k) + 1;\n    long ans = 0;\n    // jump[i][j] := the the node you reach after jumping 2^j steps from i\n    vector<vector<int>> jump(n, vector<int>(m));\n    // sum[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    vector<vector<long>> sum(n, vector<long>(m));\n\n    for (int i = 0; i < n; ++i) {\n      jump[i][0] = receiver[i];\n      sum[i][0] = receiver[i];\n    }\n\n    // Calculate binary lifting.\n    for (int j = 1; j < m; ++j)\n      for (int i = 0; i < n; ++i) {\n        const int midNode = jump[i][j - 1];\n        //   the the node you reach after jumping 2^j steps from i\n        // = the node you reach after jumping 2^(j - 1) steps from i\n        // + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1];\n        //   the sum of the first 2^j nodes you reach when jumping from i\n        // = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        // + the sum of another 2^(j - 1) nodes you reach\n        sum[i][j] = sum[i][j - 1] + sum[midNode][j - 1];\n      }\n\n    for (int i = 0; i < n; ++i) {\n      long currSum = i;\n      int currPos = i;\n      for (int j = 0; j < m; ++j)\n        if (k >> j & 1) {\n          currSum += sum[currPos][j];\n          currPos = jump[currPos][j];\n        }\n      ans = max(ans, currSum);\n    }\n\n    return ans;\n  }\n};\n", "2838": "class Solution {\n public:\n  vector<long long> maximumCoins(vector<int>& heroes, vector<int>& monsters,\n                                 vector<int>& coins) {\n    const vector<pair<int, int>> monsterAndCoins =\n        getSortedMonsterAndCoins(monsters, coins);\n    vector<long long> ans;\n    vector<long long> coinsPrefix{0};\n\n    for (const auto& [_, coin] : monsterAndCoins)\n      coinsPrefix.push_back(coinsPrefix.back() + coin);\n\n    for (const int hero : heroes)\n      ans.push_back(coinsPrefix[firstGreaterEqual(monsterAndCoins, hero)]);\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getSortedMonsterAndCoins(const vector<int>& monsters,\n                                                  const vector<int>& coins) {\n    vector<pair<int, int>> monsterAndCoins;\n    for (int i = 0; i < monsters.size(); ++i)\n      monsterAndCoins.emplace_back(monsters[i], coins[i]);\n    ranges::sort(monsterAndCoins);\n    return monsterAndCoins;\n  }\n\n  int firstGreaterEqual(const vector<pair<int, int>>& monsterAndCoins,\n                        int hero) {\n    int l = 0;\n    int r = monsterAndCoins.size();\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (monsterAndCoins[m].first > hero)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n};\n", "2839": "class Solution {\n public:\n  bool canBeEqual(string s1, string s2) {\n    for (const string& a : swappedStrings(s1))\n      for (const string& b : swappedStrings(s2))\n        if (a == b)\n          return true;\n    return false;\n  }\n\n private:\n  vector<string> swappedStrings(const string& s) {\n    vector<char> chars(s.begin(), s.end());\n    return {s, string({chars[2], chars[1], chars[0], chars[3]}),\n            string({chars[0], chars[3], chars[2], chars[1]}),\n            string({chars[2], chars[3], chars[0], chars[1]})};\n  }\n};\n", "284": "class PeekingIterator : public Iterator {\n public:\n  PeekingIterator(const vector<int>& nums) : Iterator(nums) {}\n\n  // Returns the next element in the iteration without advancing the iterator.\n  int peek() {\n    // Iterator(*this) makes a copy of current iterator, then call next on the\n    // Copied iterator to get the next value without affecting current iterator\n    return Iterator(*this).next();\n  }\n\n  // hasNext() and next() should behave the same as in the Iterator interface.\n  // Override them if needed.\n  int next() {\n    return Iterator::next();\n  }\n\n  bool hasNext() const {\n    return Iterator::hasNext();\n  }\n};\n", "2840": "class Solution {\n public:\n  bool checkStrings(string s1, string s2) {\n    vector<vector<int>> count(2, vector<int>(26));\n\n    for (int i = 0; i < s1.length(); ++i) {\n      ++count[i % 2][s1[i] - 'a'];\n      --count[i % 2][s2[i] - 'a'];\n    }\n\n    for (int i = 0; i < 26; ++i)\n      if (count[0][i] > 0 || count[1][i] > 0)\n        return false;\n\n    return true;\n  }\n};\n", "2841": "class Solution {\n public:\n  long long maxSum(vector<int>& nums, int m, int k) {\n    long ans = 0;\n    long sum = 0;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      sum += nums[i];\n      ++count[nums[i]];\n      if (i >= k) {\n        const int numToRemove = nums[i - k];\n        sum -= numToRemove;\n        if (--count[numToRemove] == 0)\n          count.erase(numToRemove);\n      }\n      if (count.size() >= m)\n        ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};\n", "2842": "class Solution {\n public:\n  int countKSubsequencesWithMaxBeauty(string s, int k) {\n    unordered_map<char, int> count;\n    for (const char c : s)\n      ++count[c];\n    if (count.size() < k)\n      return 0;\n\n    long ans = 1;\n\n    for (const auto& [fc, numOfChars] : getFreqCountPairs(count)) {\n      if (numOfChars >= k) {\n        ans *= nCk(numOfChars, k);\n        ans %= kMod;\n        return ans * modPow(fc, k) % kMod;\n      }\n      ans *= modPow(fc, numOfChars);\n      ans %= kMod;\n      k -= numOfChars;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  vector<pair<int, int>> getFreqCountPairs(\n      const unordered_map<char, int>& count) {\n    unordered_map<int, int> freqCount;\n    for (const auto& [_, value] : count)\n      ++freqCount[value];\n    vector<pair<int, int>> freqCountPairs;\n    for (const auto& [fc, numOfChars] : freqCount)\n      freqCountPairs.emplace_back(fc, numOfChars);\n    ranges::sort(freqCountPairs, ranges::greater{},\n                 [](const pair<int, int>& freqCountPair) {\n      return freqCountPair.first;\n    });\n    return freqCountPairs;\n  }\n\n  long nCk(int n, int k) {\n    long res = 1;\n    for (int i = 1; i <= k; ++i)\n      res = res * (n - i + 1) / i;\n    return res;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2843": "class Solution {\n public:\n  int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n\n    for (int num = low; num <= high; ++num)\n      if (isSymmetricInteger(num))\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  bool isSymmetricInteger(int num) {\n    if (num >= 10 && num <= 99)\n      return num / 10 == num % 10;\n    if (num >= 1000 && num <= 9999) {\n      const int left = num / 100;\n      const int right = num % 100;\n      return left / 10 + left % 10 == right / 10 + right % 10;\n    }\n    return false;\n  }\n};\n", "2844": "class Solution {\n public:\n  int minimumOperations(string num) {\n    const int n = num.length();\n    bool seenFive = false;\n    bool seenZero = false;\n\n    for (int i = n - 1; i >= 0; --i) {\n      if (seenZero && num[i] == '0')  // '00'\n        return n - i - 2;\n      if (seenZero && num[i] == '5')  // '50'\n        return n - i - 2;\n      if (seenFive && num[i] == '2')  // '25'\n        return n - i - 2;\n      if (seenFive && num[i] == '7')  // '75'\n        return n - i - 2;\n      seenZero = seenZero || num[i] == '0';\n      seenFive = seenFive || num[i] == '5';\n    }\n\n    return seenZero ? n - 1 : n;\n  }\n};\n", "2845": "class Solution {\n public:\n  long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {\n    long ans = 0;\n    int prefix = 0;  // (number of nums[i] % modulo == k so far) % modulo\n    unordered_map<int, int> prefixCount{{0, 1}};\n\n    for (const int num : nums) {\n      if (num % modulo == k)\n        prefix = (prefix + 1) % modulo;\n      ans += prefixCount[(prefix - k + modulo) % modulo];\n      ++prefixCount[prefix];\n    }\n\n    return ans;\n  }\n};\n", "2846": "class Solution {\n public:\n  vector<int> minOperationsQueries(int n, vector<vector<int>>& edges,\n                                   vector<vector<int>>& queries) {\n    constexpr int kMax = 26;\n    const int m = ceil(log2(n));\n    vector<int> ans;\n    vector<vector<pair<int, int>>> graph(n);\n    // jump[i][j] := the 2^j-th ancestor of i\n    vector<vector<int>> jump(n, vector<int>(m));\n    // depth[i] := the depth of i\n    vector<int> depth(n);\n    // count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    vector<vector<int>> count(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    count[0] = vector<int>(kMax + 1);\n    dfs(graph, 0, /*prev=*/-1, jump, depth, count);\n\n    for (int j = 1; j < m; ++j)\n      for (int i = 0; i < n; ++i)\n        jump[i][j] = jump[jump[i][j - 1]][j - 1];\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      const int lca = getLCA(u, v, jump, depth);\n      // the number of edges between (u, v).\n      const int numEdges = depth[u] + depth[v] - 2 * depth[lca];\n      // the maximum frequency of edges between (u, v)\n      int maxFreq = 0;\n      for (int j = 1; j <= kMax; ++j)\n        maxFreq = max(maxFreq, count[u][j] + count[v][j] - 2 * count[lca][j]);\n      ans.push_back(numEdges - maxFreq);\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev,\n           vector<vector<int>>& jump, vector<int>& depth,\n           vector<vector<int>>& count) {\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      jump[v][0] = u;\n      depth[v] = depth[u] + 1;\n      count[v] = count[u];\n      ++count[v][w];\n      dfs(graph, v, u, jump, depth, count);\n    }\n  }\n\n  // Returns the lca(u, v) by binary jump.\n  int getLCA(int u, int v, const vector<vector<int>>& jump,\n             const vector<int>& depth) {\n    // v is always deeper than u.\n    if (depth[u] > depth[v])\n      return getLCA(v, u, jump, depth);\n    // Jump v to the same height of u.\n    for (int j = 0; j < jump[0].size(); ++j)\n      if (depth[v] - depth[u] >> j & 1)\n        v = jump[v][j];\n    if (u == v)\n      return u;\n    // Jump u and v to the node right below the lca.\n    for (int j = jump[0].size() - 1; j >= 0; --j)\n      if (jump[u][j] != jump[v][j]) {\n        u = jump[u][j];\n        v = jump[v][j];\n      }\n    return jump[v][0];\n  }\n};\n", "2847": "class Solution {\n public:\n  string smallestNumber(long long n) {\n    if (n <= 9)\n      return to_string(n);\n\n    string ans;\n\n    for (int divisor = 9; divisor > 1; --divisor)\n      while (n % divisor == 0) {\n        ans += to_string(divisor);\n        n /= divisor;\n      }\n\n    return n > 1 ? \"-1\" : string{ans.rbegin(), ans.rend()};\n  }\n};\n", "2848": "class Solution {\n public:\n  int numberOfPoints(vector<vector<int>>& nums) {\n    constexpr int kMax = 100;\n    int ans = 0;\n    int runningSum = 0;\n    vector<int> count(kMax + 2);\n\n    for (const vector<int>& num : nums) {\n      const int start = num[0];\n      const int end = num[1];\n      ++count[start];\n      --count[end + 1];\n    }\n\n    for (int i = 1; i <= kMax; ++i) {\n      runningSum += count[i];\n      if (runningSum > 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "2849": "class Solution {\n public:\n  bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    const int minStep = max(abs(sx - fx), abs(sy - fy));\n    return minStep == 0 ? t != 1 : minStep <= t;\n  }\n};\n", "285": "class Solution {\n public:\n  TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val <= p->val)\n      return inorderSuccessor(root->right, p);\n\n    TreeNode* left = inorderSuccessor(root->left, p);\n    return left ? left : root;\n  }\n};\n", "2850": "class Solution {\n public:\n  int minimumMoves(vector<vector<int>>& grid) {\n    const int zeroCount = accumulate(grid.begin(), grid.end(), 0,\n                                     [](int acc, const vector<int>& row) {\n      return acc + ranges::count(row, 0);\n    });\n    if (zeroCount == 0)\n      return 0;\n\n    int ans = INT_MAX;\n\n    for (int i = 0; i < 3; ++i)\n      for (int j = 0; j < 3; ++j)\n        if (grid[i][j] == 0)\n          for (int x = 0; x < 3; ++x)\n            for (int y = 0; y < 3; ++y)\n              // Move a stone at (x, y) to (i, j).\n              if (grid[x][y] > 1) {\n                --grid[x][y];\n                ++grid[i][j];\n                ans = min(ans, abs(x - i) + abs(y - j) + minimumMoves(grid));\n                ++grid[x][y];\n                --grid[i][j];\n              }\n\n    return ans;\n  }\n};\n", "2851": "class Solution {\n public:\n  // This dynamic programming table dp[k][i] represents the number of ways to\n  // rearrange the string s after k steps such that it starts with s[i].\n  // A string can be rotated from 1 to n - 1 times. The transition rule is\n  // dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  // k = 3, the table looks like this:\n  //\n  // -----------------------------------------------------------\n  // |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  // -----------------------------------------------------------\n  // | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  // | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  // | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  // | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  // -----------------------------------------------------------\n  //\n  // By observation, we have\n  //   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  //   * dp[k][0] = dp[k][!0] + (-1)^k\n  int numberOfWays(string s, string t, long long k) {\n    const int n = s.length();\n    const int negOnePowK = (k % 2 == 0 ? 1 : -1);  // (-1)^k\n    const vector<int> z = zFunction(s + t + t);\n    const vector<int> indices = getIndices(z, n);\n    vector<int> dp(2);  // dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (modPow(n - 1, k) - negOnePowK + kMod) % kMod *\n            modPow(n, kMod - 2) % kMod;\n    dp[0] = (dp[1] + negOnePowK + kMod) % kMod;\n    return accumulate(indices.begin(), indices.end(), 0L,\n                      [&](long acc, int index) {\n      return (acc + dp[index == 0 ? 0 : 1]) % kMod;\n    });\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x, n - 1) % kMod;\n    return modPow(x * x % kMod, n / 2);\n  }\n\n  // Returns the z array, where z[i] is the length of the longest prefix of\n  // s[i..n) which is also a prefix of s.\n  //\n  // https://cp-algorithms.com/string/z-function.html#implementation\n  vector<int> zFunction(const string& s) {\n    const int n = s.length();\n    vector<int> z(n);\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l]);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n    return z;\n  }\n\n  // Returns the indices in `s` s.t. for each `i` in the returned indices,\n  // `s[i..n) + s[0..i) = t`.\n  vector<int> getIndices(const vector<int>& z, int n) {\n    vector<int> indices;\n    for (int i = n; i < n + n; ++i)\n      if (z[i] >= n)\n        indices.push_back(i - n);\n    return indices;\n  }\n};\n", "2852": "class Solution {\n public:\n  long long sumRemoteness(vector<vector<int>>& grid) {\n    const long sum = accumulate(grid.begin(), grid.end(), 0L,\n                                [](long acc, const vector<int>& row) {\n      return acc +\n             accumulate(row.begin(), row.end(), 0L,\n                        [](long acc, int num) { return acc + max(0, num); });\n    });\n\n    long ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] > 0) {\n          const auto [count, componentSum] = dfs(grid, i, j);\n          ans += (sum - componentSum) * count;\n        }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  // Returns the (count, componentSum) of the connected component that contains\n  // (x, y).\n  pair<int, long> dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return {0, 0};\n    if (grid[i][j] == -1)\n      return {0, 0};\n\n    int count = 1;\n    long componentSum = grid[i][j];\n    grid[i][j] = -1;  // Mark as visited.;\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      const auto [nextCount, nextComponentSum] = dfs(grid, x, y);\n      count += nextCount;\n      componentSum += nextComponentSum;\n    }\n\n    return {count, componentSum};\n  }\n};\n", "2855": "class Solution {\n public:\n  int minimumRightShifts(vector<int>& nums) {\n    int count = 0;\n    int pivot = -1;\n\n    for (int i = 0; i + 1 < nums.size(); i++)\n      if (nums[i] > nums[i + 1]) {\n        ++count;\n        pivot = i;\n      }\n\n    if (count == 0)\n      return 0;\n    if (count > 1 || nums.back() > nums.front())\n      return -1;\n    return nums.size() - 1 - pivot;\n  }\n};\n", "2856": "class Solution {\n public:\n  int minLengthAfterRemovals(vector<int>& nums) {\n    const int n = nums.size();\n    unordered_map<int, int> count;\n    int maxFreq = 0;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [_, freq] : count)\n      maxFreq = max(maxFreq, freq);\n\n    // The number with the maximum frequency cancel all the other numbers.\n    if (maxFreq <= n / 2)\n      return n % 2;\n    // The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq);\n  }\n};\n", "2857": "class Solution {\n public:\n  int countPairs(vector<vector<int>>& coordinates, int k) {\n    int ans = 0;\n\n    for (int x = 0; x <= k; ++x) {\n      const int y = k - x;\n      unordered_map<pair<int, int>, int, PairHash> count;\n      for (const vector<int>& point : coordinates) {\n        const int xi = point[0];\n        const int yi = point[1];\n        if (const auto it = count.find({xi ^ x, yi ^ y}); it != count.cend())\n          ans += it->second;\n        ++count[{xi, yi}];\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "2858": "class Solution {\n public:\n  vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {\n    vector<int> ans(n);\n    vector<vector<pair<int, bool>>> graph(n);\n    vector<bool> seen(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, /*isForward=*/true);\n      graph[v].emplace_back(u, /*isForward=*/false);\n    }\n\n    vector<int> mem(n, -1);\n    ans[0] = minEdgeReversals(graph, 0, seen, mem);\n    seen = vector<bool>(n);\n    dfs(graph, 0, seen, ans);\n    return ans;\n  }\n\n private:\n  // Returns the minimum number of edge reversals so node u can reach every\n  // node in its subtree.\n  int minEdgeReversals(const vector<vector<pair<int, bool>>>& graph, int u,\n                       vector<bool>& seen, vector<int>& mem) {\n    if (mem[u] != -1)\n      return mem[u];\n    int res = 0;\n    seen[u] = true;\n    for (const auto& [v, isForward] : graph[u]) {\n      if (seen[v])\n        continue;\n      seen[v] = true;\n      res += minEdgeReversals(graph, v, seen, mem) + (isForward ? 0 : 1);\n    }\n    return mem[u] = res;\n  }\n\n  void dfs(const vector<vector<pair<int, bool>>>& graph, int u,\n           vector<bool>& seen, vector<int>& ans) {\n    seen[u] = true;\n    for (const auto& [v, isForward] : graph[u]) {\n      if (seen[v])\n        continue;\n      seen[v] = true;\n      ans[v] = ans[u] + (isForward ? 1 : -1);\n      dfs(graph, v, seen, ans);\n    }\n  }\n};\n", "2859": "class Solution {\n public:\n  int sumIndicesWithKSetBits(vector<int>& nums, int k) {\n    int ans = 0;\n    for (unsigned i = 0; i < nums.size(); ++i)\n      if (popcount(i) == k)\n        ans += nums[i];\n    return ans;\n  }\n};\n", "286": "class Solution {\n public:\n  void wallsAndGates(vector<vector<int>>& rooms) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = rooms.size();\n    const int n = rooms[0].size();\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (rooms[i][j] == 0)\n          q.emplace(i, j);\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (rooms[x][y] != INT_MAX)\n          continue;\n        rooms[x][y] = rooms[i][j] + 1;\n        q.emplace(x, y);\n      }\n    }\n  }\n};\n", "2860": "class Solution {\n public:\n  int countWays(vector<int>& nums) {\n    nums.push_back(-1);\n    nums.push_back(INT_MAX);\n    ranges::sort(nums);\n\n    int ans = 0;\n\n    // i := the number of the selected numbers\n    for (int i = 0; i + 1 < nums.size(); ++i)\n      if (nums[i] < i && i < nums[i + 1])\n        ++ans;\n\n    return ans;\n  }\n};\n", "2861": "class Solution {\n public:\n  int maxNumberOfAlloys(int n, int k, int budget,\n                        vector<vector<int>>& composition, vector<int>& stock,\n                        vector<int>& cost) {\n    int l = 1;\n    int r = 1'000'000'000;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (isPossible(n, budget, composition, stock, cost, m))\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l - 1;\n  }\n\n private:\n  // Returns true if it's possible to create `m` alloys by using any machine.\n  bool isPossible(int n, int budget, const vector<vector<int>>& composition,\n                  const vector<int>& stock, const vector<int>& costs, int m) {\n    // Try all the possible machines.\n    for (const vector<int>& machine : composition) {\n      long requiredMoney = 0;\n      for (int j = 0; j < n; ++j) {\n        const long requiredUnits =\n            max(0L, static_cast<long>(machine[j]) * m - stock[j]);\n        requiredMoney += static_cast<long>(requiredUnits) * costs[j];\n      }\n      if (requiredMoney <= budget)\n        return true;\n    }\n    return false;\n  }\n};\n", "2862": "class Solution {\n public:\n  long long maximumSum(vector<int>& nums) {\n    long ans = 0;\n\n    for (int oddPower = 1; oddPower <= nums.size(); ++oddPower) {\n      long sum = 0;\n      for (int num = 1; num * num * oddPower <= nums.size(); ++num)\n        sum += nums[oddPower * num * num - 1];\n      ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};\n", "2863": "class Solution {\n public:\n  int maxSubarrayLength(vector<int>& nums) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = nums.size() - 1; i >= 0; --i)\n      // If nums[stack.top()] <= nums[i], stack.top() is better than i.\n      // So, no need to push it.\n      if (stack.empty() || nums[stack.top()] > nums[i])\n        stack.push(i);\n\n    for (int i = 0; i < nums.size(); ++i)\n      while (!stack.empty() && num > nums[stack.top()])\n        ans = max(ans, stack.top() - i + 1), stack.pop();\n\n    return ans;\n  }\n};\n", "2864": "class Solution {\n public:\n  string maximumOddBinaryNumber(string s) {\n    const int zeros = ranges::count(s, '0');\n    const int ones = s.length() - zeros;\n    return string(ones - 1, '1') + string(zeros, '0') + '1';\n  }\n};\n", "2865": "class Solution {\n public:\n  long long maximumSumOfHeights(vector<int>& heights) {\n    const int n = heights.size();\n    vector<long> maxSum(n);  // maxSum[i] := the maximum sum with peak i\n\n    stack<int> stack{{-1}};\n    long sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n      sum = process(stack, heights, i, sum);\n      maxSum[i] = sum;\n    }\n\n    stack = std::stack<int>{{n}};\n    sum = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n      sum = process(stack, heights, i, sum);\n      maxSum[i] += sum - heights[i];\n    }\n\n    return ranges::max(maxSum);\n  }\n\n private:\n  long process(stack<int>& stack, const vector<int>& heights, int i, long sum) {\n    while (stack.size() > 1 && heights[stack.top()] > heights[i]) {\n      const int j = stack.top();\n      stack.pop();\n      // The last abs(j - stack.top()) heights are `heights[j]`.\n      sum -= static_cast<long>(abs(j - stack.top())) * heights[j];\n    }\n    // Put abs(i - stack.top()) * heights[i] in `heights`.\n    sum += static_cast<long>(abs(i - stack.top())) * heights[i];\n    stack.push(i);\n    return sum;\n  }\n};\n", "2866": "class Solution {\n public:\n  // Same as 2865. Beautiful Towers I\n  long long maximumSumOfHeights(vector<int>& maxHeights) {\n    const int n = maxHeights.size();\n    vector<long> maxSum(n);  // maxSum[i] := the maximum sum with peak i\n\n    stack<int> stack{{-1}};\n    long sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n      sum = process(stack, maxHeights, i, sum);\n      maxSum[i] = sum;\n    }\n\n    stack = std::stack<int>{{n}};\n    sum = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n      sum = process(stack, maxHeights, i, sum);\n      maxSum[i] += sum - maxHeights[i];\n    }\n\n    return ranges::max(maxSum);\n  }\n\n private:\n  long process(stack<int>& stack, const vector<int>& maxHeights, int i,\n               long sum) {\n    while (stack.size() > 1 && maxHeights[stack.top()] > maxHeights[i]) {\n      const int j = stack.top();\n      stack.pop();\n      // The last abs(j - stack.top()) maxHeights are `maxHeights[j]`.\n      sum -= static_cast<long>(abs(j - stack.top())) * maxHeights[j];\n    }\n    // Put abs(i - stack.top()) * maxHeights[i] in `maxHeights`.\n    sum += static_cast<long>(abs(i - stack.top())) * maxHeights[i];\n    stack.push(i);\n    return sum;\n  }\n};\n", "2867": "class Solution {\n public:\n  long long countPaths(int n, vector<vector<int>>& edges) {\n    long ans = 0;\n    const vector<bool> isPrime = sieveEratosthenes(n + 1);\n    vector<vector<int>> graph(n + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    dfs(graph, 1, /*prev=*/-1, isPrime, ans);\n    return ans;\n  }\n\n private:\n  pair<long, long> dfs(const vector<vector<int>>& graph, int u, int prev,\n                       const vector<bool>& isPrime, long& ans) {\n    long countZeroPrimePath = !isPrime[u];\n    long countOnePrimePath = isPrime[u];\n\n    for (const int v : graph[u]) {\n      if (v == prev)\n        continue;\n      const auto& [countZeroPrimeChildPath, countOnePrimeChildPath] =\n          dfs(graph, v, u, isPrime, ans);\n      ans += countZeroPrimePath * countOnePrimeChildPath +\n             countOnePrimePath * countZeroPrimeChildPath;\n      if (isPrime[u]) {\n        countOnePrimePath += countZeroPrimeChildPath;\n      } else {\n        countZeroPrimePath += countZeroPrimeChildPath;\n        countOnePrimePath += countOnePrimeChildPath;\n      }\n    }\n\n    return {countZeroPrimePath, countOnePrimePath};\n  }\n\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "2868": "class Solution {\n public:\n  bool canAliceWin(vector<string>& a, vector<string>& b) {\n    // words[0][i] := the biggest word starting with ('a' + i) for Alice\n    // words[1][i] := the biggest word starting with ('a' + i) for Bob\n    vector<vector<string>> words(2, vector<string>(26));\n\n    // For each letter, only the biggest word is useful.\n    for (const string& word : a)\n      words[0][word[0] - 'a'] = word;\n\n    for (const string& word : b)\n      words[1][word[0] - 'a'] = word;\n\n    // Find Alice's smallest word.\n    int i = 0;\n    while (words[0][i].empty())\n      ++i;\n\n    // Iterate through each letter until we find a winner.\n    // Start with Alice's turn (0), so it's Bob's turn (1) now.\n    for (int turn = 1; true; turn = turn ^ 1)\n      // If the current player has a word that having the letter that is greater\n      // than the opponent's word, choose it.\n      if (!words[turn][i].empty() && words[turn][i] > words[turn ^ 1][i]) {\n        // Choose the current words[turn][i].\n      } else if (!words[turn][i + 1].empty()) {\n        // Choose the next words[turn][i + 1].\n        ++i;\n      } else {\n        // Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1;\n      }\n  }\n};\n", "2869": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int k) {\n    unordered_set<int> seen;\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      if (nums[i] > k)\n        continue;\n      seen.insert(nums[i]);\n      if (seen.size() == k)\n        return nums.size() - i;\n    }\n\n    throw;\n  }\n};\n", "287": "class Solution {\n public:\n  int findDuplicate(vector<int>& nums) {\n    int slow = nums[nums[0]];\n    int fast = nums[nums[nums[0]]];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[nums[fast]];\n    }\n\n    slow = nums[0];\n\n    while (slow != fast) {\n      slow = nums[slow];\n      fast = nums[fast];\n    }\n\n    return slow;\n  }\n};\n", "2870": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [_, freq] : count) {\n      // If freq == 3k, need k operations.\n      // If freq == 3k + 1 = 3*(k - 1) + 2*2, need k + 1 operations.\n      // If freq == 3k + 2, need k + 1 operations.\n      if (freq == 1)\n        return -1;\n      ans += (freq + 2) / 3;\n    }\n\n    return ans;\n  }\n};\n", "2871": "class Solution {\n public:\n  int maxSubarrays(vector<int>& nums) {\n    int ans = 0;\n    int score = 0;\n\n    for (const int num : nums) {\n      score = score == 0 ? num : score & num;\n      if (score == 0)\n        ++ans;\n    }\n\n    return max(1, ans);\n  }\n};\n", "2872": "class Solution {\n public:\n  int maxKDivisibleComponents(int n, vector<vector<int>>& edges,\n                              vector<int>& values, int k) {\n    int ans = 0;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    dfs(graph, 0, /*prev=*/-1, values, k, ans);\n    return ans;\n  }\n\n private:\n  long dfs(const vector<vector<int>>& graph, int u, int prev,\n           const vector<int>& values, int k, int& ans) {\n    long treeSum = values[u];\n\n    for (const int v : graph[u])\n      if (v != prev)\n        treeSum += dfs(graph, v, u, values, k, ans);\n\n    if (treeSum % k == 0)\n      ++ans;\n    return treeSum;\n  }\n};\n", "2873": "class Solution {\n public:\n  long long maximumTripletValue(vector<int>& nums) {\n    long ans = 0;\n    int maxDiff = 0;  // max(nums[i] - nums[j])\n    int maxNum = 0;   // max(nums[i])\n\n    for (const int num : nums) {\n      ans = max(ans, static_cast<long>(maxDiff) * num);  // num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num);              // num := nums[j]\n      maxNum = max(maxNum, num);                         // num := nums[i]\n    }\n\n    return ans;\n  }\n};\n", "2874": "class Solution {\n public:\n  // Same as 2873. Maximum Value of an Ordered Triplet I\n  long long maximumTripletValue(vector<int>& nums) {\n    long ans = 0;\n    int maxDiff = 0;  // max(nums[i] - nums[j])\n    int maxNum = 0;   // max(nums[i])\n\n    for (const int num : nums) {\n      ans = max(ans, static_cast<long>(maxDiff) * num);  // num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num);              // num := nums[j]\n      maxNum = max(maxNum, num);                         // num := nums[i]\n    }\n\n    return ans;\n  }\n};\n", "2875": "class Solution {\n public:\n  int minSizeSubarray(vector<int>& nums, int target) {\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    const int n = nums.size();\n    const int remainingTarget = target % sum;\n    const int repeatLength = (target / sum) * n;\n    if (remainingTarget == 0)\n      return repeatLength;\n\n    int suffixPlusPrefixLength = n;\n    long prefix = 0;\n    unordered_map<long, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < 2 * n; ++i) {\n      prefix += nums[i % n];\n      if (const auto it = prefixToIndex.find(prefix - remainingTarget);\n          it != prefixToIndex.cend())\n        suffixPlusPrefixLength = min(suffixPlusPrefixLength, i - it->second);\n      prefixToIndex[prefix] = i;\n    }\n\n    return suffixPlusPrefixLength == n ? -1\n                                       : suffixPlusPrefixLength + repeatLength;\n  }\n};\n", "2876": "class Solution {\n public:\n  vector<int> countVisitedNodes(vector<int>& edges) {\n    const int n = edges.size();\n    vector<int> ans(n);\n    vector<int> inDegrees(n);\n    vector<bool> seen(n);\n    queue<int> q;\n    stack<int> stack;\n\n    for (const int v : edges)\n      ++inDegrees[v];\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    // Push non-cyclic nodes to stack.\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      if (--inDegrees[edges[u]] == 0)\n        q.push(edges[u]);\n      stack.push(u);\n      seen[u] = true;\n    }\n\n    // Fill the length of cyclic nodes.\n    for (int i = 0; i < n; ++i)\n      if (!seen[i])\n        fillCycle(edges, i, seen, ans);\n\n    // Fill the length of non-cyclic nodes.\n    while (!stack.empty()) {\n      const int u = stack.top();\n      stack.pop();\n      ans[u] = ans[edges[u]] + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  void fillCycle(const vector<int>& edges, int start, vector<bool>& seen,\n                 vector<int>& ans) {\n    int cycleLength = 0;\n    for (int u = start; !seen[u]; u = edges[u]) {\n      ++cycleLength;\n      seen[u] = true;\n    }\n    ans[start] = cycleLength;\n    for (int u = edges[start]; u != start; u = edges[u])\n      ans[u] = cycleLength;\n  }\n};\n", "288": "class ValidWordAbbr {\n public:\n  ValidWordAbbr(vector<string>& dictionary) {\n    dict = unordered_set(dictionary.begin(), dictionary.end());\n\n    for (const string& word : dict) {\n      const string& abbr = getAbbr(word);\n      abbrUnique[abbr] = !abbrUnique.contains(abbr);\n    }\n  }\n\n  bool isUnique(string word) {\n    const string& abbr = getAbbr(word);\n    return !abbrUnique.contains(abbr) ||\n           abbrUnique[abbr] && dict.contains(word);\n  }\n\n private:\n  unordered_set<string> dict;\n  unordered_map<string, bool> abbrUnique;  // T := unique, F := not unique\n\n  string getAbbr(const string& s) {\n    const int n = s.length();\n    if (n <= 2)\n      return s;\n    return s[0] + to_string(n - 2) + s.back();\n  }\n};\n", "289": "class Solution {\n public:\n  void gameOfLife(vector<vector<int>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        int ones = 0;\n        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)\n          for (int y = max(0, j - 1); y < min(n, j + 2); ++y)\n            ones += board[x][y] & 1;\n        // Any live cell with two or three live neighbors lives on to the next\n        // generation.\n        if (board[i][j] == 1 && (ones == 3 || ones == 4))\n          board[i][j] |= 0b10;\n        // Any dead cell with exactly three live neighbors becomes a live cell,\n        // as if by reproduction.\n        if (board[i][j] == 0 && ones == 3)\n          board[i][j] |= 0b10;\n      }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        board[i][j] >>= 1;\n  }\n};\n", "2892": "class Solution {\n public:\n  int minArrayLength(vector<int>& nums, int k) {\n    int count = 0;\n    long prod = -1;\n\n    for (const int num : nums) {\n      if (num == 0)\n        return 1;\n      if (prod != -1 && prod * num <= k) {\n        prod *= num;\n      } else {\n        prod = num;\n        ++count;\n      }\n    }\n\n    return count;\n  }\n};\n", "2894": "class Solution {\n public:\n  int differenceOfSums(int n, int m) {\n    const int sum = (1 + n) * n / 2;\n    const int num2 = getDivisibleSum(n, m);\n    const int num1 = sum - num2;\n    return num1 - num2;\n  }\n\n private:\n  // Returns the sum of all the integers in [1, n] that are divisible by m.\n  int getDivisibleSum(int n, int m) {\n    const int last = n / m * m;\n    if (last == 0)\n      return 0;\n    const int first = m;\n    const int count = (last - first) / m + 1;\n    return (first + last) * count / 2;\n  }\n};\n", "2895": "class Solution {\n public:\n  int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {\n    int ans = 0;\n    ranges::sort(processorTime);\n    ranges::sort(tasks, greater<>());\n\n    // It's optimal to run each 4 longer tasks with a smaller processor time.\n    // Therefore, for each processor, take the maximum of the sum of the\n    // processor time and the largest assigned tasks[i].\n    for (int i = 0; i < processorTime.size(); ++i)\n      ans = max(ans, processorTime[i] + tasks[i * 4]);\n\n    return ans;\n  }\n};\n", "2896": "class Solution {\n public:\n  int minOperations(string s1, string s2, int x) {\n    const vector<int> diffIndices = getDiffIndices(s1, s2);\n    if (diffIndices.empty())\n      return 0;\n    // It's impossible to make two strings equal if there are an odd number of\n    // differences.\n    if (diffIndices.size() % 2 == 1)\n      return -1;\n\n    vector<double> dp(diffIndices.size() + 1, DBL_MAX);\n    dp.back() = 0;\n    dp[diffIndices.size() - 1] = x / 2.0;\n\n    for (int i = diffIndices.size() - 2; i >= 0; --i)\n      dp[i] = min(dp[i + 1] + x / 2.0,\n                  dp[i + 2] + diffIndices[i + 1] - diffIndices[i]);\n\n    return dp[0];\n  }\n\n private:\n  vector<int> getDiffIndices(const string& s1, const string& s2) {\n    vector<int> diffIndices;\n    for (int i = 0; i < s1.length(); ++i)\n      if (s1[i] != s2[i])\n        diffIndices.push_back(i);\n    return diffIndices;\n  }\n};\n", "2897": "class Solution {\n public:\n  int maxSum(vector<int>& nums, int k) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMaxBit = 30;\n    int ans = 0;\n    // minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    // should be moved to\n    vector<int> minIndices(kMaxBit);\n    vector<int> optimalNums(nums.size());\n\n    for (const int num : nums)\n      for (int i = 0; i < kMaxBit; ++i)\n        if (num >> i & 1)\n          optimalNums[minIndices[i]++] |= 1 << i;\n\n    for (int i = 0; i < k; ++i)\n      ans = (ans + static_cast<long>(optimalNums[i]) * optimalNums[i]) % kMod;\n\n    return ans;\n  }\n};\n", "2898": "class Solution {\n public:\n  long long maxScore(vector<int>& prices) {\n    //    prices[indices[j]] - prices[indices[j - 1]]\n    // == indices[j] - indices[j - 1]\n    //    prices[indices[j]] - indices[j]\n    // == prices[indices[j - 1]] - indices[j - 1]\n    //\n    // So, elements in the same subsequence must have the same prices[i] - i.\n    unordered_map<int, long> groupIdToSum;\n\n    for (int i = 0; i < prices.size(); ++i)\n      groupIdToSum[prices[i] - i] += prices[i];\n\n    return ranges::max_element(groupIdToSum,\n                               [](const std::pair<int, long>& p1,\n                                  const std::pair<int, long>& p2) {\n      return p1.second < p2.second;\n    })->second;\n  }\n};\n", "2899": "class Solution {\n public:\n  vector<int> lastVisitedIntegers(vector<string>& words) {\n    vector<int> ans;\n    vector<int> nums;\n    int k = 0;\n\n    for (const string& word : words)\n      if (word == \"prev\") {\n        ++k;\n        ans.push_back(k > nums.size() ? -1 : nums[nums.size() - k]);\n      } else {\n        k = 0;\n        nums.push_back(stoi(word));\n      }\n\n    return ans;\n  }\n};\n", "29": "class Solution {\n public:\n  int divide(int dividend, int divisor) {\n    // -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.\n    if (dividend == INT_MIN && divisor == -1)\n      return INT_MAX;\n\n    const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n    long ans = 0;\n    long dvd = labs(dividend);\n    long dvs = labs(divisor);\n\n    while (dvd >= dvs) {\n      long k = 1;\n      while (k * 2 * dvs <= dvd)\n        k *= 2;\n      dvd -= k * dvs;\n      ans += k;\n    }\n\n    return sign * ans;\n  }\n};\n", "290": "class Solution {\n public:\n  bool wordPattern(string pattern, string str) {\n    const int n = pattern.length();\n    istringstream iss(str);\n    vector<int> charToIndex(128);\n    unordered_map<string, int> stringToIndex;\n\n    int i = 0;\n    for (string word; iss >> word; ++i) {\n      if (i == n)  // out-of-bounds\n        return false;\n      if (charToIndex[pattern[i]] != stringToIndex[word])\n        return false;\n      charToIndex[pattern[i]] = i + 1;\n      stringToIndex[word] = i + 1;\n    }\n\n    return i == n;\n  }\n};\n", "2900": "class Solution {\n public:\n  vector<string> getWordsInLongestSubsequence(int n, vector<string>& words,\n                                              vector<int>& groups) {\n    vector<string> ans;\n    int groupId = -1;\n\n    for (int i = 0; i < n; ++i)\n      if (groups[i] != groupId) {\n        groupId = groups[i];\n        ans.push_back(words[i]);\n      }\n\n    return ans;\n  }\n};\n", "2901": "class Solution {\n public:\n  vector<string> getWordsInLongestSubsequence(int n, vector<string>& words,\n                                              vector<int>& groups) {\n    vector<string> ans;\n    // dp[i] := the length of the longest subsequence ending in `words[i]`\n    vector<int> dp(n, 1);\n    // prev[i] := the best index of words[i]\n    vector<int> prev(n, -1);\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        if (groups[i] == groups[j])\n          continue;\n        if (words[i].length() != words[j].length())\n          continue;\n        if (hammingDist(words[i], words[j]) != 1)\n          continue;\n        if (dp[i] < dp[j] + 1) {\n          dp[i] = dp[j] + 1;\n          prev[i] = j;\n        }\n      }\n\n    // Find the last index of the subsequence.\n    int index = ranges::max_element(dp) - dp.begin();\n    while (index != -1) {\n      ans.push_back(words[index]);\n      index = prev[index];\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n\n private:\n  int hammingDist(const string& s1, const string& s2) {\n    int dist = 0;\n    for (int i = 0; i < s1.length(); ++i)\n      if (s1[i] != s2[i])\n        ++dist;\n    return dist;\n  }\n};\n", "2902": "class Solution {\n public:\n  int countSubMultisets(vector<int>& nums, int l, int r) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i] := the number of submultisets of `nums` with sum i\n    vector<long> dp(r + 1);\n    dp[0] = 1;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    const int zeros = count[0];\n    count.erase(0);\n\n    for (const auto& [num, freq] : count) {\n      // stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      vector<long> stride = dp;\n      for (int i = num; i <= r; ++i)\n        stride[i] += stride[i - num];\n      for (int i = r; i > 0; --i)\n        if (i >= num * (freq + 1))\n          // dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = (stride[i] - stride[i - num * (freq + 1)]) % kMod;\n        else\n          dp[i] = stride[i] % kMod;\n    }\n\n    long ans = 0;\n    for (int i = l; i <= r; ++i)\n      ans = (ans + dp[i]) % kMod;\n    return ((zeros + 1) * ans) % kMod;\n  }\n};\n", "2903": "class Solution {\n public:\n  vector<int> findIndices(vector<int>& nums, int indexDifference,\n                          int valueDifference) {\n    // nums[minIndex] := the minimum number with enough index different from the\n    // current number\n    int minIndex = 0;\n    // nums[maxIndex] := the maximum number with enough index different from the\n    // current number\n    int maxIndex = 0;\n\n    for (int i = indexDifference; i < nums.size(); ++i) {\n      if (nums[i - indexDifference] < nums[minIndex])\n        minIndex = i - indexDifference;\n      if (nums[i - indexDifference] > nums[maxIndex])\n        maxIndex = i - indexDifference;\n      if (nums[i] - nums[minIndex] >= valueDifference)\n        return {i, minIndex};\n      if (nums[maxIndex] - nums[i] >= valueDifference)\n        return {i, maxIndex};\n    }\n\n    return {-1, -1};\n  }\n};\n", "2904": "class Solution {\n public:\n  // Same as 76. Minimum Window Substring\n  string shortestBeautifulSubstring(string s, int k) {\n    int bestLeft = -1;\n    int minLength = s.length() + 1;\n    int ones = 0;\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (s[r] == '1')\n        ++ones;\n      while (ones == k) {\n        if (r - l + 1 < minLength) {\n          bestLeft = l;\n          minLength = r - l + 1;\n        } else if (r - l + 1 == minLength &&\n                   s.compare(l, minLength, s, bestLeft, minLength) < 0) {\n          bestLeft = l;\n        }\n        if (s[l++] == '1')\n          --ones;\n      }\n    }\n\n    return bestLeft == -1 ? \"\" : s.substr(bestLeft, minLength);\n  }\n};\n", "2905": "class Solution {\n public:\n  vector<int> findIndices(vector<int>& nums, int indexDifference,\n                          int valueDifference) {\n    // nums[minIndex] := the minimum number with enough index different from the\n    // current number\n    int minIndex = 0;\n    // nums[maxIndex] := the maximum number with enough index different from the\n    // current number\n    int maxIndex = 0;\n\n    for (int i = indexDifference; i < nums.size(); ++i) {\n      if (nums[i - indexDifference] < nums[minIndex])\n        minIndex = i - indexDifference;\n      if (nums[i - indexDifference] > nums[maxIndex])\n        maxIndex = i - indexDifference;\n      if (nums[i] - nums[minIndex] >= valueDifference)\n        return {i, minIndex};\n      if (nums[maxIndex] - nums[i] >= valueDifference)\n        return {i, maxIndex};\n    }\n\n    return {-1, -1};\n  }\n};\n", "2906": "class Solution {\n public:\n  vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {\n    constexpr int kMod = 12345;\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n    vector<int> prefix{1};\n    int suffix = 1;\n\n    for (const vector<int>& row : grid)\n      for (const int num : row)\n        prefix.push_back(static_cast<long>(prefix.back()) * num % kMod);\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j) {\n        ans[i][j] = prefix[i * n + j] * suffix % kMod;\n        suffix = static_cast<long>(suffix) * grid[i][j] % kMod;\n      }\n\n    return ans;\n  }\n};\n", "2907": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  void maximize(int i, int val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<int> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int maxProfit(vector<int>& prices, vector<int>& profits) {\n    const int maxPrice = ranges::max(prices);\n    int ans = -1;\n    FenwickTree maxProfitTree1(maxPrice);\n    FenwickTree maxProfitTree2(maxPrice);\n\n    for (int i = 0; i < prices.size(); ++i) {\n      const int price = prices[i];\n      const int profit = profits[i];\n      // max(proftis[i])\n      const int maxProfit1 = maxProfitTree1.get(price - 1);\n      // max(proftis[i]) + max(profits[j])\n      const int maxProfit2 = maxProfitTree2.get(price - 1);\n      maxProfitTree1.maximize(price, profit);\n      if (maxProfit1 > 0)\n        maxProfitTree2.maximize(price, profit + maxProfit1);\n      if (maxProfit2 > 0)\n        ans = max(ans, profit + maxProfit2);\n    }\n\n    return ans;\n  }\n};\n", "2908": "class Solution {\n public:\n  int minimumSum(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = INT_MAX;\n    vector<int> minPrefix(n);\n    vector<int> minSuffix(n);\n\n    partial_sum(nums.begin(), nums.end(), minPrefix.begin(),\n                [](int x, int y) { return min(x, y); });\n    partial_sum(nums.rbegin(), nums.rend(), minSuffix.begin(),\n                [](int x, int y) { return min(x, y); });\n    ranges::reverse(minSuffix);\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] > minPrefix[i] && nums[i] > minSuffix[i])\n        ans = min(ans, nums[i] + minPrefix[i] + minSuffix[i]);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "2909": "class Solution {\n public:\n  // Same as 2908. Minimum Sum of Mountain Triplets I\n  int minimumSum(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = INT_MAX;\n    vector<int> minPrefix(n);\n    vector<int> minSuffix(n);\n\n    partial_sum(nums.begin(), nums.end(), minPrefix.begin(),\n                [](int x, int y) { return min(x, y); });\n    partial_sum(nums.rbegin(), nums.rend(), minSuffix.begin(),\n                [](int x, int y) { return min(x, y); });\n    ranges::reverse(minSuffix);\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] > minPrefix[i] && nums[i] > minSuffix[i])\n        ans = min(ans, nums[i] + minPrefix[i] + minSuffix[i]);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "291": "class Solution {\n public:\n  bool wordPatternMatch(string pattern, string s) {\n    return isMatch(pattern, 0, s, 0, unordered_map<char, string>(),\n                   unordered_set<string>());\n  }\n\n private:\n  bool isMatch(const string& pattern, int i, const string& s, int j,\n               unordered_map<char, string>&& charToString,\n               unordered_set<string>&& seen) {\n    if (i == pattern.length() && j == s.length())\n      return true;\n    if (i == pattern.length() || j == s.length())\n      return false;\n\n    const char c = pattern[i];\n\n    if (const auto it = charToString.find(c); it != charToString.cend()) {\n      const string& t = it->second;\n      // See if we can match t with s[j..n).\n      if (s.substr(j).find(t) == string::npos)\n        return false;\n\n      // If there's a match, continue to match the rest.\n      return isMatch(pattern, i + 1, s, j + t.length(), std::move(charToString),\n                     std::move(seen));\n    }\n\n    for (int k = j; k < s.length(); ++k) {\n      const string& t = s.substr(j, k - j + 1);\n\n      // This string is mapped by another character.\n      if (seen.contains(t))\n        continue;\n\n      charToString[c] = t;\n      seen.insert(t);\n\n      if (isMatch(pattern, i + 1, s, k + 1, std::move(charToString),\n                  std::move(seen)))\n        return true;\n\n      // Backtrack.\n      charToString.erase(c);\n      seen.erase(t);\n    }\n\n    return false;\n  }\n};\n", "2910": "class Solution {\n public:\n  int minGroupsForValidAssignment(vector<int>& nums) {\n    unordered_map<int, int> count;\n    int minFreq = nums.size();\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [_, freq] : count)\n      minFreq = min(minFreq, freq);\n\n    for (int groupSize = minFreq; groupSize >= 1; --groupSize) {\n      const int numGroups = getNumGroups(count, groupSize);\n      if (numGroups > 0)\n        return numGroups;\n    }\n\n    throw;\n  }\n\n private:\n  // Returns the number of groups if each group's size is `groupSize` or\n  // `groupSize + 1`.\n  int getNumGroups(unordered_map<int, int>& count, int groupSize) {\n    int numGroups = 0;\n    for (const auto& [_, freq] : count) {\n      const int a = freq / (groupSize + 1);\n      const int b = freq % (groupSize + 1);\n      if (b == 0) {\n        numGroups += a;\n      } else if (groupSize - b <= a) {\n        // Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        // so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        // and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        // `a + 1` groups.\n        numGroups += a + 1;\n      } else {\n        return 0;\n      }\n    }\n    return numGroups;\n  }\n};\n", "2911": "class Solution {\n public:\n  int minimumChanges(string s, int k) {\n    const int n = s.length();\n    // factors[i] := factors of i\n    const vector<vector<int>> factors = getFactors(n);\n    // cost[i][j] := changes to make s[i..j] a semi-palindrome\n    const vector<vector<int>> cost = getCost(s, n, factors);\n    // dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, n));\n\n    dp[n][0] = 0;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = 1; j <= k; ++j)\n        for (int l = i + 1; l < n; ++l)\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l]);\n\n    return dp[0][k];\n  }\n\n private:\n  vector<vector<int>> getFactors(int n) {\n    vector<vector<int>> factors(n + 1);\n    for (int i = 1; i <= n; ++i)\n      factors[i].push_back(1);\n    for (int d = 2; d < n; ++d)\n      for (int i = d * 2; i <= n; i += d)\n        factors[i].push_back(d);\n    return factors;\n  }\n\n  vector<vector<int>> getCost(const string& s, int n,\n                              const vector<vector<int>>& factors) {\n    vector<vector<int>> cost(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        const int length = j - i + 1;\n        int minCost = length;\n        for (const int d : factors[length])\n          minCost = min(minCost, getCost(s, i, j, d));\n        cost[i][j] = minCost;\n      }\n    return cost;\n  }\n\n  // Returns the cost to make s[i..j] a semi-palindrome of `d`.\n  int getCost(const string& s, int i, int j, int d) {\n    int cost = 0;\n    for (int offset = 0; offset < d; ++offset) {\n      int l = i + offset;\n      int r = j - d + 1 + offset;\n      while (l < r) {\n        if (s[l] != s[r])\n          ++cost;\n        l += d;\n        r -= d;\n      }\n    }\n    return cost;\n  }\n};\n", "2912": "class Solution {\n public:\n  int numberOfWays(int n, int m, int k, vector<int>& source,\n                   vector<int>& dest) {\n    constexpr int kMod = 1'000'000'007;\n    // the number of ways of `source` to `dest` using steps so far\n    int ans = source[0] == dest[0] && source[1] == dest[1];\n    // the number of ways of `source` to dest's row using steps so far\n    int row = source[0] == dest[0] && source[1] != dest[1];\n    // the number of ways of `source` to dest's col using steps so far\n    int col = source[0] != dest[0] && source[1] == dest[1];\n    // the number of ways of `source` to others using steps so far\n    int others = source[0] != dest[0] && source[1] != dest[1];\n\n    for (int i = 0; i < k; ++i) {\n      const int nextAns = (row + col) % kMod;\n      const int nextRow = static_cast<int>((ans * (m - 1L) +  // -self\n                                            row * (m - 2L) +  //-self, -center\n                                            others) %\n                                           kMod);\n      const int nextCol = static_cast<int>((ans * (n - 1L) +  // -self\n                                            col * (n - 2L) +  // -self, -center\n                                            others) %\n                                           kMod);\n      const int nextOthers =\n          static_cast<int>((row * (n - 1L) +              // -self\n                            col * (m - 1L) +              // -self\n                            others * (m + n - 1 - 3L)) %  // -self, -row, -col\n                           kMod);\n      ans = nextAns;\n      row = nextRow;\n      col = nextCol;\n      others = nextOthers;\n    }\n\n    return ans;\n  }\n};\n", "2913": "class LazySegmentTree {\n public:\n  LazySegmentTree(int n, int kMod)\n      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}\n\n  void updateRange(int l, int r) {\n    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);\n  }\n\n  void propagate(int i, int l, int r) {\n    const int gap = r - l + 1;\n    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]\n    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3\n    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;\n    squaredSums[i] %= kMod;\n    sums[i] += lazy[i] * gap;\n    sums[i] %= kMod;\n    if (l < r) {\n      lazy[i * 2 + 1] += lazy[i];\n      lazy[i * 2 + 2] += lazy[i];\n    }\n    lazy[i] = 0;\n  }\n\n  int getTreeSquaredSums() {\n    return squaredSums[0];\n  }\n\n private:\n  const int kMod;\n  const int n;\n  vector<long> lazy;\n  vector<long> sums;\n  vector<long> squaredSums;\n\n  void updateRange(int i, int start, int end, int l, int r) {\n    if (lazy[i] > 0)\n      propagate(i, start, end);\n    if (end < l || start > r)\n      return;\n    if (start >= l && end <= r) {\n      lazy[i] = 1;\n      propagate(i, start, end);\n      return;\n    }\n    const int mid = (start + end) / 2;\n    updateRange(i * 2 + 1, start, mid, l, r);\n    updateRange(i * 2 + 2, mid + 1, end, l, r);\n    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;\n    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;\n  }\n};\n\nclass Solution {\n public:\n  int sumCounts(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    unordered_map<int, int> lastSeen;\n    LazySegmentTree tree(n, kMod);\n\n    for (int r = 0; r < n; ++r) {\n      const int l = lastSeen.contains(nums[r]) ? lastSeen[nums[r]] + 1 : 0;\n      tree.updateRange(l, r);\n      lastSeen[nums[r]] = r;\n      ans = (ans + tree.getTreeSquaredSums()) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "2914": "class Solution {\n public:\n  int minChanges(string s) {\n    int ans = 0;\n\n    for (int i = 0; i + 1 < s.length(); i += 2)\n      if (s[i] != s[i + 1])\n        ++ans;\n\n    return ans;\n  }\n};\n", "2915": "class Solution {\n public:\n  int lengthOfLongestSubsequence(vector<int>& nums, int target) {\n    // dp[i] := the maximum length of any subsequence of numbers so far that\n    // sum to j\n    vector<int> dp(target + 1);\n\n    for (const int num : nums)\n      for (int i = target; i >= num; --i)\n        if (i == num || dp[i - num] > 0)\n          dp[i] = max(dp[i], 1 + dp[i - num]);\n\n    return dp[target] > 0 ? dp[target] : -1;\n  }\n};\n", "2916": "class LazySegmentTree {\n public:\n  LazySegmentTree(int n, int kMod)\n      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}\n\n  void updateRange(int l, int r) {\n    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);\n  }\n\n  void propagate(int i, int l, int r) {\n    const int gap = r - l + 1;\n    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]\n    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3\n    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;\n    squaredSums[i] %= kMod;\n    sums[i] += lazy[i] * gap;\n    sums[i] %= kMod;\n    if (l < r) {\n      lazy[i * 2 + 1] += lazy[i];\n      lazy[i * 2 + 2] += lazy[i];\n    }\n    lazy[i] = 0;\n  }\n\n  int getTreeSquaredSums() {\n    return squaredSums[0];\n  }\n\n private:\n  const int kMod;\n  const int n;\n  vector<long> lazy;\n  vector<long> sums;\n  vector<long> squaredSums;\n\n  void updateRange(int i, int start, int end, int l, int r) {\n    if (lazy[i] > 0)\n      propagate(i, start, end);\n    if (end < l || start > r)\n      return;\n    if (start >= l && end <= r) {\n      lazy[i] = 1;\n      propagate(i, start, end);\n      return;\n    }\n    const int mid = (start + end) / 2;\n    updateRange(i * 2 + 1, start, mid, l, r);\n    updateRange(i * 2 + 2, mid + 1, end, l, r);\n    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;\n    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;\n  }\n};\n\nclass Solution {\n public:\n  int sumCounts(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    unordered_map<int, int> lastSeen;\n    LazySegmentTree tree(n, kMod);\n\n    for (int r = 0; r < n; ++r) {\n      const int l = lastSeen.contains(nums[r]) ? lastSeen[nums[r]] + 1 : 0;\n      tree.updateRange(l, r);\n      lastSeen[nums[r]] = r;\n      ans = (ans + tree.getTreeSquaredSums()) % kMod;\n    }\n\n    return ans;\n  }\n};\n", "2917": "", "2918": "class Solution {\n public:\n  long long minSum(vector<int>& nums1, vector<int>& nums2) {\n    const long sum1 = accumulate(nums1.begin(), nums1.end(), 0L);\n    const long sum2 = accumulate(nums2.begin(), nums2.end(), 0L);\n    const int zero1 = ranges::count(nums1, 0);\n    const int zero2 = ranges::count(nums2, 0);\n    if (zero1 == 0 && sum1 < sum2 + zero2)\n      return -1;\n    if (zero2 == 0 && sum2 < sum1 + zero1)\n      return -1;\n    return max(sum1 + zero1, sum2 + zero2);\n  }\n};\n", "2919": "class Solution {\n public:\n  long long minIncrementOperations(std::vector<int>& nums, int k) {\n    // the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    long prev3 = 0;\n    // the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    long prev2 = 0;\n    // the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    long prev1 = 0;\n\n    for (const int& num : nums) {\n      const long dp = min({prev1, prev2, prev3}) + max(0, k - num);\n      prev3 = prev2;\n      prev2 = prev1;\n      prev1 = dp;\n    }\n\n    return min({prev1, prev2, prev3});\n  }\n};\n", "292": "class Solution {\n public:\n  bool canWinNim(int n) {\n    return n % 4 != 0;\n  }\n};\n", "2920": "class Solution {\n public:\n  int maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {\n    const int n = coins.size();\n    vector<vector<int>> graph(n);\n    vector<vector<int>> mem(n, vector<int>(kMaxHalved + 1, -1));\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    return dfs(graph, 0, /*prev=*/-1, coins, k, /*halved=*/0, mem);\n  }\n\n private:\n  static constexpr int kMaxCoin = 10000;\n  static constexpr int kMaxHalved = 13;  // log2(kMaxCoin) = 13\n\n  int dfs(const vector<vector<int>>& graph, int u, int prev,\n          const vector<int>& coins, int k, int halved,\n          vector<vector<int>>& mem) {\n    // All the children will be 0, so no need to explore.\n    if (halved > kMaxHalved)\n      return 0;\n    if (mem[u][halved] != -1)\n      return mem[u][halved];\n\n    const int val = coins[u] / (1 << halved);\n    int takeAll = val - k;\n    int takeHalf = floor(val / 2.0);\n\n    for (const int v : graph[u]) {\n      if (v == prev)\n        continue;\n      takeAll += dfs(graph, v, u, coins, k, halved, mem);\n      takeHalf += dfs(graph, v, u, coins, k, halved + 1, mem);\n    }\n\n    return mem[u][halved] = max(takeAll, takeHalf);\n  }\n};\n", "2921": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  void maximize(int i, int val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<int> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  // Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  int maxProfit(vector<int>& prices, vector<int>& profits) {\n    const int maxPrice = ranges::max(prices);\n    int ans = -1;\n    FenwickTree maxProfitTree1(maxPrice);\n    FenwickTree maxProfitTree2(maxPrice);\n\n    for (int i = 0; i < prices.size(); ++i) {\n      const int price = prices[i];\n      const int profit = profits[i];\n      // max(proftis[i])\n      const int maxProfit1 = maxProfitTree1.get(price - 1);\n      // max(proftis[i]) + max(profits[j])\n      const int maxProfit2 = maxProfitTree2.get(price - 1);\n      maxProfitTree1.maximize(price, profit);\n      if (maxProfit1 > 0)\n        maxProfitTree2.maximize(price, profit + maxProfit1);\n      if (maxProfit2 > 0)\n        ans = max(ans, profit + maxProfit2);\n    }\n\n    return ans;\n  }\n};\n", "2923": "class Solution {\n public:\n  int findChampion(vector<vector<int>>& grid) {\n    for (int i = 0; i < grid.size(); ++i)\n      if (accumulate(grid[i].begin(), grid[i].end(), 0) == grid.size() - 1)\n        return i;\n    return -1;\n  }\n};\n", "2924": "class Solution {\n public:\n  int findChampion(int n, vector<vector<int>>& edges) {\n    int ans = -1;\n    int count = 0;\n    vector<int> inDegrees(n);\n\n    for (const vector<int>& edge : edges) {\n      const int v = edge[1];\n      ++inDegrees[v];\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0) {\n        ++count;\n        ans = i;\n      }\n\n    return count > 1 ? -1 : ans;\n  }\n};\n", "2925": "class Solution {\n public:\n  long long maximumScoreAfterOperations(vector<vector<int>>& edges,\n                                        vector<int>& values) {\n    vector<vector<int>> tree(values.size());\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    return accumulate(values.begin(), values.end(), 0L) -\n           dfs(tree, 0, /*prev=*/-1, values);\n  }\n\n private:\n  // Returns the minimum of sum to be reduced.\n  long dfs(const vector<vector<int>>& tree, int u, int prev,\n           const vector<int>& values) {\n    if (u > 0 && tree[u].size() == 1)\n      return values[u];\n    long childrenSum = 0;\n    for (const int v : tree[u])\n      if (v != prev)\n        childrenSum += dfs(tree, v, u, values);\n    return min(childrenSum, static_cast<long>(values[u]));\n  }\n};\n", "2926": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  // Updates the maximum sum of subsequence ending in (i - 1) with `val`.\n  void maximize(int i, long val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  // Returns the maximum sum of subsequence ending in (i - 1).\n  long get(int i) const {\n    long res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<long> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  long long maxBalancedSubsequenceSum(vector<int>& nums) {\n    // Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    // By observation:\n    //     nums[i] - nums[j] >= i - j\n    //  => nums[i] - i >= nums[j] - j\n    //  So, if nums[i] - i >= nums[j] - j, where i > j,\n    //  maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    long ans = LONG_MIN;\n    FenwickTree tree(nums.size());\n\n    for (const auto& [_, i] : getPairs(nums)) {\n      const long subseqSum = tree.get(i) + nums[i];\n      tree.maximize(i + 1, subseqSum);\n      ans = max(ans, subseqSum);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getPairs(const vector<int>& nums) {\n    vector<pair<int, int>> pairs;\n    for (int i = 0; i < nums.size(); ++i)\n      pairs.emplace_back(nums[i] - i, i);\n    ranges::sort(pairs);\n    return pairs;\n  }\n};\n", "2927": "class Solution {\n public:\n  long long distributeCandies(int n, int limit) {\n    const int limitPlusOne = limit + 1;\n    const long oneChildExceedsLimit = ways(n - limitPlusOne);\n    const long twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);\n    const long threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);\n    // Principle of Inclusion-Exclusion (PIE)\n    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -\n           threeChildrenExceedLimit;\n  }\n\n private:\n  // Returns the number of ways to distribute n candies to 3 children.\n  long ways(int n) {\n    if (n < 0)\n      return 0;\n    // Stars and bars method:\n    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n    // stars (*) := candies and bars (|) := dividers between children.\n    return nCk(n + 2, 2);\n  }\n\n  long nCk(int n, int k) {\n    long res = 1;\n    for (int i = 1; i <= k; ++i)\n      res = res * (n - i + 1) / i;\n    return res;\n  }\n};\n", "2928": "class Solution {\n public:\n  // Same as 2927. Distribute Candies Among Children III\n  int distributeCandies(int n, int limit) {\n    const int limitPlusOne = limit + 1;\n    const int oneChildExceedsLimit = ways(n - limitPlusOne);\n    const int twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);\n    const int threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);\n    // Principle of Inclusion-Exclusion (PIE)\n    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -\n           threeChildrenExceedLimit;\n  }\n\n private:\n  // Returns the number of ways to distribute n candies to 3 children.\n  int ways(int n) {\n    if (n < 0)\n      return 0;\n    // Stars and bars method:\n    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n    // stars (*) := candies and bars (|) := dividers between children.\n    return nCk(n + 2, 2);\n  }\n\n  int nCk(int n, int k) {\n    int res = 1;\n    for (int i = 1; i <= k; ++i)\n      res = res * (n - i + 1) / i;\n    return res;\n  }\n};\n", "2929": "class Solution {\n public:\n  // Same as 2927. Distribute Candies Among Children III\n  long long distributeCandies(int n, int limit) {\n    const int limitPlusOne = limit + 1;\n    const long oneChildExceedsLimit = ways(n - limitPlusOne);\n    const long twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);\n    const long threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);\n    // Principle of Inclusion-Exclusion (PIE)\n    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -\n           threeChildrenExceedLimit;\n  }\n\n private:\n  // Returns the number of ways to distribute n candies to 3 children.\n  long ways(int n) {\n    if (n < 0)\n      return 0;\n    // Stars and bars method:\n    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n    // stars (*) := candies and bars (|) := dividers between children.\n    return nCk(n + 2, 2);\n  }\n\n  long nCk(int n, int k) {\n    long res = 1;\n    for (int i = 1; i <= k; ++i)\n      res = res * (n - i + 1) / i;\n    return res;\n  }\n};\n", "293": "class Solution {\n public:\n  vector<string> generatePossibleNextMoves(string currentState) {\n    vector<string> ans;\n\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState[i] == '+' && currentState[i + 1] == '+')\n        ans.push_back(currentState.substr(0, i) + \"--\" +\n                      currentState.substr(i + 2));\n\n    return ans;\n  }\n};\n", "2930": "class Solution {\n public:\n  int stringCount(int n) {\n    // There're three invalid conditions:\n    //   a. count('l') == 0\n    //   b. count('e') < 2\n    //   c. count('t') == 0\n    //\n    // By Principle of Inclusion-Exclusion (PIE):\n    //   ans = allCount - a - b - c + ab + ac + bc - abc\n    const long allCount = modPow(26, n);\n    const long a = modPow(25, n);\n    const long b = modPow(25, n);\n    const long c = modPow(25, n) + n * modPow(25, n - 1);\n    const long ab = modPow(24, n) + n * modPow(24, n - 1);\n    const long ac = modPow(24, n);\n    const long bc = modPow(24, n) + n * modPow(24, n - 1);\n    const long abc = modPow(23, n) + n * modPow(23, n - 1);\n    return ((allCount - a - b - c + ab + ac + bc - abc) % kMod + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2931": "class Solution {\n public:\n  long long maxSpending(vector<vector<int>>& values) {\n    const int m = values.size();\n    const int n = values[0].size();\n    long ans = 0;\n    long d = 1;\n    vector<int> items;\n\n    for (const vector<int>& shop : values)\n      for (const int item : shop)\n        items.push_back(item);\n\n    ranges::sort(items);\n\n    for (const int item : items)\n      ans += item * d++;\n\n    return ans;\n  }\n};\n", "2932": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n  int mn = INT_MAX;\n  int mx = INT_MIN;\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n      node->mn = min(node->mn, num);\n      node->mx = max(node->mx, num);\n    }\n  }\n\n  // Returns max(x ^ y), where |x - y| <= min(x, y).\n  //\n  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n  // So, y <= 2 * x.\n  int getMaxXor(int x) {\n    int maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = x >> i & 1;\n      const int toggleBit = bit ^ 1;\n      // If `node.children[toggleBit].mx > x`, it means there's a number in the\n      // node that satisfies the condition to ensure that x <= y among x and y.\n      // If `node.children[toggleBit].mn <= 2 * x`, it means there's a number\n      // in the node that satisfies the condition for a valid y.\n      if (node->children[toggleBit] != nullptr &&\n          node->children[toggleBit]->mx > x &&\n          node->children[toggleBit]->mn <= 2 * x) {\n        maxXor = maxXor | 1 << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  // Similar to 421. Maximum XOR of Two Numbers in an Array\n  int maximumStrongPairXor(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    const int maxBit = static_cast<int>(log2(maxNum));\n    int ans = 0;\n    BitTrie bitTrie(maxBit);\n\n    for (const int num : nums)\n      bitTrie.insert(num);\n\n    for (const int num : nums)\n      ans = max(ans, bitTrie.getMaxXor(num));\n\n    return ans;\n  }\n};\n", "2933": "class Solution {\n public:\n  vector<string> findHighAccessEmployees(vector<vector<string>>& access_times) {\n    unordered_set<string> ans;\n\n    ranges::sort(access_times);\n\n    for (int i = 0; i + 2 < access_times.size(); ++i) {\n      const string& name = access_times[i][0];\n      if (ans.contains(name))\n        continue;\n      if (name != access_times[i + 2][0])\n        continue;\n      if (stoi(access_times[i + 2][1]) - stoi(access_times[i][1]) < 100)\n        ans.insert(name);\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n};\n", "2934": "class Solution {\n public:\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\n    const int n = nums1.size();\n    const int mn = min(nums1.back(), nums2.back());\n    const int mx = max(nums1.back(), nums2.back());\n    // the number of the minimum operations, where nums1[n - 1] is not swapped\n    // with nums2[n - 1]\n    int dp1 = 0;\n    // the number of the minimum operations, where nums1[n - 1] is swapped with\n    // nums2[n - 1]\n    int dp2 = 0;\n\n    for (int i = 0; i < n; ++i) {\n      const int a = nums1[i];\n      const int b = nums2[i];\n      if (min(a, b) > mn)\n        return -1;\n      if (max(a, b) > mx)\n        return -1;\n      if (a > nums1.back() || b > nums2.back())\n        ++dp1;\n      if (a > nums2.back() || b > nums1.back())\n        ++dp2;\n    }\n\n    return min(dp1, dp2);\n  }\n};\n", "2935": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n  int mn = INT_MAX;\n  int mx = INT_MIN;\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n      node->mn = min(node->mn, num);\n      node->mx = max(node->mx, num);\n    }\n  }\n\n  // Returns max(x ^ y), where |x - y| <= min(x, y).\n  //\n  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n  // So, y <= 2 * x.\n  int getMaxXor(int x) {\n    int maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = x >> i & 1;\n      const int toggleBit = bit ^ 1;\n      // If `node.children[toggleBit].max > x`, it means there's a number in the\n      // node that satisfies the condition to ensure that x <= y among x and y.\n      // If `node.children[toggleBit].min <= 2 * x`, it means there's a number\n      // in the node that satisfies the condition for a valid y.\n      if (node->children[toggleBit] != nullptr &&\n          node->children[toggleBit]->mx > x &&\n          node->children[toggleBit]->mn <= 2 * x) {\n        maxXor = maxXor | 1 << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  // Same as 2932. Maximum Strong Pair XOR I\n  int maximumStrongPairXor(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    const int maxBit = static_cast<int>(log2(maxNum));\n    int ans = 0;\n    BitTrie bitTrie(maxBit);\n\n    for (const int num : nums)\n      bitTrie.insert(num);\n\n    for (const int num : nums)\n      ans = max(ans, bitTrie.getMaxXor(num));\n\n    return ans;\n  }\n};\n", "2936": "/**\n * Definition for BigArray.\n * class BigArray {\n *  public:\n *   BigArray(vector<int> elements);\n *   int at(long long index);\n *   long long size();\n * };\n */\n\nclass Solution {\n public:\n  int countBlocks(BigArray* nums) {\n    return countBlocks(nums, 0, nums->size() - 1, nums->at(0),\n                       nums->at(nums->size() - 1));\n  }\n\n private:\n  // Returns the number of maximal blocks in nums[l..r].\n  int countBlocks(BigArray* nums, long l, long r, int leftValue,\n                  int rightValue) {\n    if (leftValue == rightValue)  // nums[l..r] are identical.\n      return 1;\n    if (l + 1 == r)  // nums[l] != nums[r].\n      return 2;\n    const long m = (l + r) / 2;\n    const int midValue = nums->at(m);\n    // Substract nums[m], which will be counted twice.\n    return countBlocks(nums, l, m, leftValue, midValue) +\n           countBlocks(nums, m, r, midValue, rightValue) - 1;\n  }\n};\n", "2937": "class Solution {\n public:\n  int findMinimumOperations(string s1, string s2, string s3) {\n    const int minLength = min({s1.length(), s2.length(), s3.length()});\n    int i = 0;\n    while (i < minLength && s1[i] == s2[i] && s2[i] == s3[i])\n      ++i;\n    return i == 0 ? -1 : s1.length() + s2.length() + s3.length() - i * 3;\n  }\n};\n", "2938": "class Solution {\n public:\n  long long minimumSteps(string s) {\n    long ans = 0;\n    int ones = 0;\n\n    for (const char c : s)\n      if (c == '1')\n        ++ones;\n      else  // Move 1s to the front of the current '0'.\n        ans += ones;\n\n    return ans;\n  }\n};\n", "2939": "class Solution {\n public:\n  int maximumXorProduct(long long a, long long b, int n) {\n    constexpr int kMod = 1'000'000'007;\n    if (n > 0)\n      for (long bit = 1L << (n - 1); bit > 0; bit >>= 1)\n        // Pick a bit if it makes min(a, b) larger.\n        if ((min(a, b) & bit) == 0) {\n          a ^= bit;\n          b ^= bit;\n        }\n    return a % kMod * (b % kMod) % kMod;\n  }\n};\n", "294": "class Solution {\n public:\n  bool canWin(string currentState) {\n    const auto it = mem.find(currentState);\n    if (it == mem.cend())\n      return it->second;\n\n    // If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    // changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win.\n    for (int i = 0; i + 1 < currentState.length(); ++i)\n      if (currentState[i] == '+' && currentState[i + 1] == '+' &&\n          !canWin(currentState.substr(0, i) + '-' + currentState.substr(i + 2)))\n        return mem[currentState] = true;\n\n    return mem[currentState] = false;\n  }\n\n private:\n  unordered_map<string, bool> mem;\n};\n", "2940": "struct IndexedQuery {\n  int queryIndex;\n  int a;  // Alice's index\n  int b;  // Bob's index\n};\n\nclass Solution {\n public:\n  // Similar to 2736. Maximum Sum Queries\n  vector<int> leftmostBuildingQueries(vector<int>& heights,\n                                      vector<vector<int>>& queries) {\n    vector<int> ans(queries.size(), -1);\n    // Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    // descending order.\n    vector<int> stack;\n\n    // Iterate through queries and heights simultaneously.\n    int heightsIndex = heights.size() - 1;\n    for (const auto& [queryIndex, a, b] : getIndexedQueries(queries)) {\n      if (a == b || heights[a] < heights[b]) {\n        // 1. Alice and Bob are already in the same index (a == b) or\n        // 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b;\n      } else {\n        // Now, a < b and heights[a] >= heights[b].\n        // Gradually add heights with an index > b to the monotonic stack.\n        while (heightsIndex > b) {\n          // heights[heightsIndex] is a better candidate, given that\n          // heightsIndex is smaller than the indices in the stack and\n          // heights[heightsIndex] is larger or equal to the heights mapped in\n          // the stack.\n          while (!stack.empty() &&\n                 heights[stack.back()] <= heights[heightsIndex])\n            stack.pop_back();\n          stack.push_back(heightsIndex--);\n        }\n        // Binary search to find the smallest index j such that j > b and\n        // heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        if (const auto it = upper_bound(\n                stack.rbegin(), stack.rend(), a,\n                [&](int a, int b) { return heights[a] < heights[b]; });\n            it != stack.rend())\n          ans[queryIndex] = *it;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {\n    vector<IndexedQuery> indexedQueries;\n    for (int i = 0; i < queries.size(); ++i) {\n      // Make sure that a <= b.\n      const int a = min(queries[i][0], queries[i][1]);\n      const int b = max(queries[i][0], queries[i][1]);\n      indexedQueries.push_back({i, a, b});\n    }\n    ranges::sort(\n        indexedQueries,\n        [](const IndexedQuery& a, const IndexedQuery& b) { return a.b > b.b; });\n    return indexedQueries;\n  }\n};\n", "2941": "class Solution {\n public:\n  long long maxGcdSum(vector<int>& nums, int k) {\n    long long ans = 0;\n    // [(startIndex, gcd of subarray starting at startIndex)]\n    vector<pair<int, int>> startIndexAndGcds;\n    vector<long long> prefix = {0};\n\n    for (const int num : nums)\n      prefix.push_back(prefix.back() + num);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      vector<pair<int, int>> nextStartIndexAndGcds;\n      for (const auto& [startIndex, gcd] : startIndexAndGcds) {\n        const int nextGcd = __gcd(gcd, nums[i]);\n        if (nextStartIndexAndGcds.empty() ||\n            nextStartIndexAndGcds.back().second != nextGcd)  // Skip duplicates.\n          nextStartIndexAndGcds.emplace_back(startIndex, nextGcd);\n      }\n      startIndexAndGcds = std::move(nextStartIndexAndGcds);\n      startIndexAndGcds.emplace_back(i, nums[i]);\n      for (const auto& [startIndex, gcd] : startIndexAndGcds)\n        if (i - startIndex + 1 >= k)\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd);\n    }\n\n    return ans;\n  }\n};\n", "2942": "class Solution {\n public:\n  vector<int> findWordsContaining(vector<string>& words, char x) {\n    vector<int> ans;\n\n    for (int i = 0; i < words.size(); ++i)\n      if (words[i].find(x) != string::npos)\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "2943": "class Solution {\n public:\n  int maximizeSquareHoleArea(int n, int m, vector<int>& hBars,\n                             vector<int>& vBars) {\n    const int gap = min(maxContinousGap(hBars), maxContinousGap(vBars));\n    return gap * gap;\n  }\n\n private:\n  int maxContinousGap(vector<int>& bars) {\n    int res = 2;\n    int runningGap = 2;\n    ranges::sort(bars);\n    for (int i = 1; i < bars.size(); ++i) {\n      runningGap = bars[i] == bars[i - 1] + 1 ? runningGap + 1 : 2;\n      res = max(res, runningGap);\n    }\n    return res;\n  }\n};\n", "2944": "class Solution {\n public:\n  int minimumCoins(vector<int>& prices) {\n    const int n = prices.size();\n    int ans = 0;\n    using P = pair<int, int>;\n    // Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    // fruits[i:] (0-indexed).\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(0, n);\n\n    for (int i = n - 1; i >= 0; --i) {\n      while (!minHeap.empty() && minHeap.top().second > (i + 1) * 2)\n        minHeap.pop();\n      ans = prices[i] + minHeap.top().first;\n      minHeap.emplace(ans, i);\n    }\n\n    return ans;\n  }\n};\n", "2946": "class Solution {\n public:\n  bool areSimilar(vector<vector<int>>& mat, int k) {\n    const int n = mat[0].size();\n    for (const vector<int>& row : mat)\n      for (int j = 0; j < n; ++j)\n        if (row[j] != row[(j + k) % n])\n          return false;\n    return true;\n  }\n};\n", "2947": "class Solution {\n public:\n  int beautifulSubstrings(string s, int k) {\n    const int root = getRoot(k);\n    int ans = 0;\n    int vowels = 0;\n    int vowelsMinusConsonants = 0;\n    // {(vowels, vowelsMinusConsonants): count}\n    unordered_map<pair<int, int>, int, PairHash> prefixCount{{{0, 0}, 1}};\n\n    for (const char c : s) {\n      if (isVowel(c)) {\n        vowels = (vowels + 1) % root;\n        ++vowelsMinusConsonants;\n      } else {\n        --vowelsMinusConsonants;\n      }\n      const pair<int, int> prefix{vowels, vowelsMinusConsonants};\n      ans += prefixCount[prefix]++;\n    }\n\n    return ans;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n\n  int getRoot(int k) {\n    for (int i = 1; i <= k; ++i)\n      if (i * i % k == 0)\n        return i;\n    throw;\n  }\n\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "2948": "class Solution {\n public:\n  vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {\n    vector<int> ans(nums.size());\n    // [[(num, index)]], where the difference between in each pair in each\n    // `[(num, index)]` group <= `limit`\n    vector<vector<pair<int, int>>> numAndIndexesGroups;\n\n    for (const pair<int, int>& numAndIndex : getNumAndIndexes(nums))\n      if (numAndIndexesGroups.empty() ||\n          numAndIndex.first - numAndIndexesGroups.back().back().first > limit) {\n        // Start a new group.\n        numAndIndexesGroups.push_back({numAndIndex});\n      } else {\n        // Append to the existing group.\n        numAndIndexesGroups.back().push_back(numAndIndex);\n      }\n\n    for (const vector<pair<int, int>>& numAndIndexesGroup :\n         numAndIndexesGroups) {\n      vector<int> sortedNums;\n      vector<int> sortedIndices;\n      for (const auto& [num, index] : numAndIndexesGroup) {\n        sortedNums.push_back(num);\n        sortedIndices.push_back(index);\n      }\n      ranges::sort(sortedIndices);\n      for (int i = 0; i < sortedNums.size(); ++i)\n        ans[sortedIndices[i]] = sortedNums[i];\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getNumAndIndexes(const vector<int>& nums) {\n    vector<pair<int, int>> numAndIndexes;\n    for (int i = 0; i < nums.size(); ++i)\n      numAndIndexes.emplace_back(nums[i], i);\n    ranges::sort(numAndIndexes);\n    return numAndIndexes;\n  }\n};\n", "2949": "class Solution {\n public:\n  // Same as 2947. Count Beautiful Substrings I\n  int beautifulSubstrings(string s, int k) {\n    const int root = getRoot(k);\n    int ans = 0;\n    int vowels = 0;\n    int vowelsMinusConsonants = 0;\n    // {(vowels, vowelsMinusConsonants): count}\n    unordered_map<pair<int, int>, int, PairHash> prefixCount{{{0, 0}, 1}};\n\n    for (const char c : s) {\n      if (isVowel(c)) {\n        vowels = (vowels + 1) % root;\n        ++vowelsMinusConsonants;\n      } else {\n        --vowelsMinusConsonants;\n      }\n      const pair<int, int> prefix{vowels, vowelsMinusConsonants};\n      ans += prefixCount[prefix]++;\n    }\n\n    return ans;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n\n  int getRoot(int k) {\n    for (int i = 1; i <= k; ++i)\n      if (i * i % k == 0)\n        return i;\n    throw;\n  }\n\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "295": "class MedianFinder {\n public:\n  void addNum(int num) {\n    if (maxHeap.empty() || num <= maxHeap.top())\n      maxHeap.push(num);\n    else\n      minHeap.push(num);\n\n    // Balance the two heaps s.t.\n    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1.\n    if (maxHeap.size() < minHeap.size())\n      maxHeap.push(minHeap.top()), minHeap.pop();\n    else if (maxHeap.size() - minHeap.size() > 1)\n      minHeap.push(maxHeap.top()), maxHeap.pop();\n  }\n\n  double findMedian() {\n    if (maxHeap.size() == minHeap.size())\n      return (maxHeap.top() + minHeap.top()) / 2.0;\n    return maxHeap.top();\n  }\n\n private:\n  priority_queue<int> maxHeap;\n  priority_queue<int, vector<int>, greater<>> minHeap;\n};\n", "2950": "class Solution {\n public:\n  int countDivisibleSubstrings(string word) {\n    // Let f(c) = d, where d = 1, 2, ..., 9.\n    // Rephrase the question to return the number of substrings that satisfy\n    //    f(c1) + f(c2) + ... + f(ck) / k = avg\n    // => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    int ans = 0;\n\n    for (int avg = 1; avg <= 9; ++avg) {\n      int prefix = 0;\n      unordered_map<int, int> prefixCount{{0, 1}};\n      for (const char c : word) {\n        prefix += f(c) - avg;\n        ans += prefixCount[prefix]++;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  int f(char c) {\n    return 9 - ('z' - c) / 3;\n  }\n};\n", "2951": "class Solution {\n public:\n  vector<int> findPeaks(vector<int>& mountain) {\n    vector<int> ans;\n    for (int i = 1; i + 1 < mountain.size(); ++i)\n      if (mountain[i] > mountain[i - 1] && mountain[i] > mountain[i + 1])\n        ans.push_back(i);\n    return ans;\n  }\n};\n", "2952": "class Solution {\n public:\n  // Same as 330. Patching Array\n  int minimumAddedCoins(vector<int>& coins, int target) {\n    int ans = 0;\n    int i = 0;      // coins' index\n    long miss = 1;  // the minimum sum in [1, n] we might miss\n\n    ranges::sort(coins);\n\n    while (miss <= target)\n      if (i < coins.size() && coins[i] <= miss) {\n        miss += coins[i++];\n      } else {\n        // Greedily add `miss` itself to increase the range from\n        // [1, miss) to [1, 2 * miss).\n        miss += miss;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "2953": "class Solution {\n public:\n  int countCompleteSubstrings(string word, int k) {\n    const int uniqueLetters =\n        unordered_set<char>{word.begin(), word.end()}.size();\n    int ans = 0;\n\n    for (int windowSize = k;\n         windowSize <= k * uniqueLetters && windowSize <= word.length();\n         windowSize += k)\n      ans += countCompleteStrings(word, k, windowSize);\n\n    return ans;\n  }\n\n private:\n  // Returns the number of complete substrings of `windowSize` of `word`.\n  int countCompleteStrings(const string& word, int k, int windowSize) {\n    int res = 0;\n    int countLetters = 0;  // the number of letters in the running substring\n    vector<int> count(26);\n\n    for (int i = 0; i < word.length(); ++i) {\n      ++count[word[i] - 'a'];\n      ++countLetters;\n      if (i > 0 && abs(word[i] - word[i - 1]) > 2) {\n        count = vector<int>(26);\n        // Start a new substring starting at word[i].\n        ++count[word[i] - 'a'];\n        countLetters = 1;\n      }\n      if (countLetters == windowSize + 1) {\n        --count[word[i - windowSize] - 'a'];\n        --countLetters;\n      }\n      if (countLetters == windowSize)\n        res += ranges::all_of(count,\n                              [k](int freq) { return freq == 0 || freq == k; })\n                   ? 1\n                   : 0;\n    }\n\n    return res;\n  }\n};\n", "2954": "class Solution {\n public:\n  int numberOfSequence(int n, vector<int>& sick) {\n    const auto [fact, invFact] = getFactAndInvFact(n - sick.size());\n    long ans = fact[n - sick.size()];  // the number of infected children\n    int prevSick = -1;\n\n    for (int i = 0; i < sick.size(); ++i) {\n      // The segment [prevSick + 1, sick - 1] are the current non-infected\n      // children.\n      const int nonInfected = sick[i] - prevSick - 1;\n      prevSick = sick[i];\n      if (nonInfected == 0)\n        continue;\n      ans *= invFact[nonInfected];\n      ans %= kMod;\n      if (i > 0) {\n        // There're two choices per second since the children at the two\n        // endpoints can both be the infect candidates. So, there are\n        // 2^{nonInfected - 1} ways to infect all children in the current\n        // segment.\n        ans *= modPow(2, nonInfected - 1);\n        ans %= kMod;\n      }\n    }\n\n    const int nonInfected = n - sick.back() - 1;\n    ans *= invFact[nonInfected];\n    return ans % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "2955": "class Solution {\n public:\n  vector<int> sameEndSubstringCount(string s, vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> count(26);\n    // counts[i] := the count of s[0..i)\n    vector<vector<int>> counts = {count};\n\n    for (const char c : s) {\n      ++count[c - 'a'];\n      counts.push_back(count);\n    }\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      int sameEndCount = 0;\n      for (char c = 'a'; c <= 'z'; ++c) {\n        //   the count of s[0..r + 1) - the count of s[0..l)\n        // = the count of s[l..r]\n        const int freq = counts[r + 1][c - 'a'] - counts[l][c - 'a'];\n        //   C(freq, 2) + freq\n        // = freq * (freq - 1) / 2 + freq\n        // = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) / 2;\n      }\n      ans.push_back(sameEndCount);\n    }\n\n    return ans;\n  }\n};\n", "2956": "class Solution {\n public:\n  vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {\n    const unordered_set<int> set1{nums1.begin(), nums1.end()};\n    const unordered_set<int> set2{nums2.begin(), nums2.end()};\n    const int ans1 = ranges::count_if(\n        nums1, [&set2](int num) { return set2.contains(num); });\n    const int ans2 = ranges::count_if(\n        nums2, [&set1](int num) { return set1.contains(num); });\n    return {ans1, ans2};\n  }\n};\n", "2957": "class Solution {\n public:\n  int removeAlmostEqualCharacters(string word) {\n    int ans = 0;\n\n    int i = 1;\n    while (i < word.length())\n      if (abs(word[i] - word[i - 1]) <= 1) {\n        ++ans;\n        i += 2;\n      } else {\n        i += 1;\n      }\n\n    return ans;\n  }\n};\n", "2958": "class Solution {\n public:\n  int maxSubarrayLength(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      ++count[nums[r]];\n      while (count[nums[r]] == k + 1)\n        --count[nums[l++]];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "2959": "class Solution {\n public:\n  int numberOfSets(int n, int maxDistance, vector<vector<int>>& roads) {\n    const int maxMask = 1 << n;\n    int ans = 0;\n\n    for (int mask = 0; mask < maxMask; ++mask)\n      if (floydWarshall(n, maxDistance, roads, mask) <= maxDistance)\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  // Returns the maximum distance between any two branches, where the mask\n  // represents the selected branches.\n  int floydWarshall(int n, int maxDistanceThreshold, vector<vector<int>>& roads,\n                    int mask) {\n    int maxDistance = 0;\n    vector<vector<int>> dist(n, vector<int>(n, maxDistanceThreshold + 1));\n\n    for (int i = 0; i < n; ++i)\n      if (mask >> i & 1)\n        dist[i][i] = 0;\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0];\n      const int v = road[1];\n      const int w = road[2];\n      if (mask >> u & 1 && mask >> v & 1) {\n        dist[u][v] = min(dist[u][v], w);\n        dist[v][u] = min(dist[v][u], w);\n      }\n    }\n\n    for (int k = 0; k < n; ++k)\n      if (mask >> k & 1)\n        for (int i = 0; i < n; ++i)\n          if (mask >> i & 1)\n            for (int j = 0; j < n; ++j)\n              if (mask >> j & 1)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    for (int i = 0; i < n; ++i)\n      if (mask >> i & 1)\n        for (int j = i + 1; j < n; ++j)\n          if (mask >> j & 1)\n            maxDistance = max(maxDistance, dist[i][j]);\n\n    return maxDistance;\n  }\n};\n", "296": "class Solution {\n public:\n  int minTotalDistance(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> I;  // i indices s.t. grid[i][j] == 1\n    vector<int> J;  // j indices s.t. grid[i][j] == 1\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j])\n          I.push_back(i);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        if (grid[i][j])\n          J.push_back(j);\n\n    // sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J);\n  }\n\n private:\n  int minTotalDistance(const vector<int>& grid) {\n    int sum = 0;\n    int i = 0;\n    int j = grid.size() - 1;\n    while (i < j)\n      sum += grid[j--] - grid[i++];\n    return sum;\n  }\n};\n", "2960": "class Solution {\n public:\n  int countTestedDevices(vector<int>& batteryPercentages) {\n    int ans = 0;\n\n    for (const int batteryPercentage : batteryPercentages)\n      if (batteryPercentage - ans > 0)\n        ++ans;\n\n    return ans;\n  }\n};\n", "2961": "class Solution {\n public:\n  vector<int> getGoodIndices(vector<vector<int>>& variables, int target) {\n    vector<int> ans;\n    for (int i = 0; i < variables.size(); ++i) {\n      const int a = variables[i][0];\n      const int b = variables[i][1];\n      const int c = variables[i][2];\n      const int m = variables[i][3];\n      if (modPow(modPow(a, b, 10), c, m) == target)\n        ans.push_back(i);\n    }\n    return ans;\n  }\n\n private:\n  long modPow(long x, long n, int mod) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % mod, (n - 1), mod) % mod;\n    return modPow(x * x % mod, (n / 2), mod) % mod;\n  }\n};\n", "2962": "class Solution {\n public:\n  long long countSubarrays(vector<int>& nums, int k) {\n    const int maxNum = ranges::max(nums);\n    long ans = 0;\n    int count = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (nums[r] == maxNum)\n        ++count;\n      // Keep the window to include k - 1 times of the maximum number.\n      while (count == k)\n        if (nums[l++] == maxNum)\n          --count;\n      // If l > 0, nums[l..r] has k - 1 times of the maximum number. For any\n      // subarray nums[i..r], where i < l, it will have at least k times of the\n      // maximum number, since nums[l - 1] equals the maximum number.\n      ans += l;\n    }\n\n    return ans;\n  }\n};\n", "2963": "class Solution {\n public:\n  int numberOfGoodPartitions(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 1;\n    // lastSeen[num] := the index of the last time `num` appeared\n    unordered_map<int, int> lastSeen;\n\n    for (int i = 0; i < nums.size(); ++i)\n      lastSeen[nums[i]] = i;\n\n    // Track the maximum right index of each running partition by ensuring that\n    // the first and last occurrences of a number fall within the same\n    // partition.\n    int maxRight = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i > maxRight)\n        // Start a new partition that starts from nums[i].\n        // Each partition doubles the total number of good partitions.\n        ans = (ans * 2L) % kMod;\n      maxRight = max(maxRight, lastSeen[nums[i]]);\n    }\n\n    return ans;\n  }\n};\n", "2964": "class Solution {\n public:\n  // Similar to 1995. Count Special Quadruplets\n  int divisibleTripletCount(vector<int>& nums, int d) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int j = nums.size() - 1; j > 0; --j) {  // 'j' also represents k.\n      for (int i = j - 1; i >= 0; --i)\n        ans += count[(-(nums[i] + nums[j]) % d + d) % d];\n      ++count[nums[j] % d];  // j := k\n    }\n\n    return ans;\n  }\n};\n", "2965": "class Solution {\n public:\n  vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    const int nSquared = n * n;\n    vector<int> count(nSquared + 1);\n\n    for (const vector<int>& row : grid)\n      for (const int num : row)\n        ++count[num];\n\n    int repeated = -1;\n    int missing = -1;\n\n    for (int i = 1; i <= nSquared; ++i) {\n      if (count[i] == 2)\n        repeated = i;\n      if (count[i] == 0)\n        missing = i;\n    }\n\n    return {repeated, missing};\n  }\n};\n", "2966": "class Solution {\n public:\n  vector<vector<int>> divideArray(vector<int>& nums, int k) {\n    vector<vector<int>> ans;\n\n    ranges::sort(nums);\n\n    for (int i = 2; i < nums.size(); i += 3) {\n      if (nums[i] - nums[i - 2] > k)\n        return {};\n      ans.push_back({nums[i - 2], nums[i - 1], nums[i]});\n    }\n\n    return ans;\n  }\n};\n", "2967": "class Solution {\n public:\n  long long minimumCost(vector<int>& nums) {\n    ranges::sort(nums);\n    const int median = nums[nums.size() / 2];\n    const int nextPalindrome = getPalindrome(median, /*delta=*/1);\n    const int prevPalindrome = getPalindrome(median, /*delta=*/-1);\n    return min(cost(nums, nextPalindrome), cost(nums, prevPalindrome));\n  }\n\n private:\n  // Returns the cost to change all the numbers to `palindrome`.\n  long cost(const vector<int>& nums, int palindrome) {\n    return accumulate(nums.begin(), nums.end(), 0L,\n                      [palindrome](long acc, int num) {\n      return acc + abs(palindrome - num);\n    });\n  }\n\n  // Returns the palindrome `p`, where p = num + a * delta and a > 0.\n  int getPalindrome(int num, int delta) {\n    while (!isPalindrome(num))\n      num += delta;\n    return num;\n  }\n\n  bool isPalindrome(int num) {\n    const string original = to_string(num);\n    const string reversed = {original.rbegin(), original.rend()};\n    return original == reversed;\n  }\n};\n", "2968": "class Solution {\n public:\n  int maxFrequencyScore(vector<int>& nums, long long k) {\n    int ans = 0;\n    long cost = 0;\n\n    ranges::sort(nums);\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      cost += nums[r] - nums[(l + r) / 2];\n      while (cost > k)\n        cost -= nums[(l + r + 1) / 2] - nums[l++];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "2969": "class Solution {\n public:\n  // Same as 2944. Minimum Number of Coins for Fruits\n  int minimumCoins(vector<int>& prices) {\n    const int n = prices.size();\n    int ans = 0;\n    using P = pair<int, int>;\n    // Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    // fruits[i:] (0-indexed).\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(0, n);\n\n    for (int i = n - 1; i >= 0; --i) {\n      while (!minHeap.empty() && minHeap.top().second > (i + 1) * 2)\n        minHeap.pop();\n      ans = prices[i] + minHeap.top().first;\n      minHeap.emplace(ans, i);\n    }\n\n    return ans;\n  }\n};\n", "297": "class Codec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode* root) {\n    string s;\n    preorder(root, s);\n    return s;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode* deserialize(string data) {\n    istringstream iss(data);\n    queue<string> q;\n\n    for (string s; iss >> s;)\n      q.push(s);\n\n    return preorder(q);\n  }\n\n private:\n  void preorder(TreeNode* root, string& s) {\n    if (root == nullptr) {\n      s += \"n \";\n      return;\n    }\n\n    s += to_string(root->val) + \" \";\n    preorder(root->left, s);\n    preorder(root->right, s);\n  }\n\n  TreeNode* preorder(queue<string>& q) {\n    const string s = q.front();\n    q.pop();\n    if (s == \"n\")\n      return nullptr;\n\n    TreeNode* root = new TreeNode(stoi(s));\n    root->left = preorder(q);\n    root->right = preorder(q);\n    return root;\n  }\n};\n", "2970": "class Solution {\n public:\n  int incremovableSubarrayCount(vector<int>& nums) {\n    const int n = nums.size();\n    const int startIndex = getStartIndexOfSuffix(nums);\n    // If the complete array is strictly increasing, the total number of ways we\n    // can remove elements equals the total number of possible subarrays.\n    if (startIndex == 0)\n      return n * (n + 1) / 2;\n\n    // The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    // nums[0..startIndex], ..., nums[0..n).\n    int ans = n - startIndex + 1;\n\n    // Enumerate each prefix subarray that is strictly increasing.\n    for (int i = 0, j = startIndex; i < startIndex; ++i) {\n      if (i > 0 && nums[i] <= nums[i - 1])\n        break;\n      // Since nums[0..i] is strictly increasing, move j to the place such that\n      // nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      // nums[i + 1..j], ..., nums[i + 1..n).\n      while (j < n && nums[i] >= nums[j])\n        ++j;\n      ans += n - j + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the start index i of the suffix subarray such that nums[i..n) is\n  // strictly increasing.\n  int getStartIndexOfSuffix(const vector<int>& nums) {\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] >= nums[i + 1])\n        return i + 1;\n    return 0;\n  }\n};\n", "2971": "class Solution {\n public:\n  long long largestPerimeter(vector<int>& nums) {\n    long prefix = accumulate(nums.begin(), nums.end(), 0L);\n\n    ranges::sort(nums);\n\n    for (int i = nums.size() - 1; i >= 2; --i) {\n      prefix -= nums[i];\n      // Let nums[i] be the longest side. Check if the sum of all the edges with\n      // length no longer than nums[i] > nums[i].\n      if (prefix > nums[i])\n        return prefix + nums[i];\n    }\n\n    return -1;\n  }\n};\n", "2972": "class Solution {\n public:\n  // Same as 2970. Count the Number of Incremovable Subarrays I\n  long long incremovableSubarrayCount(vector<int>& nums) {\n    const int n = nums.size();\n    const int startIndex = getStartIndexOfSuffix(nums);\n    // If the complete array is strictly increasing, the total number of ways we\n    // can remove elements equals the total number of possible subarrays.\n    if (startIndex == 0)\n      return static_cast<long>(n) * (n + 1) / 2;\n\n    // The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    // nums[0..startIndex], ..., nums[0..n).\n    long ans = n - startIndex + 1;\n\n    // Enumerate each prefix subarray that is strictly increasing.\n    for (int i = 0, j = startIndex; i < startIndex; ++i) {\n      if (i > 0 && nums[i] <= nums[i - 1])\n        break;\n      // Since nums[0..i] is strictly increasing, move j to the place such that\n      // nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      // nums[i + 1..j], ..., nums[i + 1..n).\n      while (j < n && nums[i] >= nums[j])\n        ++j;\n      ans += n - j + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the start index i of the suffix subarray such that nums[i..n) is\n  // strictly increasing.\n  int getStartIndexOfSuffix(const vector<int>& nums) {\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] >= nums[i + 1])\n        return i + 1;\n    return 0;\n  }\n};\n", "2973": "class ChildCost {\n public:\n  ChildCost(int cost) {\n    numNodes = 1;\n    if (cost > 0)\n      maxPosCosts.push_back(cost);\n    else\n      minNegCosts.push_back(cost);\n  }\n\n  void update(ChildCost childCost) {\n    numNodes += childCost.numNodes;\n    ranges::copy(childCost.maxPosCosts, back_inserter(maxPosCosts));\n    ranges::copy(childCost.minNegCosts, back_inserter(minNegCosts));\n    ranges::sort(maxPosCosts, greater<int>());\n    ranges::sort(minNegCosts);\n    maxPosCosts.resize(min(static_cast<int>(maxPosCosts.size()), 3));\n    minNegCosts.resize(min(static_cast<int>(minNegCosts.size()), 2));\n  }\n\n  long maxProduct() {\n    if (numNodes < 3)\n      return 1;\n    if (maxPosCosts.empty())\n      return 0;\n    long res = 0;\n    if (maxPosCosts.size() == 3)\n      res = static_cast<long>(maxPosCosts[0]) * maxPosCosts[1] * maxPosCosts[2];\n    if (minNegCosts.size() == 2)\n      res = max(res, static_cast<long>(minNegCosts[0]) * minNegCosts[1] *\n                         maxPosCosts[0]);\n    return res;\n  }\n\n private:\n  int numNodes;\n  vector<int> maxPosCosts;\n  vector<int> minNegCosts;\n};\n\nclass Solution {\n public:\n  vector<long long> placedCoins(vector<vector<int>>& edges, vector<int>& cost) {\n    const int n = cost.size();\n    vector<long long> ans(n);\n    vector<vector<int>> tree(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, /*prev=*/-1, cost, ans);\n    return ans;\n  }\n\n private:\n  ChildCost dfs(const vector<vector<int>>& tree, int u, int prev,\n                const vector<int>& cost, vector<long long>& ans) {\n    ChildCost res(cost[u]);\n    for (const int v : tree[u])\n      if (v != prev)\n        res.update(dfs(tree, v, u, cost, ans));\n    ans[u] = res.maxProduct();\n    return res;\n  }\n};\n", "2974": "class Solution {\n public:\n  vector<int> numberGame(vector<int>& nums) {\n    ranges::sort(nums);\n    for (int i = 0; i < nums.size(); i += 2)\n      swap(nums[i], nums[i + 1]);\n    return nums;\n  }\n};\n", "2975": "class Solution {\n public:\n  int maximizeSquareArea(int m, int n, vector<int>& hFences,\n                         vector<int>& vFences) {\n    constexpr int kMod = 1'000'000'007;\n\n    hFences.push_back(1);\n    hFences.push_back(m);\n    vFences.push_back(1);\n    vFences.push_back(n);\n\n    ranges::sort(hFences);\n    ranges::sort(vFences);\n\n    const unordered_set<int> hGaps = getGaps(hFences);\n    const unordered_set<int> vGaps = getGaps(vFences);\n    int maxGap = -1;\n\n    for (const int hGap : hGaps)\n      if (vGaps.contains(hGap))\n        maxGap = max(maxGap, hGap);\n\n    return maxGap == -1 ? -1 : static_cast<long>(maxGap) * maxGap % kMod;\n  }\n\n private:\n  unordered_set<int> getGaps(const vector<int>& fences) {\n    unordered_set<int> gaps;\n    for (int i = 0; i < fences.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        gaps.insert(fences[i] - fences[j]);\n    return gaps;\n  }\n};\n", "2976": "class Solution {\n public:\n  long long minimumCost(string source, string target, vector<char>& original,\n                        vector<char>& changed, vector<int>& cost) {\n    long ans = 0;\n    // dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    vector<vector<long>> dist(26, vector<long>(26, LONG_MAX));\n\n    for (int i = 0; i < cost.size(); ++i) {\n      const int u = original[i] - 'a';\n      const int v = changed[i] - 'a';\n      dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n    }\n\n    for (int k = 0; k < 26; ++k)\n      for (int i = 0; i < 26; ++i)\n        if (dist[i][k] < LONG_MAX)\n          for (int j = 0; j < 26; ++j)\n            if (dist[k][j] < LONG_MAX)\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    for (int i = 0; i < source.length(); ++i) {\n      if (source[i] == target[i])\n        continue;\n      const int u = source[i] - 'a';\n      const int v = target[i] - 'a';\n      if (dist[u][v] == LONG_MAX)\n        return -1;\n      ans += dist[u][v];\n    }\n\n    return ans;\n  }\n};\n", "2977": "class Solution {\n public:\n  long long minimumCost(string source, string target, vector<string>& original,\n                        vector<string>& changed, vector<int>& cost) {\n    const unordered_set<int> subLengths = getSubLengths(original);\n    const unordered_map<string, int> subToId = getSubToId(original, changed);\n    const int subCount = subToId.size();\n    // dist[u][v] := the minimum distance to change the substring with id u to\n    // the substring with id v\n    vector<vector<long>> dist(subCount, vector<long>(subCount, LONG_MAX));\n    // dp[i] := the minimum cost to change the first i letters of `source` into\n    // `target`, leaving the suffix untouched\n    vector<long> dp(source.length() + 1, LONG_MAX);\n\n    for (int i = 0; i < cost.size(); ++i) {\n      const int u = subToId.at(original[i]);\n      const int v = subToId.at(changed[i]);\n      dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n    }\n\n    for (int k = 0; k < subCount; ++k)\n      for (int i = 0; i < subCount; ++i)\n        if (dist[i][k] < LONG_MAX)\n          for (int j = 0; j < subCount; ++j)\n            if (dist[k][j] < LONG_MAX)\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    dp[0] = 0;\n\n    for (int i = 0; i < source.length(); ++i) {\n      if (dp[i] == LONG_MAX)\n        continue;\n      if (target[i] == source[i])\n        dp[i + 1] = min(dp[i + 1], dp[i]);\n      for (const int subLength : subLengths) {\n        if (i + subLength > source.length())\n          continue;\n        const string subSource = source.substr(i, subLength);\n        const string subTarget = target.substr(i, subLength);\n        if (!subToId.contains(subSource) || !subToId.contains(subTarget))\n          continue;\n        const int u = subToId.at(subSource);\n        const int v = subToId.at(subTarget);\n        if (dist[u][v] < LONG_MAX)\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v]);\n      }\n    }\n\n    return dp[source.length()] == LONG_MAX ? -1 : dp[source.length()];\n  }\n\n private:\n  unordered_map<string, int> getSubToId(const vector<string>& original,\n                                        const vector<string>& changed) {\n    unordered_map<string, int> subToId;\n    for (const string& s : original)\n      if (!subToId.contains(s))\n        subToId[s] = subToId.size();\n    for (const string& s : changed)\n      if (!subToId.contains(s))\n        subToId[s] = subToId.size();\n    return subToId;\n  }\n\n  unordered_set<int> getSubLengths(const vector<string>& original) {\n    unordered_set<int> subLengths;\n    for (const string& s : original)\n      subLengths.insert(s.length());\n    return subLengths;\n  }\n};\n", "2979": "class Solution {\n public:\n  int mostExpensiveItem(int primeOne, int primeTwo) {\n    // https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo;\n  }\n};\n", "298": "class Solution {\n public:\n  int longestConsecutive(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return dfs(root, root->val, 0, 0);\n  }\n\n private:\n  int dfs(TreeNode* root, int target, int length, int maxLength) {\n    if (root == nullptr)\n      return maxLength;\n    if (root->val == target)\n      maxLength = max(maxLength, ++length);\n    else\n      length = 1;\n    return max(dfs(root->left, root->val + 1, length, maxLength),\n               dfs(root->right, root->val + 1, length, maxLength));\n  }\n};\n", "2980": "class Solution {\n public:\n  bool hasTrailingZeros(vector<int>& nums) {\n    int countEven = 0;\n\n    for (const int num : nums)\n      if (num % 2 == 0)\n        ++countEven;\n\n    return countEven >= 2;\n  }\n};\n", "2981": "class Solution {\n public:\n  int maximumLength(string s) {\n    const int n = s.length();\n    int ans = -1;\n    int runningLen = 0;\n    char prevLetter = '@';\n    // counts[i][j] := the frequency of ('a' + i) repeating j times\n    vector<vector<int>> counts(26, vector<int>(n + 1));\n\n    for (const char c : s)\n      if (c == prevLetter) {\n        ++counts[c - 'a'][++runningLen];\n      } else {\n        runningLen = 1;\n        ++counts[c - 'a'][runningLen];\n        prevLetter = c;\n      }\n\n    for (const vector<int>& count : counts)\n      ans = max(ans, getMaxFreq(count, n));\n\n    return ans;\n  }\n\n private:\n  // Returns the maximum frequency that occurs more than three times.\n  int getMaxFreq(const vector<int>& count, int maxFreq) {\n    int times = 0;\n    for (int freq = maxFreq; freq >= 1; --freq) {\n      times += count[freq];\n      if (times >= 3)\n        return freq;\n    }\n    return -1;\n  }\n};\n", "2982": "class Solution {\n public:\n  int maximumLength(string s) {\n    const int n = s.length();\n    int ans = -1;\n    int runningLen = 0;\n    char prevLetter = '@';\n    // counts[i][j] := the frequency of ('a' + i) repeating j times\n    vector<vector<int>> counts(26, vector<int>(n + 1));\n\n    for (const char c : s)\n      if (c == prevLetter) {\n        ++counts[c - 'a'][++runningLen];\n      } else {\n        runningLen = 1;\n        ++counts[c - 'a'][runningLen];\n        prevLetter = c;\n      }\n\n    for (const vector<int>& count : counts)\n      ans = max(ans, getMaxFreq(count, n));\n\n    return ans;\n  }\n\n private:\n  // Returns the maximum frequency that occurs more than three times.\n  int getMaxFreq(const vector<int>& count, int maxFreq) {\n    int times = 0;\n    for (int freq = maxFreq; freq >= 1; --freq) {\n      times += count[freq];\n      if (times >= 3)\n        return freq;\n    }\n    return -1;\n  }\n};\n", "2983": "class Solution {\n public:\n  vector<bool> canMakePalindromeQueries(string s,\n                                        vector<vector<int>>& queries) {\n    const int n = s.length();\n    // mirroredDiffs[i] := the number of different letters between the first i\n    // letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    const vector<int> mirroredDiffs = getMirroredDiffs(s);\n    // counts[i] := the count of s[0..i)\n    const vector<vector<int>> counts = getCounts(s);\n    vector<bool> ans;\n\n    for (const vector<int>& query : queries) {\n      // Use left-closed, right-open intervals to facilitate the calculation.\n      //   ...... [a, b) ...|... [rb, ra) ......\n      //   .... [rd, rc) .....|..... [c, d) ....\n      const int a = query[0];\n      const int b = query[1] + 1;\n      const int c = query[2];\n      const int d = query[3] + 1;\n      const int ra = n - a;  // the reflected index of a in s[n / 2..n)\n      const int rb = n - b;  // the reflected index of b in s[n / 2..n)\n      const int rc = n - c;  // the reflected index of c in s[n / 2..n)\n      const int rd = n - d;  // the reflected index of d in s[n / 2..n)\n      // No difference is allowed outside the query ranges.\n      if (min(a, rd) > 0 && mirroredDiffs[min(a, rd)] > 0 ||\n          n / 2 > max(b, rc) &&\n              mirroredDiffs[n / 2] - mirroredDiffs[max(b, rc)] > 0 ||\n          rd > b && mirroredDiffs[rd] - mirroredDiffs[b] > 0 ||\n          a > rc && mirroredDiffs[a] - mirroredDiffs[rc] > 0) {\n        ans.push_back(false);\n      } else {\n        // The `count` map of the intersection of [a, b) and [rd, rc) in\n        // s[0..n / 2) must equate to the `count` map of the intersection of\n        // [c, d) and [rb, ra) in s[n / 2..n).\n        vector<int> leftRangeCount = subtractArrays(counts[b], counts[a]);\n        vector<int> rightRangeCount = subtractArrays(counts[d], counts[c]);\n        if (a > rd)\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]));\n        if (rc > b)\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]));\n        if (c > rb)\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]));\n        if (ra > d)\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]));\n        ans.push_back(ranges::all_of(leftRangeCount, [](int freq) {\n          return freq >= 0;\n        }) && ranges::all_of(rightRangeCount, [](int freq) {\n          return freq >= 0;\n        }) && leftRangeCount == rightRangeCount);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getMirroredDiffs(const string& s) {\n    vector<int> diffs(1);\n    for (int i = 0, j = s.length() - 1; i < j; ++i, --j)\n      diffs.push_back(diffs.back() + (s[i] != s[j] ? 1 : 0));\n    return diffs;\n  }\n\n  vector<vector<int>> getCounts(const string& s) {\n    vector<int> count(26);\n    vector<vector<int>> counts{count};\n    for (const char c : s) {\n      ++count[c - 'a'];\n      counts.push_back(count);\n    }\n    return counts;\n  }\n\n  vector<int> subtractArrays(const vector<int>& a, const vector<int>& b) {\n    vector<int> res;\n    for (int i = 0; i < a.size(); ++i)\n      res.push_back(a[i] - b[i]);\n    return res;\n  }\n};\n", "299": "class Solution {\n public:\n  string getHint(string secret, string guess) {\n    int A = 0;\n    int B = 0;\n    vector<int> count1(10);\n    vector<int> count2(10);\n\n    for (int i = 0; i < secret.length(); ++i)\n      if (secret[i] == guess[i])\n        ++A;\n      else {\n        ++count1[secret[i] - '0'];\n        ++count2[guess[i] - '0'];\n      }\n\n    for (int i = 0; i < 10; ++i)\n      B += min(count1[i], count2[i]);\n\n    return to_string(A) + \"A\" + to_string(B) + \"B\";\n  }\n};\n", "2992": "class Solution {\n public:\n  int selfDivisiblePermutationCount(int n) {\n    return dfs(1, /*used=*/0, n);\n  }\n\n private:\n  int dfs(int num, int used, int n) {\n    if (num > n)\n      return 1;\n\n    int count = 0;\n    for (int i = 1; i <= n; ++i)\n      if ((used >> i & 1) == 0 && (num % i == 0 || i % num == 0))\n        count += dfs(num + 1, used | (1 << i), n);\n\n    return count;\n  }\n};\n", "2996": "class Solution {\n public:\n  int missingInteger(vector<int>& nums) {\n    const unordered_set<int> numsSet{nums.begin(), nums.end()};\n    int ans = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] != nums[i - 1] + 1)\n        break;\n      ans += nums[i];\n    }\n\n    while (numsSet.contains(ans))\n      ++ans;\n\n    return ans;\n  }\n};\n", "2997": "class Solution {\n public:\n  int minOperations(vector<int>& nums, unsigned k) {\n    const unsigned xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<>());\n    return popcount(k ^ xors);\n  }\n};\n", "2998": "class Solution {\n public:\n  int minimumOperationsToMakeEqual(int x, int y) {\n    if (x <= y)\n      return y - x;\n\n    queue<int> q{{x}};\n    unordered_set<int> seen;\n\n    for (int ans = 0; !q.empty(); ++ans) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int num = q.front();\n        q.pop();\n        if (num == y)\n          return ans;\n        if (seen.find(num) != seen.end())\n          continue;\n        seen.insert(num);\n        if (num % 11 == 0)\n          q.push(num / 11);\n        if (num % 5 == 0)\n          q.push(num / 5);\n        q.push(num - 1);\n        q.push(num + 1);\n      }\n    }\n\n    throw;\n  }\n};\n", "2999": "class Solution {\n public:\n  long long numberOfPowerfulInt(long long start, long long finish, int limit,\n                                string s) {\n    const string a = to_string(start);\n    const string b = to_string(finish);\n    const string aWithLeadingZeros = string(b.length() - a.length(), '0') + a;\n    vector<vector<vector<long>>> mem(\n        b.length(), vector<vector<long>>(2, vector<long>(2, -1)));\n    const string sWithLeadingZeros = string(b.length() - s.length(), '0') + s;\n    return count(aWithLeadingZeros, b, 0, limit, s, true, true, mem);\n  }\n\n private:\n  // Returns the number of powerful integers, considering the i-th digit, where\n  // `tight1` indicates if the current digit is tightly bound for `a` and\n  // `tight2` indicates if the current digit is tightly bound for `b`.\n  long count(const string& a, const string& b, int i, int limit,\n             const string& s, bool tight1, bool tight2,\n             vector<vector<vector<long>>>& mem) {\n    if (i + s.length() == b.length()) {\n      const string aMinSuffix = tight1\n                                    ? std::string(a.end() - s.length(), a.end())\n                                    : string(s.length(), '0');\n      const string bMaxSuffix = tight2\n                                    ? std::string(b.end() - s.length(), b.end())\n                                    : string(s.length(), '9');\n      const long suffix = stoll(s);\n      return stoll(aMinSuffix) <= suffix && suffix <= stoll(bMaxSuffix);\n    }\n\n    if (mem[i][tight1][tight2] != -1)\n      return mem[i][tight1][tight2];\n\n    long res = 0;\n    const int minDigit = tight1 ? a[i] - '0' : 0;\n    const int maxDigit = tight2 ? b[i] - '0' : 9;\n\n    for (int d = minDigit; d <= maxDigit; ++d) {\n      if (d > limit)\n        continue;\n      const bool nextTight1 = tight1 && (d == minDigit);\n      const bool nextTight2 = tight2 && (d == maxDigit);\n      res += count(a, b, i + 1, limit, s, nextTight1, nextTight2, mem);\n    }\n\n    return mem[i][tight1][tight2] = res;\n  }\n};\n", "3": "class Solution {\n public:\n  int lengthOfLongestSubstring(string s) {\n    int ans = 0;\n    // The substring s[j + 1..i] has no repeating characters.\n    int j = -1;\n    // lastSeen[c] := the index of the last time c appeared\n    vector<int> lastSeen(128, -1);\n\n    for (int i = 0; i < s.length(); ++i) {\n      // Update j to lastSeen[s[i]], so the window must start from j + 1.\n      j = max(j, lastSeen[s[i]]);\n      ans = max(ans, i - j);\n      lastSeen[s[i]] = i;\n    }\n\n    return ans;\n  }\n};\n", "30": "class Solution {\n public:\n  vector<int> findSubstring(string s, vector<string>& words) {\n    if (s.empty() || words.empty())\n      return {};\n\n    const int k = words.size();\n    const int n = words[0].length();\n    vector<int> ans;\n    unordered_map<string, int> count;\n\n    for (const string& word : words)\n      ++count[word];\n\n    for (int i = 0; i < s.length() - k * n + 1; ++i) {\n      unordered_map<string, int> seen;\n      int j;\n      for (j = 0; j < k; ++j) {\n        const string& word = s.substr(i + j * n, n);\n        if (++seen[word] > count[word])\n          break;\n      }\n      if (j == k)\n        ans.push_back(i);\n    }\n\n    return ans;\n  }\n};\n", "300": "class Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n\n    for (const int num : nums)\n      if (tails.empty() || num > tails.back())\n        tails.push_back(num);\n      else\n        tails[firstGreaterEqual(tails, num)] = num;\n\n    return tails.size();\n  }\n\n private:\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "3000": "class Solution {\n public:\n  int areaOfMaxDiagonal(vector<vector<int>>& dimensions) {\n    const vector<int> maxDimension = *ranges::max_element(\n        dimensions, [](const vector<int>& a, const vector<int>& b) {\n      return (a[0] * a[0] + a[1] * a[1] == b[0] * b[0] + b[1] * b[1])\n                 ? (a[0] * a[1] < b[0] * b[1])\n                 : (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);\n    });\n    return maxDimension[0] * maxDimension[1];\n  }\n};\n", "3001": "class Solution {\n public:\n  int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n    // The rook is in the same row as the queen.\n    if (a == e)\n      // The bishop blocks the rook or not.\n      return (c == a && (b < d && d < f || b > d && d > f)) ? 2 : 1;\n    // The rook is in the same column as the queen.\n    if (b == f)\n      // The bishop blocks the rook or not.\n      return (d == f && (a < c && c < e || a > c && c > e)) ? 2 : 1;\n    // The bishop is in the same up-diagonal as the queen.\n    if (c + d == e + f)\n      // The rook blocks the bishop or not.\n      return (a + b == c + d && (c < a && a < e || c > a && a > e)) ? 2 : 1;\n    // The bishop is in the same down-diagonal as the queen.\n    if (c - d == e - f)\n      // The rook blocks the bishop or not.\n      return (a - b == c - d && (c < a && a < e || c > a && a > e)) ? 2 : 1;\n    // The rook can always get the green in two steps.\n    return 2;\n  }\n};\n", "3002": "class Solution {\n public:\n  int maximumSetSize(vector<int>& nums1, vector<int>& nums2) {\n    const unordered_set<int> set1{nums1.begin(), nums1.end()};\n    const unordered_set<int> set2{nums2.begin(), nums2.end()};\n    unordered_set<int> common;\n\n    for (const int num1 : set1)\n      if (set2.contains(num1))\n        common.insert(num1);\n\n    const int n = nums1.size();\n    const int n1 = set1.size();\n    const int n2 = set2.size();\n    const int nc = common.size();\n    const int maxUniqueNums1 = min(n1 - nc, n / 2);\n    const int maxUniqueNums2 = min(n2 - nc, n / 2);\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc);\n  }\n};\n", "3003": "class Solution {\n public:\n  int maxPartitionsAfterOperations(string s, int k) {\n    unordered_map<long, int> mem;\n    return maxPartitionsAfterOperations(s, 0, true, 0, k, mem) + 1;\n  }\n\n private:\n  // Returns the maximum number of partitions of s[i..n), where `canChange` is\n  // true if we can still change a letter, and `mask` is the bitmask of the\n  // letters we've seen.\n  int maxPartitionsAfterOperations(const string& s, int i, bool canChange,\n                                   int mask, int k,\n                                   unordered_map<long, int>& mem) {\n    if (i == s.length())\n      return 0;\n\n    long key = static_cast<long>(i) << 27 | (canChange ? 1 : 0) << 26 | mask;\n    if (const auto it = mem.find(key); it != mem.end())\n      return it->second;\n\n    // Initialize the result based on the current letter.\n    int res = getRes(s, i, canChange, mask, 1 << (s[i] - 'a'), k, mem);\n\n    // If allowed, explore the option to change the current letter.\n    if (canChange)\n      for (int j = 0; j < 26; ++j)\n        res = max(res, getRes(s, i, false, mask, 1 << j, k, mem));\n\n    return mem[key] = res;\n  }\n\n  int getRes(const string& s, int i, bool nextCanChange, unsigned mask,\n             int newBit, int k, unordered_map<long, int>& mem) {\n    const unsigned newMask = mask | newBit;\n    if (popcount(newMask) > k)  // fresh start\n      return 1 + maxPartitionsAfterOperations(s, i + 1, nextCanChange, newBit,\n                                              k, mem);\n    return maxPartitionsAfterOperations(s, i + 1, nextCanChange, newMask, k,\n                                        mem);\n  }\n};\n", "3004": "class Solution {\n public:\n  int maximumSubtreeSize(vector<vector<int>>& edges, vector<int>& colors) {\n    int ans = 1;\n    vector<vector<int>> tree(colors.size());\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n    }\n\n    dfs(tree, 0, colors, ans);\n    return ans;\n  }\n\n private:\n  // Returns the size of subtree of u if every node in the subtree has the same\n  // color. Otherwise, returns -1.\n  int dfs(const vector<vector<int>>& tree, int u, const vector<int>& colors,\n          int& ans) {\n    int res = 1;\n    for (const int v : tree[u]) {\n      if (colors[v] != colors[u])\n        res = -1;\n      // If any node in the subtree of v has a different color, the result of\n      // the subtree of u will be -1 as well.\n      const int subtreeSize = dfs(tree, v, colors, ans);\n      if (subtreeSize == -1)\n        res = -1;\n      else if (res != -1)\n        res += subtreeSize;\n    }\n    ans = max(ans, res);\n    return res;\n  }\n};\n", "3005": "class Solution {\n public:\n  int maxFrequencyElements(vector<int>& nums) {\n    constexpr int kMax = 100;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    const int maxFreq = ranges::max(count);\n    return ranges::count(count, maxFreq) * maxFreq;\n  }\n};\n", "3006": "class Solution {\n public:\n  vector<int> beautifulIndices(string s, string a, string b, int k) {\n    vector<int> ans;\n    const vector<int> indicesA = kmp(s, a);\n    const vector<int> indicesB = kmp(s, b);\n    int indicesBIndex = 0;  // indicesB's index\n\n    for (const int i : indicesA) {\n      // The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      // `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while (indicesBIndex < indicesB.size() &&\n             indicesB[indicesBIndex] - i < -k)\n        ++indicesBIndex;\n      if (indicesBIndex < indicesB.size() && indicesB[indicesBIndex] - i <= k)\n        ans.push_back(i);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the starting indices of all occurrences of the pattern in `s`.\n  vector<int> kmp(const string& s, const string& pattern) {\n    vector<int> res;\n    const vector<int> lps = getLPS(pattern);\n    int i = 0;  // s' index\n    int j = 0;  // pattern's index\n    while (i < s.length()) {\n      if (s[i] == pattern[j]) {\n        ++i;\n        ++j;\n        if (j == pattern.length()) {\n          res.push_back(i - j);\n          j = lps[j - 1];\n        }\n      } else if (j > 0) {  // Mismatch after j matches.\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i;\n      }\n    }\n    return res;\n  }\n\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3007": "class Solution {\n public:\n  long long findMaximumNumber(long long k, int x) {\n    long l = 1;\n    long r = 1e15;\n\n    while (l < r) {\n      const long m = (l + r + 1) / 2;\n      if (getSumPrices(m, x) <= k)\n        l = m;\n      else\n        r = m - 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the sum of prices of all numbers from 1 to `num`.\n  long getSumPrices(long num, int x) {\n    long sumPrices = 0;\n    // Increment `num` to account the 0-th row in the count of groups.\n    ++num;\n    for (int i = std::bit_width(static_cast<unsigned long>(num)); i > 0; --i)\n      // If the current column is valid, count the number of 1s in this column.\n      if (i % x == 0) {\n        const long groupSize = 1L << i;\n        const long halfGroupSize = 1L << i - 1;\n        sumPrices += num / groupSize * halfGroupSize;\n        sumPrices += max(0L, (num % groupSize) - halfGroupSize);\n      }\n    return sumPrices;\n  }\n};\n", "3008": "class Solution {\n public:\n  // Same as 3006. Find Beautiful Indices in the Given Array I\n  vector<int> beautifulIndices(string s, string a, string b, int k) {\n    vector<int> ans;\n    const vector<int> indicesA = kmp(s, a);\n    const vector<int> indicesB = kmp(s, b);\n    int indicesBIndex = 0;  // indicesB's index\n\n    for (const int i : indicesA) {\n      // The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      // `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while (indicesBIndex < indicesB.size() &&\n             indicesB[indicesBIndex] - i < -k)\n        ++indicesBIndex;\n      if (indicesBIndex < indicesB.size() && indicesB[indicesBIndex] - i <= k)\n        ans.push_back(i);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the starting indices of all occurrences of the pattern in `s`.\n  vector<int> kmp(const string& s, const string& pattern) {\n    vector<int> res;\n    const vector<int> lps = getLPS(pattern);\n    int i = 0;  // s' index\n    int j = 0;  // pattern's index\n    while (i < s.length()) {\n      if (s[i] == pattern[j]) {\n        ++i;\n        ++j;\n        if (j == pattern.length()) {\n          res.push_back(i - j);\n          j = lps[j - 1];\n        }\n      } else if (j > 0) {  // Mismatch after j matches.\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i;\n      }\n    }\n    return res;\n  }\n\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3009": "class Solution {\n public:\n  int maxIntersectionCount(vector<int>& y) {\n    const int n = y.size();\n    int ans = 0;\n    int intersectionCount = 0;\n    map<int, int> line;\n\n    for (int i = 1; i < n; ++i) {\n      const int start = 2 * y[i - 1];\n      const int end = 2 * y[i] + (i == n - 1 ? 0 : y[i] > y[i - 1] ? -1 : 1);\n      ++line[min(start, end)];\n      --line[max(start, end) + 1];\n    }\n\n    for (const auto& [_, count] : line) {\n      intersectionCount += count;\n      ans = max(ans, intersectionCount);\n    }\n\n    return ans;\n  }\n};\n", "301": "class Solution {\n public:\n  vector<string> removeInvalidParentheses(string s) {\n    vector<string> ans;\n    const auto [l, r] = getLeftAndRightCounts(s);\n    dfs(s, 0, l, r, ans);\n    return ans;\n  }\n\n private:\n  // Similar to 921. Minimum Add to Make Parentheses Valid\n  // Returns how many '(' and ')' need to be deleted.\n  pair<int, int> getLeftAndRightCounts(const string& s) {\n    int l = 0;\n    int r = 0;\n\n    for (const char c : s)\n      if (c == '(')\n        ++l;\n      else if (c == ')') {\n        if (l == 0)\n          ++r;\n        else\n          --l;\n      }\n\n    return {l, r};\n  }\n\n  void dfs(const string& s, int start, int l, int r, vector<string>& ans) {\n    if (l == 0 && r == 0 && isValid(s)) {\n      ans.push_back(s);\n      return;\n    }\n\n    for (int i = start; i < s.length(); ++i) {\n      if (i > start && s[i] == s[i - 1])\n        continue;\n      if (l > 0 && s[i] == '(')  // Delete s[i].\n        dfs(s.substr(0, i) + s.substr(i + 1), i, l - 1, r, ans);\n      if (r > 0 && s[i] == ')')  // Delete s[i].\n        dfs(s.substr(0, i) + s.substr(i + 1), i, l, r - 1, ans);\n    }\n  }\n\n  bool isValid(const string& s) {\n    int opened = 0;  // the number of '(' - # of ')'\n    for (const char c : s) {\n      if (c == '(')\n        ++opened;\n      else if (c == ')')\n        --opened;\n      if (opened < 0)\n        return false;\n    }\n    return true;  // opened == 0\n  }\n};\n", "3010": "class Solution {\n public:\n  int minimumCost(vector<int>& nums) {\n    constexpr int kMax = 50;\n    int min1 = kMax;\n    int min2 = kMax;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] < min1) {\n        min2 = min1;\n        min1 = nums[i];\n      } else if (nums[i] < min2) {\n        min2 = nums[i];\n      }\n\n    return nums[0] + min1 + min2;\n  }\n};\n", "3011": "class Solution {\n public:\n  bool canSortArray(vector<int>& nums) {\n    // Divide the array into distinct segments where each segment is comprised\n    // of consecutive elements sharing an equal number of set bits. Ensure that\n    // for each segment, when moving from left to right, the maximum of a\n    // preceding segment is less than the minimum of the following segment.\n    int prevSetBits = 0;\n    int prevMax = INT_MIN;  // the maximum of the previous segment\n    int currMax = INT_MIN;  // the maximum of the current segment\n    int currMin = INT_MAX;  // the minimum of the current segment\n\n    for (const int num : nums) {\n      const int setBits = __builtin_popcount(num);\n      if (setBits != prevSetBits) {  // Start a new segment.\n        if (prevMax > currMin)\n          return false;\n        prevSetBits = setBits;\n        prevMax = currMax;\n        currMax = num;\n        currMin = num;\n      } else {  // Continue with the current segment.\n        currMax = max(currMax, num);\n        currMin = min(currMin, num);\n      }\n    }\n\n    return prevMax <= currMin;\n  }\n};\n", "3012": "class Solution {\n public:\n  int minimumArrayLength(vector<int>& nums) {\n    // Let the minimum number in the array `nums` be x.\n    // * If there exists any element nums[i] where nums[i] % x > 0, a new\n    //   minimum can be generated and all other numbers can be removed.\n    // * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    //   generated which cannot be removed. Therefore, the result will be\n    //   (frequency of x + 1) / 2.\n    const int minNum = ranges::min(nums);\n    if (ranges::any_of(nums, [minNum](int num) { return num % minNum > 0; }))\n      return 1;\n    return (ranges::count(nums, minNum) + 1) / 2;\n  }\n};\n", "3013": "class Solution {\n public:\n  long long minimumCost(vector<int>& nums, int k, int dist) {\n    // Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    // k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    long windowSum = 0;\n    multiset<int> selected;\n    multiset<int> candidates;\n\n    for (int i = 1; i <= dist + 1; ++i) {\n      windowSum += nums[i];\n      selected.insert(nums[i]);\n    }\n\n    windowSum = balance(windowSum, selected, candidates, k);\n    long minWindowSum = windowSum;\n\n    for (int i = dist + 2; i < nums.size(); ++i) {\n      const int outOfScope = nums[i - dist - 1];\n      if (selected.find(outOfScope) != selected.end()) {\n        windowSum -= outOfScope;\n        selected.erase(selected.find(outOfScope));\n      } else {\n        candidates.erase(candidates.find(outOfScope));\n      }\n      if (nums[i] < *selected.rbegin()) {  // nums[i] is a better number.\n        windowSum += nums[i];\n        selected.insert(nums[i]);\n      } else {\n        candidates.insert(nums[i]);\n      }\n      windowSum = balance(windowSum, selected, candidates, k);\n      minWindowSum = min(minWindowSum, windowSum);\n    }\n\n    return nums[0] + minWindowSum;\n  }\n\n private:\n  // Returns the updated `windowSum` by balancing the multiset `selected` to\n  // keep the top k - 1 numbers.\n  long balance(long windowSum, multiset<int>& selected,\n               multiset<int>& candidates, int k) {\n    while (selected.size() < k - 1) {\n      const int minCandidate = *candidates.begin();\n      windowSum += minCandidate;\n      selected.insert(minCandidate);\n      candidates.erase(candidates.find(minCandidate));\n    }\n    while (selected.size() > k - 1) {\n      const int maxSelected = *selected.rbegin();\n      windowSum -= maxSelected;\n      selected.erase(selected.find(maxSelected));\n      candidates.insert(maxSelected);\n    }\n    return windowSum;\n  }\n};\n", "3014": "class Solution {\n public:\n  int minimumPushes(string word) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : word)\n      ++count[c - 'a'];\n\n    ranges::sort(count, greater<>());\n\n    for (int i = 0; i < 26; ++i)\n      ans += count[i] * (i / 8 + 1);\n\n    return ans;\n  }\n};\n", "3015": "class Solution {\n public:\n  vector<int> countOfPairs(int n, int x, int y) {\n    if (x > y)\n      swap(x, y);\n\n    const int ringLen = y - x + 1;\n    const int leftLineLen = x - 1;\n    const int rightLineLen = n - y;\n\n    vector<int> ans(n);\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (int& freq : ans)\n      freq *= 2;\n    return ans;\n  }\n\n private:\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  vector<int> bothInRing(int n, int ringLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  vector<int> bothInTheSameLine(int n, int lineLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  vector<int> lineToRing(int n, int lineLen, int ringLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      const int maxInRingLen = min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      const int minInRingLen = max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  vector<int> lineToLine(int n, int x, int y, int leftLineLen,\n                         int rightLineLen) {\n    vector<int> res(n);\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      const int minInLeft = max(1, k - rightLineLen - (x < y));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  vector<int> addVectors(const vector<int>& a, const vector<int>& b) {\n    vector<int> res(a.size());\n    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());\n    return res;\n  };\n};\n", "3016": "class Solution {\n public:\n  // Same as 3014. Minimum Number of Pushes to Type Word I\n  int minimumPushes(string word) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : word)\n      ++count[c - 'a'];\n\n    ranges::sort(count, greater<>());\n\n    for (int i = 0; i < 26; ++i)\n      ans += count[i] * (i / 8 + 1);\n\n    return ans;\n  }\n};\n", "3017": "class Solution {\n public:\n  // Same as 3015. Count the Number of Houses at a Certain Distance I\n  vector<long long> countOfPairs(int n, int x, int y) {\n    if (x > y)\n      swap(x, y);\n\n    const int ringLen = y - x + 1;\n    const int leftLineLen = x - 1;\n    const int rightLineLen = n - y;\n\n    vector<long long> ans(n);\n    ans = addVectors(ans, bothInRing(n, ringLen));\n    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));\n    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));\n    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));\n    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));\n    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));\n    for (long long& freq : ans)\n      freq *= 2;\n    return ans;\n  }\n\n private:\n  // Returns the contribution from the scenario where two houses are located in\n  // the ring.\n  vector<long long> bothInRing(int n, int ringLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= (ringLen - 1) / 2; ++k)\n      res[k - 1] += ringLen;\n    if (ringLen % 2 == 0)\n      res[ringLen / 2 - 1] += ringLen / 2;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where two houses are either\n  // located in the left line [1, x) or the right line (y, n].\n  vector<long long> bothInTheSameLine(int n, int lineLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= lineLen; ++k)\n      res[k - 1] += lineLen - k;\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is either\n  // located in the left line [1, x) or the right line (y, n] and the other\n  // house is located in the cycle.\n  vector<long long> lineToRing(int n, int lineLen, int ringLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= lineLen + ringLen; ++k) {\n      // min(\n      //   at most k - 1 since we need to give 1 to the line,\n      //   at most ringLen / 2 since for length > ringLen / 2, it can always be\n      //     calculated as ringLen - ringLen / 2\n      // )\n      const int maxInRingLen = min(k - 1, ringLen / 2);\n      // max(at least 0, at lest k - lineLen)\n      const int minInRingLen = max(0, k - lineLen);\n      if (minInRingLen <= maxInRingLen) {\n        // Each ring length contributes 2 to the count due to the split of\n        // paths when entering the ring: One path traverses the upper half of\n        // the ring, and the other traverses the lower half.\n        // This is illustrated as follows:\n        //   Path 1: ... -- x -- (upper half of the ring)\n        //   Path 2: ... -- x -- (lower half of the ring)\n        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;\n        if (minInRingLen == 0)\n          // Subtract 1 since there's no split.\n          res[k - 1] -= 1;\n        if (maxInRingLen * 2 == ringLen)\n          // Subtract 1 since the following case only contribute one:\n          //   ... -- x -- (upper half of the ring) -- middle point\n          //   ... -- x -- (upper half of the ring) -- middle point\n          res[k - 1] -= 1;\n      }\n    }\n    return res;\n  }\n\n  // Returns the contribution from the scenario where one house is in the left\n  // line [1, x) and the other house is in the right line (y, n].\n  vector<long long> lineToLine(int n, int x, int y, int leftLineLen,\n                               int rightLineLen) {\n    vector<long long> res(n);\n    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {\n      // min(\n      //   at most leftLineLen,\n      //   at most k - 1 - (x < y) since we need to give 1 to the right line\n      //     and if x < y we need to give another 1 to \"x - y\".\n      // )\n      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));\n      // max(at least 1, at least k - rightLineLen - (x < y))\n      const int minInLeft = max(1, k - rightLineLen - (x < y));\n      if (minInLeft <= maxInLeft)\n        res[k - 1] += maxInLeft - minInLeft + 1;\n    }\n    return res;\n  }\n\n  vector<long long> addVectors(const vector<long long>& a,\n                               const vector<long long>& b) {\n    vector<long long> res(a.size());\n    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());\n    return res;\n  };\n};\n", "3018": "class Solution {\n public:\n  int maximumProcessableQueries(vector<int>& nums, vector<int>& queries) {\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    // removed after processing dp[i][j] queries\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int d = n - 1; d >= 0; --d) {\n      for (int i = 0; i < n; ++i) {\n        const int j = i + d;\n        if (j >= n)\n          continue;\n        if (i > 0)\n          // Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j],\n                         dp[i - 1][j] + (nums[i - 1] >= queries[dp[i - 1][j]]));\n        if (j + 1 < n)\n          // Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j],\n                         dp[i][j + 1] + (nums[j + 1] >= queries[dp[i][j + 1]]));\n        if (dp[i][j] == queries.size())\n          return queries.size();\n      }\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans = max(ans, dp[i][i] + (nums[i] >= queries[dp[i][i]]));\n\n    return ans;\n  }\n};\n", "3019": "class Solution {\n public:\n  int countKeyChanges(string s) {\n    int ans = 0;\n    for (int i = 1; i < s.length(); ++i)\n      if (tolower(s[i]) != tolower(s[i - 1]))\n        ++ans;\n    return ans;\n  }\n};\n", "302": "class Solution {\n public:\n  int minArea(vector<vector<char>>& image, int x, int y) {\n    const int x1 = firstAnyOne(image, 0, x, &rowAllZeros);\n    const int x2 = firstAllZeros(image, x + 1, image.size(), &rowAllZeros);\n    const int y1 = firstAnyOne(image, 0, y, &colAllZeros);\n    const int y2 = firstAllZeros(image, y + 1, image[0].size(), &colAllZeros);\n    return (x2 - x1) * (y2 - y1);\n  }\n\n private:\n  int firstAnyOne(const vector<vector<char>>& image, int l, int r,\n                  function<bool(const vector<vector<char>>&, int)> allZeros) {\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (allZeros(image, m))\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n\n  int firstAllZeros(const vector<vector<char>>& image, int l, int r,\n                    function<bool(const vector<vector<char>>&, int)> allZeros) {\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (allZeros(image, m))\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n\n  static bool rowAllZeros(const vector<vector<char>>& image, int rowIndex) {\n    return all_of(image[rowIndex].cbegin(), image[rowIndex].cend(),\n                  [](int pixel) { return pixel == '0'; });\n  }\n\n  static bool colAllZeros(const vector<vector<char>>& image, int colIndex) {\n    for (int i = 0; i < image.size(); ++i)\n      if (image[i][colIndex] == '1')\n        return false;\n    return true;\n  }\n};\n", "3020": "class Solution {\n public:\n  int maximumLength(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    int ans = count.contains(1) ? count[1] - (count[1] % 2 == 0) : 1;\n\n    for (const int num : nums) {\n      if (num == 1)\n        continue;\n      int length = 0;\n      long x = num;\n      while (x <= maxNum && count.contains(x) && count[x] >= 2) {\n        length += 2;\n        x *= x;\n      }\n      // x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      // The goal is to determine if we can insert x^k in the middle of the\n      // pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      // and decrease the length by 1.\n      ans = max(ans, length + (count.contains(x) ? 1 : -1));\n    }\n\n    return ans;\n  }\n};\n", "3021": "class Solution {\n public:\n  long long flowerGame(int n, int m) {\n    // Alice wins if x + y is odd, occurring when:\n    //   1. x is even and y is odd, or\n    //   2. y is even and x is odd.\n    const int xEven = n / 2;\n    const int yEven = m / 2;\n    const int xOdd = (n + 1) / 2;\n    const int yOdd = (m + 1) / 2;\n    return static_cast<long>(xEven) * yOdd + static_cast<long>(yEven) * xOdd;\n  }\n};\n", "3022": "class Solution {\n public:\n  int minOrAfterOperations(vector<int>& nums, int k) {\n    constexpr int kMaxBit = 30;\n    int ans = 0;\n    int prefixMask = 0;  // Grows like: 10000 -> 11000 -> ... -> 11111.\n\n    for (int i = kMaxBit; i >= 0; --i) {\n      // Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      // currently added bit within k operations. If it's impossible, then we\n      // add the i-th bit to the answer.\n      prefixMask |= 1 << i;\n      if (getMergeOps(nums, prefixMask, ans) > k)\n        ans |= 1 << i;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the number of merge operations to turn `prefixMask` to the target\n  // by ANDing `nums`.\n  int getMergeOps(const vector<int>& nums, int prefixMask, int target) {\n    int mergeOps = 0;\n    int ands = prefixMask;\n    for (const int num : nums) {\n      ands &= num;\n      if ((ands | target) == target)\n        ands = prefixMask;\n      else\n        ++mergeOps;  // Keep merging the next num.\n    }\n    return mergeOps;\n  }\n};\n", "3023": "/**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *  public:\n *   InfiniteStream(vector<int> bits);\n *   int next();\n * };\n */\n\nclass Solution {\n public:\n  int findPattern(InfiniteStream* stream, vector<int>& pattern) {\n    const vector<int> lps = getLPS(pattern);\n    int i = 0;    // stream's index\n    int j = 0;    // pattern's index\n    int bit = 0;  // the bit in the stream\n    bool readNext = false;\n    while (true) {\n      if (!readNext) {\n        bit = stream->next();\n        readNext = true;\n      }\n      if (bit == pattern[j]) {\n        ++i, readNext = false;\n        ++j;\n        if (j == pattern.size())\n          return i - j;\n      }\n      // Mismatch after j matches.\n      else if (j > 0) {\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i, readNext = false;\n      }\n    }\n    throw;\n  }\n\n private:\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const vector<int>& pattern) {\n    vector<int> lps(pattern.size());\n    for (int i = 1, j = 0; i < pattern.size(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3024": "class Solution {\n public:\n  string triangleType(vector<int>& nums) {\n    ranges::sort(nums);\n    if (nums[0] + nums[1] <= nums[2])\n      return \"none\";\n    if (nums[0] == nums[1] && nums[1] == nums[2])\n      return \"equilateral\";\n    if (nums[0] == nums[1] || nums[1] == nums[2])\n      return \"isosceles\";\n    return \"scalene\";\n  }\n};\n", "3025": "class Solution {\n public:\n  int numberOfPairs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    ranges::sort(points, ranges::less{}, [](const vector<int>& point) {\n      const int x = point[0];\n      const int y = point[1];\n      return pair<int, int>{x, -y};\n    });\n\n    for (int i = 0; i < points.size(); ++i) {\n      int maxY = INT_MIN;\n      for (int j = i + 1; j < points.size(); ++j)\n        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {\n          ++ans;\n          maxY = points[j][1];\n        }\n    }\n\n    return ans;\n  }\n};\n", "3026": "class Solution {\n public:\n  long long maximumSubarraySum(vector<int>& nums, int k) {\n    long ans = LONG_MIN;\n    long prefix = 0;\n    // {num: the minimum prefix sum excluding `num`}\n    unordered_map<int, long> numToMinPrefix;\n\n    for (const int num : nums) {\n      if (const auto it = numToMinPrefix.find(num);\n          it == numToMinPrefix.cend() || it->second > prefix) {\n        numToMinPrefix[num] = prefix;\n      }\n      prefix += num;\n      if (const auto it = numToMinPrefix.find(num + k);\n          it != numToMinPrefix.cend())\n        ans = max(ans, prefix - it->second);\n      if (const auto it = numToMinPrefix.find(num - k);\n          it != numToMinPrefix.cend())\n        ans = max(ans, prefix - it->second);\n    }\n\n    return ans == LONG_MIN ? 0 : ans;\n  }\n};\n", "3027": "class Solution {\n public:\n  // Same as 3025. Find the Number of Ways to Place People I\n  int numberOfPairs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    ranges::sort(points, ranges::less{}, [](const vector<int>& point) {\n      const int x = point[0];\n      const int y = point[1];\n      return pair<int, int>{x, -y};\n    });\n\n    for (int i = 0; i < points.size(); ++i) {\n      int maxY = INT_MIN;\n      for (int j = i + 1; j < points.size(); ++j)\n        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {\n          ++ans;\n          maxY = points[j][1];\n        }\n    }\n\n    return ans;\n  }\n};\n", "3028": "class Solution {\n public:\n  int returnToBoundaryCount(vector<int>& nums) {\n    partial_sum(nums.begin(), nums.end(), nums.begin());\n    return ranges::count(nums, 0);\n  }\n};\n", "3029": "class Solution {\n public:\n  // Same as 3029. Minimum Time to Revert Word to Initial State I\n  int minimumTimeToInitialState(string word, int k) {\n    const int n = word.length();\n    const int maxOps = (n - 1) / k + 1;\n    const vector<int> z = zFunction(word);\n    for (int ans = 1; ans < maxOps; ++ans)\n      if (z[ans * k] >= n - ans * k)\n        return ans;\n    return maxOps;\n  }\n\n  // Returns the z array, where z[i] is the length of the longest prefix of\n  // s[i..n) which is also a prefix of s.\n  //\n  // https://cp-algorithms.com/string/z-function.html#implementation\n  vector<int> zFunction(const string& s) {\n    const int n = s.length();\n    vector<int> z(n);\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l]);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n    return z;\n  }\n};\n", "303": "class NumArray {\n public:\n  NumArray(vector<int>& nums) : prefix(nums.size() + 1) {\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n  }\n\n  int sumRange(int left, int right) {\n    return prefix[right + 1] - prefix[left];\n  }\n\n private:\n  vector<int> prefix;\n};\n", "3030": "class Solution {\n public:\n  vector<vector<int>> resultGrid(vector<vector<int>>& image, int threshold) {\n    const int m = image.size();\n    const int n = image[0].size();\n    vector<vector<int>> sums(m, vector<int>(n));\n    vector<vector<int>> counts(m, vector<int>(n));\n\n    for (int i = 0; i < m - 2; ++i)\n      for (int j = 0; j < n - 2; ++j)\n        if (isRegion(image, i, j, threshold)) {\n          const int subgridSum = getSubgridSum(image, i, j);\n          for (int x = i; x < i + 3; ++x)\n            for (int y = j; y < j + 3; ++y) {\n              sums[x][y] += subgridSum / 9;\n              counts[x][y] += 1;\n            }\n        }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (counts[i][j] > 0)\n          image[i][j] = sums[i][j] / counts[i][j];\n\n    return image;\n  }\n\n private:\n  // Returns true if image[i..i + 2][j..j + 2] is a region.\n  bool isRegion(const vector<vector<int>>& image, int i, int j, int threshold) {\n    for (int x = i; x < i + 3; ++x)\n      for (int y = j; y < j + 3; ++y) {\n        if (x > i && abs(image[x][y] - image[x - 1][y]) > threshold)\n          return false;\n        if (y > j && abs(image[x][y] - image[x][y - 1]) > threshold)\n          return false;\n      }\n    return true;\n  }\n\n  // Returns the sum of image[i..i + 2][j..j + 2].\n  int getSubgridSum(const vector<vector<int>>& image, int i, int j) {\n    int subgridSum = 0;\n    for (int x = i; x < i + 3; ++x)\n      for (int y = j; y < j + 3; ++y)\n        subgridSum += image[x][y];\n    return subgridSum;\n  }\n};\n", "3031": "class Solution {\n public:\n  // Same as 3029. Minimum Time to Revert Word to Initial State I\n  int minimumTimeToInitialState(string word, int k) {\n    const int n = word.length();\n    const int maxOps = (n - 1) / k + 1;\n    const vector<int> z = zFunction(word);\n    for (int ans = 1; ans < maxOps; ++ans)\n      if (z[ans * k] >= n - ans * k)\n        return ans;\n    return maxOps;\n  }\n\n  // Returns the z array, where z[i] is the length of the longest prefix of\n  // s[i..n) which is also a prefix of s.\n  //\n  // https://cp-algorithms.com/string/z-function.html#implementation\n  vector<int> zFunction(const string& s) {\n    const int n = s.length();\n    vector<int> z(n);\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l]);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n    return z;\n  }\n};\n", "3032": "class Solution {\n public:\n  int numberCount(int a, int b) {\n    int ans = 0;\n    for (int num = a; num <= b; ++num)\n      if (isUniqueDigits(num))\n        ++ans;\n    return ans;\n  }\n\n private:\n  bool isUniqueDigits(int num) {\n    vector<bool> seen(10);\n    while (num > 0) {\n      const int digit = num % 10;\n      if (seen[digit])\n        return false;\n      seen[digit] = true;\n      num /= 10;\n    }\n    return true;\n  }\n};\n", "3033": "class Solution {\n public:\n  vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<vector<int>> ans = matrix;\n\n    for (int j = 0; j < n; ++j) {\n      int mx = 0;\n      for (int i = 0; i < m; ++i)\n        mx = max(mx, matrix[i][j]);\n      for (int i = 0; i < m; ++i)\n        if (matrix[i][j] == -1)\n          ans[i][j] = mx;\n    }\n\n    return ans;\n  }\n};\n", "3034": "class Solution {\n public:\n  int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n    const vector<int> numsPattern = getNumsPattern(nums);\n    return kmp(numsPattern, pattern);\n  }\n\n private:\n  int getNum(int a, int b) {\n    if (a < b)\n      return 1;\n    if (a > b)\n      return -1;\n    return 0;\n  }\n\n  vector<int> getNumsPattern(const vector<int>& nums) {\n    vector<int> numsPattern;\n    for (int i = 1; i < nums.size(); ++i)\n      numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n    return numsPattern;\n  }\n\n  // Returns the number of occurrences of the pattern in `nums`.\n  int kmp(const vector<int>& nums, const vector<int>& pattern) {\n    const vector<int> lps = getLPS(pattern);\n    int res = 0;\n    int i = 0;  // nums' index\n    int j = 0;  // pattern's index\n    while (i < nums.size()) {\n      if (nums[i] == pattern[j]) {\n        ++i;\n        ++j;\n        if (j == pattern.size()) {\n          ++res;\n          j = lps[j - 1];\n        }\n      } else if (j > 0) {  // Mismatch after j matches.\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i;\n      }\n    }\n    return res;\n  }\n\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const vector<int>& pattern) {\n    vector<int> lps(pattern.size());\n    for (int i = 1, j = 0; i < pattern.size(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3035": "class Solution {\n public:\n  int maxPalindromesAfterOperations(vector<string>& words) {\n    int ans = 0;\n    int pairs = getPairs(words);\n\n    for (const int length : getSortedLengths(words)) {\n      const int needPairs = length / 2;\n      if (pairs < needPairs)\n        return ans;\n      ++ans;\n      pairs -= needPairs;\n    }\n\n    return ans;\n  }\n\n private:\n  int getPairs(const vector<string>& words) {\n    int pairs = 0;\n    unordered_map<char, int> count;\n\n    for (const string& word : words)\n      for (const char c : word)\n        ++count[c];\n\n    for (const auto& [_, freq] : count)\n      pairs += freq / 2;\n\n    return pairs;\n  }\n\n  vector<int> getSortedLengths(const vector<string>& words) {\n    vector<int> lengths;\n    for (const string& word : words)\n      lengths.push_back(word.length());\n    ranges::sort(lengths);\n    return lengths;\n  }\n};\n", "3036": "class Solution {\n public:\n  // Same as 3034. Number of Subarrays That Match a Pattern I\n  int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n    const vector<int> numsPattern = getNumsPattern(nums);\n    return kmp(numsPattern, pattern);\n  }\n\n private:\n  int getNum(int a, int b) {\n    if (a < b)\n      return 1;\n    if (a > b)\n      return -1;\n    return 0;\n  }\n\n  vector<int> getNumsPattern(const vector<int>& nums) {\n    vector<int> numsPattern;\n    for (int i = 1; i < nums.size(); ++i)\n      numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n    return numsPattern;\n  }\n\n  // Returns the number of occurrences of the pattern in `nums`.\n  int kmp(const vector<int>& nums, const vector<int>& pattern) {\n    const vector<int> lps = getLPS(pattern);\n    int res = 0;\n    int i = 0;  // nums' index\n    int j = 0;  // pattern's index\n    while (i < nums.size()) {\n      if (nums[i] == pattern[j]) {\n        ++i;\n        ++j;\n        if (j == pattern.size()) {\n          ++res;\n          j = lps[j - 1];\n        }\n      } else if (j > 0) {  // Mismatch after j matches.\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i;\n      }\n    }\n    return res;\n  }\n\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const vector<int>& pattern) {\n    vector<int> lps(pattern.size());\n    for (int i = 1, j = 0; i < pattern.size(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3037": "/**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *  public:\n *   InfiniteStream(vector<int> bits);\n *   int next();\n * };\n */\n\nclass Solution {\n public:\n  // Same as 3023. Find Pattern in Infinite Stream I\n  int findPattern(InfiniteStream* stream, vector<int>& pattern) {\n    const vector<int> lps = getLPS(pattern);\n    int i = 0;    // stream's index\n    int j = 0;    // pattern's index\n    int bit = 0;  // the bit in the stream\n    bool readNext = false;\n    while (true) {\n      if (!readNext) {\n        bit = stream->next();\n        readNext = true;\n      }\n      if (bit == pattern[j]) {\n        ++i, readNext = false;\n        ++j;\n        if (j == pattern.size())\n          return i - j;\n      }\n      // Mismatch after j matches.\n      else if (j > 0) {\n        // Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1];\n      } else {\n        ++i, readNext = false;\n      }\n    }\n    throw;\n  }\n\n private:\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const vector<int>& pattern) {\n    vector<int> lps(pattern.size());\n    for (int i = 1, j = 0; i < pattern.size(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3038": "class Solution {\n public:\n  int maxOperations(vector<int>& nums) {\n    int ans = 1;\n    int sum = nums[0] + nums[1];\n\n    for (int i = 2; i + 1 < nums.size(); i += 2) {\n      if (nums[i] + nums[i + 1] == sum)\n        ++ans;\n      else\n        break;\n    }\n\n    return ans;\n  }\n};\n", "3039": "class Solution {\n public:\n  string lastNonEmptyString(string s) {\n    string ans;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    const int maxFreq = ranges::max(count);\n\n    for (int i = s.length() - 1; i >= 0; --i)\n      if (count[s[i] - 'a']-- == maxFreq)\n        ans += s[i];\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "304": "class NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix) {\n    if (matrix.empty())\n      return;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    // prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix.resize(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] =\n            matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] -\n           prefix[row2 + 1][col1] + prefix[row1][col1];\n  }\n\n private:\n  vector<vector<int>> prefix;\n};\n", "3040": "class Solution {\n public:\n  int maxOperations(vector<int>& nums) {\n    const int n = nums.size();\n    unordered_map<string, int> mem;\n    return max({maxOperations(nums, 0, n - 1, nums[0] + nums[1], mem),\n                maxOperations(nums, 0, n - 1, nums[n - 1] + nums[n - 2], mem),\n                maxOperations(nums, 0, n - 1, nums[0] + nums[n - 1], mem)});\n  }\n\n private:\n  // Returns the maximum number of operations that can be performed for\n  // nums[i..j], s.t. all operations have the same `score`.\n  int maxOperations(const vector<int>& nums, int i, int j, int score,\n                    unordered_map<string, int>& mem) {\n    if (i >= j)\n      return 0;\n    const string key = hash(i, j, score);\n    if (const auto it = mem.find(key); it != mem.end())\n      return it->second;\n    const int deleteFirstTwo =\n        nums[i] + nums[i + 1] == score\n            ? 1 + maxOperations(nums, i + 2, j, score, mem)\n            : 0;\n    const int deleteLastTwo =\n        nums[j] + nums[j - 1] == score\n            ? 1 + maxOperations(nums, i, j - 2, score, mem)\n            : 0;\n    const int deleteFirstAndLast =\n        nums[i] + nums[j] == score\n            ? 1 + maxOperations(nums, i + 1, j - 1, score, mem)\n            : 0;\n    return mem[key] = max({deleteFirstTwo, deleteLastTwo, deleteFirstAndLast});\n  }\n\n  string hash(int i, int j, int score) {\n    return to_string(i) + \",\" + to_string(j) + \",\" + to_string(score);\n  }\n};\n", "3041": "class Solution {\n public:\n  int maxSelectedElements(vector<int>& nums) {\n    int ans = 1;\n    int prev = INT_MIN;\n    // the length of the longest consecutive elements (seq0) ending in the\n    // previous number\n    int dp0 = 1;\n    // the length of the longest consecutive elements (seq1) ending in the\n    // previous number + 1\n    int dp1 = 1;\n\n    ranges::sort(nums);\n\n    for (const int num : nums) {\n      if (num == prev) {\n        dp1 = dp0 + 1;  // Append `num + 1` to seq0.\n      } else if (num == prev + 1) {\n        ++dp0;  // Append `num` to seq0.\n        ++dp1;  // Add 1 to every number in seq0 and append `num + 1` to seq0.\n      } else if (num == prev + 2) {\n        dp0 = dp1 + 1;  // Append `num` to seq1.\n        dp1 = 1;        // Start a new sequence [`num + 1`].\n      } else {\n        dp0 = 1;  // Start a new sequence [`num`].\n        dp1 = 1;  // Start a new sequence [`num + 1`].\n      }\n      ans = max({ans, dp0, dp1});\n      prev = num;\n    }\n\n    return ans;\n  }\n};\n", "3042": "struct TrieNode {\n  unordered_map<int, shared_ptr<TrieNode>> children;\n  int count = 0;\n};\n\nclass Trie {\n public:\n  int insert(const string& word) {\n    const int n = word.length();\n    int count = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = 0; i < n; ++i) {\n      const int j = hash(word[i], word[n - 1 - i]);\n      if (node->children[j] == nullptr)\n        node->children[j] = make_shared<TrieNode>();\n      node = node->children[j];\n      count += node->count;\n    }\n    ++node->count;\n    return count;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  static int hash(char prefix, char suffix) {\n    return 26 * (prefix - 'a') + (suffix - 'a');\n  }\n};\n\nclass Solution {\n public:\n  long long countPrefixSuffixPairs(vector<string>& words) {\n    long ans = 0;\n    Trie trie;\n\n    for (const string& word : words)\n      ans += trie.insert(word);\n\n    return ans;\n  }\n};\n", "3043": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(10) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - '0';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n  }\n\n  int search(const string& word) {\n    int prefixLength = 0;\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - '0';\n      if (node->children[i] == nullptr)\n        break;\n      node = node->children[i];\n      ++prefixLength;\n    }\n    return prefixLength;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {\n    int ans = 0;\n    Trie trie;\n\n    for (const int num : arr1)\n      trie.insert(to_string(num));\n\n    for (const int num : arr2)\n      ans = max(ans, trie.search(to_string(num)));\n\n    return ans;\n  }\n};\n", "3044": "class Solution {\n public:\n  int mostFrequentPrime(vector<vector<int>>& mat) {\n    constexpr int kDirs[8][2] = {{1, 0},  {1, -1}, {0, -1}, {-1, -1},\n                                 {-1, 0}, {-1, 1}, {0, 1},  {1, 1}};\n    const int m = mat.size();\n    const int n = mat[0].size();\n    int ans = -1;\n    int maxFreq = 0;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (const auto& [dx, dy] : kDirs) {\n          int num = 0;\n          for (int x = i, y = j; 0 <= x && x < m && 0 <= y && y < n;\n               x += dx, y += dy) {\n            num = num * 10 + mat[x][y];\n            if (num > 10 && isPrime(num))\n              ++count[num];\n          }\n        }\n\n    for (const auto& [prime, freq] : count)\n      if (freq > maxFreq) {\n        ans = prime;\n        maxFreq = freq;\n      } else if (freq == maxFreq) {\n        ans = max(ans, prime);\n      }\n\n    return ans;\n  }\n\n private:\n  bool isPrime(int num) {\n    for (int i = 2; i < sqrt(num) + 1; ++i)\n      if (num % i == 0)\n        return false;\n    return true;\n  }\n};\n", "3045": "struct TrieNode {\n  unordered_map<int, shared_ptr<TrieNode>> children;\n  int count = 0;\n};\n\nclass Trie {\n public:\n  int insert(const string& word) {\n    const int n = word.length();\n    int count = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = 0; i < n; ++i) {\n      const int j = hash(word[i], word[n - 1 - i]);\n      if (node->children[j] == nullptr)\n        node->children[j] = make_shared<TrieNode>();\n      node = node->children[j];\n      count += node->count;\n    }\n    ++node->count;\n    return count;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  static int hash(char prefix, char suffix) {\n    return 26 * (prefix - 'a') + (suffix - 'a');\n  }\n};\n\nclass Solution {\n public:\n  // Same as 3042. Count Prefix and Suffix Pairs I\n  long long countPrefixSuffixPairs(vector<string>& words) {\n    long ans = 0;\n    Trie trie;\n\n    for (const string& word : words)\n      ans += trie.insert(word);\n\n    return ans;\n  }\n};\n", "3046": "class Solution {\n public:\n  bool isPossibleToSplit(vector<int>& nums) {\n    constexpr int kMax = 100;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    return ranges::all_of(count, [](int freq) { return freq <= 2; });\n  }\n};\n", "3047": "class Solution {\n public:\n  long long largestSquareArea(vector<vector<int>>& bottomLeft,\n                              vector<vector<int>>& topRight) {\n    int minSide = 0;\n\n    for (int i = 0; i < bottomLeft.size(); ++i)\n      for (int j = i + 1; j < bottomLeft.size(); ++j) {\n        const int ax1 = bottomLeft[i][0];\n        const int ay1 = bottomLeft[i][1];\n        const int ax2 = topRight[i][0];\n        const int ay2 = topRight[i][1];\n        const int bx1 = bottomLeft[j][0];\n        const int by1 = bottomLeft[j][1];\n        const int bx2 = topRight[j][0];\n        const int by2 = topRight[j][1];\n        const int overlapX = min(ax2, bx2) - max(ax1, bx1);\n        const int overlapY = min(ay2, by2) - max(ay1, by1);\n        minSide = max(minSide, min(overlapX, overlapY));\n      }\n\n    return static_cast<long>(minSide) * minSide;\n  }\n};\n", "3048": "class Solution {\n public:\n  int earliestSecondToMarkIndices(vector<int>& nums,\n                                  vector<int>& changeIndices) {\n    int l = 0;\n    int r = changeIndices.size() + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (canMark(nums, changeIndices, m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l <= changeIndices.size() ? l : -1;\n  }\n\n private:\n  // Returns true if all indices of `nums` can be marked within `second`.\n  bool canMark(const vector<int>& nums, const vector<int>& changeIndices,\n               int second) {\n    int numMarked = 0;\n    int decrement = 0;\n    // indexToLastSecond[i] := the last second to mark the index i\n    vector<int> indexToLastSecond(nums.size(), -1);\n\n    for (int i = 0; i < second; ++i)\n      indexToLastSecond[changeIndices[i] - 1] = i;\n\n    for (int i = 0; i < second; ++i) {\n      const int index = changeIndices[i] - 1;  // Convert to 0-indexed.\n      if (i == indexToLastSecond[index]) {\n        // Reach the last occurrence of the number.\n        // So, the current second will be used to mark the index.\n        if (nums[index] > decrement)\n          // The decrement is less than the number to be marked.\n          return false;\n        decrement -= nums[index];\n        ++numMarked;\n      } else {\n        ++decrement;\n      }\n    }\n\n    return numMarked == nums.size();\n  }\n};\n", "3049": "class Solution {\n public:\n  int earliestSecondToMarkIndices(vector<int>& nums,\n                                  vector<int>& changeIndices) {\n    const long numsSum = accumulate(nums.begin(), nums.end(), 0L);\n    // {the second: the index of nums can be zeroed at the current second}\n    const unordered_map<int, int> secondToIndex =\n        getSecondToIndex(nums, changeIndices);\n    int l = 0;\n    int r = changeIndices.size() + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (canMark(nums, secondToIndex, m, numsSum))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l <= changeIndices.size() ? l : -1;\n  }\n\n private:\n  // Returns true if all indices of `nums` can be marked within `maxSecond`.\n  bool canMark(const vector<int>& nums,\n               const unordered_map<int, int>& secondToIndex, int maxSecond,\n               const long numsSum) {\n    // Use a min-heap to greedily pop out the minimum number, which yields the\n    // least saving.\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int marks = 0;\n\n    for (int second = maxSecond - 1; second >= 0; --second) {\n      if (const auto it = secondToIndex.find(second);\n          it != secondToIndex.end()) {\n        // The number mapped by the index is a candidate to be zeroed out.\n        const int index = it->second;\n        minHeap.push(nums[index]);\n        if (marks == 0) {\n          // Running out of marks, so need to pop out the minimum number.\n          // So, the current second will be used to mark an index.\n          minHeap.pop();\n          ++marks;\n        } else {\n          // There're enough marks.\n          // So, the current second will be used to zero out a number.\n          --marks;\n        }\n      } else {\n        // There's no candidate to be zeroed out.\n        // So, the current second will be used to mark an index.\n        ++marks;\n      }\n    }\n\n    const int heapSize = minHeap.size();\n    const long decrementAndMarkCost =\n        numsSum - getHeapSum(minHeap) + (nums.size() - heapSize);\n    const long zeroAndMarkCost = heapSize + heapSize;\n    return decrementAndMarkCost + zeroAndMarkCost <= maxSecond;\n  }\n\n  long getHeapSum(priority_queue<int, vector<int>, greater<int>>& heap) {\n    long heapSum = 0;\n    while (!heap.empty())\n      heapSum += heap.top(), heap.pop();\n    return heapSum;\n  }\n\n  unordered_map<int, int> getSecondToIndex(const vector<int>& nums,\n                                           const vector<int>& changeIndices) {\n    // {the `index` of nums: the earliest second to zero out nums[index]}\n    unordered_map<int, int> indexToFirstSecond;\n    unordered_map<int, int> secondToIndex;\n    for (int zeroIndexedSecond = 0; zeroIndexedSecond < changeIndices.size();\n         ++zeroIndexedSecond) {\n      // Convert to 0-indexed.\n      const int index = changeIndices[zeroIndexedSecond] - 1;\n      if (nums[index] > 0 && !indexToFirstSecond.contains(index))\n        indexToFirstSecond[index] = zeroIndexedSecond;\n    }\n    for (const auto& [index, second] : indexToFirstSecond)\n      secondToIndex[second] = index;\n    return secondToIndex;\n  }\n};\n", "305": "class UnionFind {\n public:\n  vector<int> id;\n\n  UnionFind(int n) : id(n, -1), rank(n) {}\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<int> ans;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    UnionFind uf(m * n);\n    int count = 0;\n\n    for (const vector<int>& p : positions) {\n      const int i = p[0];\n      const int j = p[1];\n      if (seen[i][j]) {\n        ans.push_back(count);\n        continue;\n      }\n      seen[i][j] = true;\n      const int id = getId(i, j, n);\n      uf.id[id] = id;\n      ++count;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int neighborId = getId(x, y, n);\n        if (uf.id[neighborId] == -1)  // water\n          continue;\n        const int currentRoot = uf.find(id);\n        const int neighborRoot = uf.find(neighborId);\n        if (currentRoot != neighborRoot) {\n          uf.unionByRank(currentRoot, neighborRoot);\n          --count;\n        }\n      }\n      ans.push_back(count);\n    }\n\n    return ans;\n  }\n\n private:\n  int getId(int i, int j, int n) {\n    return i * n + j;\n  }\n};\n", "306": "class Solution {\n public:\n  bool isAdditiveNumber(string num) {\n    const int n = num.length();\n\n    // num[0..i] = firstNum\n    for (int i = 0; i < n / 2; ++i) {\n      if (i > 0 && num[0] == '0')\n        return false;\n      const long firstNum = stol(num.substr(0, i + 1));\n      // num[i + 1..j] = secondNum\n      // |thirdNum| >= max(|firstNum|, |secondNum|)\n      for (int j = i + 1; max(i, j - i) < n - j; ++j) {\n        if (j > i + 1 && num[i + 1] == '0')\n          break;\n        const long secondNum = stol(num.substr(i + 1, j - i));\n        if (dfs(num, firstNum, secondNum, j + 1))\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n private:\n  bool dfs(const string& num, long firstNum, long secondNum, long s) {\n    if (s == num.length())\n      return true;\n\n    const long thirdNum = firstNum + secondNum;\n    const string& thirdNumStr = to_string(thirdNum);\n    return num.find(thirdNumStr, s) == s &&\n           dfs(num, secondNum, thirdNum, s + thirdNumStr.length());\n  }\n};\n", "3062": "class Solution {\n public:\n  string gameResult(ListNode* head) {\n    int even = 0;\n    int odd = 0;\n\n    while (head != nullptr) {\n      if (head->val > head->next->val)\n        ++even;\n      else if (head->val < head->next->val)\n        ++odd;\n      head = head->next->next;\n    }\n\n    if (even > odd)\n      return \"Even\";\n    if (even < odd)\n      return \"Odd\";\n    return \"Tie\";\n  }\n};\n", "3063": "class Solution {\n public:\n  ListNode* frequenciesOfElements(ListNode* head) {\n    unordered_map<int, int> count;\n    ListNode* curr = head;\n\n    while (curr != nullptr) {\n      ++count[curr->val];\n      curr = curr->next;\n    }\n\n    ListNode dummy(0);\n    ListNode* tail = &dummy;\n\n    for (const auto& [_, freq] : count) {\n      tail->next = new ListNode(freq);\n      tail = tail->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "3064": "/**\n * Definition of commonSetBits API.\n * int commonSetBits(int num);\n */\n\nclass Solution {\n public:\n  int findNumber() {\n    constexpr int kMaxBit = 30;\n    int ans = 0;\n    for (int i = 0; i <= kMaxBit; ++i)\n      if (commonSetBits(1 << i) == 1)\n        ans |= 1 << i;\n    return ans;\n  }\n};\n", "3065": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int k) {\n    return ranges::count_if(nums, [k](int num) { return num < k; });\n  }\n};\n", "3066": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int k) {\n    int ans = 0;\n    priority_queue<long, vector<long>, greater<>> minHeap;\n\n    for (const int num : nums)\n      minHeap.push(num);\n\n    while (minHeap.size() > 1 && minHeap.top() < k) {\n      const int x = minHeap.top();\n      minHeap.pop();\n      const int y = minHeap.top();\n      minHeap.pop();\n      minHeap.push(min(x, y) * 2L + max(x, y));\n      ++ans;\n    }\n\n    return ans;\n  }\n};\n", "3067": "class Solution {\n public:\n  vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges,\n                                             int signalSpeed) {\n    const int n = edges.size() + 1;\n    vector<int> ans;\n    vector<vector<pair<int, int>>> tree(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      tree[u].emplace_back(v, w);\n      tree[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans.push_back(connectablePairsRootedAt(tree, i, signalSpeed));\n\n    return ans;\n  }\n\n private:\n  // Returns the number of server pairs that are connectable through the server\n  // `u`.\n  int connectablePairsRootedAt(const vector<vector<pair<int, int>>>& tree,\n                               int u, int signalSpeed) {\n    int pairs = 0;\n    int count = 0;\n    for (const auto& [v, w] : tree[u]) {\n      const int childCount = dfs(tree, v, u, w, signalSpeed);\n      pairs += count * childCount;\n      count += childCount;\n    }\n    return pairs;\n  }\n\n  // Returns the number of servers that are connectable throught the server `u`\n  // (dist % signalSpeed == 0).\n  int dfs(const vector<vector<pair<int, int>>>& tree, int u, int prev, int dist,\n          int signalSpeed) {\n    int count = 0;\n    for (const auto& [v, w] : tree[u])\n      if (v != prev)\n        count += dfs(tree, v, u, dist + w, signalSpeed);\n    return (dist % signalSpeed == 0 ? 1 : 0) + count;\n  }\n};\n", "3068": "class Solution {\n public:\n  long long maximumValueSum(vector<int>& nums, int k,\n                            vector<vector<int>>& edges) {\n    long maxSum = 0;\n    int changedCount = 0;\n    int minChangeDiff = INT_MAX;\n\n    for (const int num : nums) {\n      maxSum += max(num, num ^ k);\n      changedCount += ((num ^ k) > num) ? 1 : 0;\n      minChangeDiff = min(minChangeDiff, abs(num - (num ^ k)));\n    }\n\n    if (changedCount % 2 == 0)\n      return maxSum;\n    return maxSum - minChangeDiff;\n  }\n};\n", "3069": "class Solution {\n public:\n  vector<int> resultArray(vector<int>& nums) {\n    vector<int> arr1{nums[0]};\n    vector<int> arr2{nums[1]};\n\n    for (int i = 2; i < nums.size(); i++)\n      if (arr1.back() > arr2.back())\n        arr1.push_back(nums[i]);\n      else\n        arr2.push_back(nums[i]);\n\n    arr1.insert(arr1.end(), arr2.begin(), arr2.end());\n    return arr1;\n  }\n};\n", "307": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = nums[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass NumArray {\n public:\n  NumArray(vector<int>& nums) : tree(nums) {}\n\n  void update(int index, int val) {\n    tree.update(index, val);\n  }\n\n  int sumRange(int left, int right) {\n    return tree.query(left, right);\n  }\n\n private:\n  SegmentTree tree;\n};\n", "3070": "class Solution {\n public:\n  int countSubmatrices(vector<vector<int>>& grid, int k) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        prefix[i + 1][j + 1] =\n            grid[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n        if (prefix[i + 1][j + 1] <= k)\n          ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3071": "class Solution {\n public:\n  int minimumOperationsToWriteY(vector<vector<int>>& grid) {\n    return min({getOperations(grid, 0, 1), getOperations(grid, 0, 2),\n                getOperations(grid, 1, 0), getOperations(grid, 1, 2),\n                getOperations(grid, 2, 0), getOperations(grid, 2, 1)});\n  }\n\n private:\n  // Returns the number of operations to turn Y into a and non-Y into b.\n  int getOperations(const vector<vector<int>>& grid, int a, int b) {\n    const int n = grid.size();\n    const int mid = n / 2;\n    int operations = 0;\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        // For the 'Y' pattern, before the midpoint, check the diagonal and\n        // anti-diagonal. After the midpoint, check the middle column.\n        if ((i < mid && (i == j || i + j == n - 1)) || (i >= mid && j == mid)) {\n          if (grid[i][j] != a)\n            ++operations;\n        } else if (grid[i][j] != b) {\n          ++operations;\n        }\n    return operations;\n  };\n};\n", "3072": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> resultArray(vector<int>& nums) {\n    vector<int> arr1;\n    vector<int> arr2;\n    const unordered_map<int, int> ranks = getRanks(nums);\n    FenwickTree tree1(ranks.size());\n    FenwickTree tree2(ranks.size());\n\n    add(nums[0], arr1, tree1, ranks);\n    add(nums[1], arr2, tree2, ranks);\n\n    for (int i = 2; i < nums.size(); ++i) {\n      const int greaterCount1 = arr1.size() - tree1.get(ranks.at(nums[i]));\n      const int greaterCount2 = arr2.size() - tree2.get(ranks.at(nums[i]));\n      if (greaterCount1 > greaterCount2)\n        add(nums[i], arr1, tree1, ranks);\n      else if (greaterCount1 < greaterCount2)\n        add(nums[i], arr2, tree2, ranks);\n      else if (arr1.size() > arr2.size())\n        add(nums[i], arr2, tree2, ranks);\n      else\n        add(nums[i], arr1, tree1, ranks);\n    }\n\n    arr1.insert(arr1.end(), arr2.begin(), arr2.end());\n    return arr1;\n  }\n\n private:\n  unordered_map<int, int> getRanks(const vector<int>& nums) {\n    unordered_map<int, int> ranks;\n    set<int> sorted(nums.begin(), nums.end());\n    int rank = 0;\n    for (const int num : sorted)\n      ranks[num] = ++rank;\n    return ranks;\n  }\n\n  void add(int num, vector<int>& arr, FenwickTree& tree,\n           const unordered_map<int, int>& ranks) {\n    arr.push_back(num);\n    tree.add(ranks.at(num), 1);\n  };\n};\n", "3073": "class Solution {\n public:\n  int maximumTripletValue(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    vector<int> rightMax(n);  // rightMax[i] := max(nums[i + 1..n))\n    set<int> leftSortedSet{nums[0]};\n\n    for (int i = n - 2; i >= 0; --i)\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1]);\n\n    for (int j = 1; j < n - 1; ++j) {\n      if (const auto it = leftSortedSet.lower_bound(nums[j]);\n          it != leftSortedSet.begin() && rightMax[j] > nums[j])\n        ans = max(ans, *prev(it) - nums[j] + rightMax[j]);\n\n      leftSortedSet.insert(nums[j]);\n    }\n\n    return ans;\n  }\n};\n", "3074": "class Solution {\n public:\n  int minimumBoxes(vector<int>& apple, vector<int>& capacity) {\n    const int appleSum = accumulate(apple.begin(), apple.end(), 0);\n    int capacitySum = 0;\n\n    ranges::sort(capacity, greater<>());\n\n    for (int i = 0; i < capacity.size(); ++i) {\n      capacitySum += capacity[i];\n      if (capacitySum >= appleSum)\n        return i + 1;\n    }\n\n    return capacity.size();\n  }\n};\n", "3075": "class Solution {\n public:\n  long long maximumHappinessSum(vector<int>& happiness, int k) {\n    long ans = 0;\n    int decremented = 0;\n\n    ranges::sort(happiness, greater<>());\n\n    for (int i = 0; i < k; ++i) {\n      ans += max(0, happiness[i] - decremented);\n      ++decremented;\n    }\n\n    return ans;\n  }\n};\n", "3076": "class Solution {\n public:\n  vector<string> shortestSubstrings(vector<string>& arr) {\n    vector<string> ans;\n    unordered_map<string, int> count;\n\n    for (const string& s : arr) {\n      add(s, count);\n    }\n\n    for (const string& s : arr) {\n      remove(s, count);\n      ans.push_back(getMinSub(s, count));\n      add(s, count);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<string> getSubstrings(const string& s) {\n    vector<string> substrings;\n    for (int i = 0; i < s.length(); ++i)\n      for (int j = i + 1; j <= s.length(); ++j)\n        substrings.push_back(s.substr(i, j - i));\n    return substrings;\n  }\n\n  void add(const string& s, unordered_map<string, int>& count) {\n    for (const string& sub : getSubstrings(s))\n      ++count[sub];\n  }\n\n  void remove(const string& s, unordered_map<string, int>& count) {\n    for (const string& sub : getSubstrings(s))\n      --count[sub];\n  }\n\n  string getMinSub(const string& s, const unordered_map<string, int>& count) {\n    string minSub;\n    for (const string& sub : getSubstrings(s)) {\n      if (count.at(sub) > 0)\n        continue;\n      if (minSub.empty() || sub.length() < minSub.length() ||\n          sub.length() == minSub.length() && sub < minSub)\n        minSub = sub;\n    }\n    return minSub;\n  }\n};\n", "3077": "class Solution {\n public:\n  long long maximumStrength(vector<int>& nums, int k) {\n    vector<vector<vector<long>>> mem(\n        nums.size(), vector<vector<long>>(k + 1, vector<long>(2, -1)));\n    return maximumStrength(nums, 0, k, /*fresh=*/true, mem);\n  }\n\n private:\n  static constexpr long kMin = LONG_MIN / 2;\n\n  // Returns the maximum strength of nums[i..n) with k operations left, where\n  // `fresh` means we're starting a new subarray.\n  long maximumStrength(const vector<int>& nums, int i, int k, bool fresh,\n                       vector<vector<vector<long>>>& mem) {\n    if (nums.size() - i < k)\n      return kMin;\n    if (k == 0)\n      return 0;\n    if (i == nums.size())\n      return k == 0 ? 0 : kMin;\n    if (mem[i][k][fresh] != -1)\n      return mem[i][k][fresh];\n    // If it's not fresh, we can't skip the current number and consider it as a\n    // fresh start, since the case where it's fresh is already covered by\n    // `includeAndFreshStart`.\n    const long skip = fresh ? maximumStrength(nums, i + 1, k, true, mem) : kMin;\n    const long gain = (k % 2 == 0 ? -1 : 1) * static_cast<long>(nums[i]) * k;\n    const long includeAndContinue =\n        maximumStrength(nums, i + 1, k, false, mem) + gain;\n    const long includeAndFreshStart =\n        maximumStrength(nums, i + 1, k - 1, true, mem) + gain;\n    return mem[i][k][fresh] =\n               max(skip, max(includeAndContinue, includeAndFreshStart));\n  }\n};\n", "3078": "class Solution {\n public:\n  vector<int> findPattern(vector<vector<int>>& board, vector<string>& pattern) {\n    for (int x = 0; x < board.size() - pattern.size() + 1; ++x)\n      for (int y = 0; y < board[0].size() - pattern[0].size() + 1; ++y)\n        if (isMatch(board, x, y, pattern))\n          return {x, y};\n    return {-1, -1};\n  }\n\n private:\n  bool isMatch(const vector<vector<int>>& board, int x, int y,\n               const vector<string>& pattern) {\n    unordered_map<int, char> digitToLetter;\n    unordered_map<char, int> letterToDigit;\n    for (int i = 0; i < pattern.size(); ++i)\n      for (int j = 0; j < pattern[i].size(); ++j) {\n        const int digit = board[i + x][j + y];\n        const char c = pattern[i][j];\n        if (isdigit(c)) {\n          if (c - '0' != digit)\n            return false;\n        } else {\n          if (const auto it = digitToLetter.find(digit);\n              it != digitToLetter.end() && it->second != c)\n            return false;\n          if (const auto it = letterToDigit.find(c);\n              it != letterToDigit.end() && it->second != digit)\n            return false;\n          digitToLetter[digit] = c;\n          letterToDigit[c] = digit;\n        }\n      }\n    return true;\n  }\n};\n", "3079": "class Solution {\n public:\n  int sumOfEncryptedInt(vector<int>& nums) {\n    int ans = 0;\n\n    for (const int num : nums) {\n      int maxDigit = 0;\n      int base = 0;\n      for (int x = num; x > 0; x /= 10) {\n        maxDigit = max(maxDigit, x % 10);\n        base = base * 10 + 1;\n      }\n      ans += base * maxDigit;\n    }\n\n    return ans;\n  }\n};\n", "308": "class FenwickTree {\n public:\n  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}\n\n  void add(int row, int col, int delta) {\n    for (int i = row; i < sums.size(); i += lowbit(i))\n      for (int j = col; j < sums[0].size(); j += lowbit(j))\n        sums[i][j] += delta;\n  }\n\n  int get(int row, int col) {\n    int sum = 0;\n    for (int i = row; i > 0; i -= lowbit(i))\n      for (int j = col; j > 0; j -= lowbit(j))\n        sum += sums[i][j];\n    return sum;\n  }\n\n private:\n  vector<vector<int>> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix)\n      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        tree.add(i + 1, j + 1, matrix[i][j]);\n  }\n\n  void update(int row, int col, int val) {\n    tree.add(row + 1, col + 1, val - matrix[row][col]);\n    matrix[row][col] = val;\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -\n           tree.get(row2 + 1, col1) + tree.get(row1, col1);\n  }\n\n private:\n  vector<vector<int>> matrix;\n  FenwickTree tree;\n};\n", "3080": "class Solution {\n public:\n  vector<long long> unmarkedSumArray(vector<int>& nums,\n                                     vector<vector<int>>& queries) {\n    vector<long long> ans;\n    vector<bool> marked(nums.size());\n    long sum = accumulate(nums.begin(), nums.end(), 0L);\n    using P = pair<int, int>;  // (nums[i], i)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    for (int i = 0; i < nums.size(); ++i)\n      minHeap.emplace(nums[i], i);\n\n    for (const vector<int>& query : queries) {\n      const int index = query[0];\n      const int k = query[1];\n      if (!marked[index]) {\n        marked[index] = true;\n        sum -= nums[index];\n      }\n      for (int popped = 0; popped < k && !minHeap.empty();) {\n        const auto [num, i] = minHeap.top();\n        minHeap.pop();\n        if (!marked[i]) {\n          marked[i] = true;\n          sum -= num;\n          ++popped;\n        }\n      }\n      ans.push_back(sum);\n    }\n\n    return ans;\n  }\n};\n", "3081": "class Solution {\n public:\n  string minimizeStringValue(string s) {\n    string ans;\n    vector<int> count(26);\n    vector<char> letters;\n\n    for (const char c : s)\n      if (c != '?')\n        ++count[c - 'a'];\n\n    for (const char c : s) {\n      if (c != '?')\n        continue;\n      const char minFreqLetter = getMinFreqLetter(count);\n      letters.push_back(minFreqLetter);\n      ++count[minFreqLetter - 'a'];\n    }\n\n    ranges::sort(letters);\n    int i = 0;  // letters' index\n\n    for (const char c : s)\n      ans += c == '?' ? letters[i++] : c;\n\n    return ans;\n  }\n\n private:\n  char getMinFreqLetter(const vector<int>& count) {\n    char minFreqLetter = 'a';\n    for (char c = 'b'; c <= 'z'; ++c)\n      if (count[c - 'a'] < count[minFreqLetter - 'a'])\n        minFreqLetter = c;\n    return minFreqLetter;\n  }\n};\n", "3082": "class Solution {\n public:\n  int sumOfPower(vector<int>& nums, int k) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    // dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n      const int num = nums[i - 1];\n      for (int j = 0; j <= k; ++j)\n        if (j < num)\n          // 1. Exclude nums[i] in the subsequence.\n          // 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2L) % kMod;\n        else\n          // 1. Exclude nums[i] in the subsequence.\n          // 2. Include nums[i] in the subsequence and skip it.\n          // 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2L + dp[i - 1][j - num]) % kMod;\n    }\n\n    return dp[n][k];\n  }\n};\n", "3083": "class Solution {\n public:\n  bool isSubstringPresent(string s) {\n    const string reversed = {s.rbegin(), s.rend()};\n    for (int i = 0; i + 2 <= s.length(); ++i)\n      if (reversed.find(s.substr(i, 2)) != string::npos)\n        return true;\n    return false;\n  }\n};\n", "3084": "class Solution {\n public:\n  long long countSubstrings(string s, char c) {\n    const int freq = ranges::count(s, c);\n    return static_cast<long>(freq) * (freq + 1) / 2;\n  }\n};\n", "3085": "class Solution {\n public:\n  int minimumDeletions(string word, int k) {\n    int ans = INT_MAX;\n    vector<int> count(26);\n\n    for (const char c : word)\n      ++count[c - 'a'];\n\n    for (const int minFreq : count) {\n      int deletions = 0;\n      for (const int freq : count)\n        if (freq < minFreq)  // Delete all the letters with smaller frequency.\n          deletions += freq;\n        else  // Delete letters with exceeding frequency.\n          deletions += max(0, freq - (minFreq + k));\n      ans = min(ans, deletions);\n    }\n\n    return ans;\n  }\n};\n", "3086": "class Solution {\n public:\n  long long minimumMoves(vector<int>& nums, int k, int maxChanges) {\n    // Dylan has two actions for collecting '1's in a sequence:\n    // Action 1: Put a '1' next to him and pick it up.\n    //           The cost is 2.\n    // Action 2: Swap a '1' towards him and collect it.\n    //           The cost equals the distance to the '1'.\n    //\n    // To minimize the swapping cost, Dylan can use a sliding window strategy,\n    // selecting the optimal position (middle '1' in the window) for efficient\n    // collection. The window's size is crucial:\n\n    // The minimum window size: min(0, k - maxChanges), ensuring the window\n    // isn't too small.\n    // The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    // preventing overly ambitious swaps.\n    //\n    // Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    // cheaper to use Action 1.\n\n    // At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    // a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    // `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    // should be replaced with Action 1.\n    constexpr int kNumOfIndicesWithinOneDistance = 3;\n    long ans = LONG_MAX;\n    vector<int> oneIndices;  // the indices of 1s\n    vector<long> prefix{0};  // the accumulated indices of 1s\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == 1)\n        oneIndices.push_back(i);\n\n    for (const int oneIndex : oneIndices)\n      prefix.push_back(prefix.back() + oneIndex);\n\n    const int minOnesByTwo = max(0, k - maxChanges);\n    const int maxOnesByTwo =\n        min({k, minOnesByTwo + kNumOfIndicesWithinOneDistance,\n             static_cast<int>(oneIndices.size())});\n\n    for (int onesByTwo = minOnesByTwo; onesByTwo <= maxOnesByTwo; ++onesByTwo)\n      for (int l = 0; l + onesByTwo < prefix.size(); ++l) {\n        const int r = l + onesByTwo;  // Collect 1s in oneIndices[l - 1..r - 1].\n        const long cost1 = (k - onesByTwo) * 2;\n        const long cost2 = (prefix[r] - prefix[(l + r) / 2]) -\n                           (prefix[(l + r + 1) / 2] - prefix[l]);\n        ans = min(ans, cost1 + cost2);\n      }\n\n    return ans;\n  }\n};\n", "3088": "class Solution {\n public:\n  string makeAntiPalindrome(string s) {\n    const int n = s.length();\n    int i = n / 2;\n    ranges::sort(s);\n    if (s[i] != s[n - 1 - i])\n      return s;\n\n    int j = getFirstDiffIndexInSecondHalf(s);\n    while (s[i] == s[n - 1 - i]) {\n      if (j == n)\n        return \"-1\";\n      swap(s[i++], s[j++]);\n    }\n\n    return s;\n  }\n\n private:\n  // Returns the first index in s[n / 2..n) that is different from the first\n  // letter of the second half, s[n / 2].\n  int getFirstDiffIndexInSecondHalf(const string& s) {\n    const int n = s.size();\n    const char firstLetter = s[n / 2];\n    int firstDiffIndex = n / 2;\n    while (firstDiffIndex < n && s[firstDiffIndex] == firstLetter)\n      ++firstDiffIndex;\n    return firstDiffIndex;\n  }\n};\n", "309": "class Solution {\n public:\n  int maxProfit(vector<int>& prices) {\n    int sell = 0;\n    int hold = INT_MIN;\n    int prev = 0;\n\n    for (const int price : prices) {\n      const int cache = sell;\n      sell = max(sell, hold + price);\n      hold = max(hold, prev - price);\n      prev = cache;\n    }\n\n    return sell;\n  }\n};\n", "3090": "class Solution {\n public:\n  int maximumLengthSubstring(string s) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s[r] - 'a'];\n      while (count[s[r] - 'a'] > 2)\n        --count[s[l++] - 'a'];\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "3091": "class Solution {\n public:\n  int minOperations(int k) {\n    // The required operations are\n    //   1. Increase `1` to `x`\n    //   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    // The number of operations used would be (x - 1) + y. Equivalently, the\n    // problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    // Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    // hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    const int x = sqrt(k);\n    const int y = (k - 1) / x + 1 - 1;  // ceil(k / x) - 1\n    return x - 1 + y;\n  }\n};\n", "3092": "class Solution {\n public:\n  vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {\n    vector<long long> ans;\n    unordered_map<int, long> numCount;  // {num: freq}\n    map<long, int> freqCount;           // {num's freq: freq}\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int num = nums[i];\n      const int f = freq[i];\n      if (const auto it = numCount.find(num); it != numCount.cend()) {\n        const int numFreq = it->second;\n        if (--freqCount[numFreq] == 0)\n          freqCount.erase(numFreq);\n      }\n      const long newFreq = numCount[num] + f;\n      if (newFreq == 0) {\n        numCount.erase(num);\n      } else {\n        numCount[num] = newFreq;\n        ++freqCount[newFreq];\n      }\n      ans.push_back(freqCount.empty() ? 0 : freqCount.rbegin()->first);\n    }\n\n    return ans;\n  }\n};\n", "3093": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(26) {}\n  int length = INT_MAX;\n  int index = -1;\n};\n\nclass Solution {\n public:\n  vector<int> stringIndices(vector<string>& wordsContainer,\n                            vector<string>& wordsQuery) {\n    vector<int> ans;\n    int minIndex = 0;\n\n    for (int i = 0; i < wordsContainer.size(); ++i) {\n      insert(wordsContainer[i], i);\n      if (wordsContainer[i].length() < wordsContainer[minIndex].length())\n        minIndex = i;\n    }\n\n    for (const string& query : wordsQuery) {\n      const int index = search(query);\n      ans.push_back(index == -1 ? minIndex : index);\n    }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word, int index) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        node->children[index] = make_shared<TrieNode>();\n      node = node->children[index];\n      if (node->length > word.length()) {\n        node->length = word.length();\n        node->index = index;\n      }\n    }\n  }\n\n  int search(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        return node->index;\n      node = node->children[index];\n    }\n    return node->index;\n  }\n};\n", "3094": "/**\n * Definition of commonBits API.\n * int commonBits(int num);\n */\n\nclass Solution {\n public:\n  int findNumber() {\n    constexpr int kMaxBit = 30;\n    int ans = 0;\n\n    for (int i = 0; i <= kMaxBit; ++i)\n      if (commonBits(1 << i) > commonBits(1 << i))\n        ans |= 1 << i;\n\n    return ans;\n  }\n};\n", "3095": "class Solution {\n public:\n  int minimumSubarrayLength(vector<int>& nums, int k) {\n    constexpr int kMax = 50;\n    const int n = nums.size();\n    int ans = n + 1;\n    int ors = 0;\n    vector<int> count(kMax + 1);\n\n    for (int l = 0, r = 0; r < n; r++) {\n      ors = orNum(ors, nums[r], count);\n      while (ors >= k && l <= r) {\n        ans = min(ans, r - l + 1);\n        ors = undoOrNum(ors, nums[l], count);\n        ++l;\n      }\n    }\n\n    return (ans == n + 1) ? -1 : ans;\n  }\n\n private:\n  static constexpr int kMaxBit = 30;\n\n  int orNum(int ors, int num, vector<int>& count) {\n    for (int i = 0; i < kMaxBit; ++i)\n      if (num >> i & 1 && ++count[i] == 1)\n        ors += 1 << i;\n    return ors;\n  }\n\n  int undoOrNum(int ors, int num, vector<int>& count) {\n    for (int i = 0; i < kMaxBit; ++i)\n      if (num >> i & 1 && --count[i] == 0)\n        ors -= 1 << i;\n    return ors;\n  }\n};\n", "3096": "class Solution {\n public:\n  int minimumLevels(vector<int>& possible) {\n    const int n = possible.size();\n    const vector<int> nums = getNums(possible);\n    vector<int> prefix(n + 1);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n\n    for (int i = 1; i < n; ++i)\n      if (prefix[i] > prefix[n] - prefix[i])\n        return i;\n\n    return -1;\n  }\n\n private:\n  vector<int> getNums(const vector<int>& possible) {\n    vector<int> nums;\n    for (const int num : possible)\n      nums.push_back(num == 1 ? 1 : -1);\n    return nums;\n  }\n};\n", "3097": "class Solution {\n public:\n  // Same as 3095. Shortest Subarray With OR at Least K I\n  int minimumSubarrayLength(vector<int>& nums, int k) {\n    constexpr int kMax = 50;\n    const int n = nums.size();\n    int ans = n + 1;\n    int ors = 0;\n    vector<int> count(kMax + 1);\n\n    for (int l = 0, r = 0; r < n; r++) {\n      ors = orNum(ors, nums[r], count);\n      while (ors >= k && l <= r) {\n        ans = min(ans, r - l + 1);\n        ors = undoOrNum(ors, nums[l], count);\n        ++l;\n      }\n    }\n\n    return (ans == n + 1) ? -1 : ans;\n  }\n\n private:\n  static constexpr int kMaxBit = 30;\n\n  int orNum(int ors, int num, vector<int>& count) {\n    for (int i = 0; i < kMaxBit; ++i)\n      if (num >> i & 1 && ++count[i] == 1)\n        ors += 1 << i;\n    return ors;\n  }\n\n  int undoOrNum(int ors, int num, vector<int>& count) {\n    for (int i = 0; i < kMaxBit; ++i)\n      if (num >> i & 1 && --count[i] == 0)\n        ors -= 1 << i;\n    return ors;\n  }\n};\n", "3098": "class Solution {\n public:\n  int sumOfPowers(vector<int>& nums, int k) {\n    const int n = nums.size();\n    ranges::sort(nums);\n    vector<vector<vector<vector<int>>>> mem(\n        n + 1, vector<vector<vector<int>>>(\n                   n + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1))));\n    return sumOfPowers(nums, 0, k, -1, -1, -1, mem);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the sum of powers of all subsequences of nums[i..n) which\n  // have length equal to k, where `lastPickedIndex` is the index of the last\n  // picked number and nums[secondIndex] - nums[firstIndex] is the minimum power\n  // so far.\n  int sumOfPowers(const vector<int>& nums, int i, int k, int lastPickedIndex,\n                  int firstIndex, int secondIndex,\n                  vector<vector<vector<vector<int>>>>& mem) {\n    if (k == 0)\n      return nums[secondIndex] - nums[firstIndex];\n    if (i == nums.size())\n      return 0;\n    const int a = hash(lastPickedIndex);\n    const int b = hash(firstIndex);\n    const int c = hash(secondIndex);\n    if (mem[a][b][c][k] != -1)\n      return mem[a][b][c][k];\n    int newFirstIndex = firstIndex;\n    int newSecondIndex = secondIndex;\n    if (firstIndex == -1) {\n      newFirstIndex = i;\n    } else if (secondIndex == -1) {\n      newSecondIndex = i;\n    } else if (nums[i] - nums[lastPickedIndex] <\n               nums[secondIndex] - nums[firstIndex]) {\n      newFirstIndex = lastPickedIndex;\n      newSecondIndex = i;\n    }\n    const int pick =\n        sumOfPowers(nums, i + 1, k - 1, i, newFirstIndex, newSecondIndex, mem);\n    const int skip = sumOfPowers(nums, i + 1, k, lastPickedIndex, firstIndex,\n                                 secondIndex, mem);\n    return mem[a][b][c][k] = (pick + skip) % kMod;\n  }\n\n  constexpr int hash(int x) {\n    return x + 1;\n  }\n};\n", "3099": "class Solution {\n public:\n  int sumOfTheDigitsOfHarshadNumber(int x) {\n    const int digitSum = getDigitSum(x);\n    return x % digitSum == 0 ? digitSum : -1;\n  }\n\n private:\n  int getDigitSum(int x) {\n    int digitSum = 0;\n    while (x > 0) {\n      digitSum += x % 10;\n      x /= 10;\n    }\n    return digitSum;\n  }\n};\n", "31": "class Solution {\n public:\n  void nextPermutation(vector<int>& nums) {\n    const int n = nums.size();\n\n    // From back to front, find the first number < nums[i + 1].\n    int i;\n    for (i = n - 2; i >= 0; --i)\n      if (nums[i] < nums[i + 1])\n        break;\n\n    // From back to front, find the first number > nums[i], swap it with\n    // nums[i].\n    if (i >= 0)\n      for (int j = n - 1; j > i; --j)\n        if (nums[j] > nums[i]) {\n          swap(nums[i], nums[j]);\n          break;\n        }\n\n    // Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, n - 1);\n  }\n\n private:\n  void reverse(vector<int>& nums, int l, int r) {\n    while (l < r)\n      swap(nums[l++], nums[r--]);\n  }\n};\n", "310": "class Solution {\n public:\n  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if (n == 1 || edges.empty())\n      return {0};\n\n    vector<int> ans;\n    unordered_map<int, unordered_set<int>> graph;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].insert(v);\n      graph[v].insert(u);\n    }\n\n    for (const auto& [label, children] : graph)\n      if (children.size() == 1)\n        ans.push_back(label);\n\n    while (n > 2) {\n      n -= ans.size();\n      vector<int> nextLeaves;\n      for (const int leaf : ans) {\n        const int u = *graph[leaf].begin();\n        graph[u].erase(leaf);\n        if (graph[u].size() == 1)\n          nextLeaves.push_back(u);\n      }\n      ans = nextLeaves;\n    }\n\n    return ans;\n  }\n};\n", "3100": "class Solution {\n public:\n  int maxBottlesDrunk(int numBottles, int numExchange) {\n    int ans = numBottles;\n\n    while (numBottles >= numExchange) {\n      numBottles = (numBottles - numExchange + 1);\n      ++numExchange;\n      ++ans;\n    }\n\n    return ans;\n  }\n};\n", "3101": "class Solution {\n public:\n  long long countAlternatingSubarrays(vector<int>& nums) {\n    // dp[i] := the number of alternating subarrays ending in index i\n    vector<long> dp(nums.size(), 1);\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] != nums[i - 1])\n        dp[i] += dp[i - 1];\n\n    return accumulate(dp.begin(), dp.end(), 0L);\n  }\n};\n", "3102": "class Solution {\n public:\n  int minimumDistance(vector<vector<int>>& points) {\n    const auto [i, j] = maxManhattanDistance(points, -1);\n    const auto [xi, yi] = maxManhattanDistance(points, i);\n    const auto [xj, yj] = maxManhattanDistance(points, j);\n    return min(manhattan(points, xi, yi), manhattan(points, xj, yj));\n  }\n\n private:\n  // Returns the pair of indices a and b where points[a] and points[b] have the\n  // maximum Manhattan distance and a != excludedIndex and b != excludedIndex.\n  pair<int, int> maxManhattanDistance(const vector<vector<int>>& points,\n                                      int excludedIndex) {\n    int minSum = INT_MAX;\n    int maxSum = INT_MIN;\n    int minDiff = INT_MAX;\n    int maxDiff = INT_MIN;\n    int minSumIndex = -1;\n    int maxSumIndex = -1;\n    int minDiffIndex = -1;\n    int maxDiffIndex = -1;\n\n    for (int i = 0; i < points.size(); ++i) {\n      if (i == excludedIndex)\n        continue;\n      const int x = points[i][0];\n      const int y = points[i][1];\n      const int sum = x + y;\n      const int diff = x - y;\n      if (sum < minSum)\n        minSum = sum, minSumIndex = i;\n      if (sum > maxSum)\n        maxSum = sum, maxSumIndex = i;\n      if (diff < minDiff)\n        minDiff = diff, minDiffIndex = i;\n      if (diff > maxDiff)\n        maxDiff = diff, maxDiffIndex = i;\n    }\n\n    return maxSum - minSum >= maxDiff - minDiff\n               ? pair<int, int>(minSumIndex, maxSumIndex)\n               : pair<int, int>(minDiffIndex, maxDiffIndex);\n  }\n\n  int manhattan(const vector<vector<int>>& points, int i, int j) {\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);\n  }\n};\n", "3104": "class Solution {\n public:\n  int maxSubstringLength(string s) {\n    int ans = -1;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int n = 1; n <= 26; ++n)\n      ans = max(ans, maxSubstringLengthWithNUniqueLetters(s, n, count));\n\n    return ans;\n  }\n\n private:\n  // Similar to 395. Longest Substring with At Least K Repeating Characters\n  int maxSubstringLengthWithNUniqueLetters(const string& s, int n,\n                                           const vector<int>& allCount) {\n    int res = -1;\n    // the number of unique letters\n    int uniqueLetters = 0;\n    // the number of letters that have all their frequency in the substring\n    int lettersHavingAllFreq = 0;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r] - 'a'] == 1)\n        ++uniqueLetters;\n      if (count[s[r] - 'a'] == allCount[s[r] - 'a'])\n        ++lettersHavingAllFreq;\n      while (uniqueLetters > n) {\n        if (count[s[l] - 'a'] == allCount[s[l] - 'a'])\n          --lettersHavingAllFreq;\n        if (--count[s[l] - 'a'] == 0)\n          --uniqueLetters;\n        ++l;\n      }\n      // Since both the number of unique letters and the number of letters\n      // having all their frequency are equal to n, this is a valid window.\n      // Implcit: uniqueLetters == n\n      if (lettersHavingAllFreq == n && r - l + 1 < s.length())\n        res = max(res, r - l + 1);\n    }\n\n    return res;\n  }\n};\n", "3105": "class Solution {\n public:\n  // Similar to 978. Longest Turbulent Subarray\n  int longestMonotonicSubarray(vector<int>& nums) {\n    int ans = 1;\n    int increasing = 1;\n    int decreasing = 1;\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] > nums[i - 1]) {\n        increasing += 1;\n        decreasing = 1;\n      } else if (nums[i] < nums[i - 1]) {\n        decreasing += 1;\n        increasing = 1;\n      } else {\n        increasing = 1;\n        decreasing = 1;\n      }\n      ans = max({ans, increasing, decreasing});\n    }\n\n    return ans;\n  }\n};\n", "3106": "class Solution {\n public:\n  string getSmallestString(string s, int k) {\n    string ans = s;\n\n    for (char& c : ans) {\n      if (k == 0)\n        break;\n      const int distToA = min(c - 'a', 'z' - c + 1);\n      if (k >= distToA) {\n        k -= distToA;\n        c = 'a';\n      } else {\n        // k is not enough to change the current letter to 'a', so move as\n        // closer to 'a' as possible.\n        c -= k;\n        k = 0;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3107": "class Solution {\n public:\n  long long minOperationsToMakeMedianK(vector<int>& nums, int k) {\n    const int n = nums.size();\n    long ans = 0;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i <= n / 2; ++i)\n      ans += max(0, nums[i] - k);\n\n    for (int i = n / 2; i < n; ++i)\n      ans += max(0, k - nums[i]);\n\n    return ans;\n  }\n};\n", "3108": "class UnionFind {\n public:\n  // 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n  UnionFind(int n) : id(n), rank(n), weight(n, (1 << 17) - 1) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v, int w) {\n    const int i = find(u);\n    const int j = find(v);\n    const int newWeight = weight[i] & weight[j] & w;\n    weight[i] = newWeight;\n    weight[j] = newWeight;\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int getMinCost(int u, int v) {\n    if (u == v)\n      return 0;\n    const int i = find(u);\n    const int j = find(v);\n    return i == j ? weight[i] : -1;\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n  vector<int> weight;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> minimumCost(int n, vector<vector<int>>& edges,\n                          vector<vector<int>>& query) {\n    vector<int> ans;\n    UnionFind uf(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      uf.unionByRank(u, v, w);\n    }\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      ans.push_back(uf.getMinCost(u, v));\n    }\n\n    return ans;\n  }\n};\n", "3109": "class FenwickTree {\n public:\n  FenwickTree(int n) : sums(n + 1) {}\n\n  void add(int i, int delta) {\n    while (i < sums.size()) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n private:\n  vector<int> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int getPermutationIndex(vector<int>& perm) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = perm.size();\n    int ans = 0;\n    FenwickTree tree(n);\n    vector<int> fact(n + 1, 1);  // fact[i] := i!\n\n    for (int i = 2; i <= n; ++i)\n      fact[i] = (fact[i - 1] * static_cast<long>(i)) % kMod;\n\n    for (int i = 0; i < n; ++i) {\n      const int num = perm[i];\n      // the number of unused numbers less than `num`\n      const int unusedNums = num - 1 - tree.get(num - 1);\n      const int suffixLength = fact[n - 1 - i];\n      ans = (ans + unusedNums * static_cast<long>(suffixLength)) % kMod;\n      tree.add(num, 1);\n    }\n\n    return ans;\n  }\n};\n", "311": "class Solution {\n public:\n  vector<vector<int>> multiply(vector<vector<int>>& mat1,\n                               vector<vector<int>>& mat2) {\n    const int m = mat1.size();\n    const int n = mat2.size();\n    const int l = mat2[0].size();\n    vector<vector<int>> ans(m, vector<int>(l));\n    vector<vector<int>> nonZeroColIndicesInMat2;\n\n    for (int i = 0; i < n; ++i) {\n      vector<int> colIndices;\n      for (int j = 0; j < l; ++j)\n        if (mat2[i][j] != 0)\n          colIndices.push_back(j);\n      nonZeroColIndicesInMat2.push_back(colIndices);\n    }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (mat1[i][j] == 0)\n          continue;\n        // mat1's j-th column matches mat2's j-th row\n        for (const int colIndex : nonZeroColIndicesInMat2[j])\n          ans[i][colIndex] += mat1[i][j] * mat2[j][colIndex];\n      }\n\n    return ans;\n  }\n};\n", "3110": "class Solution {\n public:\n  int scoreOfString(string s) {\n    int ans = 0;\n\n    for (int i = 1; i < s.length(); ++i)\n      ans += abs(s[i] - s[i - 1]);\n\n    return ans;\n  }\n};\n", "3111": "class Solution {\n public:\n  int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n    int ans = 0;\n    int prevX = -w - 1;\n    vector<int> xs;\n\n    for (const vector<int>& point : points) {\n      const int x = point[0];\n      xs.push_back(x);\n    }\n\n    ranges::sort(xs);\n\n    for (const int x : xs)\n      if (x > prevX + w) {\n        ++ans;\n        prevX = x;\n      }\n\n    return ans;\n  }\n};\n", "3112": "class Solution {\n public:\n  vector<int> minimumTime(int n, vector<vector<int>>& edges,\n                          vector<int>& disappear) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dijkstra(graph, 0, disappear);\n  }\n\n private:\n  vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n                       const vector<int>& disappear) {\n    vector<int> dist(graph.size(), INT_MAX);\n\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < disappear[v] && d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.push({dist[v], v});\n        }\n    }\n\n    for (int& d : dist)\n      if (d == INT_MAX)\n        d = -1;\n\n    return dist;\n  }\n};\n", "3113": "class Solution {\n public:\n  long long numberOfSubarrays(vector<int>& nums) {\n    long ans = 0;\n    vector<pair<int, int>> stack;\n\n    for (const int num : nums) {\n      while (!stack.empty() && stack.back().first < num)\n        stack.pop_back();\n      if (stack.empty() || stack.back().first != num)\n        stack.emplace_back(num, 0);\n      ans += ++stack.back().second;\n    }\n\n    return ans;\n  }\n};\n", "3114": "class Solution {\n public:\n  // Similar to 1736. Latest Time by Replacing Hidden Digits\n  string findLatestTime(string s) {\n    string ans = s;\n    if (s[0] == '?')\n      ans[0] = s[1] == '?' || s[1] < '2' ? '1' : '0';\n    if (s[1] == '?')\n      ans[1] = ans[0] == '1' ? '1' : '9';\n    if (s[3] == '?')\n      ans[3] = '5';\n    if (s[4] == '?')\n      ans[4] = '9';\n    return ans;\n  }\n};\n", "3115": "class Solution {\n public:\n  int maximumPrimeDifference(vector<int>& nums) {\n    constexpr int kMax = 100;\n    const vector<bool> isPrime = sieveEratosthenes(kMax + 1);\n    int minPrimeIndex = -1;\n    int maxPrimeIndex = -1;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (isPrime[nums[i]]) {\n        if (minPrimeIndex == -1)\n          minPrimeIndex = i;\n        maxPrimeIndex = i;\n      }\n\n    return maxPrimeIndex - minPrimeIndex;\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "3116": "class Solution {\n public:\n  long long findKthSmallest(vector<int>& coins, int k) {\n    const vector<vector<long>> sizeToLcms = getSizeToLcms(coins);\n    long l = 0;\n    long r = static_cast<long>(k) * ranges::min(coins);\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (numDenominationsNoGreaterThan(sizeToLcms, m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the number of denominations <= m.\n  long numDenominationsNoGreaterThan(const vector<vector<long>>& sizeToLcms,\n                                     long m) {\n    long res = 0;\n    for (int sz = 1; sz < sizeToLcms.size(); ++sz)\n      for (const long lcm : sizeToLcms[sz])\n        // Principle of Inclusion-Exclusion (PIE)\n        res += m / lcm * pow(-1, sz + 1);\n    return res;\n  };\n\n  // Returns the LCMs for each number of combination of coins.\n  vector<vector<long>> getSizeToLcms(const vector<int>& coins) {\n    const int n = coins.size();\n    const int maxMask = 1 << n;\n    vector<vector<long>> sizeToLcms(n + 1);\n\n    for (unsigned mask = 1; mask < maxMask; ++mask) {\n      long lcmOfSelectedCoins = 1;\n      for (int i = 0; i < n; ++i)\n        if (mask >> i & 1)\n          lcmOfSelectedCoins = lcm(lcmOfSelectedCoins, coins[i]);\n      sizeToLcms[popcount(mask)].push_back(lcmOfSelectedCoins);\n    }\n\n    return sizeToLcms;\n  }\n};\n", "3117": "class Solution {\n public:\n  int minimumValueSum(vector<int>& nums, vector<int>& andValues) {\n    vector<vector<unordered_map<int, int>>> mem(\n        nums.size(), vector<unordered_map<int, int>>(andValues.size()));\n    const int ans = minimumValueSum(nums, andValues, 0, 0, kFullMask, mem);\n    return ans == kInf ? -1 : ans;\n  }\n\n private:\n  static constexpr int kInf = 1'000'000'000;\n  static constexpr int kFullMask = (1 << 17) - 1;\n\n  // Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n  // `mask` is the running value of the current subarray.\n  int minimumValueSum(const vector<int>& nums, const vector<int>& andValues,\n                      int i, int j, int mask,\n                      vector<vector<unordered_map<int, int>>>& mem) {\n    if (i == nums.size() && j == andValues.size())\n      return 0;\n    if (i == nums.size() || j == andValues.size())\n      return kInf;\n    if (const auto it = mem[i][j].find(mask); it != mem[i][j].cend())\n      return it->second;\n    mask &= nums[i];\n    if (mask < andValues[j])\n      return mem[i][j][mask] = kInf;\n    if (mask == andValues[j])\n      // 1. Keep going.\n      // 2. End the subarray here and pick nums[i], then fresh start.\n      return mem[i][j][mask] =\n                 min(minimumValueSum(nums, andValues, i + 1, j, mask, mem),\n                     nums[i] + minimumValueSum(nums, andValues, i + 1, j + 1,\n                                               kFullMask, mem));\n    // Keep going.\n    return mem[i][j][mask] =\n               minimumValueSum(nums, andValues, i + 1, j, mask, mem);\n  };\n};\n", "3119": "class Solution {\n public:\n  int maxPotholes(string road, int budget) {\n    int ans = 0;\n\n    for (const int length : getSortedPotholeLengths(road)) {\n      const int canRepair = max(0, budget - 1);\n      if (length > canRepair)\n        return ans + canRepair;\n      ans += length;\n      budget -= length + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getSortedPotholeLengths(const string& road) {\n    vector<int> potholeLengths;\n    istringstream iss(road);\n    string pothole;\n\n    while (getline(iss, pothole, '.'))\n      potholeLengths.push_back(pothole.length());\n\n    ranges::sort(potholeLengths, greater<>());\n    return potholeLengths;\n  }\n};\n", "312": "class Solution {\n public:\n  int maxCoins(vector<int>& nums) {\n    const int n = nums.size();\n    // dp[i][j] := maxCoins(nums[i..j])\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2));\n\n    nums.insert(nums.begin(), 1);\n    nums.insert(nums.end(), 1);\n\n    for (int d = 0; d < n; ++d)\n      for (int i = 1; i + d <= n; ++i) {\n        const int j = i + d;\n        for (int k = i; k <= j; ++k)\n          dp[i][j] = max(dp[i][j],                      //\n                         dp[i][k - 1] + dp[k + 1][j] +  //\n                             nums[i - 1] * nums[k] * nums[j + 1]);\n      }\n\n    return dp[1][n];\n  }\n};\n", "3120": "class Solution {\n public:\n  int numberOfSpecialChars(string word) {\n    int ans = 0;\n    vector<bool> lower(26);\n    vector<bool> upper(26);\n\n    for (const char c : word)\n      if (islower(c))\n        lower[c - 'a'] = true;\n      else\n        upper[c - 'A'] = true;\n\n    for (int i = 0; i < 26; ++i)\n      if (lower[i] && upper[i])\n        ++ans;\n\n    return ans;\n  }\n};\n", "3121": "class Solution {\n public:\n  int numberOfSpecialChars(string word) {\n    int ans = 0;\n    vector<bool> lower(26);\n    vector<bool> upper(26);\n\n    for (const char c : word)\n      if (islower(c))\n        lower[c - 'a'] = !upper[c - 'a'];\n      else\n        upper[c - 'A'] = true;\n\n    for (int i = 0; i < 26; ++i)\n      if (lower[i] && upper[i])\n        ++ans;\n\n    return ans;\n  }\n};\n", "3122": "class Solution {\n public:\n  int minimumOperations(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<int>> count(n, vector<int>(10));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        ++count[j][grid[i][j]];\n\n    vector<vector<int>> mem(n, vector<int>(10, -1));\n    return minimumOperations(count, 0, 0, m, mem);\n  }\n\n private:\n  // Returns the number of minimum operations needed to make grid[:][j..n)\n  // satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n  int minimumOperations(const vector<vector<int>>& count, int j, int prev,\n                        int m, vector<vector<int>>& mem) {\n    if (j == count.size())\n      return 0;\n    if (mem[j][prev] != -1)\n      return mem[j][prev];\n\n    int res = INT_MAX;\n\n    for (int num = 0; num < 10; ++num)\n      if (j == 0 || num != prev)\n        res = min(res, m - count[j][num] +\n                           minimumOperations(count, j + 1, num, m, mem));\n\n    return mem[j][prev] = res;\n  }\n};\n", "3123": "class Solution {\n public:\n  // Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  vector<bool> findAnswer(int n, vector<vector<int>>& edges) {\n    vector<bool> ans;\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    const vector<int> from0 = dijkstra(graph, 0);\n    const vector<int> from1 = dijkstra(graph, n - 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      ans.push_back(from0[u] + w + from1[v] == from0[n - 1] ||\n                    from0[v] + w + from1[u] == from0[n - 1]);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMax = 1'000'000'000;\n\n  vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n    vector<int> dist(graph.size(), kMax);\n\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return dist;\n  }\n};\n", "3125": "class Solution {\n public:\n  long long maxNumber(long long n) {\n    // assume n = 0b00...11???\n    //        x = 0b00...01111\n    //  since y = 0b00...10000 is in [x, n]\n    //    and x & y = 0\n    const int i = 63 - __builtin_clzll(n);\n    return (1L << i) - 1;\n  }\n};\n", "3127": "class Solution {\n public:\n  bool canMakeSquare(vector<vector<char>>& grid) {\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        int black = 0;\n        int white = 0;\n        for (int x = 0; x < 2; ++x)\n          for (int y = 0; y < 2; ++y)\n            if (grid[i + x][j + y] == 'B')\n              ++black;\n            else\n              ++white;\n        if (black >= 3 || white >= 3)\n          return true;\n      }\n    return false;\n  }\n};\n", "3128": "class Solution {\n public:\n  long long numberOfRightTriangles(vector<vector<int>>& grid) {\n    long count = 0;\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> rows(m);\n    vector<int> cols(n);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1) {\n          ++rows[i];\n          ++cols[j];\n        }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          count += (rows[i] - 1) * (cols[j] - 1);\n\n    return count;\n  }\n};\n", "3129": "class Solution {\n public:\n  // Same as 3129. Find All Possible Stable Binary Arrays I\n  int numberOfStableArrays(int zero, int one, int limit) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j][k] := the number of stable arrays, where the number of\n    // ocurrences of 0 is i and the number of ocurrences of 1 is j and the last\n    // number is k (0/1)\n    vector<vector<vector<long>>> dp(\n        zero + 1, vector<vector<long>>(one + 1, vector<long>(2)));\n\n    for (int i = 0; i <= min(zero, limit); ++i)\n      dp[i][0][0] = 1;\n\n    for (int j = 0; j <= min(one, limit); ++j)\n      dp[0][j][1] = 1;\n\n    for (int i = 1; i <= zero; ++i)\n      for (int j = 1; j <= one; ++j) {\n        dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1] -\n                       (i - limit < 1 ? 0 : dp[i - limit - 1][j][1]) + kMod) %\n                      kMod;\n        dp[i][j][1] = (dp[i][j - 1][0] + dp[i][j - 1][1] -\n                       (j - limit < 1 ? 0 : dp[i][j - limit - 1][0]) + kMod) %\n                      kMod;\n      }\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % kMod;\n  }\n};\n", "313": "struct UglyNum {\n  int prime;\n  int index;   // the next index in `uglyNums`\n  long value;  // prime * uglyNums[index]\n  UglyNum(int prime, int index, long value)\n      : prime(prime), index(index), value(value) {}\n};\n\nclass Solution {\n public:\n  int nthSuperUglyNumber(int n, vector<int>& primes) {\n    auto compare = [&](const UglyNum& a, const UglyNum& b) {\n      return a.value > b.value;\n    };\n    priority_queue<UglyNum, vector<UglyNum>, decltype(compare)> minHeap(\n        compare);\n    vector<int> uglyNums{1};\n\n    for (const int prime : primes)\n      minHeap.emplace(prime, 1, prime * uglyNums[0]);\n\n    while (uglyNums.size() < n) {\n      uglyNums.push_back(minHeap.top().value);\n      while (minHeap.top().value == uglyNums.back()) {\n        const auto [prime, index, _] = minHeap.top();\n        minHeap.pop();\n        minHeap.emplace(prime, index + 1,\n                        static_cast<long>(prime) * uglyNums[index]);\n      }\n    }\n\n    return uglyNums.back();\n  }\n};\n", "3130": "class Solution {\n public:\n  // Same as 3129. Find All Possible Stable Binary Arrays I\n  int numberOfStableArrays(int zero, int one, int limit) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j][k] := the number of stable arrays, where the number of\n    // ocurrences of 0 is i and the number of ocurrences of 1 is j and the last\n    // number is k (0/1)\n    vector<vector<vector<long>>> dp(\n        zero + 1, vector<vector<long>>(one + 1, vector<long>(2)));\n\n    for (int i = 0; i <= min(zero, limit); ++i)\n      dp[i][0][0] = 1;\n\n    for (int j = 0; j <= min(one, limit); ++j)\n      dp[0][j][1] = 1;\n\n    for (int i = 1; i <= zero; ++i)\n      for (int j = 1; j <= one; ++j) {\n        dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1] -\n                       (i - limit < 1 ? 0 : dp[i - limit - 1][j][1]) + kMod) %\n                      kMod;\n        dp[i][j][1] = (dp[i][j - 1][0] + dp[i][j - 1][1] -\n                       (j - limit < 1 ? 0 : dp[i][j - limit - 1][0]) + kMod) %\n                      kMod;\n      }\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % kMod;\n  }\n};\n", "3131": "class Solution {\n public:\n  int addedInteger(vector<int>& nums1, vector<int>& nums2) {\n    return ranges::min(nums2) - ranges::min(nums1);\n  }\n};\n", "3132": "class Solution {\n public:\n  int minimumAddedInteger(vector<int>& nums1, vector<int>& nums2) {\n    // After removing two elements from nums1, either nums1[0], nums1[1], or\n    // nums1[2] will persist. Therefore, the difference between nums1 (with two\n    // elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    // 0 <= i <= 2.\n    int ans = INT_MAX;\n\n    ranges::sort(nums1);\n    ranges::sort(nums2);\n\n    for (int i = 0; i < 3; ++i) {\n      const int inc = nums2[0] - nums1[i];\n      if (isValidDiff(nums1, nums2, inc))\n        ans = min(ans, inc);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns true if it's possible to increase nums1 (with two elements removed)\n  // by `inc` to nums2.\n  bool isValidDiff(const vector<int>& nums1, const vector<int>& nums2,\n                   int inc) {\n    int removed = 0;\n    int i = 0;  // nums2's index\n\n    for (const int num : nums1)\n      if (num + inc == nums2[i]) {\n        if (++i == nums2.size())\n          break;\n      } else {\n        ++removed;\n      }\n\n    return removed <= 2;\n  }\n};\n", "3133": "class Solution {\n public:\n  long long minEnd(int n, int x) {\n    // Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    // operation increase x for (n - 1) iterations while preserving x's 1s.\n    const int kMaxBit = log2(n) + log2(x) + 2;\n    const long k = n - 1;\n    long ans = x;\n    int kBinaryIndex = 0;\n\n    for (int i = 0; i < kMaxBit; ++i) {\n      if ((ans >> i & 1) == 0) {\n        // Set x's 0 with k's bit if the running bit of k is 1.\n        if (k >> kBinaryIndex & 1)\n          ans |= 1L << i;\n        ++kBinaryIndex;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3134": "class Solution {\n public:\n  int medianOfUniquenessArray(vector<int>& nums) {\n    const int n = nums.size();\n    const long subarryCount = n * (n + 1L) / 2;\n    const long medianCount = (subarryCount + 1) / 2;\n    int l = 1;\n    int r = n;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (subarrayWithAtMostKDistinct(nums, m) >= medianCount)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Similar to 992. Subarrays with K Different Integers\n  long subarrayWithAtMostKDistinct(const vector<int>& nums, int k) {\n    long res = 0;\n    unordered_map<int, int> count;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (++count[nums[r]] == 1)\n        --k;\n      while (k == -1)\n        if (--count[nums[l++]] == 0)\n          ++k;\n      res += r - l + 1;  // nums[l..r], nums[l + 1..r], ..., nums[r]\n    }\n\n    return res;\n  }\n};\n", "3135": "class Solution {\n public:\n  int minOperations(string initial, string target) {\n    const int m = initial.length();\n    const int n = target.length();\n    // dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (initial[i - 1] == target[j - 1])\n          dp[i][j] = 1 + dp[i - 1][j - 1];\n\n    const int maxCommonLength = accumulate(dp.begin(), dp.end(), 0,\n                                           [](int acc, const vector<int>& row) {\n      return max(acc, ranges::max(row));\n    });\n    return m + n - 2 * maxCommonLength;\n  }\n};\n", "3136": "class Solution {\n public:\n  bool isValid(string word) {\n    return word.length() >= 3 &&\n           ranges::all_of(word, [](char c) { return isalnum(c); }) &&\n           ranges::any_of(word, isVowel) && ranges::any_of(word, isConsonant);\n  }\n\n private:\n  static bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n\n  static bool isConsonant(char c) {\n    return isalpha(c) && !isVowel(c);\n  }\n};\n", "3137": "class Solution {\n public:\n  int minimumOperationsToMakeKPeriodic(string word, int k) {\n    unordered_map<string, int> count;\n    int maxFreq = 0;\n\n    for (int i = 0; i < word.length(); i += k)\n      ++count[word.substr(i, k)];\n\n    for (const auto& [_, freq] : count)\n      maxFreq = max(maxFreq, freq);\n\n    return word.length() / k - maxFreq;\n  }\n};\n", "3138": "class Solution {\n public:\n  int minAnagramLength(string s) {\n    const int n = s.length();\n    for (int k = 1; k <= n; ++k)\n      if (n % k == 0 && canFormAnagram(s, k))\n        return k;\n    return n;\n  }\n\n private:\n  // Returns true if we can concatenate an anagram of length k to s.\n  bool canFormAnagram(const string& s, int k) {\n    const int n = s.length();\n    vector<int> anagramCount(26);\n    vector<int> runningCount(26);\n    for (int i = 0; i < k; ++i)\n      ++anagramCount[s[i] - 'a'];\n    for (int i = k; i < n; ++i) {\n      ++runningCount[s[i] - 'a'];\n      if (i % k == k - 1) {\n        if (runningCount != anagramCount)\n          return false;\n        fill(runningCount.begin(), runningCount.end(), 0);\n      }\n    }\n    return true;\n  }\n};\n", "3139": "class Solution {\n public:\n  int minCostToEqualizeArray(vector<int>& nums, int cost1, int cost2) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    const int minNum = ranges::min(nums);\n    const int maxNum = ranges::max(nums);\n    const long sum = accumulate(nums.begin(), nums.end(), 0L);\n    long ans = LONG_MAX;\n\n    if (cost1 * 2 <= cost2 || n < 3) {\n      const long totalGap = static_cast<long>(maxNum) * n - sum;\n      return (cost1 * totalGap) % kMod;\n    }\n\n    for (int target = maxNum; target < 2 * maxNum; ++target) {\n      const int maxGap = target - minNum;\n      const long totalGap = static_cast<long>(target) * n - sum;\n      const long pairs = min(totalGap / 2, totalGap - maxGap);\n      ans = min(ans, cost1 * (totalGap - 2 * pairs) + cost2 * pairs);\n    }\n\n    return ans % kMod;\n  }\n};\n", "314": "class Solution {\n public:\n  vector<vector<int>> verticalOrder(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> range(2);\n    getRange(root, range, 0);  // Get the leftmost and the rightmost x index.\n\n    vector<vector<int>> ans(range[1] - range[0] + 1);\n    queue<pair<TreeNode*, int>> q{{{root, -range[0]}}};  // (TreeNode, x)\n\n    while (!q.empty()) {\n      const auto [node, x] = q.front();\n      q.pop();\n      ans[x].push_back(node->val);\n      if (node->left)\n        q.emplace(node->left, x - 1);\n      if (node->right)\n        q.emplace(node->right, x + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  void getRange(TreeNode* root, vector<int>& range, int x) {\n    if (root == nullptr)\n      return;\n\n    range[0] = min(range[0], x);\n    range[1] = max(range[1], x);\n\n    getRange(root->left, range, x - 1);\n    getRange(root->right, range, x + 1);\n  }\n};\n", "3141": "class Solution {\n public:\n  vector<int> maxHammingDistances(vector<int>& nums, int m) {\n    const int maxMask = 1 << m;\n    vector<int> ans;\n    // dp[i] := the maximum hamming distance from i to any number in `nums`\n    vector<int> dp(maxMask, INT_MIN);\n\n    for (const int num : nums)\n      dp[num] = 0;\n\n    for (int bit = 0; bit < m; ++bit) {\n      vector<int> newDp(maxMask);\n      for (int mask = 0; mask < maxMask; ++mask)\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1);\n      dp = std::move(newDp);\n    }\n\n    for (const int num : nums)\n      ans.push_back(dp[num]);\n\n    return ans;\n  }\n};\n", "3142": "class Solution {\n public:\n  bool satisfiesConditions(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    for (int i = 0; i + 1 < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] != grid[i + 1][j])\n          return false;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j + 1 < n; ++j)\n        if (grid[i][j] == grid[i][j + 1])\n          return false;\n\n    return true;\n  }\n};\n", "3143": "class Solution {\n public:\n  int maxPointsInsideSquare(vector<vector<int>>& points, string s) {\n    int secondMinSize = INT_MAX;\n    vector<int> minSizes(26, INT_MAX);\n\n    for (int i = 0; i < points.size(); ++i) {\n      const int x = points[i][0];\n      const int y = points[i][1];\n      const int sz = max(abs(x), abs(y));\n      const int j = s[i] - 'a';\n      if (minSizes[j] == INT_MAX) {\n        minSizes[j] = sz;\n      } else if (sz < minSizes[j]) {\n        // This is because minSizes[j] is about to be replaced by a smaller\n        // value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[j]);\n        minSizes[j] = sz;\n      } else {\n        // `sz` is not smaller than the current minimum size, but it could be\n        // smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz);\n      }\n    }\n\n    return ranges::count_if(minSizes,\n                            [&](int sz) { return sz < secondMinSize; });\n  }\n};\n", "3144": "class Solution {\n public:\n  int minimumSubstringsInPartition(string s) {\n    const int n = s.length();\n    // dp[i] := the minimum number of substrings in s[0..i]\n    vector<int> dp(n, n);\n\n    for (int i = 0; i < n; ++i) {\n      vector<int> count(26);\n      for (int j = i; j >= 0; --j) {\n        ++count[s[j] - 'a'];\n        if (isBalanced(count))  // word[j..i] is balanced.\n          dp[i] = j > 0 ? min(dp[i], 1 + dp[j - 1]) : 1;\n      }\n    }\n\n    return dp.back();\n  }\n\n private:\n  static constexpr int kMax = 1001;\n\n  // Returns true if all non-zero frequencies are the same.\n  bool isBalanced(const vector<int>& count) {\n    int minfreq = kMax;\n    int maxfreq = 0;\n    for (const int freq : count)\n      if (freq > 0) {\n        minfreq = min(minfreq, freq);\n        maxfreq = max(maxfreq, freq);\n      }\n    return minfreq == maxfreq;\n  }\n};\n", "3145": "class Solution {\n public:\n  vector<int> findProductsOfElements(vector<vector<long long>>& queries) {\n    vector<int> ans;\n\n    for (const vector<long long>& query : queries) {\n      const long a = query[0];\n      const long b = query[1];\n      const int mod = query[2];\n      const int product = modPow(2,\n                                 sumPowersFirstKBigNums(b + 1) -  //\n                                     sumPowersFirstKBigNums(a),\n                                 mod);\n      ans.push_back(product);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the sum of powers of the first k numbers in `big_nums`.\n  long sumPowersFirstKBigNums(long k) {\n    const long num = firstNumberHavingSumBitsTillGreaterThan(k);\n    long sumPowers = sumPowersTill(num - 1);\n    long remainingCount = k - sumBitsTill(num - 1);\n    for (int power = 0; power < bitLength(num); ++power) {\n      if (num >> power & 1) {\n        sumPowers += power;\n        --remainingCount;\n        if (remainingCount == 0)\n          break;\n      }\n    }\n    return sumPowers;\n  }\n\n  // Returns the first number in [1, k] that has sumBitsTill(num) >= k.\n  long firstNumberHavingSumBitsTillGreaterThan(long k) {\n    long l = 1;\n    long r = k;\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (sumBitsTill(m) < k)\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n\n  // Returns sum(i.bit_count()), where 1 <= i <= x.\n  long sumBitsTill(long x) {\n    long sumBits = 0;\n    for (long powerOfTwo = 1; powerOfTwo <= x; powerOfTwo *= 2) {\n      sumBits += (x / (2L * powerOfTwo)) * powerOfTwo;\n      sumBits += max(0L, x % (2L * powerOfTwo) + 1 - powerOfTwo);\n    }\n    return sumBits;\n  }\n\n  // Returns sum(all powers of i), where 1 <= i <= x.\n  long sumPowersTill(long x) {\n    long sumPowers = 0;\n    long powerOfTwo = 1;\n    for (int power = 0; power < bitLength(x); ++power) {\n      sumPowers += (x / (2L * powerOfTwo)) * powerOfTwo * power;\n      sumPowers += max(0L, x % (2L * powerOfTwo) + 1 - powerOfTwo) * power;\n      powerOfTwo *= 2;\n    }\n    return sumPowers;\n  }\n\n  long modPow(long x, long n, int mod) {\n    if (n == 0)\n      return 1 % mod;\n    if (n % 2 == 1)\n      return x * modPow(x % mod, (n - 1), mod) % mod;\n    return modPow(x * x % mod, (n / 2), mod) % mod;\n  }\n\n  int bitLength(long x) {\n    return x == 0 ? 0 : 64 - __builtin_clzl(x);\n  }\n};\n", "3146": "class Solution {\n public:\n  int findPermutationDifference(string s, string t) {\n    int ans = 0;\n    vector<int> indices(26);\n\n    for (int i = 0; i < s.length(); ++i)\n      indices[s[i] - 'a'] = i;\n\n    for (int i = 0; i < t.length(); ++i)\n      ans += abs(indices[t[i] - 'a'] - i);\n\n    return ans;\n  }\n};\n", "3147": "class Solution {\n public:\n  int maximumEnergy(vector<int>& energy, int k) {\n    vector<int> dp(energy);\n    for (int i = energy.size() - 1 - k; i >= 0; --i)\n      dp[i] += dp[i + k];\n    return ranges::max(dp);\n  }\n};\n", "3148": "class Solution {\n public:\n  int maxScore(vector<vector<int>>& grid) {\n    constexpr int kMax = 200'000;\n    int ans = -kMax;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j) {\n        const int prevMin = min(i > 0 ? grid[i - 1][j] : kMax,  //\n                                j > 0 ? grid[i][j - 1] : kMax);\n        ans = max(ans, grid[i][j] - prevMin);\n        grid[i][j] = min(grid[i][j], prevMin);\n      }\n\n    return ans;\n  }\n};\n", "3149": "class Solution {\n public:\n  vector<int> findPermutation(vector<int>& nums) {\n    const int n = nums.size();\n    vector<vector<int>> mem(n, vector<int>(1 << n));\n    // bestPick[last][mask] := the best pick, where `last` is the last chosen\n    // number and `mask` is the bitmask of the chosen numbers\n    vector<vector<int>> bestPick(n, vector<int>(1 << n));\n\n    // Choose 0 as perm[0] since the score function is cyclic.\n    getScore(nums, /*last=*/0, /*mask=*/1, bestPick, mem);\n    return construct(bestPick);\n  }\n\n private:\n  // Returns the minimum score, where `last` is the last chosen number and\n  // `mask` is the bitmask of the chosen numbers.\n  int getScore(const vector<int>& nums, int last, unsigned mask,\n               vector<vector<int>>& bestPick, vector<vector<int>>& mem) {\n    if (popcount(mask) == nums.size())\n      return abs(last - nums[0]);  // |perm[n - 1] - nums[perm[0]]|\n    if (mem[last][mask] > 0)\n      return mem[last][mask];\n\n    int minScore = INT_MAX;\n    for (int i = 1; i < nums.size(); ++i) {\n      if (mask >> i & 1)\n        continue;\n      const int nextMinScore =\n          abs(last - nums[i]) + getScore(nums, i, mask | 1 << i, bestPick, mem);\n      if (nextMinScore < minScore) {\n        minScore = nextMinScore;\n        bestPick[last][mask] = i;\n      }\n    }\n\n    return mem[last][mask] = minScore;\n  }\n\n  vector<int> construct(const vector<vector<int>>& bestPick) {\n    vector<int> ans;\n    int last = 0;\n    int mask = 1;\n    for (int i = 0; i < bestPick.size(); ++i) {\n      ans.push_back(last);\n      last = bestPick[last][mask];\n      mask |= 1 << last;\n    }\n    return ans;\n  }\n};\n", "315": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Adds val to nums[i].\n  void add(int i, int val) {\n    add(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = nums[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void add(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] += val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      add(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      add(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> countSmaller(vector<int>& nums) {\n    vector<int> ans(nums.size());\n    unordered_map<int, int> ranks;\n    getRanks(nums, ranks);\n    SegmentTree tree(vector<int>(ranks.size() + 1));\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      const int num = nums[i];\n      ans[i] = tree.query(0, ranks[num] - 1);\n      tree.add(ranks[num], 1);\n    }\n\n    return ans;\n  }\n\n private:\n  void getRanks(const vector<int>& nums, unordered_map<int, int>& ranks) {\n    set<int> sorted(nums.begin(), nums.end());\n    int rank = 0;\n    for (const int num : sorted)\n      ranks[num] = ++rank;\n  }\n};\n", "3151": "class Solution {\n public:\n  bool isArraySpecial(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] % 2 == nums[i - 1] % 2)\n        return false;\n    return true;\n  }\n};\n", "3152": "class Solution {\n public:\n  vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<bool> ans;\n    int id = 0;\n    // parityIds[i] := the id of the parity group that nums[i] belongs to\n    vector<int> parityIds = {id};\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] % 2 == nums[i - 1] % 2)\n        ++id;\n      parityIds.push_back(id);\n    }\n\n    for (const vector<int> query : queries) {\n      const int from = query[0];\n      const int to = query[1];\n      ans.push_back(parityIds[from] == parityIds[to]);\n    }\n\n    return ans;\n  }\n};\n", "3153": "class Solution {\n public:\n  long long sumDigitDifferences(vector<int>& nums) {\n    const int n = nums.size();\n    const int digitSize = std::to_string(nums[0]).size();\n    long ans = 0;\n\n    for (int i = 0, denominator = 1; i < digitSize; ++i, denominator *= 10) {\n      vector<int> count(10);\n      for (const int num : nums)\n        ++count[num / denominator % 10];\n      for (const int freq : count)\n        ans += freq * (n - freq);\n    }\n\n    return ans / 2;\n  }\n};\n", "3154": "class Solution {\n public:\n  int waysToReachStair(int k) {\n    // Let's say we have `down` operation 1 and `jump` operation 2.\n    // The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    // => 1 + (2^jump - 1) - down = k.\n    // => down = 2^jump - k.\n    // Since `down` operations cannot be used consecutively, there're jump + 1\n    // positions (before and after each `jump`) for  `down`. The maximum jump is\n    // 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    // being the maximum value of 10^9.\n    constexpr int kMaxJump = 29;\n    const vector<vector<int>> comb = getComb(kMaxJump + 1, kMaxJump + 1);\n    int ans = 0;\n\n    for (int jump = 0; jump <= kMaxJump; ++jump) {\n      const int down = (1 << jump) - k;\n      if (down < 0 || down > jump + 1)\n        continue;\n      ans += comb[jump + 1][down];\n    }\n\n    return ans;\n  }\n\n private:\n  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  vector<vector<int>> getComb(int n, int k) {\n    vector<vector<int>> comb(n + 1, vector<int>(k + 1));\n    for (int i = 0; i <= n; ++i)\n      comb[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= k; ++j)\n        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n    return comb;\n  }\n};\n", "3155": "class Solution {\n public:\n  vector<int> maxUpgrades(vector<int>& count, vector<int>& upgrade,\n                          vector<int>& sell, vector<int>& money) {\n    // If there's enough money, upgrade all servers; otherwise, optimize by\n    // upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    // Therefore, x = (money + count * sell) / (sell + upgrade).\n    vector<int> ans;\n    for (int i = 0; i < count.size(); ++i)\n      ans.push_back(min(\n          count[i],\n          static_cast<int>((money[i] + static_cast<long>(count[i]) * sell[i]) /\n                           (sell[i] + upgrade[i]))));\n    return ans;\n  }\n};\n", "3157": "class Solution {\n public:\n  // Similar to 1161. Maximum Level Sum of a Binary Tree\n  int minimumLevel(TreeNode* root) {\n    // levelSums[i] := the sum of level (i + 1) (1-indexed)\n    vector<long> levelSums;\n    dfs(root, 0, levelSums);\n    return 1 + ranges::min_element(levelSums) - levelSums.begin();\n  }\n\n private:\n  void dfs(TreeNode* root, int level, vector<long>& levelSums) {\n    if (root == nullptr)\n      return;\n    if (levelSums.size() == level)\n      levelSums.push_back(0);\n    levelSums[level] += root->val;\n    dfs(root->left, level + 1, levelSums);\n    dfs(root->right, level + 1, levelSums);\n  }\n};\n", "3158": "class Solution {\n public:\n  int duplicateNumbersXOR(vector<int>& nums) {\n    constexpr int kMax = 50;\n    int ans = 0;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int num = 1; num <= kMax; ++num)\n      if (count[num] == 2)\n        ans ^= num;\n\n    return ans;\n  }\n};\n", "3159": "class Solution {\n public:\n  vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries,\n                                   int x) {\n    const vector<int> indices = getIndices(nums, x);\n    vector<int> ans;\n\n    for (const int query : queries)\n      ans.push_back(query <= indices.size() ? indices[query - 1] : -1);\n\n    return ans;\n  }\n\n private:\n  vector<int> getIndices(const vector<int>& nums, int x) {\n    vector<int> indices;\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == x)\n        indices.push_back(i);\n    return indices;\n  }\n};\n", "316": "class Solution {\n public:\n  string removeDuplicateLetters(string s) {\n    string ans;\n    vector<int> count(128);\n    vector<bool> used(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const char c : s) {\n      --count[c];\n      if (used[c])\n        continue;\n      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {\n        used[ans.back()] = false;\n        ans.pop_back();\n      }\n      used[c] = true;\n      ans.push_back(c);\n    }\n\n    return ans;\n  }\n};\n", "3160": "class Solution {\n public:\n  vector<int> queryResults(int limit, vector<vector<int>>& queries) {\n    vector<int> ans;\n    unordered_map<int, int> ballToColor;\n    unordered_map<int, int> colorCount;\n\n    for (const vector<int>& query : queries) {\n      const int ball = query[0];\n      const int color = query[1];\n      if (const auto it = ballToColor.find(ball); it != ballToColor.cend()) {\n        const int prevColor = it->second;\n        if (--colorCount[prevColor] == 0)\n          colorCount.erase(prevColor);\n      }\n      ballToColor[ball] = color;\n      ++colorCount[color];\n      ans.push_back(colorCount.size());\n    }\n\n    return ans;\n  }\n};\n", "3161": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  void maximize(int i, int val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<int> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  vector<bool> getResults(vector<vector<int>>& queries) {\n    const int n = min(50000, static_cast<int>(queries.size()) * 3);\n    vector<bool> ans;\n    FenwickTree tree(n + 1);\n    set<int> obstacles{0, n};  // sentinel values\n\n    for (const vector<int>& query : queries) {\n      const int type = query[0];\n      if (type == 1) {\n        const int x = query[1];\n        obstacles.insert(x);\n      }\n    }\n\n    for (auto it = obstacles.begin(); std::next(it) != obstacles.end(); ++it) {\n      const int x1 = *it;\n      const int x2 = *std::next(it);\n      tree.maximize(x2, x2 - x1);\n    }\n\n    for (int i = queries.size() - 1; i >= 0; --i) {\n      const int type = queries[i][0];\n      const int x = queries[i][1];\n      if (type == 1) {\n        const auto it = obstacles.find(x);\n        if (next(it) != obstacles.end())  // x is not the last element.\n          tree.maximize(*next(it), *next(it) - *prev(it));\n        obstacles.erase(it);\n      } else {\n        const int sz = queries[i][2];\n        const auto it = obstacles.upper_bound(x);\n        const int prev = *std::prev(it);\n        ans.push_back(tree.get(prev) >= sz || x - prev >= sz);\n      }\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "3162": "class Solution {\n public:\n  int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    int ans = 0;\n    for (const int num1 : nums1)\n      for (const int num2 : nums2)\n        if (num1 % (num2 * k) == 0)\n          ++ans;\n    return ans;\n  }\n};\n", "3163": "class Solution {\n public:\n  string compressedString(string word) {\n    const int n = word.length();\n    string ans;\n\n    for (int i = 0, j = 0; i < n; i = j) {\n      int count = 0;\n      while (j < n && word[j] == word[i] && count < 9) {\n        ++j;\n        ++count;\n      }\n      ans += to_string(count) + word[i];\n    }\n\n    return ans;\n  }\n};\n", "3164": "class Solution {\n public:\n  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    unordered_map<int, int> count;\n    long ans = 0;\n\n    for (const int num : nums2)\n      ++count[num * k];\n\n    for (const int num : nums1)\n      for (int divisor = 1; divisor <= sqrt(num); ++divisor)\n        if (num % divisor == 0) {\n          ans += count.contains(divisor) ? count[divisor] : 0;\n          if (num / divisor != divisor)\n            ans += count.contains(num / divisor) ? count[num / divisor] : 0;\n        }\n\n    return ans;\n  }\n};\n", "3165": "using NodeType = array<array<int, 2>, 2>;\n\nclass SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(4 * n) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns the four values of the range query from nums[i..j].\n  //\n  // The four values are:\n  //   1. nums[i] is not selected, nums[j] is not selected\n  //   2. nums[i] is not selected, nums[j] is selected\n  //   3. nums[i] is selected, nums[j] is not selected\n  //   4. nums[i] is selected, nums[j] is selected\n  NodeType query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  static constexpr int kInf = 1'000'000'000;\n  static constexpr NodeType kDefaultNode = {{{-kInf, -kInf}, {-kInf, -kInf}}};\n  const int n;  // the size of the input array\n  // tree[i][l][r] := the value of the i-th node, where `l` and `r` represent if\n  // the leftmost or rightmost element is selected, respectively\n  vector<NodeType> tree;\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = {{{0, -kInf}, {-kInf, nums[lo]}}};\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = {{{0, -kInf}, {-kInf, val}}};\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  NodeType query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return kDefaultNode;\n    const int mid = (lo + hi) / 2;\n    return merge(query(2 * treeIndex + 1, lo, mid, i, j),\n                 query(2 * treeIndex + 2, mid + 1, hi, i, j));\n  }\n\n  // Merges the result of the left node and the right node.\n  NodeType merge(const NodeType& a, const NodeType& b) const {\n    NodeType node = {{{0, 0}, {0, 0}}};\n    for (int l = 0; l < 2; ++l)\n      for (int r = 0; r < 2; ++r)\n        node[l][r] =\n            max({a[l][0] + b[0][r], a[l][0] + b[1][r], a[l][1] + b[0][r]});\n    return node;\n  }\n};\n\nclass Solution {\n public:\n  int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    int ans = 0;\n    SegmentTree tree(nums);\n\n    for (const vector<int>& query : queries) {\n      const int pos = query[0];\n      const int x = query[1];\n      tree.update(pos, x);\n      NodeType res = tree.query(0, n - 1);\n      ans = (ans + static_cast<long>(\n                       max({res[0][0], res[0][1], res[1][0], res[1][1]}))) %\n            kMod;\n    }\n\n    return ans;\n  }\n};\n", "3167": "class Solution {\n public:\n  string betterCompression(string compressed) {\n    string ans;\n    vector<int> count(26);\n\n    for (int i = 0; i < compressed.length();) {\n      const char c = compressed[i++];\n      int freq = 0;\n      while (i < compressed.length() && isdigit(compressed[i]))\n        freq = freq * 10 + (compressed[i++] - '0');\n      count[c - 'a'] += freq;\n    }\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c - 'a'] > 0)\n        ans += c + to_string(count[c - 'a']);\n\n    return ans;\n  }\n};\n", "3168": "class Solution {\n public:\n  int minimumChairs(string s) {\n    int ans = 0;\n    int chairs = 0;\n\n    for (const char c : s) {\n      chairs += c == 'E' ? 1 : -1;\n      ans = max(ans, chairs);\n    }\n\n    return ans;\n  }\n};\n", "3169": "class Solution {\n public:\n  int countDays(int days, vector<vector<int>>& meetings) {\n    int freeDays = 0;\n    int prevEnd = 0;\n\n    ranges::sort(meetings);\n\n    for (const vector<int>& meeting : meetings) {\n      const int start = meeting[0];\n      const int end = meeting[1];\n      if (start > prevEnd)\n        freeDays += start - prevEnd - 1;\n      prevEnd = max(prevEnd, end);\n    }\n\n    return freeDays + max(0, days - prevEnd);\n  }\n};\n", "317": "class Solution {\n public:\n  int shortestDistance(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int nBuildings = getBuildingsCount(grid);\n    int ans = INT_MAX;\n    // dist[i][j] := the total distance of grid[i][j] (0) to reach all the\n    // buildings (1)\n    vector<vector<int>> dist(m, vector<int>(n));\n    // reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach\n    vector<vector<int>> reachCount(m, vector<int>(n));\n\n    auto bfs = [&](int row, int col) -> bool {\n      queue<pair<int, int>> q{{{row, col}}};\n      vector<vector<bool>> seen(m, vector<bool>(n));\n      seen[row][col] = true;\n      int seenBuildings = 1;\n\n      for (int step = 1; !q.empty(); ++step)\n        for (int sz = q.size(); sz > 0; --sz) {\n          const auto [i, j] = q.front();\n          q.pop();\n          for (const auto& [dx, dy] : kDirs) {\n            const int x = i + dx;\n            const int y = j + dy;\n            if (x < 0 || x == m || y < 0 || y == n)\n              continue;\n            if (seen[x][y])\n              continue;\n            seen[x][y] = true;\n            if (!grid[x][y]) {\n              dist[x][y] += step;\n              ++reachCount[x][y];\n              q.emplace(x, y);\n            } else if (grid[x][y] == 1) {\n              ++seenBuildings;\n            }\n          }\n        }\n\n      return seenBuildings == nBuildings;\n    };\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)  // BFS from this building.\n          if (!bfs(i, j))\n            return -1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (reachCount[i][j] == nBuildings)\n          ans = min(ans, dist[i][j]);\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  int getBuildingsCount(vector<vector<int>>& grid) {\n    return accumulate(\n        grid.begin(), grid.end(), 0,\n        [](int acc, vector<int>& row) { return acc + ranges::count(row, 1); });\n  }\n};\n", "3170": "class Solution {\n public:\n  string clearStars(string s) {\n    string ans = s;\n    vector<vector<int>> buckets(26);\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == '*') {\n        ans[i] = ' ';\n        int j = 0;\n        while (buckets[j].empty())\n          ++j;\n        ans[buckets[j].back()] = ' ', buckets[j].pop_back();\n      } else {\n        buckets[s[i] - 'a'].push_back(i);\n      }\n\n    std::erase(ans, ' ');\n    return ans;\n  }\n};\n", "3171": "class Solution {\n public:\n  // Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  int minimumDifference(vector<int>& nums, int k) {\n    int ans = INT_MAX;\n    // all the values of subarrays that end in the previous number\n    unordered_set<int> prev;\n\n    for (const int num : nums) {\n      unordered_set<int> next{num};\n      // Extend each subarray that ends in the previous number. Due to\n      // monotonicity of the OR operation, the size of `next` will be at most\n      // num.bit_count() + 1.\n      for (const int val : prev)\n        next.insert(val | num);\n      for (const int val : next)\n        ans = min(ans, abs(k - val));\n      prev = std::move(next);\n    }\n\n    return ans;\n  }\n};\n", "3173": "class Solution {\n public:\n  vector<int> orArray(vector<int>& nums) {\n    vector<int> ans;\n    for (int i = 1; i < nums.size(); ++i)\n      ans.push_back(nums[i - 1] | nums[i]);\n    return ans;\n  }\n};\n", "3174": "class Solution {\n public:\n  string clearDigits(string s) {\n    string ans;\n\n    for (const char c : s)\n      if (isdigit(c))\n        // Since `ans` only contains non-digit characters, popping the last\n        // character is equivalent to deleting the closest non-digit character.\n        ans.pop_back();\n      else\n        ans += c;\n\n    return ans;\n  }\n};\n", "3175": "class Solution {\n public:\n  // Similar to 1535. Find the Winner of an Array Game\n  int findWinningPlayer(vector<int>& skills, int k) {\n    int ans = 0;\n    int wins = 0;\n\n    for (int i = 1; i < skills.size() && wins < k; ++i)\n      if (skills[i] > skills[ans]) {\n        ans = i;\n        wins = 1;\n      } else {\n        ++wins;\n      }\n\n    return ans;\n  }\n};\n", "3176": "class Solution {\n public:\n  int maximumLength(vector<int>& nums, int k) {\n    // dp[count][num] := the maximum length of a good subsequence with at most\n    // `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    vector<unordered_map<int, int>> dp(k + 1);\n    // maxLen[count] := the maximum length of a good subsequence with `count`\n    // indices where seq[i] != seq[i + 1]\n    vector<int> maxLen(k + 1);\n\n    for (const int num : nums)\n      for (int count = k; count >= 0; --count) {\n        // Append `num` to the subsequence.\n        ++dp[count][num];\n        if (count > 0)\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1);\n        maxLen[count] = max(maxLen[count], dp[count][num]);\n      }\n\n    return maxLen[k];\n  }\n};\n", "3177": "class Solution {\n public:\n  // Same as 3176. Find the Maximum Length of a Good Subsequence I\n  int maximumLength(vector<int>& nums, int k) {\n    // dp[count][num] := the maximum length of a good subsequence with at most\n    // `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    vector<unordered_map<int, int>> dp(k + 1);\n    // maxLen[count] := the maximum length of a good subsequence with `count`\n    // indices where seq[i] != seq[i + 1]\n    vector<int> maxLen(k + 1);\n\n    for (const int num : nums)\n      for (int count = k; count >= 0; --count) {\n        // Append `num` to the subsequence.\n        ++dp[count][num];\n        if (count > 0)\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1);\n        maxLen[count] = max(maxLen[count], dp[count][num]);\n      }\n\n    return maxLen[k];\n  }\n};\n", "3178": "class Solution {\n public:\n  int numberOfChild(int n, int k) {\n    // the time for the ball to return to 0\n    const int roundTime = 2 * (n - 1);\n    const int pos = k % roundTime;\n    return pos < n ? pos : roundTime - pos;\n  }\n};\n", "3179": "class Solution {\n public:\n  int valueAfterKSeconds(int n, int k) {\n    const auto [fact, invFact] = getFactAndInvFact(n + k - 1);\n    return nCk(n + k - 1, n - 1, fact, invFact);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {\n    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;\n  }\n};\n", "318": "class Solution {\n public:\n  int maxProduct(vector<string>& words) {\n    size_t ans = 0;\n    vector<int> masks;\n\n    for (const string& word : words)\n      masks.push_back(getMask(word));\n\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        if ((masks[i] & masks[j]) == 0)\n          ans = max(ans, words[i].length() * words[j].length());\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& word) {\n    int mask = 0;\n    for (const char c : word)\n      mask |= 1 << c - 'a';\n    return mask;\n  }\n};\n", "3180": "// According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n// reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n// `rewardValue` is achievable in O(1).\n//\n// Let's use `rewardValues = [1, 3, 4]` as an example.\n//\n// The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n// Therefore, we can set the size of the bitset to 8 to represent possible\n// total rewards from 0 to 7.\n//\n// Let's define a bitset `dp` to record whether each total reward is\n// achievable. dp[num] = true if reward `num` is achievable.\n//\n// Initially, dp = 0b00000001 := reward 0 is achievable.\n//\n// * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n//   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n//\n// * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n//   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n//\n// * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n//   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n//\n// Therefore, the maximum total reward is 7.\n\nclass Solution {\n public:\n  int maxTotalReward(vector<int>& rewardValues) {\n    constexpr int kPossibleRewards = 100'000;\n    // dp[num] := true if reward `num` is achievable\n    bitset<kPossibleRewards> dp;\n    dp[0] = true;\n\n    ranges::sort(rewardValues);\n\n    for (const int num : rewardValues) {\n      bitset<kPossibleRewards> newBits = dp;\n      // Remove the numbers >= the current number.\n      newBits <<= kPossibleRewards - num;\n      newBits >>= kPossibleRewards - num;\n      dp |= newBits << num;\n    }\n\n    for (int ans = kPossibleRewards - 1; ans >= 0; --ans)\n      if (dp[ans])\n        return ans;\n\n    throw;\n  }\n};\n", "3181": "class Solution {\n public:\n  // Same as 3180. Maximum Total Reward Using Operations I\n  int maxTotalReward(vector<int>& rewardValues) {\n    constexpr int kPossibleRewards = 100'000;\n    // dp[num] := true if reward `num` is achievable\n    bitset<kPossibleRewards> dp;\n    dp[0] = true;\n\n    ranges::sort(rewardValues);\n\n    for (const int num : rewardValues) {\n      bitset<kPossibleRewards> newBits = dp;\n      // Remove the numbers >= the current number.\n      newBits <<= kPossibleRewards - num;\n      newBits >>= kPossibleRewards - num;\n      dp |= newBits << num;\n    }\n\n    for (int ans = kPossibleRewards - 1; ans >= 0; --ans)\n      if (dp[ans])\n        return ans;\n\n    throw;\n  }\n};\n", "3183": "class Solution {\n public:\n  int numberOfWays(int n) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n\n    for (const int coin : {1, 2, 6})\n      for (int i = coin; i <= n; ++i)\n        dp[i] = (dp[i] + dp[i - coin]) % kMod;\n\n    int ans = dp[n];\n    if (n - 4 >= 0)\n      ans = (ans + dp[n - 4]) % kMod;\n    if (n - 8 >= 0)\n      ans = (ans + dp[n - 8]) % kMod;\n    return ans;\n  }\n};\n", "3184": "class Solution {\n public:\n  int countCompleteDayPairs(vector<int>& hours) {\n    int ans = 0;\n    vector<int> count(24);\n\n    for (const int hour : hours) {\n      ans += count[(24 - hour % 24) % 24];\n      ++count[hour % 24];\n    }\n\n    return ans;\n  }\n};\n", "3185": "class Solution {\n public:\n  // Same as 3184. Count Pairs That Form a Complete Day I\n  long long countCompleteDayPairs(vector<int>& hours) {\n    long ans = 0;\n    vector<int> count(24);\n\n    for (const int hour : hours) {\n      ans += count[(24 - hour % 24) % 24];\n      ++count[hour % 24];\n    }\n\n    return ans;\n  }\n};\n", "3186": "class Solution {\n public:\n  long long maximumTotalDamage(vector<int>& power) {\n    unordered_map<int, int> count;\n\n    for (const int damage : power)\n      ++count[damage];\n\n    const vector<int> uniqueDamages = getSortedUniqueDamages(count);\n    const int n = uniqueDamages.size();\n    // dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    // indicates if the i-th damage is used\n    vector<vector<long>> dp(n, vector<long>(2));\n\n    for (int i = 0; i < n; ++i) {\n      const long damage = uniqueDamages[i];\n      if (i == 0) {\n        dp[0][0] = 0;\n        dp[0][1] = damage * count[damage];\n        continue;\n      }\n      dp[i][0] = ranges::max(dp[i - 1]);\n      dp[i][1] = damage * count[damage];\n      if (i >= 1 && uniqueDamages[i - 1] != damage - 1 &&\n          uniqueDamages[i - 1] != damage - 2) {\n        dp[i][1] += max(dp[i - 1][0], dp[i - 1][1]);\n      } else if (i >= 2 && uniqueDamages[i - 2] != damage - 2) {\n        dp[i][1] += max(dp[i - 2][0], dp[i - 2][1]);\n      } else if (i >= 3) {\n        dp[i][1] += max(dp[i - 3][0], dp[i - 3][1]);\n      }\n    }\n\n    return ranges::max(dp.back());\n  }\n\n private:\n  vector<int> getSortedUniqueDamages(const unordered_map<int, int>& count) {\n    vector<int> uniqueDamages;\n    for (const auto& [damage, _] : count)\n      uniqueDamages.push_back(damage);\n    ranges::sort(uniqueDamages);\n    return uniqueDamages;\n  }\n};\n", "3187": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& peak) : n(peak.size()), tree(n * 4) {\n    build(peak, 0, 0, n - 1);\n  }\n\n  // Updates peak[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(peak[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& peak, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = peak[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(peak, 2 * treeIndex + 1, lo, mid);\n    build(peak, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n    const vector<int> peak = getPeak(nums);\n    vector<int> ans;\n    SegmentTree tree(peak);\n\n    for (const vector<int>& query : queries)\n      if (query[0] == 1) {\n        const int l = query[1];\n        const int r = query[2];\n        ans.push_back(tree.query(l + 1, r - 1));\n      } else if (query[0] == 2) {\n        const int index = query[1];\n        const int val = query[2];\n        nums[index] = val;\n        tree.update(index, isPeak(nums, index));\n        if (index > 0)\n          tree.update(index - 1, isPeak(nums, index - 1));\n        if (index + 1 < nums.size())\n          tree.update(index + 1, isPeak(nums, index + 1));\n      }\n\n    return ans;\n  }\n\n private:\n  vector<int> getPeak(const vector<int>& nums) {\n    vector<int> peak(nums.size());\n    for (int i = 1; i + 1 < nums.size(); ++i)\n      peak[i] = nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n    return peak;\n  }\n\n  bool isPeak(const vector<int>& nums, int i) {\n    return i > 0 && i + 1 < nums.size() && nums[i] > nums[i - 1] &&\n           nums[i] > nums[i + 1];\n  }\n};\n", "3189": "class Solution {\n public:\n  int minMoves(vector<vector<int>>& rooks) {\n    const int n = rooks.size();\n    int ans = 0;\n    vector<vector<int>> sortedByRow(rooks);\n    vector<vector<int>> sortedByCol(rooks);\n\n    ranges::sort(sortedByRow, ranges::less{},\n                 [](const vector<int>& rook) { return rook[0]; });\n\n    ranges::sort(sortedByCol, ranges::less{},\n                 [](const vector<int>& rook) { return rook[1]; });\n\n    for (int i = 0; i < n; ++i) {\n      ans += abs(sortedByRow[i][0] - /*targetRow=*/i);\n      ans += abs(sortedByCol[i][1] - /*targetCol=*/i);\n    }\n\n    return ans;\n  }\n};\n", "319": "class Solution {\n public:\n  int bulbSwitch(int n) {\n    // The k-th bulb can only be switched when k % i == 0.\n    // So, we can rephrase the problem:\n    // To find number of numbers <= n that have odd factors.\n    // Obviously, only square numbers have odd factor(s).\n    // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return sqrt(n);\n  }\n};\n", "3190": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    return ranges::count_if(nums, [](int num) { return num % 3 != 0; });\n  }\n};\n", "3191": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n\n    for (int i = 0; i + 2 < n; ++i)\n      if (nums[i] == 0) {\n        nums[i + 1] ^= 1;\n        nums[i + 2] ^= 1;\n        ++ans;\n      }\n\n    return nums[n - 1] == 0 || nums[n - 2] == 0 ? -1 : ans;\n  }\n};\n", "3192": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n    int target = 1;\n\n    for (const int num : nums)\n      if (num != target) {\n        target ^= 1;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3193": "class Solution {\n public:\n  int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMaxInversions = 400;\n    // dp[i][j] := the number of ways to arrange the first i numbers of the\n    // permutation s.t. there are j inversions\n    vector<vector<int>> dp(n + 1, vector<int>(kMaxInversions + 1));\n    vector<int> endToCnt(n + 1, -1);\n\n    for (const vector<int>& requirement : requirements) {\n      const int end = requirement[0];\n      const int cnt = requirement[1];\n      endToCnt[end + 1] = cnt;\n    }\n\n    // There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      for (int newInversions = 0; newInversions < i; ++newInversions)\n        for (int j = 0; j + newInversions <= kMaxInversions; ++j) {\n          const int inversionsAfterInsertion = j + newInversions;\n          if (endToCnt[i] != -1 && inversionsAfterInsertion != endToCnt[i])\n            continue;\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j];\n          dp[i][inversionsAfterInsertion] %= kMod;\n        }\n\n    return dp[n][endToCnt[n]];\n  }\n};\n", "3194": "class Solution {\n public:\n  double minimumAverage(vector<int>& nums) {\n    constexpr int kMax = 50;\n    double ans = kMax;\n    int i = 0;\n    int j = nums.size() - 1;\n\n    ranges::sort(nums);\n\n    while (i < j)\n      ans = min(ans, (nums[i++] + nums[j--]) / 2.0);\n\n    return ans;\n  }\n};\n", "3195": "class Solution {\n public:\n  int minimumArea(vector<vector<int>>& grid) {\n    int x1 = INT_MAX;\n    int y1 = INT_MAX;\n    int x2 = 0;\n    int y2 = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == 1) {\n          x1 = min(x1, i);\n          y1 = min(y1, j);\n          x2 = max(x2, i);\n          y2 = max(y2, j);\n        }\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n};\n", "3196": "class Solution {\n public:\n  long long maximumTotalCost(vector<int>& nums) {\n    // A small trick so that we don't need to handle the edge case and can use\n    // ranged-based for loop.\n    long keep = LONG_MIN / 2;  // the maximum cost if the last number is kept\n    long flip = 0;             // the maximum cost if the last number is flipped\n\n    for (const int num : nums) {\n      const long keepCurr = max(keep, flip) + num;\n      const long flipCurr = keep - num;\n      keep = keepCurr;\n      flip = flipCurr;\n    }\n\n    return max(keep, flip);\n  }\n};\n", "3197": "class Solution {\n public:\n  int minimumSum(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = m * n;\n\n    for (int i = 0; i < m; ++i) {\n      const int top = minimumArea(grid, 0, i, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = min(ans,\n                  top + /*left*/ minimumArea(grid, i + 1, m - 1, 0, j) +\n                      /*right*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      const int bottom = minimumArea(grid, i, m - 1, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = min(ans, bottom + /*left*/ minimumArea(grid, 0, i - 1, 0, j) +\n                           /*right*/ minimumArea(grid, 0, i - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      const int left = minimumArea(grid, 0, m - 1, 0, j);\n      for (int i = 0; i < m; ++i)\n        ans = min(ans,\n                  left + /*top*/ minimumArea(grid, 0, i, j + 1, n - 1) +\n                      /*bottom*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      const int right = minimumArea(grid, 0, m - 1, j, n - 1);\n      for (int i = 0; i < m; ++i)\n        ans =\n            min(ans, right + /*top*/ minimumArea(grid, 0, i, 0, j - 1) +\n                         /*bottom*/ minimumArea(grid, i + 1, m - 1, 0, j - 1));\n    }\n\n    for (int i1 = 0; i1 < m; ++i1)\n      for (int i2 = i1 + 1; i2 < m; ++i2)\n        ans =\n            min(ans, /*top*/ minimumArea(grid, 0, i1, 0, n - 1) +\n                         /*middle*/ minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                         /*bottom*/ minimumArea(grid, i2 + 1, m - 1, 0, n - 1));\n\n    for (int j1 = 0; j1 < n; ++j1)\n      for (int j2 = j1 + 1; j2 < n; ++j2)\n        ans =\n            min(ans, /*left*/ minimumArea(grid, 0, m - 1, 0, j1) +\n                         /*middle*/ minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                         /*right*/ minimumArea(grid, 0, m - 1, j2 + 1, n - 1));\n\n    return ans;\n  }\n\n private:\n  int minimumArea(vector<vector<int>>& grid, int si, int ei, int sj, int ej) {\n    int x1 = INT_MAX;\n    int y1 = INT_MAX;\n    int x2 = 0;\n    int y2 = 0;\n    for (int i = si; i <= ei; ++i)\n      for (int j = sj; j <= ej; ++j)\n        if (grid[i][j] == 1) {\n          x1 = min(x1, i);\n          y1 = min(y1, j);\n          x2 = max(x2, i);\n          y2 = max(y2, j);\n        }\n    return x1 == INT_MAX ? 0 : (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n};\n", "3199": "class Solution {\n public:\n  int tripletCount(vector<int>& a, vector<int>& b, vector<int>& c) {\n    const auto [evenA, oddA] = getEvenOddBitCount(a);\n    const auto [evenB, oddB] = getEvenOddBitCount(b);\n    const auto [evenC, oddC] = getEvenOddBitCount(c);\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC +\n           evenA * evenB * evenC;\n  }\n\n private:\n  // Returns the count of numbers in the `nums` arrays that have even number of\n  // ones and odd number of ones in their binary representation.\n  pair<int, int> getEvenOddBitCount(const vector<int>& nums) {\n    int even = 0;\n    int odd = 0;\n    for (const unsigned num : nums)\n      if (popcount(num) % 2 == 0)\n        ++even;\n      else\n        ++odd;\n    return {even, odd};\n  }\n};\n", "32": "class Solution {\n public:\n  int longestValidParentheses(string s) {\n    const string s2 = \")\" + s;\n    // dp[i] := the length of the longest valid parentheses in the substring\n    // s2[1..i]\n    vector<int> dp(s2.length());\n\n    for (int i = 1; i < s2.length(); ++i)\n      if (s2[i] == ')' && s2[i - dp[i - 1] - 1] == '(')\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\n\n    return ranges::max(dp);\n  }\n};\n", "320": "class Solution {\n public:\n  vector<string> generateAbbreviations(string word) {\n    vector<string> ans;\n    dfs(word, 0, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& word, int i, int count, vector<string>&& path,\n           vector<string>& ans) {\n    if (i == word.length()) {\n      ans.push_back(join(path) + getCountString(count));\n      return;\n    }\n\n    // Abbreviate the word[i].\n    dfs(word, i + 1, count + 1, std::move(path), ans);\n    // Keep the word[i], so consume the count as a string\n    path.push_back(getCountString(count) + word[i]);\n    // Reset the count to 0.\n    dfs(word, i + 1, 0, std::move(path), ans);\n    path.pop_back();\n  }\n\n  string getCountString(int count) {\n    return count > 0 ? to_string(count) : \"\";\n  }\n\n  string join(const vector<string>& path) {\n    string joined;\n    for (const string& s : path)\n      joined += s;\n    return joined;\n  };\n};\n", "3200": "class Solution {\n public:\n  int maxHeightOfTriangle(int red, int blue) {\n    return max(maxHeight(red, blue), maxHeight(blue, red));\n  }\n\n private:\n  // Returns the maximum height of a triangle with the odd levels having `n1`\n  // balls and the even levels having `n2` balls.\n  int maxHeight(int n1, int n2) {\n    //             1 + 3 + ... + h <= n1\n    // ((1 + h) * (n + 1) / 2) / 2 <= n1\n    //                           h <= sqrt(4 * n1) - 1\n    const int oddHeight = sqrt(4 * n1) - 1;\n    //       2 + 4 + ... + h <= n2\n    // ((2 + h) * h / 2) / 2 <= n2\n    //                     h <= sqrt(4 * n2 + 1) - 1\n    const int evenHeight = sqrt(4 * n2 + 1) - 1;\n    // If the difference between the odd and even heights is >= 1, we can add an\n    // extra level to the minimum height.\n    return min(oddHeight, evenHeight) +\n           (abs(oddHeight - evenHeight) >= 1 ? 1 : 0);\n  }\n};\n", "3201": "class Solution {\n public:\n  int maximumLength(vector<int>& nums) {\n    // dp[i][j] := the maximum length of a valid subsequence, where the last\n    // number mod 2 equal to i and the next desired number mod 2 equal to j\n    vector<vector<int>> dp(2, vector<int>(2));\n\n    // Extend the pattern xyxyxy...xy.\n    for (const int x : nums)\n      for (int y = 0; y < 2; ++y)\n        dp[x % 2][y] = dp[y][x % 2] + 1;\n\n    return accumulate(dp.begin(), dp.end(), 0,\n                      [](int acc, const vector<int>& row) {\n      return max(acc, ranges::max(row));\n    });\n  }\n};\n", "3202": "class Solution {\n public:\n  // Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  int maximumLength(vector<int>& nums, int k) {\n    // dp[i][j] := the maximum length of a valid subsequence, where the last\n    // number mod k equal to i and the next desired number mod k equal to j\n    vector<vector<int>> dp(k, vector<int>(k));\n\n    // Extend the pattern xyxyxy...xy.\n    for (const int x : nums)\n      for (int y = 0; y < k; ++y)\n        dp[x % k][y] = dp[y][x % k] + 1;\n\n    return accumulate(dp.begin(), dp.end(), 0,\n                      [](int acc, const vector<int>& row) {\n      return max(acc, ranges::max(row));\n    });\n  }\n};\n", "3203": "class Solution {\n public:\n  int minimumDiameterAfterMerge(vector<vector<int>>& edges1,\n                                vector<vector<int>>& edges2) {\n    const int diameter1 = getDiameter(edges1);\n    const int diameter2 = getDiameter(edges2);\n    const int combinedDiameter = (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n    return max({diameter1, diameter2, combinedDiameter});\n  }\n\n private:\n  int getDiameter(const vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    int maxDiameter = 0;\n    maxDepth(graph, 0, /*prev=*/-1, maxDiameter);\n    return maxDiameter;\n  }\n\n  // Similar to 1522. Diameter of N-Ary Tree\n  // Returns the maximum depth of the subtree rooted at u.\n  int maxDepth(const vector<vector<int>>& graph, int u, int prev,\n               int& maxDiameter) {\n    int maxSubDepth1 = 0;\n    int maxSubDepth2 = 0;\n    for (const int v : graph[u]) {\n      if (v == prev)\n        continue;\n      const int maxSubDepth = maxDepth(graph, v, u, maxDiameter);\n      if (maxSubDepth > maxSubDepth1) {\n        maxSubDepth2 = maxSubDepth1;\n        maxSubDepth1 = maxSubDepth;\n      } else if (maxSubDepth > maxSubDepth2) {\n        maxSubDepth2 = maxSubDepth;\n      }\n    }\n    maxDiameter = max(maxDiameter, maxSubDepth1 + maxSubDepth2);\n    return 1 + maxSubDepth1;\n  }\n};\n", "3205": "class Solution {\n public:\n  int maxScore(vector<int>& nums) {\n    // The optimal jump is the maximum number in the remaining suffix.\n    int ans = 0;\n    int mx = 0;\n\n    for (int i = nums.size() - 1; i > 0; --i) {\n      mx = max(mx, nums[i]);\n      ans += mx;\n    }\n\n    return ans;\n  }\n};\n", "3206": "class Solution {\n public:\n  int numberOfAlternatingGroups(vector<int>& colors) {\n    const int n = colors.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (colors[i] != colors[(i - 1 + n) % n] &&\n          colors[i] != colors[(i + 1) % n])\n        ++ans;\n\n    return ans;\n  }\n};\n", "3207": "class Solution {\n public:\n  long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {\n    const int minEnergy = ranges::min(enemyEnergies);\n    return currentEnergy < minEnergy\n               ? 0\n               : (currentEnergy +\n                  accumulate(enemyEnergies.begin(), enemyEnergies.end(), 0LL) -\n                  minEnergy) /\n                     minEnergy;\n  }\n};\n", "3208": "class Solution {\n public:\n  int numberOfAlternatingGroups(vector<int>& colors, int k) {\n    const int n = colors.size();\n    int ans = 0;\n    int alternating = 1;\n\n    for (int i = 0; i < n + k - 2; ++i) {\n      alternating =\n          colors[i % n] == colors[(i - 1 + n) % n] ? 1 : alternating + 1;\n      if (alternating >= k)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "3209": "class Solution {\n public:\n  // Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  long long countSubarrays(vector<int>& nums, int k) {\n    long long ans = 0;\n    // the counter of all the values of subarrays that end in the previous\n    // number\n    unordered_map<int, int> prev;\n\n    for (const int num : nums) {\n      unordered_map<int, int> curr{{num, 1}};\n      // Extend each subarray that ends in the previous number. Due to\n      // monotonicity of the AND operation, the size of `curr` will be at most\n      // num.bit_count() + 1.\n      for (const auto& [val, freq] : prev)\n        curr[val & num] += freq;\n      ans += curr.contains(k) ? curr[k] : 0;\n      prev = std::move(curr);\n    }\n\n    return ans;\n  }\n};\n", "321": "class Solution {\n public:\n  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n    vector<int> ans;\n\n    for (int k1 = 0; k1 <= k; ++k1) {\n      const int k2 = k - k1;\n      if (k1 > nums1.size() || k2 > nums2.size())\n        continue;\n      ans = max(ans, merge(maxArray(nums1, k1), maxArray(nums2, k2)));\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> maxArray(const vector<int>& nums, int k) {\n    vector<int> res;\n    int toPop = nums.size() - k;\n    for (const int num : nums) {\n      while (!res.empty() && res.back() < num && toPop-- > 0)\n        res.pop_back();\n      res.push_back(num);\n    }\n    return {res.begin(), res.begin() + k};\n  }\n\n  // Merges nums1 and nums2.\n  vector<int> merge(const vector<int>& nums1, const vector<int>& nums2) {\n    vector<int> res;\n    auto s1 = nums1.cbegin();\n    auto s2 = nums2.cbegin();\n    while (s1 != nums1.cend() || s2 != nums2.cend())\n      if (lexicographical_compare(s1, nums1.cend(), s2, nums2.cend()))\n        res.push_back(*s2++);\n      else\n        res.push_back(*s1++);\n    return res;\n  }\n};\n", "3210": "class Solution {\n public:\n  string getEncryptedString(string s, int k) {\n    k %= s.length();\n    return s.substr(k) + s.substr(0, k);\n  }\n};\n", "3211": "class Solution {\n public:\n  vector<string> validStrings(int n) {\n    vector<string> ans;\n    dfs(n, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, string&& s, vector<string>& ans) {\n    if (n == 0) {\n      ans.push_back(s);\n      return;\n    }\n    if (s.empty() || s.back() == '1') {\n      s.push_back('0');\n      dfs(n - 1, std::move(s), ans);\n      s.pop_back();\n    }\n    s.push_back('1');\n    dfs(n - 1, std::move(s), ans);\n    s.pop_back();\n  }\n};\n", "3212": "class Solution {\n public:\n  int numberOfSubmatrices(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    // x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    vector<vector<int>> x(m + 1, vector<int>(n + 1));\n    // y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    vector<vector<int>> y(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        x[i + 1][j + 1] =\n            (grid[i][j] == 'X' ? 1 : 0) + x[i][j + 1] + x[i + 1][j] - x[i][j];\n        y[i + 1][j + 1] =\n            (grid[i][j] == 'Y' ? 1 : 0) + y[i][j + 1] + y[i + 1][j] - y[i][j];\n        if (x[i + 1][j + 1] > 0 && x[i + 1][j + 1] == y[i + 1][j + 1])\n          ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3213": "class Solution {\n public:\n  int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n    constexpr int kMax = 1'000'000'000;\n    const int n = target.length();\n    // dp[i] := the minimum cost to construct target[0..i)\n    vector<int> dp(n + 1, kMax);\n    dp[0] = 0;\n    // minCost[c][word] := the minimum cost to construct word starting with `c`\n    vector<unordered_map<string, int>> minCost(26);\n\n    for (int i = 0; i < words.size(); ++i) {\n      const int index = words[i][0] - 'a';\n      const string& word = words[i];\n      minCost[index][word] =\n          min(minCost[index].contains(word) ? minCost[index][word] : kMax,\n              costs[i]);\n    }\n\n    for (int i = 0; i < n; ++i)\n      for (const auto& [word, cost] : minCost[target[i] - 'a']) {\n        const int j = i + word.length();\n        if (j <= n && cost + dp[i] < dp[j] &&\n            string_view(target.data() + i, word.length()) == word)\n          dp[j] = cost + dp[i];\n      }\n\n    return dp[n] == kMax ? -1 : dp[n];\n  }\n};\n", "3215": "class Solution {\n public:\n  // Same as 3199. Count Triplets with Even XOR Set Bits I\n  long long tripletCount(vector<int>& a, vector<int>& b, vector<int>& c) {\n    const auto [evenA, oddA] = getEvenOddBitCount(a);\n    const auto [evenB, oddB] = getEvenOddBitCount(b);\n    const auto [evenC, oddC] = getEvenOddBitCount(c);\n    return static_cast<long>(evenA) * oddB * oddC +\n           static_cast<long>(oddA) * evenB * oddC +\n           static_cast<long>(oddA) * oddB * evenC +\n           static_cast<long>(evenA) * evenB * evenC;\n  }\n\n private:\n  // Returns the count of numbers in the `nums` arrays that have even number of\n  // ones and odd number of ones in their binary representation.\n  pair<int, int> getEvenOddBitCount(const vector<int>& nums) {\n    int even = 0;\n    int odd = 0;\n    for (const unsigned num : nums)\n      if (popcount(num) % 2 == 0)\n        ++even;\n      else\n        ++odd;\n    return {even, odd};\n  }\n};\n", "3216": "class Solution {\n public:\n  string getSmallestString(string s) {\n    for (int i = 1; i < s.length(); ++i)\n      if (s[i - 1] % 2 == s[i] % 2 && s[i - 1] > s[i]) {\n        swap(s[i - 1], s[i]);\n        break;\n      }\n    return s;\n  }\n};\n", "3217": "class Solution {\n public:\n  ListNode* modifiedList(vector<int>& nums, ListNode* head) {\n    ListNode dummy(0, head);\n    unordered_set<int> numsSet{nums.begin(), nums.end()};\n\n    for (ListNode* curr = &dummy; curr->next != nullptr;)\n      if (numsSet.contains(curr->next->val))\n        curr->next = curr->next->next;\n      else\n        curr = curr->next;\n\n    return dummy.next;\n  }\n};\n", "3218": "class Solution {\n public:\n  int minimumCost(int m, int n, vector<int>& horizontalCut,\n                  vector<int>& verticalCut) {\n    int cost = 0;\n    int sumH = accumulate(horizontalCut.begin(), horizontalCut.end(), 0);\n    int sumV = accumulate(verticalCut.begin(), verticalCut.end(), 0);\n\n    ranges::sort(horizontalCut, greater<>());\n    ranges::sort(verticalCut, greater<>());\n\n    for (int i = 0, j = 0; i < m - 1 && j < n - 1;)\n      if (horizontalCut[i] > verticalCut[j]) {\n        cost += horizontalCut[i] + sumV;\n        sumH -= horizontalCut[i++];\n      } else {\n        cost += verticalCut[j] + sumH;\n        sumV -= verticalCut[j++];\n      }\n\n    return cost + sumH + sumV;\n  }\n};\n", "3219": "class Solution {\n public:\n  // Same as 3218. Minimum Cost for Cutting Cake I\n  long long minimumCost(int m, int n, vector<int>& horizontalCut,\n                        vector<int>& verticalCut) {\n    long cost = 0;\n    long sumH = accumulate(horizontalCut.begin(), horizontalCut.end(), 0L);\n    long sumV = accumulate(verticalCut.begin(), verticalCut.end(), 0L);\n\n    ranges::sort(horizontalCut, greater<>());\n    ranges::sort(verticalCut, greater<>());\n\n    for (int i = 0, j = 0; i < m - 1 && j < n - 1;)\n      if (horizontalCut[i] > verticalCut[j]) {\n        cost += horizontalCut[i] + sumV;\n        sumH -= horizontalCut[i++];\n      } else {\n        cost += verticalCut[j] + sumH;\n        sumV -= verticalCut[j++];\n      }\n\n    return cost + sumH + sumV;\n  }\n};\n", "322": "class Solution {\n public:\n  int coinChange(vector<int>& coins, int amount) {\n    // dp[i] := the minimum number of coins to make up i\n    vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; ++i)\n      for (const int coin : coins)\n        if (coin <= i)\n          dp[i] = min(dp[i], dp[i - coin] + 1);\n\n    return dp[amount] == amount + 1 ? -1 : dp[amount];\n  }\n};\n", "3221": "class Solution {\n public:\n  // Same as 3205. Maximum Array Hopping Score I\n  long long maxScore(vector<int>& nums) {\n    // The optimal jump is the maximum number in the remaining suffix.\n    long ans = 0;\n    int mx = 0;\n\n    for (int i = nums.size() - 1; i > 0; --i) {\n      mx = max(mx, nums[i]);\n      ans += mx;\n    }\n\n    return ans;\n  }\n};\n", "3222": "class Solution {\n public:\n  string losingPlayer(int x, int y) {\n    return min(x, y / 4) % 2 == 0 ? \"Bob\" : \"Alice\";\n  }\n};\n", "3223": "class Solution {\n public:\n  int minimumLength(string s) {\n    int ans = 0;\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int i = 0; i < 26; ++i)\n      if (count[i] > 0)\n        ans += count[i] % 2 == 0 ? 2 : 1;\n\n    return ans;\n  }\n};\n", "3224": "class Solution {\n public:\n  int minChanges(vector<int>& nums, int k) {\n    const int n = nums.size();\n    const int pairSize = n / 2;\n    int ans = n;\n    unordered_map<int, int> diffCount;  // {abs(nums[-1 - i] - nums[i]): freq}\n    // oneChangeCount[i] := the number of pairs that need only one change to to\n    // achieve a difference of `i`\n    vector<int> oneChangeCount(k + 1);\n\n    for (int i = 0; i < pairSize; ++i) {\n      const int a = nums[i];\n      const int b = nums[n - 1 - i];\n      ++diffCount[abs(a - b)];\n      ++oneChangeCount[max({a, b, k - a, k - b})];\n    }\n\n    // prefixOneChangeCount[i] := the number of pairs that need only one change\n    // to achieve a difference >= `i`\n    // prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    vector<int> prefixOneChangeCount{oneChangeCount};\n\n    for (int i = k - 1; i >= 0; --i)\n      prefixOneChangeCount[i] += prefixOneChangeCount[i + 1];\n\n    for (const auto& [diff, freq] : diffCount) {\n      const int oneChange = prefixOneChangeCount[diff] - freq;\n      const int twoChanges = (pairSize - prefixOneChangeCount[diff]) * 2;\n      ans = min(ans, oneChange + twoChanges);\n    }\n\n    return ans;\n  }\n};\n", "3225": "class Solution {\n public:\n  long long maximumScore(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    // prefix[j][i] := the sum of the first i elements in the j-th column\n    vector<vector<long>> prefix(n, vector<long>(n + 1));\n    // prevPick[i] := the maximum achievable score up to the previous column,\n    // where the bottommost selected element in that column is in row (i - 1)\n    vector<long> prevPick(n + 1);\n    // prevSkip[i] := the maximum achievable score up to the previous column,\n    // where the bottommost selected element in the column before the previous\n    // one is in row (i - 1)\n    vector<long> prevSkip(n + 1);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < n; ++i)\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j];\n\n    for (int j = 1; j < n; ++j) {\n      vector<long> currPick(n + 1);\n      vector<long> currSkip(n + 1);\n      // Consider all possible combinations of the number of current and\n      // previous selected elements.\n      for (int curr = 0; curr <= n; ++curr)\n        for (int prev = 0; prev <= n; ++prev)\n          if (curr > prev) {\n            // 1. The current bottom is deeper than the previous bottom.\n            // Get the score of grid[prev..curr)[j - 1] for pick and skip.\n            const long score = prefix[j - 1][curr] - prefix[j - 1][prev];\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score);\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score);\n          } else {\n            // 2. The previous bottom is deeper than the current bottom.\n            // Get the score of grid[curr..prev)[j] for pick only.\n            const long score = prefix[j][prev] - prefix[j][curr];\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score);\n            currSkip[curr] = max(currSkip[curr], prevPick[prev]);\n          }\n      prevPick = std::move(currPick);\n      prevSkip = std::move(currSkip);\n    }\n\n    return ranges::max(prevPick);\n  }\n};\n", "3226": "class Solution {\n public:\n  int minChanges(unsigned n, unsigned k) {\n    // n needs to be a superset of k.\n    return (n & k) == k ? popcount(n ^ k) : -1;\n  }\n};\n", "3227": "class Solution {\n public:\n  bool doesAliceWin(string s) {\n    // Let k be the number of vowels in s.\n    // 1. If k == 0, Bob wins since Alice has no vowels to pick.\n    // 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.\n    // 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,\n    // then Bob will either pick a substring containing 0 vowels, resulting in\n    // Alice picking the remaining entire string, or Bob couldn't pick at all\n    // (the last vowel).\n    return ranges::any_of(s, [this](char c) { return isVowel(c); });\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "3228": "class Solution {\n public:\n  int maxOperations(string s) {\n    int ans = 0;\n    int ones = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == '1')\n        ++ones;\n      else if (i + 1 == s.length() || s[i + 1] == '1')\n        ans += ones;\n\n    return ans;\n  }\n};\n", "3229": "class Solution {\n public:\n  // Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target\n  // Array\n  long long minimumOperations(vector<int>& nums, vector<int>& target) {\n    long ans = abs(nums[0] - target[0]);\n\n    for (int i = 1; i < nums.size(); ++i) {\n      const int currDiff = target[i] - nums[i];\n      const int prevDiff = target[i - 1] - nums[i - 1];\n      if (currDiff >= 0 && prevDiff >= 0)\n        ans += max(0, currDiff - prevDiff);\n      else if (currDiff <= 0 && prevDiff <= 0)\n        ans += max(0, abs(currDiff) - abs(prevDiff));\n      else\n        ans += abs(currDiff);\n    }\n\n    return ans;\n  }\n};\n", "323": "class Solution {\n public:\n  int countComponents(int n, vector<vector<int>>& edges) {\n    int ans = 0;\n    vector<vector<int>> graph(n);\n    unordered_set<int> seen;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (seen.insert(i).second) {\n        dfs(graph, i, seen);\n        ++ans;\n      }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {\n    for (const int v : graph[u])\n      if (seen.insert(v).second)\n        dfs(graph, v, seen);\n  }\n};\n", "3231": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    // The length of the longest non-increasing subsequence is equal to the\n    // number of strictly increasing subsequences needed to cover the entire\n    // array. This is because any number in the non-increasing subsequence must\n    // use one number from each of the strictly increasing subsequences. e.g.,\n    // [4, 3, 1, 2] has 3 strictly increasing subsequences: [4], [3], and [1,\n    // 2]. The longest non-increasing subsequences are [4, 3, 1] or [4, 3, 2].\n    return lengthOfLIS({nums.rbegin(), nums.rend()});\n  }\n\n private:\n  // Similar to 300. Longest Increasing Subsequence\n  int lengthOfLIS(const vector<int>& nums) {\n    // tails[i] := the minimum tail of all the non-decreasing subsequences\n    // having length i + 1\n    vector<int> tails;\n\n    for (const int num : nums)\n      if (tails.empty() || num >= tails.back())\n        tails.push_back(num);\n      else\n        tails[firstGreater(tails, num)] = num;\n\n    return tails.size();\n  }\n\n private:\n  int firstGreater(const vector<int>& arr, int target) {\n    return ranges::upper_bound(arr, target) - arr.begin();\n  }\n};\n", "3232": "class Solution {\n public:\n  bool canAliceWin(vector<int>& nums) {\n    return accumulate(nums.begin(), nums.end(), 0, [](int acc, int num) {\n      return acc + (num < 10 ? num : -num);\n    }) != 0;\n  }\n};\n", "3233": "class Solution {\n public:\n  int nonSpecialCount(int l, int r) {\n    const int maxRoot = sqrt(r);\n    const vector<bool> isPrime = sieveEratosthenes(maxRoot + 1);\n    int specialCount = 0;\n\n    for (int num = 2; num <= sqrt(r); ++num)\n      if (isPrime[num] && l <= num * num && num * num <= r)\n        ++specialCount;\n\n    return r - l + 1 - specialCount;\n  }\n\n private:\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "3234": "class Solution {\n public:\n  int numberOfSubstrings(string s) {\n    int ans = 0;\n\n    // Iterate through all possible number of 0s.\n    for (int zero = 0; zero + zero * zero <= s.length(); ++zero) {\n      int lastInvalidPos = -1;\n      vector<int> count(2);\n      for (int l = 0, r = 0; r < s.length(); ++r) {\n        ++count[s[r] - '0'];\n        // Try to shrink the window to maintain the \"minimum\" length of the\n        // valid substring.\n        for (; l < r; ++l)\n          if (s[l] == '0' && count[0] > zero) {\n            --count[0];  // Remove an extra '0'.\n            lastInvalidPos = l;\n          } else if (s[l] == '1' && count[1] - 1 >= zero * zero) {\n            --count[1];  // Remove an extra '1'.\n          } else {\n            break;  // Cannot remove more characters.\n          }\n        if (count[0] == zero && count[1] >= zero * zero)\n          // Add valid substrings ending in s[r] to the answer. They are\n          // s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3235": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n    const int n = circles.size();\n    // Add two virtual nodes, where node n represents (0, 0) and node n + 1\n    // represents (X, Y).\n    UnionFind uf(n + 2);\n\n    // Iterate through each circle.\n    for (int i = 0; i < n; ++i) {\n      const int x = circles[i][0];\n      const int y = circles[i][1];\n      const int r = circles[i][2];\n      // Union the current circle with the node (0, 0) if the circle overlaps\n      // with the left or top edges.\n      if (x - r <= 0 || y + r >= Y)\n        uf.unionByRank(i, n);\n      // Union the current circle with the node (X, Y) if the circle overlaps\n      // with the right or bottom edges.\n      if (x + r >= X || y - r <= 0)\n        uf.unionByRank(i, n + 1);\n      // Union the current circle with previous circles if they overlap.\n      for (int j = 0; j < i; ++j) {\n        const int x2 = circles[j][0];\n        const int y2 = circles[j][1];\n        const int r2 = circles[j][2];\n        if (static_cast<long>(x - x2) * (x - x2) +\n                static_cast<long>(y - y2) * (y - y2) <=\n            static_cast<long>(r + r2) * (r + r2))\n          uf.unionByRank(i, j);\n      }\n    }\n\n    // If nodes (0, 0) and (X, Y) are in the same union set, that means there's\n    // a path of overlapping circles that connects the left or top edges to the\n    // right or bottom edges, implying that (0, 0) cannot reach (X, Y).\n    return uf.find(n) != uf.find(n + 1);\n  }\n};\n", "3237": "class Solution {\n public:\n  vector<int> simulationResult(vector<int>& windows, vector<int>& queries) {\n    vector<int> ans;\n    unordered_set<int> seen;\n\n    for (int i = queries.size() - 1; i >= 0; --i)\n      if (!seen.contains(queries[i])) {\n        ans.push_back(queries[i]);\n        seen.insert(queries[i]);\n      }\n\n    for (const int window : windows)\n      if (!seen.contains(window)) {\n        ans.push_back(window);\n        seen.insert(window);\n      }\n\n    return ans;\n  }\n};\n", "3238": "class Solution {\n public:\n  int winningPlayerCount(int n, vector<vector<int>>& pick) {\n    constexpr int kMaxColor = 10;\n    int ans = 0;\n    vector<vector<int>> counts(n, vector<int>(kMaxColor + 1));\n\n    for (const vector<int>& p : pick) {\n      const int player = p[0];\n      const int color = p[1];\n      ++counts[player][color];\n    }\n\n    for (int i = 0; i < n; ++i) {\n      int maxCount = 0;\n      for (const int freq : counts[i])\n        maxCount = max(maxCount, freq);\n      if (maxCount > i)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "3239": "class Solution {\n public:\n  int minFlips(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int rowFlips = 0;\n    int colFlips = 0;\n\n    for (const vector<int>& row : grid)\n      for (int i = 0; i < n / 2; ++i)\n        if (row[i] != row[n - 1 - i])\n          ++rowFlips;\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m / 2; ++i)\n        if (grid[i][j] != grid[m - 1 - i][j])\n          ++colFlips;\n\n    return min(rowFlips, colFlips);\n  }\n};\n", "324": "class Solution {\n public:\n  void wiggleSort(vector<int>& nums) {\n    const int n = nums.size();\n    const auto it = nums.begin() + n / 2;\n    nth_element(nums.begin(), it, nums.end());\n    const int median = *it;\n\n// index-rewiring\n#define A(i) nums[(1 + 2 * i) % (n | 1)]\n\n    for (int i = 0, j = 0, k = n - 1; i <= k;)\n      if (A(i) > median)\n        swap(A(i++), A(j++));\n      else if (A(i) < median)\n        swap(A(i), A(k--));\n      else\n        ++i;\n  }\n};\n", "3240": "class Solution {\n public:\n  int minFlips(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    int middleOnes = 0;\n    int mismatchedPairs = 0;\n\n    // Handle top-left, top-right, bottom-left, bottom-right cells.\n    for (int i = 0; i < m / 2; ++i)\n      for (int j = 0; j < n / 2; ++j) {\n        const int ones = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] +\n                         grid[m - 1 - i][n - 1 - j];\n        ans += min(ones, 4 - ones);\n      }\n\n    // Handle the middle row if the number of m is odd.\n    if (m % 2 == 1)\n      for (int j = 0; j < n / 2; ++j) {\n        const int leftCell = grid[m / 2][j];\n        const int rightCell = grid[m / 2][n - 1 - j];\n        mismatchedPairs += leftCell ^ rightCell;\n        middleOnes += leftCell + rightCell;\n      }\n\n    // Handle the middle column if the number of columns is odd.\n    if (n % 2 == 1)\n      for (int i = 0; i < m / 2; ++i) {\n        const int topCell = grid[i][n / 2];\n        const int bottomCell = grid[m - 1 - i][n / 2];\n        mismatchedPairs += topCell ^ bottomCell;\n        middleOnes += topCell + bottomCell;\n      }\n\n    if (mismatchedPairs == 0) {\n      // Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.\n      if (middleOnes % 4 == 2)\n        ans += 2;  // Flip two 1s to 0s.\n    } else {\n      // Flip every mismatched pair 01 to 00 or 11. It doesn't matter.\n      ans += mismatchedPairs;\n    }\n\n    // Handle the center cell if both dimensions are odd.\n    if (m % 2 == 1 && n % 2 == 1)\n      ans += grid[m / 2][n / 2];\n\n    return ans;\n  }\n};\n", "3241": "struct Node {\n  int node = 0;  // the node number\n  int time = 0;  // the time taken to mark the entire subtree rooted at the node\n};\n\nstruct Top2 {\n  // the direct child node, where the time taken to mark the entire subtree\n  // rooted at the node is the maximum\n  Node top1;\n  // the direct child node, where the time taken to mark the entire subtree\n  // rooted at the node is the second maximum\n  Node top2;\n};\n\nclass Solution {\n public:\n  vector<int> timeTaken(vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    vector<int> ans(n);\n    vector<vector<int>> tree(n);\n    // dp[i] := the top two direct child nodes for subtree rooted at node i,\n    // where each node contains the time taken to mark the entire subtree rooted\n    // at the node itself\n    vector<Top2> dp(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, /*prev=*/-1, dp);\n    reroot(tree, 0, /*prev=*/-1, /*maxTime=*/0, dp, ans);\n    return ans;\n  }\n\n private:\n  // Return the time taken to mark node u.\n  int getTime(int u) {\n    return u % 2 == 0 ? 2 : 1;\n  }\n\n  // Performs a DFS traversal of the subtree rooted at node `u`, computes the\n  // time taken to mark all nodes in the subtree, records the top two direct\n  // child nodes, where the time taken to mark the subtree rooted at each of the\n  // child nodes is maximized, and returns the top child node.\n  //\n  // These values are used later in the rerooting process.\n  int dfs(const vector<vector<int>>& tree, int u, int prev, vector<Top2>& dp) {\n    Node top1;\n    Node top2;\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      const int time = dfs(tree, v, u, dp) + getTime(v);\n      if (time >= top1.time) {\n        top2 = top1;\n        top1 = Node(v, time);\n      } else if (time > top2.time) {\n        top2 = Node(v, time);\n      }\n    }\n    dp[u] = Top2(top1, top2);\n    return top1.time;\n  }\n\n  // Reroots the tree at node `u` and updates the answer array, where `maxTime`\n  // is the longest path that doesn't go through `u`'s subtree.\n  void reroot(const vector<vector<int>>& tree, int u, int prev, int maxTime,\n              const vector<Top2>& dp, vector<int>& ans) {\n    ans[u] = max(maxTime, dp[u].top1.time);\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      const int newMaxTime =\n          getTime(u) + max(maxTime, dp[u].top1.node == v ? dp[u].top2.time\n                                                         : dp[u].top1.time);\n      reroot(tree, v, u, newMaxTime, dp, ans);\n    }\n  }\n};\n", "3242": "class neighborSum {\n public:\n  neighborSum(vector<vector<int>>& grid)\n      : n(grid.size()), grid(grid), numToPos(n * n) {\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        numToPos[grid[i][j]] = {i, j};\n  }\n\n  int adjacentSum(int value) {\n    const auto& [i, j] = numToPos[value];\n    int sum = 0;\n    for (const auto& [x, y] :\n         vector<pair<int, int>>{{i - 1, j}, {i + 1, j}, {i, j - 1}, {i, j + 1}})\n      if (x >= 0 && x < n && y >= 0 && y < n)\n        sum += grid[x][y];\n    return sum;\n  }\n\n  int diagonalSum(int value) {\n    const auto& [i, j] = numToPos[value];\n    int sum = 0;\n    for (const auto& [x, y] : vector<pair<int, int>>{\n             {i - 1, j - 1}, {i - 1, j + 1}, {i + 1, j - 1}, {i + 1, j + 1}})\n      if (x >= 0 && x < n && y >= 0 && y < n)\n        sum += grid[x][y];\n    return sum;\n  }\n\n private:\n  const int n;\n  vector<vector<int>> grid;\n  vector<pair<int, int>> numToPos;\n};\n", "3243": "class Solution {\n public:\n  vector<int> shortestDistanceAfterQueries(int n,\n                                           vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> dist(n);\n    vector<vector<int>> graph(n);\n\n    iota(dist.begin(), dist.end(), 0);\n\n    for (int i = 0; i < n - 1; ++i)\n      graph[i].push_back(i + 1);\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      graph[u].push_back(v);\n      if (dist[u] + 1 < dist[v]) {\n        dist[v] = dist[u] + 1;\n        bfs(graph, v, dist);\n      }\n      ans.push_back(dist[n - 1]);\n    }\n\n    return ans;\n  }\n\n private:\n  // Performs a BFS to update the shortest distances from the given `start` node\n  // to all other reachable nodes in the graph. It updates the `dist` vector\n  // with the new shortest distances.\n  void bfs(const vector<vector<int>>& graph, int start, vector<int>& dist) {\n    queue<int> q{{start}};\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const int v : graph[u]) {\n        if (dist[u] + 1 < dist[v]) {\n          dist[v] = dist[u] + 1;\n          q.push(v);\n        }\n      }\n    }\n  }\n};\n", "3244": "class Solution {\n public:\n  vector<int> shortestDistanceAfterQueries(int n,\n                                           vector<vector<int>>& queries) {\n    vector<int> ans;\n    unordered_map<int, int> nodeToFarthestNode;\n\n    for (int i = 0; i < n - 1; ++i)\n      nodeToFarthestNode[i] = i + 1;\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      // If `u` exists in the map and `v` is farther than the current farthest\n      // node for `u`, we need to update the map and remove intermediate nodes.\n      if (nodeToFarthestNode.contains(u) && nodeToFarthestNode[u] < v) {\n        int node = nodeToFarthestNode[u];\n        while (node < v) {\n          const int cache = node;\n          node = nodeToFarthestNode[node];\n          nodeToFarthestNode.erase(cache);\n        }\n        nodeToFarthestNode[u] = v;\n      }\n      ans.push_back(nodeToFarthestNode.size());\n    }\n\n    return ans;\n  }\n};\n", "3245": "struct SegmentTree {\n public:\n  explicit SegmentTree(int n)\n      : n(n), treeIntervalCounts(4 * n), treeIntervalLengths(4 * n) {}\n\n  // Adds val to intervalCounts[i] and updates intervalLengths[i] accordingly.\n  void add(int i, int val) {\n    add(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(intervalCounts[i..n - 1]).\n  int queryIntervalCounts(int i) const {\n    return query(treeIntervalCounts, 0, 0, n - 1, i, n - 1);\n  }\n\n  // Returns sum(intervalLengths[i..n - 1]).\n  int queryIntervalLengths(int i) const {\n    return query(treeIntervalLengths, 0, 0, n - 1, i, n - 1);\n  }\n\n private:\n  const int n;\n  vector<int> treeIntervalCounts;\n  vector<int> treeIntervalLengths;\n\n  void add(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      treeIntervalCounts[treeIndex] += val;\n      treeIntervalLengths[treeIndex] = treeIntervalCounts[treeIndex] * i;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      add(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      add(2 * treeIndex + 2, mid + 1, hi, i, val);\n    treeIntervalCounts[treeIndex] =\n        merge(treeIntervalCounts[2 * treeIndex + 1],\n              treeIntervalCounts[2 * treeIndex + 2]);\n    treeIntervalLengths[treeIndex] =\n        merge(treeIntervalLengths[2 * treeIndex + 1],\n              treeIntervalLengths[2 * treeIndex + 2]);\n  }\n\n  int query(const vector<int>& tree, int treeIndex, int lo, int hi, int i,\n            int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(tree, treeIndex * 2 + 1, lo, mid, i, j),\n                 query(tree, treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> numberOfAlternatingGroups(vector<int>& colors,\n                                        vector<vector<int>>& queries) {\n    const int n = colors.size();\n    vector<int> ans;\n    vector<int> arr{colors};\n    SegmentTree tree(2 * n - 1);\n    set<pair<int, int>> intervals;\n\n    arr.insert(arr.end(), colors.begin(), colors.end());\n\n    // Insert all intervals, each of them is an alternating sequence.\n    int start = 0;\n    for (int i = 1; i < 2 * n - 1; ++i)\n      if (arr[i] == arr[i - 1]) {\n        insert(intervals, {start, i - 1}, tree, n);\n        start = i;\n      }\n    insert(intervals, {start, 2 * n - 2}, tree, n);\n\n    for (const vector<int>& query : queries)\n      if (query[0] == 1) {\n        const int sz = query[1];\n        const pair<int, int>& intervalWithN = findInterval(intervals, n);\n        const int numAlternatingGroups =\n            getNumAlternatingGroups(sz, intervalWithN, tree, n);\n        ans.push_back(numAlternatingGroups);\n      } else {\n        const int index = query[1];\n        const int color = query[2];\n        if (arr[index] == color)\n          continue;\n        update(intervals, index, color, arr, tree, n);\n        if (index < n - 1)\n          update(intervals, index + n, color, arr, tree, n);\n      }\n\n    return ans;\n  }\n\n private:\n  // Returns the number of alternating groups of size `sz`.\n  int getNumAlternatingGroups(int sz, const pair<int, int>& intervalWithN,\n                              const SegmentTree& tree, int n) {\n    const int numIntervals = tree.queryIntervalCounts(sz);\n    const int sumIntervals = tree.queryIntervalLengths(sz);\n    // The number of alternating groups for an interval is |interval| - sz + 1.\n    // Therefore, the number of alternating groups for all intervals is\n    //   sum(|intervals[i]| - sz + 1)\n    // = sum(|intervals[i]) - numIntervals * sz + numIntervals\n    const int numAlternatingGroups =\n        sumIntervals - numIntervals * sz + numIntervals;\n    // We need to check if the interval (l, r) contains n, and if it does, we\n    // need to adjust the number of alternating groups to avoid duplicates.\n    const auto& [l, r] = intervalWithN;\n    // 1. For an interval with l >= n, it wasn't being considered in `insert`\n    // and `remove`.\n    // 2. For an interval with r - l + 1 < sz, it's impossible to form a group\n    // of size `sz`.\n    if (l >= n || r - l + 1 < sz)\n      return numAlternatingGroups;\n    // 3. For an interval with r >= n, it's possible to duplicately count the\n    // groups starting from n.\n    if (r >= n) {  // l < n && r - 1 + 1 >= sz\n      // Groups starting from [l..n) are non-duplicately counted.\n      const int nonDuplicateGroups = n - l;\n      // The number of groups of size `sz` in the interval [l..r].\n      const int numGroups = (r - l + 1) - sz + 1;\n      return numAlternatingGroups - max(0, numGroups - nonDuplicateGroups);\n    }\n    return numAlternatingGroups;\n  }\n\n  // Inserts an interval into `intervals` and updates `tree`.\n  void insert(set<pair<int, int>>& intervals, const pair<int, int>& interval,\n              SegmentTree& tree, int n) {\n    intervals.insert(interval);\n    if (interval.first < n)\n      tree.add(interval.second - interval.first + 1, 1);\n  }\n\n  // Removes an interval from `intervals` and updates `tree`.\n  void remove(set<pair<int, int>>& intervals, const pair<int, int>& interval,\n              SegmentTree& tree, int n) {\n    intervals.erase(interval);\n    if (interval.first < n)\n      tree.add(interval.second - interval.first + 1, -1);\n  }\n\n  // Returns the interval containing the target.\n  pair<int, int> findInterval(const set<pair<int, int>>& intervals,\n                              int target) {\n    auto it = intervals.upper_bound({target, INT_MAX});\n    return (*--it);\n  }\n\n  // Updates the color of the index-th element in `arr` and updates `intervals`\n  // and `tree`.\n  void update(set<pair<int, int>>& intervals, int index, int color,\n              vector<int>& arr, SegmentTree& tree, int n) {\n    arr[index] = color;\n\n    const pair<int, int> intervalWithIndex = findInterval(intervals, index);\n    remove(intervals, intervalWithIndex, tree, n);\n    auto [start, end] = intervalWithIndex;\n\n    // interval [s..i - 1|i|i + 1..e]\n    //    index           ^\n    if (start < index && index < end) {\n      insert(intervals, {start, index - 1}, tree, n);\n      insert(intervals, {index, index}, tree, n);\n      insert(intervals, {index + 1, end}, tree, n);\n      return;\n    }\n\n    // interval [s|s + 1..e]\n    //    index  ^\n    if (start == index && index < end)\n      insert(intervals, {start + 1, end}, tree, n);\n\n    // interval [s..e - 1|e]\n    //    index           ^\n    if (start < index && index == end)\n      insert(intervals, {start, end - 1}, tree, n);\n\n    start = index;\n    end = index;\n    vector<pair<int, int>> intervalsToRemove;\n\n    auto it = intervals.upper_bound({index, INT_MAX});\n\n    for (auto lit = it; lit != intervals.begin();) {\n      --lit;\n      if (arr[lit->second] == arr[start])  // [..lit->second|start..]\n        break;\n      intervalsToRemove.push_back(*lit);\n      start = lit->first;\n    }\n\n    for (auto rit = it; rit != intervals.end(); ++rit) {\n      if (arr[rit->first] == arr[end])  // [..end|rit->first..]\n        break;\n      intervalsToRemove.push_back(*rit);\n      end = rit->second;\n    }\n\n    for (const pair<int, int>& interval : intervalsToRemove)\n      remove(intervals, interval, tree, n);\n\n    insert(intervals, {start, end}, tree, n);\n  }\n};\n", "3247": "class Solution {\n public:\n  int subsequenceCount(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    int even = 0;  // the number of subsequences with even sum\n    int odd = 0;   // the number of subsequences with odd sum\n\n    for (const int num : nums)\n      if (num % 2 == 0) {\n        // Appending an even number to a subsequence doesn't change the parity.\n        // The even number itself is also a valid subsequence.\n        even = (even + even + 1) % kMod;\n        odd = (odd + odd) % kMod;\n      } else {\n        // Appending an odd number to a subsequence changes the parity.\n        // The odd number itself is also a valid subsequence.\n        const int newEven = (even + odd) % kMod;\n        odd = (odd + even + 1) % kMod;\n        even = newEven;\n      }\n\n    return odd % kMod;\n  }\n};\n", "3248": "class Solution {\n public:\n  int finalPositionOfSnake(int n, vector<string>& commands) {\n    const unordered_map<string, pair<int, int>> directions = {\n        {\"UP\", {-1, 0}},\n        {\"RIGHT\", {0, 1}},\n        {\"DOWN\", {1, 0}},\n        {\"LEFT\", {0, -1}}};\n    int i = 0;\n    int j = 0;\n\n    for (const string& command : commands) {\n      const auto& [dx, dy] = directions.at(command);\n      i += dx;\n      j += dy;\n    }\n\n    return i * n + j;\n  }\n};\n", "3249": "class Solution {\n public:\n  int countGoodNodes(vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    int ans = 0;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    dfs(graph, 0, /*prev=*/-1, ans);\n    return ans;\n  }\n\n private:\n  int ans = 0;\n\n  // Returns the size of the subtree rooted at u.\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int& ans) {\n    int size = 1;\n    vector<int> childrenSizes;\n\n    for (const int v : graph[u]) {\n      if (v == prev)\n        continue;\n      const int childSize = dfs(graph, v, u, ans);\n      size += childSize;\n      childrenSizes.push_back(childSize);\n    }\n\n    if (childrenSizes.empty() || allSameSizes(childrenSizes))\n      ++ans;\n\n    return size;\n  }\n\n private:\n  bool allSameSizes(const vector<int>& childrenSizes) {\n    for (int i = 1; i < childrenSizes.size(); ++i)\n      if (childrenSizes[i] != childrenSizes[0])\n        return false;\n    return true;\n  }\n};\n", "325": "class Solution {\n public:\n  int maxSubArrayLen(vector<int>& nums, int k) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      const int target = prefix - k;\n      if (const auto it = prefixToIndex.find(target);\n          it != prefixToIndex.cend())\n        ans = max(ans, i - it->second);\n      if (!prefixToIndex.contains(prefix))\n        prefixToIndex[prefix] = i;\n    }\n\n    return ans;\n  }\n};\n", "3250": "class Solution {\n public:\n  int countOfPairs(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMax = 1000;\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][num] := the number of valid ways to fill the arrays up to index i\n    // with arr1[i] = num\n    vector<vector<int>> dp(n, vector<int>(kMax + 1));\n\n    for (int num = 0; num <= nums[0]; ++num)\n      dp[0][num] = 1;\n\n    for (int i = 1; i < n; ++i) {\n      int ways = 0;\n      int prevNum = 0;\n      // To satisfy arr1, prevNum <= num.\n      // To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      //               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      // As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      // becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      // Since the range of `prevNum` can only increase by at most 1, there's\n      // no need to iterate through all possible values of `prevNum`. We can\n      // simply increment `prevNum` by 1 if it meets the condition.\n      for (int num = 0; num <= nums[i]; ++num) {\n        if (prevNum <= min(num, num - (nums[i] - nums[i - 1]))) {\n          ways = (ways + dp[i - 1][prevNum]) % kMod;\n          ++prevNum;\n        }\n        dp[i][num] = ways;\n      }\n    }\n\n    for (int i = 0; i <= kMax; ++i)\n      ans = (ans + dp[n - 1][i]) % kMod;\n\n    return ans;\n  }\n};\n", "3251": "class Solution {\n public:\n  // Same as 3250. Find the Count of Monotonic Pairs I\n  int countOfPairs(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMax = 1000;\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][num] := the number of valid ways to fill the arrays up to index i\n    // with arr1[i] = num\n    vector<vector<int>> dp(n, vector<int>(kMax + 1));\n\n    for (int num = 0; num <= nums[0]; ++num)\n      dp[0][num] = 1;\n\n    for (int i = 1; i < n; ++i) {\n      int ways = 0;\n      int prevNum = 0;\n      // To satisfy arr1, prevNum <= num.\n      // To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      //               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      // As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      // becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      // Since the range of `prevNum` can only increase by at most 1, there's\n      // no need to iterate through all possible values of `prevNum`. We can\n      // simply increment `prevNum` by 1 if it meets the condition.\n      for (int num = 0; num <= nums[i]; ++num) {\n        if (prevNum <= min(num, num - (nums[i] - nums[i - 1]))) {\n          ways = (ways + dp[i - 1][prevNum]) % kMod;\n          ++prevNum;\n        }\n        dp[i][num] = ways;\n      }\n    }\n\n    for (int i = 0; i <= kMax; ++i)\n      ans = (ans + dp[n - 1][i]) % kMod;\n\n    return ans;\n  }\n};\n", "3253": "class Solution {\n public:\n  int minimumCost(string target, vector<string>& words, vector<int>& costs) {\n    const int n = target.length();\n    // dp[i] := the minimum cost to construct target[0..i)\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = 0; j < words.size(); ++j)\n        if (i >= words[j].length() &&\n            target.substr(i - words[j].length(), words[j].length()) ==\n                words[j] &&\n            dp[i - words[j].length()] != INT_MAX)\n          dp[i] = min(dp[i], dp[i - words[j].length()] + costs[j]);\n\n    return dp[n] == INT_MAX ? -1 : dp[n];\n  }\n};\n", "3254": "class Solution {\n public:\n  vector<int> resultsArray(vector<int>& nums, int k) {\n    vector<int> ans;\n    int start = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i > 0 && nums[i] != nums[i - 1] + 1)\n        start = i;\n      if (i >= k - 1)\n        ans.push_back(i - start + 1 >= k ? nums[i] : -1);\n    }\n\n    return ans;\n  }\n};\n", "3255": "class Solution {\n public:\n  // Same as 3254. Find the Power of K-Size Subarrays I\n  vector<int> resultsArray(vector<int>& nums, int k) {\n    vector<int> ans;\n    int start = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i > 0 && nums[i] != nums[i - 1] + 1)\n        start = i;\n      if (i >= k - 1)\n        ans.push_back(i - start + 1 >= k ? nums[i] : -1);\n    }\n\n    return ans;\n  }\n};\n", "3256": "class Solution {\n public:\n  long long maximumValueSum(vector<vector<int>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n    long ans = LONG_MIN;\n    using T = tuple<long, int, int>;\n    vector<vector<T>> rows(m);  // [(val, i, j)]\n    vector<vector<T>> cols(n);  // [(val, i, j)]\n    set<T> rowSet;              // {(val, i, j)}\n    set<T> colSet;              // {(val, i, j)}\n    set<T> topNine;             // {(val, i, j)}\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        rows[i].emplace_back(board[i][j], i, j);\n        cols[j].emplace_back(board[i][j], i, j);\n      }\n\n    auto getTop3 = [](vector<T>& row) -> vector<T> {\n      partial_sort(row.begin(),\n                   row.begin() + min(3, static_cast<int>(row.size())),\n                   row.end(), greater<>());\n      row.resize(min(3, (int)row.size()));\n      return row;\n    };\n\n    for (vector<T>& row : rows) {\n      row = getTop3(row);\n      rowSet.insert(row.begin(), row.end());\n    }\n\n    for (vector<T>& col : cols) {\n      col = getTop3(col);\n      colSet.insert(col.begin(), col.end());\n    }\n\n    set_intersection(rowSet.begin(), rowSet.end(), colSet.begin(), colSet.end(),\n                     inserter(topNine, topNine.begin()));\n\n    // At least 9 positions are required on the board to place 3 rooks such that\n    // none can attack another.\n    if (topNine.size() > 9) {\n      auto it = topNine.begin();\n      advance(it, topNine.size() - 9);\n      topNine.erase(topNine.begin(), it);\n    }\n\n    for (auto it1 = topNine.begin(); it1 != topNine.end(); ++it1)\n      for (auto it2 = next(it1); it2 != topNine.end(); ++it2)\n        for (auto it3 = next(it2); it3 != topNine.end(); ++it3) {\n          const auto [val1, i1, j1] = *it1;\n          const auto [val2, i2, j2] = *it2;\n          const auto [val3, i3, j3] = *it3;\n          if (i1 == i2 || i1 == i3 || i2 == i3 ||  //\n              j1 == j2 || j1 == j3 || j2 == j3)\n            continue;\n          ans = max(ans, val1 + val2 + val3);\n        }\n\n    return ans;\n  }\n};\n", "3257": "class Solution {\n public:\n  // Same as 3256. Maximum Value Sum by Placing Three Rooks I\n  long long maximumValueSum(vector<vector<int>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n    long ans = LONG_MIN;\n    using T = tuple<long, int, int>;\n    vector<vector<T>> rows(m);  // [(val, i, j)]\n    vector<vector<T>> cols(n);  // [(val, i, j)]\n    set<T> rowSet;              // {(val, i, j)}\n    set<T> colSet;              // {(val, i, j)}\n    set<T> topNine;             // {(val, i, j)}\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        rows[i].emplace_back(board[i][j], i, j);\n        cols[j].emplace_back(board[i][j], i, j);\n      }\n\n    auto getTop3 = [](vector<T>& row) -> vector<T> {\n      partial_sort(row.begin(),\n                   row.begin() + min(3, static_cast<int>(row.size())),\n                   row.end(), greater<>());\n      row.resize(min(3, (int)row.size()));\n      return row;\n    };\n\n    for (vector<T>& row : rows) {\n      row = getTop3(row);\n      rowSet.insert(row.begin(), row.end());\n    }\n\n    for (vector<T>& col : cols) {\n      col = getTop3(col);\n      colSet.insert(col.begin(), col.end());\n    }\n\n    set_intersection(rowSet.begin(), rowSet.end(), colSet.begin(), colSet.end(),\n                     inserter(topNine, topNine.begin()));\n\n    // At least 9 positions are required on the board to place 3 rooks such that\n    // none can attack another.\n    if (topNine.size() > 9) {\n      auto it = topNine.begin();\n      advance(it, topNine.size() - 9);\n      topNine.erase(topNine.begin(), it);\n    }\n\n    for (auto it1 = topNine.begin(); it1 != topNine.end(); ++it1)\n      for (auto it2 = next(it1); it2 != topNine.end(); ++it2)\n        for (auto it3 = next(it2); it3 != topNine.end(); ++it3) {\n          const auto [val1, i1, j1] = *it1;\n          const auto [val2, i2, j2] = *it2;\n          const auto [val3, i3, j3] = *it3;\n          if (i1 == i2 || i1 == i3 || i2 == i3 ||  //\n              j1 == j2 || j1 == j3 || j2 == j3)\n            continue;\n          ans = max(ans, val1 + val2 + val3);\n        }\n\n    return ans;\n  }\n};\n", "3258": "class Solution {\n public:\n  int countKConstraintSubstrings(string s, int k) {\n    int ans = 0;\n    vector<int> count(2);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      ++count[s[r] - '0'];\n      while (count[0] > k && count[1] > k)\n        --count[s[l++] - '0'];\n      ans += r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "3259": "class Solution {\n public:\n  long long maxEnergyBoost(vector<int>& energyDrinkA,\n                           vector<int>& energyDrinkB) {\n    long dpA = 0;  // the maximum energy boost if the last drink is A\n    long dpB = 0;  // the maximum energy boost if the last drink is B\n\n    for (int i = 0; i < energyDrinkA.size(); ++i) {\n      const long newDpA = max(dpB, dpA + energyDrinkA[i]);\n      const long newDpB = max(dpA, dpB + energyDrinkB[i]);\n      dpA = newDpA;\n      dpB = newDpB;\n    }\n\n    return max(dpA, dpB);\n  }\n};\n", "326": "class Solution {\n public:\n  bool isPowerOfThree(int n) {\n    return n > 0 && static_cast<int>(pow(3, 19)) % n == 0;\n  }\n};\n", "3260": "class Solution {\n public:\n  string largestPalindrome(int n, int k) {\n    switch (k) {\n      case 1:\n        return string(n, '9');\n      case 2:\n        return n <= 2 ? string(n, '8') : \"8\" + string(n - 2, '9') + \"8\";\n      case 3:\n      case 9:\n        return string(n, '9');\n      case 4:\n        return n <= 4 ? string(n, '8') : \"88\" + string(n - 4, '9') + \"88\";\n      case 5:\n        return n <= 2 ? string(n, '5') : \"5\" + string(n - 2, '9') + \"5\";\n      case 6:\n        if (n <= 2) {\n          return string(n, '6');\n        } else if (n % 2 == 1) {\n          const int l = n / 2 - 1;\n          return \"8\" + string(l, '9') + \"8\" + string(l, '9') + \"8\";\n        } else {\n          const int l = n / 2 - 2;\n          return \"8\" + string(l, '9') + \"77\" + string(l, '9') + \"8\";\n        }\n      case 8:\n        return n <= 6 ? string(n, '8') : \"888\" + string(n - 6, '9') + \"888\";\n      default:\n        const string middle[] = {\"\",          \"7\",          \"77\",\n                                 \"959\",       \"9779\",       \"99799\",\n                                 \"999999\",    \"9994999\",    \"99944999\",\n                                 \"999969999\", \"9999449999\", \"99999499999\"};\n        const int q = n / 12;\n        const int r = n % 12;\n        return string(q * 6, '9') + middle[r] + string(q * 6, '9');\n    }\n  }\n};\n", "3261": "class Solution {\n public:\n  vector<long long> countKConstraintSubstrings(string s, int k,\n                                               vector<vector<int>>& queries) {\n    const int n = s.size();\n    vector<long long> ans;\n    vector<int> count(2);\n    // leftToRight[l] : = the maximum right index r s.t.s[l..r] is valid\n    vector<int> leftToRight(n);\n    // rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid\n    vector<int> rightToLeft(n);\n    // prefix[i] := the number of valid substrings ending in [0..i - 1].\n    vector<long> prefix{0};\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      ++count[s[r] - '0'];\n      while (count[0] > k && count[1] > k)\n        --count[s[l++] - '0'];\n      rightToLeft[r] = l;\n    }\n\n    count = vector<int>(2);\n\n    for (int l = n - 1, r = n - 1; l >= 0; --l) {\n      ++count[s[l] - '0'];\n      while (count[0] > k && count[1] > k)\n        --count[s[r--] - '0'];\n      leftToRight[l] = r;\n    }\n\n    for (int r = 0; r < n; ++r)\n      prefix.push_back(prefix.back() + r - rightToLeft[r] + 1);\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      long numValidSubstrings = 0;\n      if (r > leftToRight[l]) {\n        // If r is beyond leftToRight[l], compute the number of valid substrings\n        // from l to leftToRight[l] and add the number of valid substrings\n        // ending in [leftToRight[l] + 1..r].\n        //\n        // prefix[r + 1] := the number of valid substrings ending in [0..r].\n        // prefix[leftToRight[l] + 1] := the number of valid substrings ending\n        // in [0..leftToRight].\n        // => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid\n        // substrings ending in [leftToRight[l] + 1..r].\n        const int sz = leftToRight[l] - l + 1;\n        numValidSubstrings =\n            (sz * (sz + 1)) / 2 + (prefix[r + 1] - prefix[leftToRight[l] + 1]);\n      } else {\n        // If r is within the range of leftToRight[l], compute the number of\n        // valid substrings directly from l to r.\n        const int sz = r - l + 1;\n        numValidSubstrings = (sz * static_cast<long>(sz + 1)) / 2;\n      }\n      ans.push_back(numValidSubstrings);\n    }\n\n    return ans;\n  }\n};\n", "3263": "class Solution {\n public:\n  vector<int> toArray(Node* head) {\n    vector<int> ans;\n    Node* curr = head;\n\n    while (curr != nullptr) {\n      ans.push_back(curr->val);\n      curr = curr->next;\n    }\n\n    return ans;\n  }\n};\n", "3264": "class Solution {\n public:\n  vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n    vector<int> ans(nums.size());\n    using P = pair<int, int>;  // (nums[i], i)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    for (int i = 0; i < nums.size(); ++i)\n      minHeap.emplace(nums[i], i);\n\n    while (k-- > 0) {\n      const auto [num, i] = minHeap.top();\n      minHeap.pop();\n      minHeap.emplace(num * multiplier, i);\n    }\n\n    while (!minHeap.empty()) {\n      const auto [num, i] = minHeap.top();\n      minHeap.pop();\n      ans[i] = num;\n    }\n\n    return ans;\n  }\n};\n", "3265": "class Solution {\n public:\n  int countPairs(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> count;\n    const int maxLen = to_string(ranges::max(nums)).length();\n\n    for (const int num : nums) {\n      const string digits =\n          string(maxLen - to_string(num).length(), '0') + to_string(num);\n      for (const int swap : getSwaps(digits))\n        ans += count[swap];\n      ++count[num];\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns all possible numbers after 1 swap.\n  unordered_set<int> getSwaps(const string& digits) {\n    const int n = digits.length();\n    unordered_set<int> swaps{{stoi(digits)}};\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        string newDigits = digits;\n        swap(newDigits[i], newDigits[j]);\n        swaps.insert(stoi(newDigits));\n      }\n\n    return swaps;\n  }\n};\n", "3266": "class Solution {\n public:\n  vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n    if (multiplier == 1)\n      return nums;\n\n    const int n = nums.size();\n    const int maxNum = ranges::max(nums);\n    vector<int> ans(n);\n    using P = pair<int, int>;  // (nums[i], i)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n\n    for (int i = 0; i < n; ++i)\n      minHeap.emplace(nums[i], i);\n\n    // Keep multiplying the minimum number as close as possible to the maximum\n    // number in the array. After that, stop multiplying the minimum number\n    // because it will be greater than the maximum number in the array and break\n    // the circularity.\n    while (k > 0 &&\n           static_cast<long>(minHeap.top().first) * multiplier <= maxNum) {\n      const auto [num, i] = minHeap.top();\n      minHeap.pop();\n      minHeap.emplace(num * multiplier, i);\n      --k;\n    }\n\n    vector<pair<int, int>> sortedIndexedNums;\n    while (!minHeap.empty())\n      sortedIndexedNums.push_back(minHeap.top()), minHeap.pop();\n\n    const int multipliesPerNum = k / n;\n    const int remainingK = k % n;\n\n    // Evenly distribute the remaining multiplications to each number by using\n    // fast exponentiation.\n    for (auto& [num, _] : sortedIndexedNums)\n      num = (num * modPow(multiplier, multipliesPerNum)) % kMod;\n\n    // Distribute the remaining multiplications to the minimum `remainingK`\n    // numbers.\n    for (int i = 0; i < remainingK; ++i)\n      sortedIndexedNums[i].first =\n          (static_cast<long>(sortedIndexedNums[i].first) * multiplier % kMod);\n\n    for (const auto& [num, i] : sortedIndexedNums)\n      ans[i] = num;\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x, n - 1) % kMod;\n    return modPow(x * x % kMod, n / 2);\n  }\n};\n", "3267": "class Solution {\n public:\n  // Similar to 3265. Count Almost Equal Pairs I\n  int countPairs(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> count;\n    const int maxLen = to_string(ranges::max(nums)).length();\n\n    for (const int num : nums) {\n      const string digits =\n          string(maxLen - to_string(num).length(), '0') + to_string(num);\n      for (const int swap : getSwaps(digits))\n        ans += count[swap];\n      ++count[num];\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns all possible numbers after 1 or 2 swaps.\n  unordered_set<int> getSwaps(const string& digits) {\n    const int n = digits.length();\n    unordered_set<int> swaps{{stoi(digits)}};\n\n    // Add all numbers after 1 swap.\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        string newDigits = digits;\n        swap(newDigits[i], newDigits[j]);\n        swaps.insert(stoi(newDigits));\n      }\n\n    // Add all numbers after 2 swaps.\n    for (int i1 = 0; i1 < n; ++i1)\n      for (int j1 = i1 + 1; j1 < n; ++j1)\n        for (int i2 = 0; i2 < n; ++i2)\n          for (int j2 = i2 + 1; j2 < n; ++j2) {\n            string newDigits = digits;\n            swap(newDigits[i1], newDigits[j1]);\n            swap(newDigits[i2], newDigits[j2]);\n            swaps.insert(stoi(newDigits));\n          }\n\n    return swaps;\n  }\n};\n", "3269": "class Solution {\n public:\n  int minLargest(vector<int>& nums1, vector<int>& nums2) {\n    const int m = nums1.size();\n    const int n = nums2.size();\n    // dp[i][j] := the minimum largest number for the first i nums1 and the\n    // first j nums2\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));\n    dp[0][0] = 0;\n\n    for (int i = 0; i <= m; ++i)\n      for (int j = 0; j <= n; ++j) {\n        if (i > 0)\n          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]));\n        if (j > 0)\n          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]));\n      }\n\n    return dp[m][n];\n  }\n\n private:\n  // Returns the next number to fill in the array based on the previous number\n  // and the current number.\n  int f(int prev, int num) {\n    return prev + (prev % 2 == num ? 2 : 1);\n  }\n};\n", "327": "class Solution {\n public:\n  int countRangeSum(vector<int>& nums, int lower, int upper) {\n    const int n = nums.size();\n    int ans = 0;\n    vector<long> prefix{0};\n\n    for (int i = 0; i < n; ++i)\n      prefix.push_back(prefix.back() + nums[i]);\n\n    mergeSort(prefix, 0, n, lower, upper, ans);\n    return ans;\n  }\n\n private:\n  void mergeSort(vector<long>& prefix, int l, int r, int lower, int upper,\n                 int& ans) {\n    if (l >= r)\n      return;\n\n    const int m = (l + r) / 2;\n    mergeSort(prefix, l, m, lower, upper, ans);\n    mergeSort(prefix, m + 1, r, lower, upper, ans);\n    merge(prefix, l, m, r, lower, upper, ans);\n  }\n\n  void merge(vector<long>& prefix, int l, int m, int r, int lower, int upper,\n             int& ans) {\n    int lo = m + 1;  // the first index s.t. prefix[lo] - prefix[i] >= lower\n    int hi = m + 1;  // the first index s.t. prefix[hi] - prefix[i] > upper\n\n    // For each index i in range [l, m], add hi - lo to `ans`.\n    for (int i = l; i <= m; ++i) {\n      while (lo <= r && prefix[lo] - prefix[i] < lower)\n        ++lo;\n      while (hi <= r && prefix[hi] - prefix[i] <= upper)\n        ++hi;\n      ans += hi - lo;\n    }\n\n    vector<long> sorted(r - l + 1);\n    int k = 0;      // sorted's index\n    int i = l;      // left's index\n    int j = m + 1;  // right's index\n\n    while (i <= m && j <= r)\n      if (prefix[i] < prefix[j])\n        sorted[k++] = prefix[i++];\n      else\n        sorted[k++] = prefix[j++];\n\n    // Put the possible remaining left part into the sorted array.\n    while (i <= m)\n      sorted[k++] = prefix[i++];\n\n    // Put the possible remaining right part into the sorted array.\n    while (j <= r)\n      sorted[k++] = prefix[j++];\n\n    copy(sorted.begin(), sorted.end(), prefix.begin() + l);\n  }\n};\n", "3270": "class Solution {\n public:\n  int generateKey(int num1, int num2, int num3) {\n    const string s1 = zfill(num1, 4);\n    const string s2 = zfill(num2, 4);\n    const string s3 = zfill(num3, 4);\n    string ans;\n\n    for (int i = 0; i < 4; ++i)\n      ans += min({s1[i], s2[i], s3[i]});\n\n    return stoi(ans);\n  }\n\n private:\n  string zfill(int num, int width) {\n    ostringstream oss;\n    oss.width(width);\n    oss.fill('0');\n    oss << num;\n    return oss.str();\n  }\n};\n", "3271": "class Solution {\n public:\n  string stringHash(string s, int k) {\n    string ans;\n\n    for (int i = 0; i < s.length(); i += k) {\n      int sumHash = 0;\n      for (int j = i; j < i + k; ++j)\n        sumHash += s[j] - 'a';\n      ans += 'a' + sumHash % 26;\n    }\n\n    return ans;\n  }\n};\n", "3272": "class Solution {\n public:\n  long long countGoodIntegers(int n, int k) {\n    const int halfLength = (n + 1) / 2;\n    const int minHalf = pow(10, halfLength - 1);\n    const int maxHalf = pow(10, halfLength);\n    long ans = 0;\n    unordered_set<string> seen;\n\n    for (int num = minHalf; num < maxHalf; ++num) {\n      const string firstHalf = to_string(num);\n      const string secondHalf = {firstHalf.rbegin(), firstHalf.rend()};\n      const string palindrome = firstHalf + secondHalf.substr(n % 2);\n      if (stol(palindrome) % k != 0)\n        continue;\n      string sortedDigits = palindrome;\n      ranges::sort(sortedDigits);\n      if (seen.contains(sortedDigits))\n        continue;\n      seen.insert(sortedDigits);\n      vector<int> digitCount(10);\n      for (const char c : palindrome)\n        ++digitCount[c - '0'];\n      // Leading zeros are not allowed, so the first digit is special.\n      const int firstDigitChoices = n - digitCount[0];\n      long permutations = firstDigitChoices * factorial(n - 1);\n      // For each repeated digit, divide by the factorial of the frequency since\n      // permutations that swap identical digits don't create a new number.\n      for (const int freq : digitCount)\n        if (freq > 1)\n          permutations /= factorial(freq);\n      ans += permutations;\n    }\n\n    return ans;\n  }\n\n private:\n  long factorial(int n) {\n    long res = 1;\n    for (int i = 2; i <= n; ++i)\n      res *= i;\n    return res;\n  }\n};\n", "3273": "struct Enemy {\n  int damage;\n  int timeTakenDown;\n};\n\nclass Solution {\n public:\n  long long minDamage(int power, vector<int>& damage, vector<int>& health) {\n    long ans = 0;\n    long sumDamage = accumulate(damage.begin(), damage.end(), 0L);\n    vector<Enemy> enemies;\n\n    for (int i = 0; i < damage.size(); ++i)\n      enemies.emplace_back(damage[i], (health[i] + power - 1) / power);\n\n    // It's better to take down the enemy i first if the damage dealt of taking\n    // down i first is less than the damage dealt of taking down j first. So,\n    //    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <\n    //    damage[j] * t[j] + (t[i] + t[j]) * damage[i]\n    // => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <\n    //    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]\n    // => damage[j] * t[i] < damage[i] * t[j]\n    // => damage[j] / t[j] < damage[i] / t[i]\n    ranges::sort(enemies, ranges::greater{}, [](const Enemy& e) {\n      return static_cast<double>(e.damage) / e.timeTakenDown;\n    });\n\n    for (const Enemy& enemy : enemies) {\n      ans += sumDamage * enemy.timeTakenDown;\n      sumDamage -= enemy.damage;\n    }\n\n    return ans;\n  }\n};\n", "3274": "class Solution {\n public:\n  bool checkTwoChessboards(string coordinate1, string coordinate2) {\n    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2);\n  }\n\n private:\n  // Same as 1812. Determine Color of a Chessboard Square\n  bool squareIsWhite(const string& coordinates) {\n    const char letter = coordinates[0];\n    const char digit = coordinates[1];\n    return letter % 2 != digit % 2;\n  }\n};\n", "3275": "class Solution {\n public:\n  vector<int> resultsArray(vector<vector<int>>& queries, int k) {\n    vector<int> ans;\n    priority_queue<int> maxHeap;\n\n    for (const vector<int>& query : queries) {\n      const int x = query[0];\n      const int y = query[1];\n      maxHeap.push(abs(x) + abs(y));\n      if (maxHeap.size() > k)\n        maxHeap.pop();\n      ans.push_back(maxHeap.size() == k ? maxHeap.top() : -1);\n    }\n\n    return ans;\n  }\n};\n", "3276": "class Solution {\n public:\n  int maxScore(vector<vector<int>>& grid) {\n    unordered_map<int, unordered_set<int>> numToIndices;\n    for (int index = 0; index < grid.size(); ++index)\n      for (const int num : grid[index])\n        numToIndices[num].insert(index);\n    vector<vector<int>> mem(numToIndices.size(), vector<int>(1 << grid.size()));\n    return maxScore({numToIndices.begin(), numToIndices.end()}, 0, 0, mem);\n  }\n\n private:\n  // Returns the maximum score by selecting numbers from numToIndices[i..],\n  // where `mask` is the bitmask of the used row indices.\n  int maxScore(const vector<pair<int, unordered_set<int>>>& numToIndices, int i,\n               int mask, vector<vector<int>>& mem) {\n    if (i == numToIndices.size())\n      return 0;\n    if (mem[i][mask] != 0)\n      return mem[i][mask];\n    // Skip numToIndices[i].first.\n    int res = maxScore(numToIndices, i + 1, mask, mem);\n    for (const int index : numToIndices[i].second)\n      if ((mask >> index & 1) == 0)\n        // Take numToIndices[i].first.\n        res =\n            max(res, numToIndices[i].first +\n                         maxScore(numToIndices, i + 1, mask | 1 << index, mem));\n    return mem[i][mask] = res;\n  }\n};\n", "3277": "class Solution {\n public:\n  vector<int> maximumSubarrayXor(vector<int>& nums,\n                                 vector<vector<int>>& queries) {\n    const int n = nums.size();\n    vector<int> ans;\n    // xors[i][j] := the XOR score of nums[i..j]\n    vector<vector<int>> xors(n, vector<int>(n));\n    // dp[i][j] := the maximum XOR score of nums[i..j]\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n      xors[i][i] = nums[i];\n      dp[i][i] = nums[i];\n    }\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j];\n        dp[i][j] = max({xors[i][j], dp[i][j - 1], dp[i + 1][j]});\n      }\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      ans.push_back(dp[l][r]);\n    }\n\n    return ans;\n  }\n};\n", "3279": "class Solution {\n public:\n  long long maxArea(int height, vector<int>& positions, string directions) {\n    long area = accumulate(positions.begin(), positions.end(), 0L);\n    long ans = area;\n    long diffPerSecond = 0;\n    map<int, vector<int>> timeToIndices;\n\n    for (int i = 0; i < positions.size(); ++i)\n      if (directions[i] == 'U') {\n        timeToIndices[height - positions[i]].push_back(i);\n        timeToIndices[height - positions[i] + height].push_back(i);\n        ++diffPerSecond;\n      } else {\n        timeToIndices[positions[i]].push_back(i);\n        timeToIndices[positions[i] + height].push_back(i);\n        --diffPerSecond;\n      }\n\n    int prevTime = 0;\n\n    for (const auto& [time, indices] : timeToIndices) {\n      area += (time - prevTime) * diffPerSecond;\n      ans = max(ans, area);\n      prevTime = time;\n      for (const int i : indices)\n        if (directions[i] == 'U') {\n          directions[i] = 'D';\n          diffPerSecond -= 2;\n        } else {\n          directions[i] = 'U';\n          diffPerSecond += 2;\n        }\n    }\n\n    return ans;\n  }\n};\n", "328": "class Solution {\n public:\n  ListNode* oddEvenList(ListNode* head) {\n    ListNode oddHead(0);\n    ListNode evenHead(0);\n    ListNode* odd = &oddHead;\n    ListNode* even = &evenHead;\n\n    for (int isOdd = 0; head; head = head->next)\n      if (isOdd ^= 1) {\n        odd->next = head;\n        odd = odd->next;\n      } else {\n        even->next = head;\n        even = even->next;\n      }\n\n    odd->next = evenHead.next;\n    even->next = nullptr;\n    return oddHead.next;\n  }\n};\n", "3280": "class Solution {\n public:\n  string convertDateToBinary(string date) {\n    const int year = stoi(date.substr(0, 4));\n    const int month = stoi(date.substr(5, 2));\n    const int day = stoi(date.substr(8, 2));\n    return toBinary(year) + '-' + toBinary(month) + '-' + toBinary(day);\n  }\n\n private:\n  // Converts an integer to binary without leading zeros.\n  string toBinary(int value) {\n    const string binary = bitset<16>(value).to_string();\n    return binary.substr(binary.find('1'));  // Remove leading zeros.\n  }\n};\n", "3281": "class Solution {\n public:\n  int maxPossibleScore(vector<int>& start, int d) {\n    ranges::sort(start);\n\n    long l = 0;\n    long r = (start.back() + d) - start.front() + 1;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (isPossible(start, d, m))\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l - 1;\n  }\n\n private:\n  bool isPossible(const vector<int>& start, int d, long m) {\n    int lastPick = start[0];\n    for (int i = 1; i < start.size(); ++i) {\n      if (lastPick + m > start[i] + d)\n        return false;\n      lastPick = max(lastPick + m, static_cast<long>(start[i]));\n    }\n    return true;\n  }\n};\n", "3282": "class Solution {\n public:\n  // Similar to 3205. Maximum Array Hopping Score I\n  long long findMaximumScore(vector<int>& nums) {\n    // The optimal jump is the nearest index j > i s.t. nums[j] > nums[i].\n    long ans = 0;\n    int mx = 0;\n\n    for (const int num : nums) {\n      ans += mx;\n      mx = max(mx, num);\n    }\n\n    return ans;\n  }\n};\n", "3283": "class Solution {\n public:\n  int maxMoves(int kx, int ky, vector<vector<int>>& positions) {\n    const int n = positions.size();\n    positions.push_back({kx, ky});\n    unordered_map<int, int> hashedPositionToIndex;\n    // dist[i][j] := the minimum distance from positions[i] to positions[j]\n    vector<vector<int>> dist(n + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < positions.size(); ++i) {\n      const int x = positions[i][0];\n      const int y = positions[i][1];\n      hashedPositionToIndex[hash(x, y)] = i;\n    }\n\n    for (int sourceIndex = 0; sourceIndex < n + 1; ++sourceIndex)\n      bfs(positions, sourceIndex, hashedPositionToIndex, dist);\n\n    const int maxMask = 1 << (n + 1);\n    // dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to\n    // kill all pawns, where i is the current pawn, mask is the set of pawns\n    // that have been killed, and turn is the current player's turn (0 for Alice\n    // and 1 for Bob)\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(1 << (n + 1), vector<int>(2)));\n\n    for (int i = 0; i < n + 1; ++i)\n      for (int mask = 0; mask < maxMask - 1; ++mask)\n        dp[i][mask] = {-kMax, kMax};\n\n    for (int mask = maxMask - 2; mask >= 0; --mask)\n      for (int i = 0; i < n + 1; ++i)\n        for (int turn = 0; turn < 2; ++turn)\n          for (int j = 0; j < n; ++j) {\n            if (mask >> j & 1)\n              continue;\n            const int moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn];\n            dp[i][mask][turn] = turn == 0 ? max(dp[i][mask][turn], moves)\n                                          : min(dp[i][mask][turn], moves);\n          }\n\n    // Returns the maximum cost to kill all pawns, i.e., the original positions\n    // array without the knight (kx, ky).\n    return dp[n][1 << n][0];\n  }\n\n private:\n  static constexpr int kSize = 50;\n  static constexpr int kMax = 1'000'000;\n  static constexpr int kDirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},\n                                      {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\n\n  int hash(int x, int y) {\n    return x * kSize + y;\n  }\n\n  // Computes the distance between positions[sourceIndex] and other positions.\n  void bfs(const vector<vector<int>>& positions, int sourceIndex,\n           const unordered_map<int, int>& hashedPositionToIndex,\n           vector<vector<int>>& dist) {\n    const int sx = positions[sourceIndex][0];\n    const int sy = positions[sourceIndex][1];\n    queue<pair<int, int>> q{{{sx, sy}}};\n    vector<vector<bool>> seen(kSize, vector<bool>(kSize));\n    seen[sx][sy] = true;\n    int seenPositions = 0;\n\n    for (int step = 0; !q.empty() && seenPositions < positions.size(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        if (const auto it = hashedPositionToIndex.find(hash(i, j));\n            it != end(hashedPositionToIndex)) {\n          dist[sourceIndex][it->second] = step;\n          ++seenPositions;\n        }\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x >= kSize || y < 0 || y >= kSize)\n            continue;\n          if (seen[x][y])\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n  }\n};\n", "3284": "class Solution {\n public:\n  int getSum(const std::vector<int>& nums) {\n    const long sum = accumulate(nums.begin(), nums.end(), 0L) % kMod;\n    return (getSum(nums, 1) + getSum(nums, -1) - sum) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the sum of all subarrays with a difference of `diff`.\n  long getSum(const vector<int>& nums, int diff) {\n    long res = nums[0];\n    long summ = nums[0];\n    long count = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] == nums[i - 1] + diff) {\n        count += 1;\n        summ += count * nums[i];\n      } else {\n        count = 1;\n        summ = nums[i];\n      }\n      res += summ;\n      res %= kMod;\n    }\n    return res;\n  };\n};\n", "3285": "class Solution {\n public:\n  vector<int> stableMountains(vector<int>& height, int threshold) {\n    vector<int> ans;\n\n    for (int i = 1; i < height.size(); ++i)\n      if (height[i - 1] > threshold)\n        ans.push_back(i);\n\n    return ans;\n  }\n};\n", "3286": "class Solution {\n public:\n  bool findSafeWalk(vector<vector<int>>& grid, int health) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    const int initialHealth = health - grid[0][0];\n    using T = tuple<int, int, int>;  // (i, j, h)\n    queue<T> q{{{0, 0, initialHealth}}};\n    vector<vector<vector<bool>>> seen(\n        m, vector<vector<bool>>(n, vector<bool>(health + 1)));\n    seen[0][0][initialHealth] = true;\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j, h] = q.front();\n        q.pop();\n        if (i == m - 1 && j == n - 1 && h > 0)\n          return true;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          const int nextHealth = h - grid[x][y];\n          if (nextHealth <= 0 || seen[x][y][nextHealth])\n            continue;\n          q.emplace(x, y, nextHealth);\n          seen[x][y][nextHealth] = true;\n        }\n      }\n\n    return false;\n  }\n};\n", "3287": "class Solution {\n public:\n  int maxValue(vector<int>& nums, int k) {\n    // left[i][j][x] := true if it's possible to get an OR value of x by\n    // selecting j numbers from nums[0..i]\n    const vector<vector<vector<bool>>> left = getPossibleORs(nums, k);\n    // right[i][j][x] := true if it's possible to get an OR value of x by\n    // selecting j numbers from nums[i..n - 1]\n    vector<vector<vector<bool>>> right =\n        getPossibleORs({nums.rbegin(), nums.rend()}, k);\n    ranges::reverse(right);\n\n    int ans = 0;\n\n    for (int i = k - 1; i + k < nums.size(); ++i)\n      for (int a = 0; a <= kMaxXor; ++a)\n        for (int b = 0; b <= kMaxXor; ++b)\n          if (left[i][k][a] && right[i + 1][k][b])\n            ans = max(ans, a ^ b);\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMaxXor = 128;\n\n  // Gets all possible OR values till each index and number of numbers.\n  vector<vector<vector<bool>>> getPossibleORs(const vector<int>& nums, int k) {\n    // dp[i][j][x] := true if it's possible to get an OR value of x by selecting\n    // j numbers from nums[0..i]\n    vector<vector<vector<bool>>> dp(\n        nums.size(), vector<vector<bool>>(k + 1, vector<bool>(kMaxXor + 1)));\n\n    dp[0][1][nums[0]] = true;\n\n    // No number is selected.\n    for (int i = 0; i < nums.size(); ++i)\n      dp[i][0][0] = true;\n\n    for (int i = 1; i < nums.size(); ++i)\n      for (int j = 1; j <= k; ++j)\n        for (int x = 0; x <= kMaxXor; ++x) {\n          // 1. Skip the current number.\n          if (dp[i - 1][j][x])\n            dp[i][j][x] = true;\n          // 2. Pick the current number.\n          if (dp[i - 1][j - 1][x])\n            dp[i][j][nums[i] | x] = true;\n        }\n\n    return dp;\n  }\n};\n", "3288": "class Solution {\n public:\n  int maxPathLength(vector<vector<int>>& coordinates, int k) {\n    const int xk = coordinates[k][0];\n    const int yk = coordinates[k][1];\n    vector<pair<int, int>> leftCoordinates;\n    vector<pair<int, int>> rightCoordinates;\n\n    for (const vector<int>& coordinate : coordinates) {\n      const int x = coordinate[0];\n      const int y = coordinate[1];\n      if (x < xk && y < yk)\n        leftCoordinates.emplace_back(x, y);\n      else if (x > xk && y > yk)\n        rightCoordinates.emplace_back(x, y);\n    }\n\n    return 1 + lengthOfLIS(leftCoordinates) + lengthOfLIS(rightCoordinates);\n  }\n\n private:\n  // Similar to 300. Longest Increasing Subsequence\n  int lengthOfLIS(vector<pair<int, int>>& coordinates) {\n    ranges::sort(coordinates, ranges::less{},\n                 [](const pair<int, int>& coordinate) {\n      const auto& [x, y] = coordinate;\n      return pair<int, int>{x, -y};\n    });\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n    for (const auto& [_, y] : coordinates)\n      if (tails.empty() || y > tails.back())\n        tails.push_back(y);\n      else\n        tails[firstGreaterEqual(tails, y)] = y;\n    return tails.size();\n  }\n\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "3289": "class Solution {\n public:\n  vector<int> getSneakyNumbers(const vector<int>& nums) {\n    constexpr int kMax = 100;\n    vector<int> ans;\n    vector<int> count(kMax + 1);\n\n    for (const int num : nums)\n      if (++count[num] == 2)\n        ans.push_back(num);\n\n    return ans;\n  }\n};\n", "329": "class Solution {\n public:\n  int longestIncreasingPath(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = 0;\n    vector<vector<int>> mem(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        ans = max(ans, dfs(matrix, i, j, INT_MIN, mem));\n\n    return ans;\n  }\n\n private:\n  // mem[i][j] := the LIP starting from matrix[i][j]\n  int dfs(const vector<vector<int>>& matrix, int i, int j, int prev,\n          vector<vector<int>>& mem) {\n    if (i < 0 || i == matrix.size() || j < 0 || j == matrix[0].size())\n      return 0;\n    if (matrix[i][j] <= prev)\n      return 0;\n    int& ans = mem[i][j];\n    if (ans > 0)\n      return ans;\n\n    const int curr = matrix[i][j];\n    return ans = 1 + max({dfs(matrix, i + 1, j, curr, mem),\n                          dfs(matrix, i - 1, j, curr, mem),\n                          dfs(matrix, i, j + 1, curr, mem),\n                          dfs(matrix, i, j - 1, curr, mem)});\n  }\n};\n", "3290": "class Solution {\n public:\n  long long maxScore(vector<int>& a, vector<int>& b) {\n    // dp[i] := the maximum score of a[0..i]\n    vector<long> dp(4, LONG_MIN / 2);\n\n    for (const long num : b)\n      for (int i = 3; i >= 0; --i)\n        // Skip `num` or pair a[i] with `num`.\n        dp[i] = max(dp[i], (i > 0 ? dp[i - 1] : 0) + a[i] * num);\n\n    return dp[3];\n  }\n};\n", "3291": "class Solution {\n public:\n  int minValidStrings(vector<string>& words, string target) {\n    int ans = 0;\n    int unmatchedPrefix = target.length();\n    vector<vector<int>> lpsList;\n\n    for (const string& word : words)\n      lpsList.push_back(getLPS(word + '#' + target));\n\n    while (unmatchedPrefix > 0) {\n      // Greedily choose the word that has the longest suffix match with the\n      // remaining unmatched prefix.\n      int maxMatchSuffix = 0;\n      for (int i = 0; i < words.size(); ++i)\n        maxMatchSuffix = max(maxMatchSuffix,\n                             lpsList[i][words[i].length() + unmatchedPrefix]);\n      if (maxMatchSuffix == 0)\n        return -1;\n      ++ans;\n      unmatchedPrefix -= maxMatchSuffix;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3292": "class Solution {\n public:\n  // 3291. Minimum Number of Valid Strings to Form Target I\n  int minValidStrings(vector<string>& words, string target) {\n    int ans = 0;\n    int unmatchedPrefix = target.length();\n    vector<vector<int>> lpsList;\n\n    for (const string& word : words)\n      lpsList.push_back(getLPS(word + '#' + target));\n\n    while (unmatchedPrefix > 0) {\n      // Greedily choose the word that has the longest suffix match with the\n      // remaining unmatched prefix.\n      int maxMatchSuffix = 0;\n      for (int i = 0; i < words.size(); ++i)\n        maxMatchSuffix = max(maxMatchSuffix,\n                             lpsList[i][words[i].length() + unmatchedPrefix]);\n      if (maxMatchSuffix == 0)\n        return -1;\n      ++ans;\n      unmatchedPrefix -= maxMatchSuffix;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n};\n", "3294": "class Solution {\n public:\n  vector<int> toArray(Node* node) {\n    vector<int> ans;\n    Node* curr = node;\n\n    while (curr->prev != nullptr)\n      curr = curr->prev;\n\n    while (curr != nullptr) {\n      ans.push_back(curr->val);\n      curr = curr->next;\n    }\n\n    return ans;\n  }\n};\n", "3295": "class Solution {\n public:\n  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\n    const unordered_set<string> bannedWordsSet{bannedWords.begin(),\n                                               bannedWords.end()};\n    int count = 0;\n\n    for (const string& word : message)\n      if (bannedWordsSet.contains(word) && ++count > 1)\n        return true;\n\n    return false;\n  }\n};\n", "3296": "class Solution {\n public:\n  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {\n    long l = 1;\n    long r = static_cast<long>(ranges::min(workerTimes)) * mountainHeight *\n             (mountainHeight + 1) / 2;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (getReducedHeight(workerTimes, m) < mountainHeight)\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the total height reduced by all workers in `m` seconds.\n  int getReducedHeight(const vector<int>& workerTimes, long m) {\n    int reducedHeight = 0;\n    for (const int workerTime : workerTimes)\n      // The height `x` that a worker with working time `w` reduces in `m`\n      // seconds.\n      // w * (1 + 2 + ... + x) <= m\n      //       (1 + x) * x / 2 <= m / w\n      //   x^2 + x - 2 * m / w <= 0\n      //                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2\n      reducedHeight += (-1 + sqrt(1 + 8 * m / workerTime)) / 2;\n    return reducedHeight;\n  }\n};\n", "3297": "class Solution {\n public:\n  long long validSubstringCount(string word1, string word2) {\n    long ans = 0;\n    int required = word2.length();\n    vector<int> count(26);\n\n    for (const char c : word2)\n      ++count[c - 'a'];\n\n    for (int l = 0, r = 0; r < word1.length(); ++r) {\n      if (--count[word1[r] - 'a'] >= 0)\n        --required;\n      while (required == 0) {\n        // Add valid substrings containing word1[l..r] to the answer. They are\n        // word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += word1.length() - r;\n        if (++count[word1[l++] - 'a'] > 0)\n          ++required;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3298": "class Solution {\n public:\n  // Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I\n  long long validSubstringCount(string word1, string word2) {\n    long ans = 0;\n    int required = word2.length();\n    vector<int> count(26);\n\n    for (const char c : word2)\n      ++count[c - 'a'];\n\n    for (int l = 0, r = 0; r < word1.length(); ++r) {\n      if (--count[word1[r] - 'a'] >= 0)\n        --required;\n      while (required == 0) {\n        // Add valid substrings containing word1[l..r] to the answer. They are\n        // word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += word1.length() - r;\n        if (++count[word1[l++] - 'a'] > 0)\n          ++required;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3299": "class Solution {\n public:\n  int getSum(vector<int>& nums) {\n    const int increasingSequenceSum = getSequenceSum(nums, 1);\n    const int decreasingSequenceSum = getSequenceSum(nums, -1);\n    const int arraySum = getArraySum(nums);\n    return (increasingSequenceSum + decreasingSequenceSum -\n            static_cast<long>(arraySum) + kMod) %\n           kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the sum of all sequences in the array that are in consecutive\n  // increasing order if `direction` is 1, or in consecutive decreasing order if\n  // `direction` is -1.\n  int getSequenceSum(const vector<int>& nums, int direction) {\n    const int n = nums.size();\n    long sequenceSum = 0;\n    // {num: the number of subsequences ending in `num` so far}\n    unordered_map<int, int> prefixCount;\n    // {num: the number of subsequences starting from `num` so far}\n    unordered_map<int, int> suffixCount;\n    // prefixSubseqs[i] := the number of subsequences ending in nums[i]\n    vector<int> prefixSubseqs(n);\n    // suffixSubseqs[i] := the number of subsequences starting from nums[i]\n    vector<int> suffixSubseqs(n);\n\n    for (int i = 0; i < n; ++i) {\n      const int prevNum = nums[i] - direction;\n      const int subseqsCount =\n          (prefixCount.contains(prevNum) ? prefixCount[prevNum] : 0) + 1;\n      prefixSubseqs[i] = subseqsCount;\n      prefixCount[nums[i]] += subseqsCount;\n      prefixCount[nums[i]] %= kMod;\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int nextNum = nums[i] + direction;\n      const int subseqsCount =\n          (suffixCount.contains(nextNum) ? suffixCount[nextNum] : 0) + 1;\n      suffixSubseqs[i] = subseqsCount;\n      suffixCount[nums[i]] += subseqsCount;\n      suffixCount[nums[i]] %= kMod;\n    }\n\n    for (int i = 0; i < n; ++i) {\n      sequenceSum += static_cast<long>(nums[i]) * prefixSubseqs[i] % kMod *\n                     suffixSubseqs[i];\n      sequenceSum %= kMod;\n    }\n\n    return sequenceSum;\n  }\n\n  int getArraySum(const vector<int>& nums) {\n    int arraySum = 0;\n    for (const int num : nums)\n      arraySum = (arraySum + num) % kMod;\n    return arraySum;\n  }\n};\n", "33": "class Solution {\n public:\n  int search(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[l] <= nums[m]) {  // nums[l..m] are sorted.\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else {  // nums[m..n - 1] are sorted.\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    }\n\n    return -1;\n  }\n};\n", "330": "class Solution {\n public:\n  int minPatches(vector<int>& nums, int n) {\n    int ans = 0;\n    int i = 0;      // nums' index\n    long miss = 1;  // the minimum sum in [1, n] we might miss\n\n    while (miss <= n)\n      if (i < nums.size() && nums[i] <= miss) {\n        miss += nums[i++];\n      } else {\n        // Greedily add `miss` itself to increase the range from\n        // [1, miss) to [1, 2 * miss).\n        miss += miss;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3300": "class Solution {\n public:\n  int minElement(vector<int>& nums) {\n    int ans = INT_MAX;\n    for (const int num : nums)\n      ans = min(ans, getDigitSum(num));\n    return ans;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int digitSum = 0;\n    while (num > 0) {\n      digitSum += num % 10;\n      num /= 10;\n    }\n    return digitSum;\n  }\n};\n", "3301": "class Solution {\n public:\n  long long maximumTotalSum(vector<int>& maximumHeight) {\n    long ans = 0;\n    int mn = INT_MAX;\n\n    ranges::sort(maximumHeight, greater<>());\n\n    for (const int height : maximumHeight) {\n      const int assigned = min(height, mn - 1);\n      if (assigned == 0)\n        return -1;\n      ans += assigned;\n      mn = assigned;\n    }\n\n    return ans;\n  }\n};\n", "3302": "class Solution {\n public:\n  vector<int> validSequence(string word1, string word2) {\n    vector<int> ans(word2.length());\n    // last[j] := the index i of the last occurrence in word1, where\n    // word1[i] == word2[j]\n    vector<int> last(word2.length(), -1);\n\n    int i = word1.length() - 1;\n    int j = word2.length() - 1;\n    while (i >= 0 && j >= 0) {\n      if (word1[i] == word2[j])\n        last[j--] = i;\n      --i;\n    }\n\n    bool canSkip = true;\n    j = 0;\n    for (i = 0; i < word1.length(); ++i) {\n      if (j == word2.length())\n        break;\n      if (word1[i] == word2[j]) {\n        ans[j++] = i;\n      } else if (canSkip && (j == word2.length() - 1 || i < last[j + 1])) {\n        canSkip = false;\n        ans[j++] = i;\n      }\n    }\n\n    return j == word2.length() ? ans : vector<int>();\n  }\n};\n", "3303": "class Solution {\n public:\n  int minStartingIndex(string s, string pattern) {\n    const vector<int> z1 = zFunction(pattern + s);\n    const vector<int> z2 = zFunction(reversed(pattern) + reversed(s));\n\n    // Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and\n    // the suffix.\n    for (int i = 0; i <= s.length() - pattern.length(); ++i)\n      if (z1[pattern.length() + i] + z2[s.length() - i] >= pattern.length() - 1)\n        return i;\n\n    return -1;\n  }\n\n private:\n  // Returns the z array, where z[i] is the length of the longest prefix of\n  // s[i..n) which is also a prefix of s.\n  //\n  // https://cp-algorithms.com/string/z-function.html#implementation\n  vector<int> zFunction(const string& s) {\n    const int n = s.length();\n    vector<int> z(n);\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l]);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n    return z;\n  }\n\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n};\n", "3304": "class Solution {\n public:\n  char kthCharacter(unsigned k) {\n    return 'a' + popcount(k - 1);\n  }\n};\n", "3305": "class Solution {\n public:\n  int countOfSubstrings(string word, int k) {\n    return substringsWithAtMost(word, k) - substringsWithAtMost(word, k - 1);\n  }\n\n private:\n  // Return the number of substrings containing every vowel with at most k\n  // consonants.\n  int substringsWithAtMost(const string& word, int k) {\n    if (k == -1)\n      return 0;\n\n    int res = 0;\n    int vowels = 0;\n    int uniqueVowels = 0;\n    unordered_map<char, int> vowelLastSeen;\n\n    for (int l = 0, r = 0; r < word.length(); ++r) {\n      if (isVowel(word[r])) {\n        ++vowels;\n        if (const auto it = vowelLastSeen.find(word[r]);\n            it == vowelLastSeen.end() || it->second < l)\n          ++uniqueVowels;\n        vowelLastSeen[word[r]] = r;\n      }\n      while (r - l + 1 - vowels > k) {\n        if (isVowel(word[l])) {\n          --vowels;\n          if (vowelLastSeen[word[l]] == l)\n            --uniqueVowels;\n        }\n        ++l;\n      }\n      if (uniqueVowels == 5)\n        // Add substrings containing every vowel with at most k consonants to\n        // the answer. They are\n        // word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n        res += min({vowelLastSeen['a'], vowelLastSeen['e'], vowelLastSeen['i'],\n                    vowelLastSeen['o'], vowelLastSeen['u']}) -\n               l + 1;\n    }\n\n    return res;\n  }\n\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "3306": "class Solution {\n public:\n  // Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I\n  long long countOfSubstrings(string word, int k) {\n    return substringsWithAtMost(word, k) - substringsWithAtMost(word, k - 1);\n  }\n\n private:\n  // Return the number of substrings containing every vowel with at most k\n  // consonants.\n  long substringsWithAtMost(const string& word, int k) {\n    if (k == -1)\n      return 0;\n\n    long res = 0;\n    int vowels = 0;\n    int uniqueVowels = 0;\n    unordered_map<char, int> vowelLastSeen;\n\n    for (int l = 0, r = 0; r < word.length(); ++r) {\n      if (isVowel(word[r])) {\n        ++vowels;\n        if (const auto it = vowelLastSeen.find(word[r]);\n            it == vowelLastSeen.end() || it->second < l)\n          ++uniqueVowels;\n        vowelLastSeen[word[r]] = r;\n      }\n      while (r - l + 1 - vowels > k) {\n        if (isVowel(word[l])) {\n          --vowels;\n          if (vowelLastSeen[word[l]] == l)\n            --uniqueVowels;\n        }\n        ++l;\n      }\n      if (uniqueVowels == 5)\n        // Add substrings containing every vowel with at most k consonants to\n        // the answer. They are\n        // word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n        res += min({vowelLastSeen['a'], vowelLastSeen['e'], vowelLastSeen['i'],\n                    vowelLastSeen['o'], vowelLastSeen['u']}) -\n               l + 1;\n    }\n\n    return res;\n  }\n\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "3307": "class Solution {\n public:\n  char kthCharacter(long long k, vector<int>& operations) {\n    const int operationsCount = ceil(log2(k));\n    int increases = 0;\n\n    for (int i = operationsCount - 1; i >= 0; --i) {\n      const long halfSize = 1L << i;\n      if (k > halfSize) {\n        k -= halfSize;  // Move k from the right half to the left half.\n        increases += operations[i];\n      }\n    }\n\n    return 'a' + increases % 26;\n  }\n};\n", "3309": "class Solution {\n public:\n  int maxGoodNumber(vector<int>& nums) {\n    int ans = 0;\n\n    ranges::sort(nums,\n                 [this](int a, int b) { return concat(a, b) > concat(b, a); });\n\n    for (const int num : nums)\n      ans = concat(ans, num);\n\n    return ans;\n  }\n\n private:\n  // Returns the concatenation of the binary representations of a and b.\n  int concat(int a, int b) {\n    return (a << static_cast<int>(log2(b)) + 1) + b;\n  }\n};\n", "331": "class Solution {\n public:\n  bool isValidSerialization(string preorder) {\n    int degree = 1;  // out-degree (children) - in-degree (parent)\n    istringstream iss(preorder);\n\n    for (string node; getline(iss, node, ',');) {\n      if (--degree < 0)\n        return false;\n      if (node != \"#\")\n        degree += 2;\n    }\n\n    return degree == 0;\n  }\n};\n", "3310": "class Solution {\n public:\n  vector<int> remainingMethods(int n, int k, vector<vector<int>>& invocations) {\n    vector<int> ans;\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& invocation : invocations) {\n      const int u = invocation[0];\n      const int v = invocation[1];\n      graph[u].push_back(v);\n    }\n\n    queue<int> q{{k}};\n    vector<bool> seen(n);\n    seen[k] = true;\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u])\n          if (!seen[v]) {\n            q.push(v);\n            seen[v] = true;\n          }\n      }\n\n    for (int u = 0; u < n; ++u) {\n      if (seen[u])\n        continue;\n      for (const int v : graph[u])\n        if (seen[v]) {\n          ans.resize(n);\n          iota(ans.begin(), ans.end(), 0);\n          return ans;\n        }\n      ans.push_back(u);\n    }\n\n    return ans;\n  }\n};\n", "3311": "class Solution {\n public:\n  vector<vector<int>> constructGridLayout(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    // Randomly choose a node with the minimum degree as the corner.\n    const int corner =\n        ranges::min_element(graph, ranges::less{}, &vector<int>::size) -\n        graph.begin();\n\n    vector<bool> seen(n);\n    seen[corner] = true;\n    const vector<int> firstRow = getFirstRow(graph, corner, seen);\n    const int cols = firstRow.size();\n    const int rows = n / cols;\n\n    vector<vector<int>> ans(rows, vector<int>(cols));\n    ans[0] = firstRow;\n\n    for (int i = 1; i < rows; ++i)\n      for (int j = 0; j < cols; ++j)\n        for (const int v : graph[ans[i - 1][j]])\n          if (!seen[v]) {\n            ans[i][j] = v;\n            seen[v] = true;\n            break;\n          }\n\n    return ans;\n  }\n\n private:\n  vector<int> getFirstRow(vector<vector<int>>& graph, int corner,\n                          vector<bool>& seen) {\n    const int cornerDegree = graph[corner].size();\n    vector<int> row = {corner};\n\n    // Continue appending neighbors until we hit another corner.\n    while (row.size() == 1 || graph[row.back()].size() == cornerDegree + 1) {\n      // Sort neighbors by degree to prioritize smaller ones (shortest row built\n      // first).\n      vector<int>& neighbors = graph[row.back()];\n      ranges::sort(neighbors, ranges::less{},\n                   [&graph](int v) { return graph[v].size(); });\n      for (const int v : neighbors)\n        if (!seen[v] && (graph[v].size() == cornerDegree ||\n                         graph[v].size() == cornerDegree + 1)) {\n          row.push_back(v);\n          seen[v] = true;\n          break;\n        }\n    }\n\n    return row;\n  }\n};\n", "3312": "class Solution {\n public:\n  vector<int> gcdValues(vector<int>& nums, vector<long long>& queries) {\n    const int maxNum = ranges::max(nums);\n    vector<int> ans;\n    // countDivisor[d] := the number of `nums` having `num % d == 0`\n    vector<int> countDivisor(maxNum + 1);\n    // countGcdPair[g] := the number of pairs having gcd == g\n    vector<long> countGcdPair(maxNum + 1);\n    // prefixCountGcdPair[g] := the number of pairs having gcd <= g\n    vector<long> prefixCountGcdPair{0};\n\n    for (const int num : nums)\n      for (int i = 1; i * i <= num; ++i)\n        if (num % i == 0) {\n          ++countDivisor[i];\n          if (i != num / i)\n            ++countDivisor[num / i];\n        }\n\n    for (int gcd = maxNum; gcd >= 1; --gcd) {\n      // There are C(countDivisor[gcd], 2) pairs that have a common divisor\n      // that's a multiple of `gcd` (including the one that equals to `gcd`).\n      // So, substract the multiples of `gcd` to have the number of pairs with a\n      // gcd that's exactly `gcd`.\n      countGcdPair[gcd] =\n          countDivisor[gcd] * static_cast<long>(countDivisor[gcd] - 1) / 2;\n      for (int largerGcd = 2 * gcd; largerGcd <= maxNum; largerGcd += gcd)\n        countGcdPair[gcd] -= countGcdPair[largerGcd];\n    }\n\n    for (int gcd = 1; gcd <= maxNum; ++gcd)\n      prefixCountGcdPair.push_back(prefixCountGcdPair.back() +\n                                   countGcdPair[gcd]);\n\n    for (const long query : queries)\n      ans.push_back(getNthGcdPair(query, prefixCountGcdPair));\n\n    return ans;\n  }\n\n private:\n  // Returns the `query`-th gcd pair.\n  int getNthGcdPair(long query, const vector<long>& prefixCountGcdPair) {\n    int l = 1;\n    int r = prefixCountGcdPair.size() - 1;\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (prefixCountGcdPair[m] < query + 1)\n        l = m + 1;\n      else\n        r = m;\n    }\n    return l;\n  }\n};\n", "3313": "struct Node {\n  int node = 0;  // the node number\n  int time = 0;  // the time it got marked\n};\n\nstruct Last2 {\n  Node last1;  // the last marked node\n  Node last2;  // the second last marked node\n};\n\nclass Solution {\n public:\n  // Similar to 3241. Time Taken to Mark All Nodes\n  vector<int> lastMarkedNodes(vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    vector<int> ans(n);\n    vector<vector<int>> tree(n);\n    // dp[i] := the last marked two nodes for subtree rooted at node i, where\n    // each node contains the time it got marked\n    vector<Last2> dp(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].push_back(v);\n      tree[v].push_back(u);\n    }\n\n    dfs(tree, 0, /*prev=*/-1, dp);\n    reroot(tree, 0, /*prev=*/-1, /*last=*/Node(), dp, ans);\n    return ans;\n  }\n\n private:\n  // Performs a DFS traversal of the subtree rooted at node `u`, computes the\n  // time taken to mark all nodes in the subtree, records the last two marked\n  // nodes, and returns the last marked node.\n  //\n  // These values are used later in the rerooting process.\n  Node dfs(const vector<vector<int>>& tree, int u, int prev,\n           vector<Last2>& dp) {\n    Node last1(u, 0);\n    Node last2;\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      Node child = dfs(tree, v, u, dp);\n      const int time = child.time + 1;\n      if (time > last1.time) {\n        last2 = last1;\n        last1 = Node(child.node, time);\n      } else if (time > last2.time) {\n        last2 = Node(child.node, time);\n      }\n    }\n    dp[u] = {last1, last2};\n    return last1;\n  }\n\n  // Reroots the tree at node `u` and updates the answer array, where `last`\n  // is the last marked node that doesn't go through `u`'s subtree.\n  void reroot(const vector<vector<int>>& tree, int u, int prev,\n              const Node& last, vector<Last2>& dp, vector<int>& ans) {\n    ans[u] = last.time > dp[u].last1.time ? last.node : dp[u].last1.node;\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      Node newLast(last.node, last.time + 1);\n      if (dp[u].last1.node == dp[v].last1.node) {\n        const int alternativeTime = 1 + dp[u].last2.time;\n        if (alternativeTime > newLast.time)\n          newLast = Node(dp[u].last2.node, alternativeTime);\n      } else {\n        const int alternativeTime = 1 + dp[u].last1.time;\n        if (alternativeTime > newLast.time)\n          newLast = Node(dp[u].last1.node, alternativeTime);\n      }\n      reroot(tree, v, u, newLast, dp, ans);\n    }\n  }\n};\n", "3314": "class Solution {\n public:\n  vector<int> minBitwiseArray(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums)\n      ans.push_back(num == 2 ? -1 : num - getLeadingOneOfLastGroupOfOnes(num));\n\n    return ans;\n  }\n\n private:\n  // Returns the leading one of the last group of 1s in the binary\n  // representation of num. For example, if num = 0b10111, the leading one of\n  // the last group of 1s is 0b100.\n  int getLeadingOneOfLastGroupOfOnes(int num) {\n    int leadingOne = 1;\n    while ((num & leadingOne) > 0)\n      leadingOne <<= 1;\n    return leadingOne >> 1;\n  }\n};\n", "3315": "class Solution {\n public:\n  // Same as 3314. Construct the Minimum Bitwise Array I\n  vector<int> minBitwiseArray(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums)\n      ans.push_back(num == 2 ? -1 : num - getLeadingOneOfLastGroupOfOnes(num));\n\n    return ans;\n  }\n\n private:\n  // Returns the leading one of the last group of 1s in the binary\n  // representation of num. For example, if num = 0b10111, the leading one of\n  // the last group of 1s is 0b100.\n  int getLeadingOneOfLastGroupOfOnes(int num) {\n    int leadingOne = 1;\n    while ((num & leadingOne) > 0)\n      leadingOne <<= 1;\n    return leadingOne >> 1;\n  }\n};\n", "3316": "class Solution {\n public:\n  int maxRemovals(string source, string pattern, vector<int>& targetIndices) {\n    const int m = source.length();\n    const int n = pattern.length();\n    const unordered_set<int> target{targetIndices.begin(), targetIndices.end()};\n    // dp[i][j] := the maximum number of operations that can be performed for\n    // source[i..m) and pattern[j..n)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\n    dp[m][n] = 0;\n\n    for (int i = m - 1; i >= 0; --i) {\n      dp[i][n] = (target.contains(i) ? 1 : 0) + dp[i + 1][n];\n      for (int j = n - 1; j >= 0; --j) {\n        const int pick = source[i] == pattern[j] ? dp[i + 1][j + 1] : INT_MIN;\n        const int skip = (target.contains(i) ? 1 : 0) + dp[i + 1][j];\n        dp[i][j] = max(pick, skip);\n      }\n    }\n\n    return dp[0][0] == INT_MIN ? 0 : dp[0][0];\n  }\n};\n", "3317": "class Solution {\n public:\n  int numberOfWays(int n, int x, int y) {\n    const int maxStages = min(n, x);\n    const auto [fact, invFact] = getFactAndInvFact(max(n, x));\n    const vector<vector<int>> stirling = getStirling(n, maxStages);\n    int ans = 0;\n\n    for (int k = 1; k <= maxStages; ++k) {\n      // 1. Choose `k` stages from `x` stages.\n      long events = nCk(x, k, fact, invFact);\n      // 2. Partition `n` performers into `k` stages.\n      events = events * stirling[n][k] % kMod;\n      // 3. Permute `k` stages.\n      events = events * fact[k] % kMod;\n      // 4. Score `k` stages with score in the range [1, y], so y^k ways.\n      events = events * modPow(y, k) % kMod;\n      ans = (ans + events) % kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {\n    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;\n  }\n\n  // Returns a 2D array stirling, where stirling[i][j] := the number of ways to\n  // partition a set of i objects into j non-empty subsets.\n  //\n  // https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n  vector<vector<int>> getStirling(int n, int k) {\n    vector<vector<int>> stirling(n + 1, vector<int>(k + 1));\n    stirling[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      stirling[i][1] = 1;\n      for (int j = 2; j <= min(i, k); ++j)\n        stirling[i][j] = (static_cast<long>(j) * stirling[i - 1][j] +\n                          stirling[i - 1][j - 1]) %\n                         kMod;\n    }\n    return stirling;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "3318": "class Solution {\n public:\n  vector<int> findXSum(vector<int>& nums, int k, int x) {\n    vector<int> ans;\n    long windowSum = 0;\n    unordered_map<int, int> count;\n    multiset<pair<int, int>> top;  // the top x elements\n    multiset<pair<int, int>> bot;  // the rest of the elements\n\n    // Updates the count of num by freq and the window sum accordingly.\n    auto update = [&count, &top, &bot, &windowSum](int num, int freq) -> void {\n      if (count[num] > 0) {  // Clean up the old count.\n        if (auto it = bot.find({count[num], num}); it != bot.end()) {\n          bot.erase(it);\n        } else {\n          it = top.find({count[num], num});\n          top.erase(it);\n          windowSum -= num * count[num];\n        }\n      }\n      count[num] += freq;\n      if (count[num] > 0)\n        bot.insert({count[num], num});\n    };\n\n    for (int i = 0; i < nums.size(); ++i) {\n      update(nums[i], 1);\n      if (i >= k)\n        update(nums[i - k], -1);\n      // Move the bottom elements to the top if needed.\n      while (!bot.empty() && top.size() < x) {\n        const auto [countB, b] = *bot.rbegin();\n        bot.erase(--bot.end());\n        top.insert({countB, b});\n        windowSum += b * countB;\n      }\n      // Swap the bottom and top elements if needed.\n      while (!bot.empty() && *bot.rbegin() > *top.begin()) {\n        const auto [countB, b] = *bot.rbegin();\n        const auto [countT, t] = *top.begin();\n        bot.erase(--bot.end());\n        top.erase(top.begin());\n        bot.insert({countT, t});\n        top.insert({countB, b});\n        windowSum += b * countB;\n        windowSum -= t * countT;\n      }\n      if (i >= k - 1)\n        ans.push_back(windowSum);\n    }\n\n    return ans;\n  }\n};\n", "3319": "struct T {\n  bool isPerfect;\n  int sz;\n};\n\nclass Solution {\n public:\n  int kthLargestPerfectSubtree(TreeNode* root, int k) {\n    vector<int> ans;\n    dfs(root, ans);\n    ranges::sort(ans, greater<>());\n    return ans.size() < k ? -1 : ans[k - 1];\n  }\n\n private:\n  T dfs(TreeNode* root, vector<int>& ans) {\n    if (root == nullptr)\n      return {true, 0};\n    const auto l = dfs(root->left, ans);\n    const auto r = dfs(root->right, ans);\n    if (l.isPerfect && r.isPerfect && l.sz == r.sz) {\n      const int sz = 1 + l.sz + r.sz;\n      ans.push_back(sz);\n      return {true, sz};\n    }\n    return {false, 0};\n  }\n};\n", "332": "class Solution {\n public:\n  vector<string> findItinerary(vector<vector<string>>& tickets) {\n    vector<string> ans;\n    unordered_map<string, multiset<string>> graph;\n\n    for (const vector<string>& ticket : tickets)\n      graph[ticket[0]].insert(ticket[1]);\n\n    dfs(graph, \"JFK\", ans);\n    ranges::reverse(ans);\n    return ans;\n  }\n\n private:\n  void dfs(unordered_map<string, multiset<string>>& graph, const string& u,\n           vector<string>& ans) {\n    while (graph.contains(u) && !graph[u].empty()) {\n      const string v = *graph[u].begin();\n      graph[u].erase(graph[u].begin());\n      dfs(graph, v, ans);\n    }\n    ans.push_back(u);\n  }\n};\n", "3320": "\nclass Solution {\n public:\n  int countWinningSequences(string s) {\n    vector<vector<vector<int>>> mem(\n        s.length(), vector<vector<int>>(3, vector<int>(2 * s.length(), -1)));\n    const long ans = count(s, 0, 0, 0, mem) + count(s, 0, 1, 0, mem) +\n                     count(s, 0, 2, 0, mem);\n    return (ans / 2) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of distinct sequences Bob can use to beat Alice for\n  // s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the\n  // number of points that Bob is having is `bob`.\n  long count(const string& s, int i, int prev, int bob,\n             vector<vector<vector<int>>>& mem) {\n    if (i == s.length())\n      return bob > 0 ? 1 : 0;\n    // Map [-s.length(), s.length() - 1] to [0, 2 * s.length() - 1].\n    int& res = mem[i][prev][bob + s.length()];\n    if (res != -1)\n      return res;\n\n    long f = 0;  // If Bob summons a Fire Dragon at i.\n    long w = 0;  // If Bob summons a Water Serpent at i.\n    long e = 0;  // If Bob summons a Earth Golem at i.\n\n    switch (s[i]) {\n      case 'F':\n        if (prev != 0)\n          f = count(s, i + 1, 0, bob, mem) % kMod;\n        if (prev != 1)\n          w = count(s, i + 1, 1, bob + 1, mem) % kMod;\n        if (prev != 2)\n          e = count(s, i + 1, 2, bob - 1, mem) % kMod;\n        break;\n      case 'W':\n        if (prev != 0)\n          f = count(s, i + 1, 0, bob - 1, mem) % kMod;\n        if (prev != 1)\n          w = count(s, i + 1, 1, bob, mem) % kMod;\n        if (prev != 2)\n          e = count(s, i + 1, 2, bob + 1, mem) % kMod;\n        break;\n      case 'E':\n        if (prev != 0)\n          f = count(s, i + 1, 0, bob + 1, mem) % kMod;\n        if (prev != 1)\n          w = count(s, i + 1, 1, bob - 1, mem) % kMod;\n        if (prev != 2)\n          e = count(s, i + 1, 2, bob, mem) % kMod;\n      default:\n        break;\n    }\n\n    return res = f + w + e;\n  }\n};\n", "3321": "class Solution {\n public:\n  // Same as 3318. Find X-Sum of All K-Long Subarrays I\n  vector<long long> findXSum(vector<int>& nums, int k, int x) {\n    vector<long long> ans;\n    long windowSum = 0;\n    unordered_map<int, int> count;\n    multiset<pair<int, int>> top;  // the top x elements\n    multiset<pair<int, int>> bot;  // the rest of the elements\n\n    // Updates the count of num by freq and the window sum accordingly.\n    auto update = [&count, &top, &bot, &windowSum](int num, int freq) -> void {\n      if (count[num] > 0) {  // Clean up the old count.\n        if (auto it = bot.find({count[num], num}); it != bot.end()) {\n          bot.erase(it);\n        } else {\n          it = top.find({count[num], num});\n          top.erase(it);\n          windowSum -= static_cast<long>(num) * count[num];\n        }\n      }\n      count[num] += freq;\n      if (count[num] > 0)\n        bot.insert({count[num], num});\n    };\n\n    for (int i = 0; i < nums.size(); ++i) {\n      update(nums[i], 1);\n      if (i >= k)\n        update(nums[i - k], -1);\n      // Move the bottom elements to the top if needed.\n      while (!bot.empty() && top.size() < x) {\n        const auto [countB, b] = *bot.rbegin();\n        bot.erase(--bot.end());\n        top.insert({countB, b});\n        windowSum += static_cast<long>(b) * countB;\n      }\n      // Swap the bottom and top elements if needed.\n      while (!bot.empty() && *bot.rbegin() > *top.begin()) {\n        const auto [countB, b] = *bot.rbegin();\n        const auto [countT, t] = *top.begin();\n        bot.erase(--bot.end());\n        top.erase(top.begin());\n        bot.insert({countT, t});\n        top.insert({countB, b});\n        windowSum += static_cast<long>(b) * countB;\n        windowSum -= static_cast<long>(t) * countT;\n      }\n      if (i >= k - 1)\n        ans.push_back(windowSum);\n    }\n\n    return ans;\n  }\n};\n", "3323": "class Solution {\n public:\n  int minConnectedGroups(vector<vector<int>>& intervals, int k) {\n    int mergedIntervals = 0;\n    int maxMergedIntervals = 0;\n\n    intervals = merge(intervals);\n\n    int i = 0;\n    for (const vector<int>& interval : intervals) {\n      const int end = interval[1];\n      while (i < intervals.size() && end + k >= intervals[i][0]) {\n        ++mergedIntervals;\n        ++i;\n      }\n      --mergedIntervals;  // Exclude intervals[i].\n      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals);\n    }\n\n    return intervals.size() - maxMergedIntervals;\n  }\n\n private:\n  // Same as 56. Merge Intervals\n  vector<vector<int>> merge(vector<vector<int>>& intervals) {\n    vector<vector<int>> res;\n    ranges::sort(intervals);\n    for (const vector<int>& interval : intervals)\n      if (res.empty() || res.back()[1] < interval[0])\n        res.push_back(interval);\n      else\n        res.back()[1] = max(res.back()[1], interval[1]);\n    return res;\n  }\n};\n", "3324": "class Solution {\n public:\n  vector<string> stringSequence(string target) {\n    vector<string> ans;\n    string s;\n\n    for (const char targetChar : target) {\n      s += 'a';\n      ans.push_back(s);\n      for (char c = 'b'; c <= targetChar; c++) {\n        s.back() = c;\n        ans.push_back(s);\n      }\n    }\n\n    return ans;\n  }\n};\n", "3325": "class Solution {\n public:\n  int numberOfSubstrings(string s, int k) {\n    const int n = s.length();\n    int ans = n * (n + 1) / 2;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      const int c = s[r];\n      ++count[c - 'a'];\n      while (count[c - 'a'] == k)\n        --count[s[l++] - 'a'];\n      ans -= r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "3326": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n\n    for (int i = nums.size() - 2; i >= 0; --i)\n      if (nums[i] > nums[i + 1]) {\n        const int minDivisor = getMinDivisor(nums[i]);\n        if (minDivisor > nums[i + 1])\n          return -1;\n        nums[i] = minDivisor;\n        ++ans;\n      }\n\n    return ans;\n  }\n\n private:\n  int getMinDivisor(int num) {\n    for (int divisor = 2; divisor <= sqrt(num); ++divisor)\n      if (num % divisor == 0)\n        return divisor;\n    return num;\n  }\n};\n", "3327": "class Solution {\n public:\n  vector<bool> findAnswer(vector<int>& parent, string s) {\n    const int n = parent.size();\n    vector<bool> ans(n);\n    vector<vector<int>> tree(n);\n    vector<int> start(n);  // start[i] := the start index of `dfsStr` of node i\n    vector<int> end(n);    // end[i] := the end index of `dfsStr` of node i\n    string dfsStr;\n\n    for (int i = 1; i < n; ++i)\n      tree[parent[i]].push_back(i);\n\n    dfs(tree, 0, /*index=*/0, s, start, end, dfsStr);\n    const string t = join('@' + dfsStr + '$', /*delimiter=*/'#');\n    const vector<int> p = manacher(t);\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = isPalindrome(start[i], end[i], p);\n\n    return ans;\n  }\n\n private:\n  // Returns the start index of the \"DFS string\" of u's next node.\n  int dfs(const vector<vector<int>>& tree, int u, int index, const string& s,\n          vector<int>& start, vector<int>& end, string& dfsStr) {\n    start[u] = index;\n    for (const int v : tree[u])\n      index = dfs(tree, v, index, s, start, end, dfsStr);\n    end[u] = index;\n    dfsStr += s[u];\n    return index + 1;\n  }\n\n  // Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n  // centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n  vector<int> manacher(const string& t) {\n    vector<int> p(t.length());\n    int center = 0;\n    for (int i = 1; i < t.length() - 1; ++i) {\n      const int rightBoundary = center + p[center];\n      const int mirrorIndex = center - (i - center);\n      if (rightBoundary > i)\n        p[i] = min(rightBoundary - i, p[mirrorIndex]);\n      // Try to expand the palindrome centered at i.\n      while (t[i + 1 + p[i]] == t[i - 1 - p[i]])\n        ++p[i];\n      // If a palindrome centered at i expands past `rightBoundary`, adjust\n      // the center based on the expanded palindrome.\n      if (i + p[i] > rightBoundary)\n        center = i;\n    }\n    return p;\n  }\n\n  // Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed\n  // array `p` from the Manacher's algorithm.\n  //\n  // The precomputed array `p` is based on the string `t` with delimiters and\n  // sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of\n  // `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`\n  // and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is\n  // `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.\n  bool isPalindrome(int s, int e, const vector<int>& p) {\n    const int length = e - s + 1;\n    const int center = s + e + 2;\n    return p[center] >= length;\n  }\n\n  string join(const string& s, char delimiter) {\n    string joined;\n    for (int i = 0; i < s.length() - 1; ++i) {\n      joined += s[i];\n      joined += delimiter;\n    }\n    joined += s.back();\n    return joined;\n  }\n};\n", "3329": "class Solution {\n public:\n  long long numberOfSubstrings(string s, int k) {\n    const int n = s.length();\n    long ans = n * static_cast<long>(n + 1) / 2;\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < n; ++r) {\n      const int c = s[r];\n      ++count[c - 'a'];\n      while (count[c - 'a'] == k)\n        --count[s[l++] - 'a'];\n      ans -= r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "333": "struct T {\n  int mn;    // the minimum value in the subtree\n  int mx;    // the maximum value in the subtree\n  int size;  // the size of the subtree\n};\n\nclass Solution {\n public:\n  int largestBSTSubtree(TreeNode* root) {\n    return dfs(root).size;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {INT_MAX, INT_MIN, 0};\n\n    T l = dfs(root->left);\n    T r = dfs(root->right);\n\n    if (l.mx < root->val && root->val < r.mn)\n      return {min(l.mn, root->val), max(r.mx, root->val), 1 + l.size + r.size};\n\n    // Mark one as invalid, but still record the size of children.\n    // Return (-INF, INF) because no node will be > INT or < -INF.\n    return {INT_MIN, INT_MAX, max(l.size, r.size)};\n  }\n};\n", "3330": "class Solution {\n public:\n  int possibleStringCount(string word) {\n    int ans = 1;\n    for (int i = 1; i < word.length(); ++i)\n      if (word[i] == word[i - 1])\n        ++ans;\n    return ans;\n  }\n};\n", "3331": "class Solution {\n public:\n  vector<int> findSubtreeSizes(vector<int>& parent, string s) {\n    const int n = parent.size();\n    vector<int> ans(n);\n    vector<int> newParent = parent;\n    vector<vector<int>> tree(n);\n\n    for (int i = 1; i < n; ++i) {\n      const int closest = findClosestAncestor(i, parent, s);\n      if (closest != -1)\n        newParent[i] = closest;\n    }\n\n    for (int i = 1; i < n; ++i)\n      tree[newParent[i]].push_back(i);\n\n    dfs(tree, 0, ans);\n    return ans;\n  }\n\n private:\n  // Returns the closest ancestor of node `u` that has the same value as `u`.\n  int findClosestAncestor(int u, const vector<int>& parent, const string& s) {\n    for (int curr = parent[u]; curr != -1; curr = parent[curr])\n      if (s[curr] == s[u])\n        return curr;\n    return -1;\n  }\n\n  int dfs(const vector<vector<int>>& tree, int u, vector<int>& ans) {\n    int sz = 1;\n    for (const int v : tree[u])\n      sz += dfs(tree, v, ans);\n    return ans[u] = sz;\n  }\n};\n", "3332": "class Solution {\n public:\n  int maxScore(int n, int k, vector<vector<int>>& stayScore,\n               vector<vector<int>>& travelScore) {\n    // dp[j] := the maximum score after days so far being at city j\n    vector<int> dp(n);\n\n    for (int i = 0; i < k; ++i) {\n      vector<int> newDp(n);\n      for (int dest = 0; dest < n; ++dest) {\n        // 1. Stay at the current city.\n        newDp[dest] = dp[dest] + stayScore[i][dest];\n        // 2. Travel from any other city.\n        for (int curr = 0; curr < n; ++curr)\n          if (curr != dest)\n            newDp[dest] = max(newDp[dest], dp[curr] + travelScore[curr][dest]);\n      }\n      dp = std::move(newDp);\n    }\n\n    return ranges::max(dp);\n  }\n};\n", "3333": "class Solution {\n public:\n  int possibleStringCount(string word, int k) {\n    const vector<int> groups = getConsecutiveLetters(word);\n    const int totalCombinations =\n        accumulate(groups.begin(), groups.end(), 1L,\n                   [](long acc, int group) { return acc * group % kMod; });\n    if (k <= groups.size())\n      return totalCombinations;\n\n    // dp[j] := the number of ways to form strings of length j using\n    // groups[0..i]\n    vector<int> dp(k);\n    dp[0] = 1;  // Base case: empty string\n\n    for (int i = 0; i < groups.size(); ++i) {\n      vector<int> newDp(k);\n      int windowSum = 0;\n      int group = groups[i];\n      for (int j = i; j < k; ++j) {\n        newDp[j] = (newDp[j] + windowSum) % kMod;\n        windowSum = (windowSum + dp[j]) % kMod;\n        if (j >= group)\n          windowSum = (windowSum - dp[j - group] + kMod) % kMod;\n      }\n      dp = std::move(newDp);\n    }\n\n    const int invalidCombinations =\n        accumulate(dp.begin(), dp.end(), 0,\n                   [](int acc, int count) { return (acc + count) % kMod; });\n    return (totalCombinations - invalidCombinations + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns consecutive identical letters in the input string.\n  // e.g. \"aabbbc\" -> [2, 3, 1].\n  vector<int> getConsecutiveLetters(const string& word) {\n    vector<int> groups;\n    int group = 1;\n    for (int i = 1; i < word.length(); ++i)\n      if (word[i] == word[i - 1]) {\n        ++group;\n      } else {\n        groups.push_back(group);\n        group = 1;\n      }\n    groups.push_back(group);\n    return groups;\n  }\n};\n", "3334": "class Solution {\n public:\n  long long maxScore(vector<int>& nums) {\n    const int n = nums.size();\n    // prefixGcd[i] := GCD of nums[0..i]\n    // prefixLcm[i] := LCM of nums[0..i]\n    const auto [prefixGcd, prefixLcm] = getPrefix(nums);\n    // suffixGcd[i] := GCD of nums[i..n - 1]\n    // suffixLcm[i] := LCM of nums[i..n - 1]\n    const auto [suffixGcd, suffixLcm] = getSuffix(nums);\n    long ans = suffixGcd[0] * suffixLcm[0];\n\n    for (int i = 0; i < n; ++i) {\n      const long gcd1 = i > 0 ? prefixGcd[i - 1] : 0;\n      const long gcd2 = i + 1 < n ? suffixGcd[i + 1] : 0;\n      const long lcm1 = i > 0 ? prefixLcm[i - 1] : 1;\n      const long lcm2 = i + 1 < n ? suffixLcm[i + 1] : 1;\n      const long score = gcd(gcd1, gcd2) * lcm(lcm1, lcm2);\n      ans = max(ans, score);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the prefix GCD and LCM arrays.\n  pair<vector<long>, vector<long>> getPrefix(const vector<int>& nums) {\n    vector<long> prefixGcd;\n    vector<long> prefixLcm;\n    long currGcd = 0;\n    long currLcm = 1;\n    for (const int num : nums) {\n      currGcd = gcd(currGcd, num);\n      currLcm = lcm(currLcm, num);\n      prefixGcd.push_back(currGcd);\n      prefixLcm.push_back(currLcm);\n    }\n    return {prefixGcd, prefixLcm};\n  }\n\n  // Returns the suffix GCD and LCM arrays.\n  pair<vector<long>, vector<long>> getSuffix(const vector<int>& nums) {\n    vector<long> suffixGcd;\n    vector<long> suffixLcm;\n    long currGcd = 0;\n    long currLcm = 1;\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      currGcd = gcd(currGcd, nums[i]);\n      currLcm = lcm(currLcm, nums[i]);\n      suffixGcd.push_back(currGcd);\n      suffixLcm.push_back(currLcm);\n    }\n    ranges::reverse(suffixGcd);\n    ranges::reverse(suffixLcm);\n    return {suffixGcd, suffixLcm};\n  }\n};\n", "3335": "class Solution {\n public:\n  int lengthAfterTransformations(string s, int t) {\n    // T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    const vector<vector<int>> T = getTransformationMatrix();\n    const vector poweredT = matrixPow(T, t);\n    vector<int> count(26);\n    // lengths[i] := the total length of ('a' + i) after t transformations\n    vector<long> lengths(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int i = 0; i < 26; ++i)\n      for (int j = 0; j < 26; ++j) {\n        lengths[j] += static_cast<long>(count[i]) * poweredT[i][j];\n        lengths[j] %= kMod;\n      }\n\n    return accumulate(lengths.begin(), lengths.end(), 0L) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  vector<vector<int>> getTransformationMatrix() {\n    vector<vector<int>> T(26, vector<int>(26));\n    // 'z' -> 'ab'\n    T[25][0] = 1;\n    T[25][1] = 1;\n    // 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n    for (int i = 0; i < 25; ++i)\n      T[i][i + 1] = 1;\n    return T;\n  }\n\n  vector<vector<int>> getIdentityMatrix(int sz) {\n    vector<vector<int>> I(sz, vector<int>(sz));\n    for (int i = 0; i < sz; ++i)\n      I[i][i] = 1;\n    return I;\n  }\n\n  // Returns A * B.\n  vector<vector<int>> matrixMult(const vector<vector<int>>& A,\n                                 const vector<vector<int>>& B) {\n    const int sz = A.size();\n    vector<vector<int>> C(sz, vector<int>(sz));\n    for (int i = 0; i < sz; ++i)\n      for (int j = 0; j < sz; ++j)\n        for (int k = 0; k < sz; ++k)\n          C[i][j] = (C[i][j] + static_cast<long>(A[i][k]) * B[k][j]) % kMod;\n    return C;\n  }\n\n  // Returns M^n.\n  vector<vector<int>> matrixPow(const vector<vector<int>>& M, int n) {\n    if (n == 0)\n      return getIdentityMatrix(M.size());\n    if (n % 2 == 1)\n      return matrixMult(M, matrixPow(M, n - 1));\n    return matrixPow(matrixMult(M, M), n / 2);\n  }\n};\n", "3336": "class Solution {\n public:\n  int subsequencePairCount(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    const int maxNum = ranges::max(nums);\n    // dp[i][x][y] := the number of disjoint pairs `seq1` and `seq2` of\n    // nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(maxNum + 1, vector<int>(maxNum + 1)));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i)\n      for (int x = 0; x <= maxNum; ++x)\n        for (int y = 0; y <= maxNum; ++y) {\n          // 1. Skip nums[i].\n          dp[i + 1][x][y] += dp[i][x][y];\n          dp[i + 1][x][y] %= kMod;\n          // 2. Pick nums[i] in the first subsequence.\n          const int newX = gcd(x, nums[i]);\n          dp[i + 1][newX][y] += dp[i][x][y];\n          dp[i + 1][newX][y] %= kMod;\n          // 3. Pick nums[i] in the second subsequence.\n          const int newY = gcd(y, nums[i]);\n          dp[i + 1][x][newY] += dp[i][x][y];\n          dp[i + 1][x][newY] %= kMod;\n        }\n\n    int ans = 0;\n    for (int g = 1; g <= maxNum; ++g) {\n      ans += dp[n][g][g];\n      ans %= kMod;\n    }\n    return ans;\n  }\n};\n", "3337": "class Solution {\n public:\n  // Similar to 3335. Total Characters in String After Transformations I\n  int lengthAfterTransformations(string s, int t, vector<int>& nums) {\n    // T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    const vector<vector<int>> T = getTransformationMatrix(nums);\n    const vector poweredT = matrixPow(T, t);\n    vector<int> count(26);\n    // lengths[i] := the total length of ('a' + i) after t transformations\n    vector<long> lengths(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int i = 0; i < 26; ++i)\n      for (int j = 0; j < 26; ++j) {\n        lengths[j] += static_cast<long>(count[i]) * poweredT[i][j];\n        lengths[j] %= kMod;\n      }\n\n    return accumulate(lengths.begin(), lengths.end(), 0L) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  vector<vector<int>> getTransformationMatrix(const vector<int>& nums) {\n    vector<vector<int>> T(26, vector<int>(26));\n    for (int i = 0; i < nums.size(); ++i)\n      for (int step = 1; step <= nums[i]; ++step)\n        ++T[i][(i + step) % 26];\n    return T;\n  }\n\n  vector<vector<int>> getIdentityMatrix(int sz) {\n    vector<vector<int>> I(sz, vector<int>(sz));\n    for (int i = 0; i < sz; ++i)\n      I[i][i] = 1;\n    return I;\n  }\n\n  // Returns A * B.\n  vector<vector<int>> matrixMult(const vector<vector<int>>& A,\n                                 const vector<vector<int>>& B) {\n    const int sz = A.size();\n    vector<vector<int>> C(sz, vector<int>(sz));\n    for (int i = 0; i < sz; ++i)\n      for (int j = 0; j < sz; ++j)\n        for (int k = 0; k < sz; ++k)\n          C[i][j] = (C[i][j] + static_cast<long>(A[i][k]) * B[k][j]) % kMod;\n    return C;\n  }\n\n  // Returns M^n.\n  vector<vector<int>> matrixPow(const vector<vector<int>>& M, int n) {\n    if (n == 0)\n      return getIdentityMatrix(M.size());\n    if (n % 2 == 1)\n      return matrixMult(M, matrixPow(M, n - 1));\n    return matrixPow(matrixMult(M, M), n / 2);\n  }\n};\n", "3339": "class Solution {\n public:\n  int countOfArrays(int n, int m, int k) {\n    constexpr int kMod = 1'000'000'007;\n    const int even = m / 2;    // the number of even numbers in [1, m]\n    const int odd = m - even;  // the number of odd numbers in [1, m]\n    // dp[j][0/1] := the number of arrays of length so far i with j consecutive\n    // even number pairs ending in an even number (0) or an odd number (1)\n    vector<vector<int>> dp(k + 1, vector<int>(2));\n\n    // Base case: arrays of length 1\n    // For an array of length 1, we can't have any even number pairs yet.\n    dp[0][0] = even;\n    dp[0][1] = odd;\n\n    for (int i = 2; i <= n; ++i) {\n      vector<vector<int>> newDp(k + 1, vector<int>(2));\n      for (int j = 0; j <= k; ++j) {\n        // 1. Appending an even number to an array ending in an even number\n        //    creates a new consecutive even number pair.\n        // 2. Appending an even number to an array ending in an odd number.\n        newDp[j][0] = (static_cast<long>(j > 0 ? dp[j - 1][0] : 0) * even +\n                       static_cast<long>(dp[j][1]) * even) %\n                      kMod;\n        // 3. Appending an odd number to an array.\n        newDp[j][1] = static_cast<long>(dp[j][0] + dp[j][1]) * odd % kMod;\n      }\n      dp = std::move(newDp);\n    }\n\n    return (dp[k][0] + dp[k][1]) % kMod;\n  }\n};\n", "334": "class Solution {\n public:\n  bool increasingTriplet(vector<int>& nums) {\n    int first = INT_MAX;\n    int second = INT_MAX;\n\n    for (const int num : nums)\n      if (num <= first)\n        first = num;\n      else if (num <= second)  // first < num <= second\n        second = num;\n      else\n        return true;  // first < second < num (third)\n\n    return false;\n  }\n};\n", "3340": "class Solution {\n public:\n  bool isBalanced(string num) {\n    int balance = 0;\n    int sign = 1;\n\n    for (const char c : num) {\n      balance += sign * (c - '0');\n      sign *= -1;\n    }\n\n    return balance == 0;\n  }\n};\n", "3341": "class Solution {\n public:\n  int minTimeToReach(vector<vector<int>>& moveTime) {\n    return dijkstra(moveTime, {0, 0},\n                    {moveTime.size() - 1, moveTime[0].size() - 1});\n  }\n\n private:\n  int dijkstra(const vector<vector<int>>& moveTime, const pair<int, int>& src,\n               const pair<int, int>& dst) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = moveTime.size();\n    const int n = moveTime[0].size();\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n\n    dist[0][0] = 0;\n    using T = pair<int, pair<int, int>>;  // (d, u)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.push({dist[0][0], src});\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return d;\n      const auto [i, j] = u;\n      if (d > dist[i][j])\n        continue;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int newDist = max(moveTime[x][y], d) + 1;\n        if (newDist < dist[x][y]) {\n          dist[x][y] = newDist;\n          minHeap.push({newDist, {x, y}});\n        }\n      }\n    }\n\n    return -1;\n  }\n};\n", "3342": "class Solution {\n public:\n  // Similar to 3341. Find Minimum Time to Reach Last Room I\n  int minTimeToReach(vector<vector<int>>& moveTime) {\n    return dijkstra(moveTime, {0, 0},\n                    {moveTime.size() - 1, moveTime[0].size() - 1});\n  }\n\n private:\n  int dijkstra(const vector<vector<int>>& moveTime, const pair<int, int>& src,\n               const pair<int, int>& dst) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = moveTime.size();\n    const int n = moveTime[0].size();\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n\n    dist[0][0] = 0;\n    using T = pair<int, pair<int, int>>;  // (d, (ux, uy))\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.push({dist[0][0], src});\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return d;\n      const auto [i, j] = u;\n      if (d > dist[i][j])\n        continue;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int newDist = max(moveTime[x][y], d) + ((i + j) % 2 + 1);\n        if (newDist < dist[x][y]) {\n          dist[x][y] = newDist;\n          minHeap.push({newDist, {x, y}});\n        }\n      }\n    }\n\n    return -1;\n  }\n};\n", "3343": "class Solution {\n public:\n  int countBalancedPermutations(string num) {\n    vector<int> nums = getNums(num);\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (sum % 2 == 1)\n      return 0;\n\n    ranges::sort(nums, greater<>());\n\n    const int even = (nums.size() + 1) / 2;\n    const int odd = nums.size() / 2;\n    const int evenBalance = sum / 2;\n    vector<vector<vector<long>>> mem(\n        even + 1,\n        vector<vector<long>>(odd + 1, vector<long>(evenBalance + 1, -1)));\n    const long perm = getPerm(nums);\n    return countBalancedPermutations(nums, even, odd, evenBalance, mem) *\n           modInverse(perm) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of permutations where there are `even` even indices\n  // left, `odd` odd indices left, and `evenBalance` is the target sum of the\n  // remaining numbers to be placed in even indices.\n  long countBalancedPermutations(const vector<int>& nums, int even, int odd,\n                                 int evenBalance,\n                                 vector<vector<vector<long>>>& mem) {\n    if (evenBalance < 0)\n      return 0;\n    if (even == 0)\n      return evenBalance == 0 ? factorial(odd) : 0;\n    const int index = nums.size() - (even + odd);\n    if (odd == 0) {\n      long remainingSum = 0;\n      for (int i = index; i < nums.size(); ++i)\n        remainingSum += nums[i];\n      return (remainingSum == evenBalance) ? factorial(even) : 0;\n    }\n    if (mem[even][odd][evenBalance] != -1)\n      return mem[even][odd][evenBalance];\n    const long placeEven =\n        countBalancedPermutations(nums, even - 1, odd,\n                                  evenBalance - nums[index], mem) *\n        even % kMod;\n    const long placeOdd =\n        countBalancedPermutations(nums, even, odd - 1, evenBalance, mem) * odd %\n        kMod;\n    return mem[even][odd][evenBalance] = (placeEven + placeOdd) % kMod;\n  }\n\n  vector<int> getNums(const string& num) {\n    vector<int> nums;\n    for (const char c : num)\n      nums.push_back(c - '0');\n    return nums;\n  }\n\n  long getPerm(const vector<int>& nums) {\n    long res = 1;\n    vector<int> count(10);\n    for (const int num : nums)\n      ++count[num];\n    for (const int freq : count)\n      res = res * factorial(freq) % kMod;\n    return res;\n  }\n\n  long factorial(int n) {\n    long res = 1;\n    for (int i = 2; i <= n; ++i)\n      res = res * i % kMod;\n    return res;\n  }\n\n  long modInverse(long a) {\n    long m = kMod;\n    long y = 0;\n    long x = 1;\n    while (a > 1) {\n      const long q = a / m;\n      long t = m;\n      m = a % m;\n      a = t;\n      t = y;\n      y = x - q * y;\n      x = t;\n    }\n    return x < 0 ? x + kMod : x;\n  }\n};\n", "3344": "class Solution {\n public:\n  int maxSizedArray(long long s) {\n    if (s == 0)\n      return 1;\n\n    int l = 0;\n    int r = 1196;  // when s = 10^15, n = 1196\n\n    while (l < r) {\n      const int m = (l + r + 1) / 2;\n      if (getArraySum(m) <= s)\n        l = m;\n      else\n        r = m - 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the number of integers in [0, n - 1] with the i-th bit set.\n  //\n  // For the i-th bit, numbers in the range [0, n - 1] can be divided into\n  // groups of 2^(i + 1) numbers. In each group, exactly half of the numbers\n  // have the i-th bit set.\n  int getNumbersWithBitSet(int n, int i) {\n    const int groupSize = 1 << (i + 1);\n    const int halfGroupSize = 1 << i;\n    const int fullGroups = n / groupSize;\n    const int remaining = max(0, (n % groupSize) - halfGroupSize);\n    return fullGroups * halfGroupSize + remaining;\n  }\n\n  // Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.\n  //\n  //   sum(i * (j OR k)), where 0 <= i, j, k < n\n  // = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)\n  // = (0 + 1 + ... + n - 1) * sum(j OR k)\n  // = (n * (n - 1) / 2) * sum(j OR k)\n  long getArraySum(int n) {\n    const int arithmeticSum = n * (n - 1) / 2;\n    long orSum = 0;\n    for (int i = 0; i < bitLength(n); ++i) {\n      const int numbersWituoutBit = n - getNumbersWithBitSet(n, i);\n      const int pairsWithBit =\n          (n * n) - (numbersWituoutBit * numbersWituoutBit);\n      orSum += pairsWithBit * (1L << i);\n    }\n    return arithmeticSum * orSum;\n  }\n\n  int bitLength(int n) {\n    return 32 - __builtin_clz(n);\n  }\n};\n", "3345": "class Solution {\n public:\n  int smallestNumber(int n, int t) {\n    for (int num = n; num < n + 10; ++num)\n      if (getDigitProd(num) % t == 0)\n        return num;\n    throw;\n  }\n\n private:\n  int getDigitProd(int num) {\n    int digitProd = 1;\n    while (num > 0) {\n      digitProd *= num % 10;\n      num /= 10;\n    }\n    return digitProd;\n  }\n};\n", "3346": "class Solution {\n public:\n  int maxFrequency(vector<int>& nums, int k, int numOperations) {\n    int ans = 1;\n    int adjustable = 0;\n    unordered_map<int, int> count;\n    map<int, int> line;\n    set<int> candidates;\n\n    for (const int num : nums) {\n      ++count[num];\n      ++line[num - k];\n      --line[num + k + 1];\n      candidates.insert(num);\n      candidates.insert(num - k);\n      candidates.insert(num + k + 1);\n    }\n\n    for (const int num : candidates) {\n      adjustable += line.contains(num) ? line[num] : 0;\n      const int countNum = count.contains(num) ? count[num] : 0;\n      const int adjusted = adjustable - countNum;\n      ans = max(ans, countNum + min(numOperations, adjusted));\n    }\n\n    return ans;\n  }\n};\n", "3347": "class Solution {\n public:\n  // Same as 3346. Maximum Frequency of an Element After Performing Operations I\n  int maxFrequency(vector<int>& nums, int k, int numOperations) {\n    int ans = 1;\n    int adjustable = 0;\n    unordered_map<int, int> count;\n    map<int, int> line;\n    set<int> candidates;\n\n    for (const int num : nums) {\n      ++count[num];\n      ++line[num - k];\n      --line[num + k + 1];\n      candidates.insert(num);\n      candidates.insert(num - k);\n      candidates.insert(num + k + 1);\n    }\n\n    for (const int num : candidates) {\n      adjustable += line.contains(num) ? line[num] : 0;\n      const int countNum = count.contains(num) ? count[num] : 0;\n      const int adjusted = adjustable - countNum;\n      ans = max(ans, countNum + min(numOperations, adjusted));\n    }\n\n    return ans;\n  }\n};\n", "3348": "class Solution {\n public:\n  string smallestNumber(string num, long long t) {\n    const auto [primeCount, isDivisible] = getPrimeCount(t);\n    if (!isDivisible)\n      return \"-1\";\n\n    const unordered_map<int, int> factorCount = getFactorCount(primeCount);\n    if (sumValues(factorCount) > num.length())\n      return consturct(factorCount);\n\n    unordered_map<int, int> primeCountPrefix = getPrimeCount(num);\n    int firstZeroIndex = num.find('0');\n    if (firstZeroIndex == string::npos) {\n      firstZeroIndex = num.length();\n      if (isSubset(primeCount, primeCountPrefix))\n        return num;\n    }\n\n    for (int i = num.length() - 1; i >= 0; --i) {\n      const int d = num[i] - '0';\n      // Remove the current digit's factors from primeCountPrefix.\n      primeCountPrefix = substract(primeCountPrefix, kFactorCounts.at(d));\n      const int spaceAfterThisDigit = num.length() - 1 - i;\n      if (i > firstZeroIndex)\n        continue;\n      for (int biggerDigit = d + 1; biggerDigit < 10; ++biggerDigit) {\n        // Compute the required factors after replacing with a larger digit.\n        const unordered_map<int, int> factorsAfterReplacement =\n            getFactorCount(substract(substract(primeCount, primeCountPrefix),\n                                     kFactorCounts.at(biggerDigit)));\n        // Check if the replacement is possible within the available space.\n        if (sumValues(factorsAfterReplacement) <= spaceAfterThisDigit) {\n          // Fill extra space with '1', if any, and construct the result.\n          const int fillOnes =\n              spaceAfterThisDigit - sumValues(factorsAfterReplacement);\n          return num.substr(0, i) +        // Keep the prefix unchanged.\n                 to_string(biggerDigit) +  // Replace the current digit.\n                 string(fillOnes, '1') +   // Fill remaining space with '1'.\n                 consturct(factorsAfterReplacement);\n        }\n      }\n    }\n\n    // No solution of the same length exists, so we need to extend the number\n    // by prepending '1's and adding the required factors.\n    const unordered_map<int, int> factorsAfterExtension =\n        getFactorCount(primeCount);\n    return string(num.length() + 1 - sumValues(factorsAfterExtension), '1') +\n           consturct(factorsAfterExtension);\n  }\n\n private:\n  constexpr static unordered_map<int, unordered_map<int, int>> kFactorCounts = {\n      {0, {}},       {1, {}},       {2, {{2, 1}}},         {3, {{3, 1}}},\n      {4, {{2, 2}}}, {5, {{5, 1}}}, {6, {{2, 1}, {3, 1}}}, {7, {{7, 1}}},\n      {8, {{2, 3}}}, {9, {{3, 2}}}};\n\n  // Returns the prime count of t and if t is divisible by 2, 3, 5, 7.\n  pair<unordered_map<int, int>, bool> getPrimeCount(long t) {\n    unordered_map<int, int> count{{2, 0}, {3, 0}, {5, 0}, {7, 0}};\n    for (const int prime : {2, 3, 5, 7}) {\n      while (t % prime == 0) {\n        t /= prime;\n        ++count[prime];\n      }\n    }\n    return {count, t == 1};\n  }\n\n  // Returns the prime count of `num`.\n  unordered_map<int, int> getPrimeCount(const string& num) {\n    unordered_map<int, int> count{{2, 0}, {3, 0}, {5, 0}, {7, 0}};\n    for (const char d : num)\n      for (const auto& [prime, freq] : kFactorCounts.at(d - '0'))\n        count[prime] += freq;\n    return count;\n  }\n\n  unordered_map<int, int> getFactorCount(const unordered_map<int, int>& count) {\n    unordered_map<int, int> res;\n    // 2^3 = 8\n    const int count8 = count.at(2) / 3;\n    const int remaining2 = count.at(2) % 3;\n    // 3^2 = 9\n    const int count9 = count.at(3) / 2;\n    int count3 = count.at(3) % 2;\n    // 2^2 = 4\n    int count4 = remaining2 / 2;\n    int count2 = remaining2 % 2;\n    // Combine 2 and 3 to 6 if both are present.\n    int count6 = 0;\n    if (count2 == 1 && count3 == 1) {\n      count2 = 0;\n      count3 = 0;\n      count6 = 1;\n    }\n    // Combine 3 and 4 to 2 and 6 if both are present.\n    if (count3 == 1 && count4 == 1) {\n      count2 = 1;\n      count6 = 1;\n      count3 = 0;\n      count4 = 0;\n    }\n    return unordered_map<int, int>{\n        {2, count2}, {3, count3},      {4, count4}, {5, count.at(5)},\n        {6, count6}, {7, count.at(7)}, {8, count8}, {9, count9}};\n  }\n\n  string consturct(const unordered_map<int, int>& factors) {\n    string res;\n    for (int digit = 2; digit < 10; ++digit)\n      res += string(factors.at(digit), '0' + digit);\n    return res;\n  }\n\n  // Returns true if a is a subset of b.\n  bool isSubset(const unordered_map<int, int>& a,\n                const unordered_map<int, int>& b) {\n    for (const auto& [key, value] : a)\n      if (b.at(key) < value)\n        return false;\n    return true;\n  }\n\n  // Returns a - b.\n  unordered_map<int, int> substract(unordered_map<int, int> a,\n                                    const unordered_map<int, int>& b) {\n    for (const auto& [key, value] : b)\n      a[key] = max(0, a[key] - value);\n    return a;\n  }\n\n  // Returns the sum of the values in `count`.\n  int sumValues(const unordered_map<int, int>& count) {\n    return accumulate(\n        count.begin(), count.end(), 0,\n        [](int acc, const pair<int, int>& p) { return acc + p.second; });\n  }\n};\n", "3349": "class Solution {\n public:\n  bool hasIncreasingSubarrays(vector<int>& nums, int k) {\n    int increasing = 1;\n    int prevIncreasing = 0;\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] > nums[i - 1]) {\n        ++increasing;\n      } else {\n        prevIncreasing = increasing;\n        increasing = 1;\n      }\n      if (increasing / 2 >= k || min(prevIncreasing, increasing) >= k)\n        return true;\n    }\n\n    return false;\n  }\n};\n", "335": "class Solution {\n public:\n  bool isSelfCrossing(vector<int>& x) {\n    if (x.size() <= 3)\n      return false;\n\n    for (int i = 3; i < x.size(); ++i) {\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\n        return true;\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\n        return true;\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] &&\n          x[i - 1] <= x[i - 3] && x[i - 3] <= x[i - 1] + x[i - 5])\n        return true;\n    }\n\n    return false;\n  }\n};\n", "3350": "class Solution {\n public:\n  // Similar to 3349. Adjacent Increasing Subarrays Detection I\n  int maxIncreasingSubarrays(vector<int>& nums) {\n    int ans = 0;\n    int increasing = 1;\n    int prevIncreasing = 0;\n\n    for (int i = 1; i < nums.size(); ++i) {\n      if (nums[i] > nums[i - 1]) {\n        ++increasing;\n      } else {\n        prevIncreasing = increasing;\n        increasing = 1;\n      }\n      ans = max(ans, increasing / 2);\n      ans = max(ans, min(prevIncreasing, increasing));\n    }\n\n    return ans;\n  }\n};\n", "3351": "class Solution {\n public:\n  int sumOfGoodSubsequences(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int maxNum = ranges::max(nums);\n    // endsIn[i] := the number of good subsequences ending in i\n    vector<long> endsIn(maxNum + 3);\n    // dp[i] := the sum of good subsequences ending in i\n    vector<long> dp(maxNum + 3);\n\n    for (const int num : nums) {\n      const long seqsToAppend = 1 + endsIn[num] + endsIn[num + 2];\n      dp[num + 1] =\n          (seqsToAppend * num + (dp[num + 1] + dp[num] + dp[num + 2])) % kMod;\n      endsIn[num + 1] = (endsIn[num + 1] + seqsToAppend) % kMod;\n    }\n\n    return accumulate(dp.begin(), dp.end(), 0,\n                      [&](int acc, int d) { return (acc + d) % kMod; });\n  }\n};\n", "3352": "class Solution {\n public:\n  int countKReducibleNumbers(string s, int k) {\n    vector<vector<vector<int>>> mem(\n        s.length(), vector<vector<int>>(s.length() + 1, vector<int>(2, -1)));\n    return count(s, 0, 0, true, k, getOps(s), mem) - 1;  // - 0\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns the number of positive integers less than n that are k-reducible,\n  // considering the i-th digit, where `setBits` is the number of set bits in\n  // the current number, and `tight` indicates if the current digit is\n  // tightly bound.\n  int count(const string& s, int i, int setBits, bool tight, int k,\n            const vector<int>& ops, vector<vector<vector<int>>>& mem) {\n    if (i == s.length())\n      return (ops[setBits] < k && !tight) ? 1 : 0;\n    if (mem[i][setBits][tight] != -1)\n      return mem[i][setBits][tight];\n\n    int res = 0;\n    const int maxDigit = tight ? s[i] - '0' : 1;\n\n    for (int d = 0; d <= maxDigit; ++d) {\n      const bool nextTight = tight && (d == maxDigit);\n      res += count(s, i + 1, setBits + d, nextTight, k, ops, mem);\n      res %= kMod;\n    }\n\n    return mem[i][setBits][tight] = res;\n  };\n\n  // Returns the number of operations to reduce a number to 0.\n  vector<int> getOps(string& s) {\n    vector<int> ops(s.length() + 1);\n    for (int num = 2; num <= s.length(); ++num)\n      ops[num] = 1 + ops[__builtin_popcount(num)];\n    return ops;\n  }\n};\n", "3353": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] != nums[i - 1])\n        ++ans;\n    return ans;\n  }\n};\n", "3354": "class Solution {\n public:\n  int countValidSelections(vector<int>& nums) {\n    int ans = 0;\n    int prefix = 0;\n    int suffix = accumulate(nums.begin(), nums.end(), 0);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      suffix -= nums[i];\n      prefix += nums[i];\n      if (nums[i] > 0)\n        continue;\n      if (prefix == suffix)\n        ans += 2;  // Go to either direction.\n      if (abs(prefix - suffix) == 1)\n        ans += 1;  // Go to the direction with the larger sum.\n    }\n\n    return ans;\n  }\n};\n", "3355": "class Solution {\n public:\n  bool isZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> line(nums.size() + 1);\n    int decrement = 0;\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      ++line[l];\n      --line[r + 1];\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      decrement += line[i];\n      if (decrement < nums[i])\n        return false;\n    }\n\n    return true;\n  }\n};\n", "3356": "class Solution {\n public:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> line(nums.size() + 1);\n    int decrement = 0;\n    int k = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      while (decrement + line[i] < nums[i]) {\n        if (k == queries.size())\n          return -1;\n        const int l = queries[k][0];\n        const int r = queries[k][1];\n        const int val = queries[k][2];\n        ++k;\n        if (r < i)\n          continue;\n        line[max(l, i)] += val;\n        line[r + 1] -= val;\n      }\n      decrement += line[i];\n    }\n\n    return k;\n  }\n};\n", "3357": "class Solution {\n public:\n  int minDifference(vector<int>& nums) {\n    int maxPositiveGap = 0;\n    int mn = 1'000'000'000;\n    int mx = 0;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if ((nums[i - 1] == -1) != (nums[i] == -1)) {\n        const int positive = max(nums[i - 1], nums[i]);\n        mn = min(mn, positive);\n        mx = max(mx, positive);\n      } else {\n        maxPositiveGap = max(maxPositiveGap, abs(nums[i - 1] - nums[i]));\n      }\n\n    int l = maxPositiveGap;\n    int r = (mx - mn + 1) / 2;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (check(nums, m, mn + m, mx - m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if it's possible have `m` as maximum absolute difference\n  // between adjacent numbers, where -1s are replaced with `x` or `y`.\n  bool check(const vector<int>& nums, int m, int x, int y) {\n    int gapLength = 0;\n    int prev = 0;\n\n    for (const int num : nums) {\n      if (num == -1) {\n        ++gapLength;\n        continue;\n      }\n      if (prev > 0 && gapLength > 0) {\n        if (gapLength == 1 && !checkSingleGap(prev, num, m, x, y))\n          return false;\n        if (gapLength > 1 && !checkMultipleGaps(prev, num, m, x, y))\n          return false;\n      }\n      prev = num;\n      gapLength = 0;\n    }\n\n    // Check leading gaps.\n    if (nums[0] == -1) {\n      const int num = findFirstNumber(nums, 0, 1);\n      if (num != -1 && !checkBoundaryGaps(num, m, x, y))\n        return false;\n    }\n\n    // Check trailing gaps.\n    if (nums.back() == -1) {\n      const int num = findFirstNumber(nums, nums.size() - 1, -1);\n      if (num != -1 && !checkBoundaryGaps(num, m, x, y))\n        return false;\n    }\n\n    return true;\n  }\n\n  // Returns true if it's possible to have at most `m` as the minimized maximum\n  // difference for a sequence with a single -1 between two numbers.\n  // e.g. [a, -1, b] can be filled with either x or y.\n  bool checkSingleGap(int a, int b, int m, int x, int y) {\n    const int gapWithX = max(abs(a - x), abs(b - x));  // [a, x, b]\n    const int gapWithY = max(abs(a - y), abs(b - y));  // [a, y, b]\n    return min(gapWithX, gapWithY) <= m;\n  }\n\n  // Returns true if it's possible to have at most `m` as the minimized maximum\n  // difference for a sequence with multiple -1s between two numbers.\n  // e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.\n  bool checkMultipleGaps(int a, int b, int m, int x, int y) {\n    const int ax = abs(a - x);\n    const int ay = abs(a - y);\n    const int bx = abs(b - x);\n    const int by = abs(b - y);\n    const int xy = abs(x - y);\n    const int gapAllX = max(ax, bx);        // [a, x, x, ..., x, b]\n    const int gapAllY = max(ay, by);        // [a, y, y, ..., y, b]\n    const int gapXToY = max({ax, xy, by});  // [a, x, ..., y, b]\n    const int gapYToX = max({ay, xy, bx});  // [a, y, ..., x, b]\n    return min({gapAllX, gapAllY, gapXToY, gapYToX}) <= m;\n  }\n\n  // Returns true if it's possible to have at most `m` as the minimized maximum\n  // difference for a boundary sequence starting or ending with -1s.\n  // e.g. [a, -1, -1, ...] or [..., -1, -1, a].\n  bool checkBoundaryGaps(int a, int m, int x, int y) {\n    const int gapAllX = abs(a - x);  // [x, x, ..., x, a]\n    const int gapAllY = abs(a - y);  // [y, y, ..., y, a]\n    return min(gapAllX, gapAllY) <= m;\n  }\n\n  // Returns the first positive number starting from the given index or -1\n  // if not found.\n  int findFirstNumber(const vector<int>& nums, int start, int step) {\n    int i = start;\n    while (i >= 0 && i < nums.size() && nums[i] == -1)\n      i += step;\n    return i >= 0 && i < nums.size() ? nums[i] : -1;\n  }\n};\n", "3359": "\nstruct T {\n  int subarrayWidth;\n  int rowIndex;\n  int accumulatedSubmatrices;\n};\n\nclass Solution {\n public:\n  long long countSubmatrices(vector<vector<int>>& grid, int k) {\n    int m = grid.size();\n    int n = grid[0].size();\n    long ans = 0;\n    // dp[i][j] := the number of valid subarrays ending in grid[i][j]\n    vector<vector<int>> dp(m, vector<int>(n));\n    // stacks[j] := the stack of valid\n    // (subarray width, row index, number of accumulated submatrices) ending in\n    // column j\n    vector<stack<T>> stacks(n);\n\n    for (int j = 0; j < n; ++j)\n      stacks[j].emplace(0, -1, 0);\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] > k) {\n          stacks[j] = stack<T>();\n          stacks[j].emplace(0, i, 0);\n        } else {\n          dp[i][j] = 1;\n          if (j > 0 && grid[i][j - 1] <= k && grid[i][j - 1] >= grid[i][j])\n            // Extend the valid subarrays to the current number.\n            dp[i][j] += dp[i][j - 1];\n          const int width = dp[i][j];\n          stack<T>& stack = stacks[j];\n          // Remove subarray widths greater than the current width since they\n          // will become invalid.\n          while (!stack.empty() && width < stack.top().subarrayWidth)\n            stack.pop();\n          const int height = i - stack.top().rowIndex;\n          const int newSubmatrices = width * height;\n          const int accumulatedSubmatrices =\n              stack.top().accumulatedSubmatrices + newSubmatrices;\n          ans += accumulatedSubmatrices;\n          stack.emplace(width, i, accumulatedSubmatrices);\n        }\n\n    return ans;\n  }\n};\n", "336": "class Solution {\n public:\n  vector<vector<int>> palindromePairs(vector<string>& words) {\n    vector<vector<int>> ans;\n    unordered_map<string, int> map;  // {reversed word: its index}\n\n    for (int i = 0; i < words.size(); ++i) {\n      string word = words[i];\n      ranges::reverse(word);\n      map[word] = i;\n    }\n\n    for (int i = 0; i < words.size(); ++i) {\n      const string& word = words[i];\n      // a special case to prevent duplicate calculation\n      if (const auto it = map.find(\"\");\n          it != map.cend() && it->second != i && isPalindrome(word))\n        ans.push_back({i, it->second});\n      for (int j = 1; j <= word.length(); ++j) {\n        const string& l = word.substr(0, j);\n        const string& r = word.substr(j);\n        if (const auto it = map.find(l);\n            it != map.cend() && it->second != i && isPalindrome(r))\n          ans.push_back({i, it->second});\n        if (const auto it = map.find(r);\n            it != map.cend() && it->second != i && isPalindrome(l))\n          ans.push_back({it->second, i});\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  bool isPalindrome(const string& word) {\n    int l = 0;\n    int r = word.length() - 1;\n    while (l < r)\n      if (word[l++] != word[r--])\n        return false;\n    return true;\n  }\n};\n", "3360": "class Solution {\n public:\n  bool canAliceWin(int n) {\n    for (int stones = 10; stones >= 0; --stones) {\n      if (stones > n)\n        return stones % 2 == 1;\n      n -= stones;\n    }\n    throw;\n  }\n};\n", "3361": "class Solution {\n public:\n  long long shiftDistance(string s, string t, vector<int>& nextCost,\n                          vector<int>& previousCost) {\n    long ans = 0;\n    // prev[i][j] := the prev cost to shift from ('a' + i) to ('a' + j)\n    vector<vector<long>> prev(26, vector<long>(26));\n    // next[i][j] := the next cost to shift from ('a' + i) to ('a' + j)\n    vector<vector<long>> next(26, vector<long>(26));\n\n    for (int i = 0; i < 26; ++i) {\n      long cost = 0;\n      for (int j = 0; j < 26; ++j) {\n        next[i][(i + j) % 26] = cost;\n        cost += nextCost[(i + j) % 26];\n      }\n    }\n\n    for (int i = 0; i < 26; ++i) {\n      long cost = 0;\n      for (int j = 0; j < 26; ++j) {\n        prev[i][(i - j + 26) % 26] = cost;\n        cost += previousCost[(i - j + 26) % 26];\n      }\n    }\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int a = s[i] - 'a';\n      const int b = t[i] - 'a';\n      ans += min(next[a][b], prev[a][b]);\n    }\n\n    return ans;\n  }\n};\n", "3362": "class Solution {\n public:\n  int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {\n    int queryIndex = 0;\n    priority_queue<int> available;                        // available `r`s\n    priority_queue<int, vector<int>, greater<>> running;  // running `r`s\n\n    ranges::sort(queries);\n\n    for (int i = 0; i < nums.size(); ++i) {\n      while (queryIndex < queries.size() && queries[queryIndex][0] <= i)\n        available.push(queries[queryIndex++][1]);\n      while (!running.empty() && running.top() < i)\n        running.pop();\n      while (nums[i] > running.size()) {\n        if (available.empty() || available.top() < i)\n          return -1;\n        running.push(available.top()), available.pop();\n      }\n    }\n\n    return available.size();\n  }\n};\n", "3363": "class Solution {\n public:\n  int maxCollectedFruits(vector<vector<int>>& fruits) {\n    return getTopLeft(fruits) + getTopRight(fruits) + getBottomLeft(fruits) -\n           2 * fruits.back().back();\n  }\n\n private:\n  int getTopLeft(const vector<vector<int>>& fruits) {\n    const int n = fruits.size();\n    int res = 0;\n    for (int i = 0; i < n; ++i)\n      res += fruits[i][i];\n    return res;\n  }\n\n  int getTopRight(const vector<vector<int>>& fruits) {\n    const int n = fruits.size();\n    // dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)\n    vector<vector<int>> dp(n, vector<int>(n));\n    dp[0][n - 1] = fruits[0][n - 1];\n    for (int x = 0; x < n; ++x) {\n      for (int y = 0; y < n; ++y) {\n        if (x >= y && !(x == n - 1 && y == n - 1))\n          continue;\n        for (const auto& [dx, dy] :\n             vector<pair<int, int>>{{1, -1}, {1, 0}, {1, 1}}) {\n          const int i = x - dx;\n          const int j = y - dy;\n          if (i < 0 || i == n || j < 0 || j == n)\n            continue;\n          if (i < j && j < n - 1 - i)\n            continue;\n          dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y]);\n        }\n      }\n    }\n\n    return dp[n - 1][n - 1];\n  }\n\n  int getBottomLeft(const vector<vector<int>>& fruits) {\n    const int n = fruits.size();\n    // dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)\n    vector<vector<int>> dp(n, vector<int>(n));\n    dp[n - 1][0] = fruits[n - 1][0];\n    for (int y = 0; y < n; ++y) {\n      for (int x = 0; x < n; ++x) {\n        if (x <= y && !(x == n - 1 && y == n - 1))\n          continue;\n        for (const auto& [dx, dy] :\n             vector<pair<int, int>>{{-1, 1}, {0, 1}, {1, 1}}) {\n          const int i = x - dx;\n          const int j = y - dy;\n          if (i < 0 || i == n || j < 0 || j == n)\n            continue;\n          if (j < i && i < n - 1 - j)\n            continue;\n          dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y]);\n        }\n      }\n    }\n    return dp[n - 1][n - 1];\n  }\n};\n", "3364": "class Solution {\n public:\n  int minimumSumSubarray(vector<int>& nums, int l, int r) {\n    int ans = INT_MAX;\n\n    for (int windowSize = l; windowSize <= r; ++windowSize) {\n      int sum = accumulate(nums.begin(), nums.begin() + windowSize, 0);\n      if (sum > 0)\n        ans = min(ans, sum);\n      for (int i = windowSize; i < nums.size(); ++i) {\n        sum -= nums[i - windowSize];\n        sum += nums[i];\n        if (sum > 0)\n          ans = min(ans, sum);\n      }\n    }\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "3365": "class Solution {\n public:\n  bool isPossibleToRearrange(string s, string t, int k) {\n    const int n = s.length();\n    return getCount(s, n / k) == getCount(t, n / k);\n  }\n\n private:\n  unordered_map<string, int> getCount(const string& s, int sz) {\n    unordered_map<string, int> count;\n    for (int i = 0; i < s.length(); i += sz)\n      ++count[s.substr(i, sz)];\n    return count;\n  };\n};\n", "3366": "class Solution {\n public:\n  int minArraySum(vector<int>& nums, int k, int op1, int op2) {\n    const int n = nums.size();\n    // dp[i][j][k] := the minimum sum of nums[i..n - 1] with j operations of op1\n    // and k operations of op2\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(op1 + 1, vector<int>(op2 + 1, INT_MAX)));\n\n    // Base case: When index reaches the end of the array, the result is 0.\n    for (int i = 0; i <= op1; ++i)\n      for (int j = 0; j <= op2; ++j)\n        dp[n][i][j] = 0;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int o1 = 0; o1 <= op1; ++o1)\n        for (int o2 = 0; o2 <= op2; ++o2) {\n          int sum = nums[i] + dp[i + 1][o1][o2];\n          if (o1 > 0)\n            sum = min(sum, (nums[i] + 1) / 2 + dp[i + 1][o1 - 1][o2]);\n          if (o2 > 0 && nums[i] >= k)\n            sum = min(sum, nums[i] - k + dp[i + 1][o1][o2 - 1]);\n          if (o1 > 0 && o2 > 0) {\n            if ((nums[i] + 1) / 2 >= k)\n              sum = min(sum, (nums[i] + 1) / 2 - k + dp[i + 1][o1 - 1][o2 - 1]);\n            if (nums[i] >= k)\n              sum = min(sum, (nums[i] - k + 1) / 2 + dp[i + 1][o1 - 1][o2 - 1]);\n          }\n          dp[i][o1][o2] = sum;\n        }\n\n    return dp[0][op1][op2];\n  }\n};\n", "3367": "class Solution {\n public:\n  long long maximizeSumOfWeights(vector<vector<int>>& edges, int k) {\n    const int n = edges.size() + 1;\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    return dfs(graph, 0, -1, k).second;\n  }\n\n  // Returns\n  // (the weight sum of the subtree rooted at u with at most k - 1 children,\n  //  the weight sum of the subtree rooted at u with at most k children).\n  pair<long, long> dfs(const vector<vector<pair<int, int>>>& graph, int u,\n                       int prev, int k) {\n    long weightSum = 0;\n    priority_queue<long> diffs;\n\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      const auto [subK1, subK] = dfs(graph, v, u, k);\n      weightSum += subK;\n      // If picking (u, v) makes the sum larger, we should pick it.\n      diffs.push(max(0L, subK1 - subK + w));\n    }\n\n    long topK1 = 0;\n    long topK = 0;\n\n    for (int i = 0; i < k && !diffs.empty(); ++i) {\n      if (i < k - 1)\n        topK1 += diffs.top();\n      topK += diffs.top();\n      diffs.pop();\n    }\n\n    return {weightSum + topK1, weightSum + topK};\n  };\n};\n", "3369": "class StatisticsTracker {\n public:\n  void addNumber(int number) {\n    q.push(number);\n    ++count[number];\n    sortedList.insert(number);\n    modeMaxHeap.emplace(count[number], -number);\n    sum += number;\n  }\n\n  void removeFirstAddedNumber() {\n    const int number = q.front();\n    q.pop();\n    if (--count[number])\n      count.erase(number);\n    sortedList.erase(sortedList.find(number));\n    // Note: No need to update the heap now; we'll clean up stale entries when\n    // getting the mode.\n    sum -= number;\n  }\n\n  int getMean() {\n    return sum / q.size();\n  }\n\n  int getMedian() {\n    auto it = sortedList.begin();\n    advance(it, sortedList.size() / 2);\n    return *it;\n  }\n\n  int getMode() {\n    // Removes stale entries from the top of the heap.\n    while (!modeMaxHeap.empty()) {\n      const int frequency = modeMaxHeap.top().first;\n      const int number = -modeMaxHeap.top().second;\n      if (count.contains(number) && count[number] == frequency)\n        return number;\n      modeMaxHeap.pop();\n    }\n    throw;\n  }\n\n private:\n  queue<int> q;\n  unordered_map<int, int> count;\n  multiset<int> sortedList;\n  priority_queue<pair<int, int>> modeMaxHeap;  // (frequency, number)\n  long sum = 0;\n};\n", "337": "struct T {\n  int robRoot;\n  int notRobRoot;\n};\n\nclass Solution {\n public:\n  int rob(TreeNode* root) {\n    const auto& [robRoot, notRobRoot] = robOrNotRob(root);\n    return max(robRoot, notRobRoot);\n  }\n\n private:\n  T robOrNotRob(TreeNode* root) {\n    if (root == nullptr)\n      return {0, 0};\n    const T l = robOrNotRob(root->left);\n    const T r = robOrNotRob(root->right);\n    return {root->val + l.notRobRoot + r.notRobRoot,\n            max(l.robRoot, l.notRobRoot) + max(r.robRoot, r.notRobRoot)};\n  }\n};\n", "3370": "class Solution {\n public:\n  int smallestNumber(int n) {\n    return (1 << bitLength(n)) - 1;\n  }\n\n private:\n  int bitLength(int n) {\n    return 32 - __builtin_clz(n);\n  }\n};\n", "3371": "class Solution {\n public:\n  int getLargestOutlier(vector<int>& nums) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    int ans = INT_MIN;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const int num : nums) {\n      const int withoutNum = sum - num;\n      if (withoutNum % 2 == 0) {\n        const int specialSum = withoutNum / 2;  // the sum of special numbers\n        if (count[specialSum] > (num == specialSum ? 1 : 0))\n          ans = max(ans, num);\n      }\n    }\n\n    return ans;\n  }\n};\n", "3372": "class Solution {\n public:\n  vector<int> maxTargetNodes(vector<vector<int>>& edges1,\n                             vector<vector<int>>& edges2, int k) {\n    vector<int> ans;\n    const vector<vector<int>> graph1 = buildGraph(edges1);\n    const vector<vector<int>> graph2 = buildGraph(edges2);\n    int maxReachableInGraph2 = 0;\n\n    if (k > 0)\n      for (int i = 0; i < edges2.size() + 1; ++i)\n        maxReachableInGraph2 =\n            max(maxReachableInGraph2, dfs(graph2, i, -1, k - 1));\n\n    for (int i = 0; i < edges1.size() + 1; ++i)\n      ans.push_back(maxReachableInGraph2 + dfs(graph1, i, -1, k));\n\n    return ans;\n  }\n\n private:\n  // Returns the number of nodes that can be reached from u with k steps.\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int k) {\n    if (k == 0)\n      return 1;\n    int res = 0;\n    for (const int v : graph[u])\n      if (v != prev)\n        res += dfs(graph, v, u, k - 1);\n    return 1 + res;\n  }\n\n  vector<vector<int>> buildGraph(const vector<vector<int>>& edges) {\n    vector<vector<int>> graph(edges.size() + 1);\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n    return graph;\n  }\n};\n", "3373": "class Solution {\n public:\n  vector<int> maxTargetNodes(vector<vector<int>>& edges1,\n                             vector<vector<int>>& edges2) {\n    const int n = edges1.size() + 1;\n    const int m = edges2.size() + 1;\n    vector<int> ans;\n    const vector<vector<int>> graph1 = buildGraph(edges1);\n    const vector<vector<int>> graph2 = buildGraph(edges2);\n    vector<bool> parity1(n);\n    vector<bool> parity2(m);  // placeholder (parity2 is not used)\n    const int even1 = dfs(graph1, 0, -1, parity1, /*isEven=*/true);\n    const int even2 = dfs(graph2, 0, -1, parity2, /*isEven=*/true);\n    const int odd1 = n - even1;\n    const int odd2 = m - even2;\n\n    for (int i = 0; i < n; ++i) {\n      const int tree1 = parity1[i] ? even1 : odd1;\n      // Can connect the current node in tree1 to either an even node or an odd\n      // node in tree2.\n      const int tree2 = max(even2, odd2);\n      ans.push_back(tree1 + tree2);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the number of nodes that can be reached from u with even steps.\n  int dfs(const vector<vector<int>>& graph, int u, int prev,\n          vector<bool>& parity, bool isEven) {\n    int res = isEven ? 1 : 0;\n    parity[u] = isEven;\n    for (const int v : graph[u])\n      if (v != prev)\n        res += dfs(graph, v, u, parity, !isEven);\n    return res;\n  }\n\n  vector<vector<int>> buildGraph(const vector<vector<int>>& edges) {\n    vector<vector<int>> graph(edges.size() + 1);\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n    return graph;\n  }\n};\n", "3375": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int k) {\n    const unordered_set<int> numsSet{nums.begin(), nums.end()};\n    const int mn = ranges::min(nums);\n    if (mn < k)\n      return -1;\n    if (mn > k)\n      return numsSet.size();\n    return numsSet.size() - 1;\n  }\n};\n", "3376": "class Solution {\n public:\n  int findMinimumTime(vector<int>& strength, int K) {\n    return find(strength, /*x=*/1, 0, K);\n  }\n\n private:\n  int find(const vector<int>& strength, int x, int mask, int k) {\n    if (mask == (1 << strength.size()) - 1)\n      return 0;\n    int res = INT_MAX;\n    for (int i = 0; i < strength.size(); ++i)\n      if ((mask >> i & 1) == 0) {\n        const int time = (strength[i] - 1) / x + 1;  // ceil(strength[i] / x)\n        res = min(res, time + find(strength, x + k, mask | 1 << i, k));\n      }\n    return res;\n  }\n};\n", "3377": "class Solution {\n public:\n  int minOperations(int n, int m) {\n    constexpr int kMax = 10000;\n    const vector<bool> isPrime = sieveEratosthenes(kMax);\n    if (isPrime[n] || isPrime[m])\n      return -1;\n    return dijkstra(n, m, isPrime);\n  }\n\n private:\n  int dijkstra(int src, int dst, const vector<bool>& isPrime) {\n    unordered_set<int> seen{src};\n    using P = tuple<int, int>;  // (cost, num)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(src, src);\n\n    while (!minHeap.empty()) {\n      const auto [cost, curr] = minHeap.top();\n      minHeap.pop();\n      if (curr == dst)\n        return cost;\n      string s = to_string(curr);\n      for (int i = 0; i < s.length(); ++i) {\n        if (s[i] < '9') {\n          ++s[i];\n          const int next = stoi(s);\n          if (!isPrime[next] && !seen.contains(next)) {\n            minHeap.emplace(cost + next, next);\n            seen.insert(next);\n          }\n          --s[i];\n        }\n        if (s[i] > '0' && !(i == 0 && s[i] == '1')) {\n          --s[i];\n          const int next = stoi(s);\n          if (!isPrime[next] && !seen.contains(next)) {\n            minHeap.emplace(cost + next, next);\n            seen.insert(next);\n          }\n          ++s[i];\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  vector<bool> sieveEratosthenes(int n) {\n    vector<bool> isPrime(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i)\n      if (isPrime[i])\n        for (int j = i * i; j < n; j += i)\n          isPrime[j] = false;\n    return isPrime;\n  }\n};\n", "3378": "class UnionFind {\n public:\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    if (!id.contains(u))\n      id[u] = u;\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  unordered_map<int, int> id;\n  unordered_map<int, int> rank;\n};\n\nclass Solution {\n public:\n  int countComponents(vector<int>& nums, int threshold) {\n    UnionFind uf;\n\n    for (const int num : nums)\n      for (int multiple = 2 * num; multiple <= threshold; multiple += num)\n        uf.unionByRank(num, multiple);\n\n    unordered_set<int> components;\n    for (const int num : nums)\n      components.insert(uf.find(num));\n    return components.size();\n  }\n};\n", "3379": "class Solution {\n public:\n  vector<int> constructTransformedArray(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans;\n\n    for (int i = 0; i < n; ++i)\n      ans.push_back(nums[(i + nums[i] % n + n) % n]);\n\n    return ans;\n  }\n};\n", "338": "class Solution {\n public:\n  vector<int> countBits(int n) {\n    // f(i) := i's number of 1s in bitmask\n    // f(i) = f(i / 2) + i % 2\n    vector<int> ans(n + 1);\n\n    for (int i = 1; i <= n; ++i)\n      ans[i] = ans[i / 2] + (i & 1);\n\n    return ans;\n  }\n};\n", "3380": "class SegmentTree {\n public:\n  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns min(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int kInf;    // the invalid value\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return kInf;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return max(left, right);\n  }\n};\n\nclass Solution {\n public:\n  int maxRectangleArea(vector<vector<int>>& points) {\n    int ans = -1;\n    ranges::sort(points);\n    const vector<int> ys = getUniqueAndSortedYs(points);\n    SegmentTree tree(ys.size(), /*kInf=*/-1);\n    unordered_map<int, int> yToIndex;\n    unordered_map<int, int> yToX;\n\n    for (int i = 0; i < ys.size(); ++i)\n      yToIndex[ys[i]] = i;\n\n    int prevX = points[0][0];\n    int prevY = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i) {\n      const int x = points[i][0];\n      const int y = points[i][1];\n      if (yToX.contains(prevY) && yToX.contains(y)) {\n        const int xLeft = yToX[y];\n        if (prevX == x && yToX[prevY] == xLeft &&\n            xLeft > tree.query(yToIndex[prevY] + 1, yToIndex[y] - 1))\n          ans = max(ans, (y - prevY) * (x - xLeft));\n      }\n      yToX[prevY] = prevX;\n      tree.update(yToIndex[prevY], prevX);\n      prevX = x;\n      prevY = y;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getUniqueAndSortedYs(const vector<vector<int>>& points) {\n    vector<int> ys;\n    for (const vector<int>& point : points)\n      ys.push_back(point[1]);\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    return ys;\n  }\n};\n", "3381": "class Solution {\n public:\n  long long maxSubarraySum(std::vector<int>& nums, int k) {\n    long ans = LONG_MIN;\n    long prefix = 0;\n    // minPrefix[i % k] := the minimum prefix sum of the first i numbers\n    vector<long> minPrefix(k, LONG_MAX / 2);\n    minPrefix[k - 1] = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      ans = max(ans, prefix - minPrefix[i % k]);\n      minPrefix[i % k] = min(minPrefix[i % k], prefix);\n    }\n\n    return ans;\n  }\n};\n", "3382": "class SegmentTree {\n public:\n  explicit SegmentTree(int n, int kInf) : kInf(kInf), n(n), tree(4 * n, kInf) {}\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns min(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int kInf;    // the invalid value\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return kInf;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return max(left, right);\n  }\n};\n\nclass Solution {\n public:\n  // Same as 3380. Maximum Area Rectangle With Point Constraints I\n  long long maxRectangleArea(vector<int>& xCoord, vector<int>& yCoord) {\n    long ans = -1;\n    const vector<pair<int, int>> points = getSortedPoints(xCoord, yCoord);\n    const vector<int> ys = getUniqueAndSortedYs(yCoord);\n    SegmentTree tree(ys.size(), /*kInf=*/-1);\n    unordered_map<int, int> yToIndex;\n    unordered_map<int, int> yToX;\n\n    for (int i = 0; i < ys.size(); ++i)\n      yToIndex[ys[i]] = i;\n\n    auto [prevX, prevY] = points[0];\n    for (int i = 1; i < points.size(); ++i) {\n      const auto [x, y] = points[i];\n      if (yToX.contains(prevY) && yToX.contains(y)) {\n        const int xLeft = yToX[y];\n        if (prevX == x && yToX[prevY] == xLeft &&\n            xLeft > tree.query(yToIndex[prevY] + 1, yToIndex[y] - 1))\n          ans = max(ans, static_cast<long>(y - prevY) * (x - xLeft));\n      }\n      yToX[prevY] = prevX;\n      tree.update(yToIndex[prevY], prevX);\n      prevX = x;\n      prevY = y;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getSortedPoints(const vector<int>& xCoord,\n                                         const vector<int>& yCoord) {\n    vector<pair<int, int>> points;\n    for (int i = 0; i < xCoord.size(); ++i)\n      points.emplace_back(xCoord[i], yCoord[i]);\n    ranges::sort(points);\n    return points;\n  }\n\n  vector<int> getUniqueAndSortedYs(const vector<int>& yCoord) {\n    vector<int> ys = yCoord;\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    return ys;\n  }\n};\n", "3383": "class Solution {\n public:\n  int minRunesToAdd(int n, vector<int>& crystals, vector<int>& flowFrom,\n                    vector<int>& flowTo) {\n    vector<vector<int>> graph(n);\n    vector<vector<int>> reversedGraph(n);\n\n    for (int i = 0; i < flowFrom.size(); ++i) {\n      const int u = flowFrom[i];\n      const int v = flowTo[i];\n      graph[u].push_back(v);\n      reversedGraph[v].push_back(u);\n    }\n\n    // Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm\n    vector<bool> seen(n);\n    vector<int> orderStack;\n    vector<int> componentIds(n, -1);\n    int componentCount = 0;\n\n    for (int i = 0; i < n; ++i)\n      if (!seen[i])\n        kosaraju(graph, i, seen, orderStack);\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int u = orderStack[i];\n      if (componentIds[u] == -1)\n        identifySCC(reversedGraph, u, componentIds, componentCount++);\n    }\n\n    // Track crystal-containing components and inter-component edges.\n    vector<bool> hasCrystal(componentCount);\n    vector<bool> hasInterComponentEdge(componentCount);\n\n    for (const int u : crystals)\n      hasCrystal[componentIds[u]] = true;\n\n    for (int i = 0; i < flowFrom.size(); ++i) {\n      const int id1 = componentIds[flowFrom[i]];\n      const int id2 = componentIds[flowTo[i]];\n      if (id1 != id2)  // Edge is inter-component.\n        hasInterComponentEdge[id2] = true;\n    }\n\n    // Count components requiring additional runes.\n    int ans = 0;\n\n    for (int i = 0; i < componentCount; ++i)\n      if (!hasCrystal[i] && !hasInterComponentEdge[i])\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  // Creates a topological order stack using Kosaraju's Algorithm.\n  void kosaraju(const vector<vector<int>>& graph, int u, vector<bool>& seen,\n                vector<int>& orderStack) {\n    seen[u] = true;\n    for (const int v : graph[u])\n      if (!seen[v])\n        kosaraju(graph, v, seen, orderStack);\n    orderStack.push_back(u);\n  }\n\n  // Assigns component IDs during SCC identification in the second DFS.\n  void identifySCC(const vector<vector<int>>& reversedGraph, int u,\n                   vector<int>& componentIds, int componentId) {\n    if (componentIds[u] != -1)\n      return;\n    componentIds[u] = componentId;\n    for (const int v : reversedGraph[u])\n      if (componentIds[v] < 0)\n        identifySCC(reversedGraph, v, componentIds, componentId);\n  }\n};\n", "3385": "class Solution {\n public:\n  int findMinimumTime(vector<int>& strength) {\n    vector<vector<int>> costs;\n\n    for (int turn = 1; turn <= strength.size(); ++turn) {\n      vector<int> cost;\n      for (const int s : strength)\n        cost.push_back((s + turn - 1) / turn);\n      costs.push_back(cost);\n    }\n\n    return hungarian(costs).back();\n  }\n\n private:\n  // Updates the currentMinimum if potentialMinimum is smaller and returns true.\n  bool updateMinimum(int& currentMinimum, const int& potentialMinimum) {\n    if (potentialMinimum < currentMinimum) {\n      currentMinimum = potentialMinimum;\n      return true;\n    }\n    return false;\n  }\n\n  // Returns an array `res` of length n (costs.length), with `res[i]` equaling\n  // the minimum cost to assign the first (i + 1) turns to the first (i + 1)\n  // locks using Hungarian algorithm, where costs[i][j] is the energy required\n  // to break j-th lock in i-th turn.\n  //\n  // https://en.wikipedia.org/wiki/Hungarian_algorithm\n  vector<int> hungarian(const vector<vector<int>>& costs) {\n    const int numLocks = costs.size();\n    vector<int> res;\n    vector<int> lockAssignments(numLocks + 1, -1);\n    vector<int> turnPotentials(numLocks);\n    vector<int> lockPotentials(numLocks + 1);\n\n    for (int currentTurn = 0; currentTurn < numLocks; ++currentTurn) {\n      int currentLock = numLocks;\n      lockAssignments[currentLock] = currentTurn;\n      vector<int> minReducedCosts(numLocks + 1, INT_MAX);\n      vector<int> previousLockAssignments(numLocks + 1, -1);\n      vector<bool> locksInOptimalPath(numLocks + 1);\n\n      while (lockAssignments[currentLock] != -1) {\n        locksInOptimalPath[currentLock] = true;\n        const int assignedTurn = lockAssignments[currentLock];\n        int minCostDelta = INT_MAX;\n        int nextLock;\n\n        for (int lock = 0; lock < numLocks; ++lock)\n          if (!locksInOptimalPath[lock]) {\n            const int reducedCost = costs[assignedTurn][lock] -\n                                    turnPotentials[assignedTurn] -\n                                    lockPotentials[lock];\n            if (updateMinimum(minReducedCosts[lock], reducedCost))\n              previousLockAssignments[lock] = currentLock;\n            if (updateMinimum(minCostDelta, minReducedCosts[lock]))\n              nextLock = lock;\n          }\n\n        for (int lock = 0; lock <= numLocks; ++lock)\n          if (locksInOptimalPath[lock]) {\n            turnPotentials[lockAssignments[lock]] += minCostDelta;\n            lockPotentials[lock] -= minCostDelta;\n          } else {\n            minReducedCosts[lock] -= minCostDelta;\n          }\n\n        currentLock = nextLock;\n      }\n\n      for (int lock; currentLock != numLocks; currentLock = lock)\n        lockAssignments[currentLock] =\n            lockAssignments[lock = previousLockAssignments[currentLock]];\n\n      res.push_back(-lockPotentials[numLocks]);\n    }\n\n    return res;\n  }\n};\n", "3386": "class Solution {\n public:\n  int buttonWithLongestTime(vector<vector<int>>& events) {\n    int ans = 0;\n    int maxTimeTaken = 0;\n    int prevTime = 0;\n\n    for (const vector<int>& event : events) {\n      const int index = event[0];\n      const int time = event[1];\n      const int timeTaken = time - prevTime;\n      if (timeTaken > maxTimeTaken ||\n          timeTaken == maxTimeTaken && index < ans) {\n        maxTimeTaken = timeTaken;\n        ans = index;\n      }\n      prevTime = time;\n    }\n\n    return ans;\n  }\n};\n", "3387": "class Solution {\n public:\n  double maxAmount(string initialCurrency, vector<vector<string>>& pairs1,\n                   vector<double>& rates1, vector<vector<string>>& pairs2,\n                   vector<double>& rates2) {\n    // dp[currency] := the maximum amount of money to convert to `currency`\n    unordered_map<string, double> dp{{initialCurrency, 1}};\n    bellman(dp, pairs1, rates1);\n    bellman(dp, pairs2, rates2);\n    return dp[initialCurrency];\n  }\n\n private:\n  void bellman(unordered_map<string, double>& dp,\n               const vector<vector<string>>& pairs,\n               const vector<double>& rates) {\n    for (int relax = 0; relax < pairs.size(); ++relax)\n      for (int i = 0; i < pairs.size(); ++i) {\n        const string start = pairs[i][0];\n        const string target = pairs[i][1];\n        dp[target] = max(dp[target], dp[start] * rates[i]);\n        dp[start] = max(dp[start], dp[target] / rates[i]);\n      }\n  }\n};\n", "3388": "class Solution {\n public:\n  int beautifulSplits(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // z[start][i] := the z array of nums[i..n) with respect to nums[start..n)\n    vector<vector<int>> z;\n\n    for (int start = 0; start < n; ++start)\n      z.push_back(zFunction(nums, start));\n\n    // nums1 | nums2 | nums3 = nums[0..i] | nums[i + 1..j] | nums[j + 1..n - 1]\n    for (int i = 0; i < n - 2; ++i)\n      for (int j = i + 1; j < n - 1; ++j)\n        if ((j - i >= i + 1 &&\n             z[0][i + 1] >= i + 1) ||  // nums1 is a prefix of nums2.\n            z[i + 1][j + 1] >= j - i)  // nums2 is a suffix of nums3.\n          ++ans;\n\n    return ans;\n  }\n\n private:\n  // Returns the z array, where z[i] is the length of the longest prefix of\n  // nums[i..n) which is also a prefix of nums[start..n).\n  vector<int> zFunction(const vector<int>& nums, int start) {\n    const int n = nums.size();\n    vector<int> z(n);\n    int l = 0;\n    int r = 0;\n    for (int i = 1 + start; i < n; ++i) {\n      if (i < r)\n        z[i] = min(r - i, z[i - l + start]);\n      while (i + z[i] < n && nums[z[i] + start] == nums[i + z[i]])\n        ++z[i];\n      if (i + z[i] > r) {\n        l = i;\n        r = i + z[i];\n      }\n    }\n    return z;\n  }\n};\n", "3389": "class Solution {\n public:\n  int makeStringGood(string s) {\n    int ans = s.length();\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    const int mx = ranges::max(count);\n    for (int target = 1; target <= mx; ++target)\n      ans = min(ans, getMinOperations(count, target));\n\n    return ans;\n  }\n\n private:\n  int getMinOperations(const vector<int>& count, int target) {\n    // dp[i] := the minimum number of operations to make the frequency of\n    // (i..25)-th (0-indexed) letters equal to `target`.\n    vector<int> dp(27);\n\n    for (int i = 25; i >= 0; --i) {\n      // 1. Delete all the i-th letters.\n      const int deleteAllToZero = count[i];\n      // 2. Insert/delete the i-th letters to have `target` number of letters.\n      const int deleteOrInsertToTarget = abs(target - count[i]);\n      dp[i] = min(deleteAllToZero, deleteOrInsertToTarget) + dp[i + 1];\n      if (i + 1 < 26 && count[i + 1] < target) {\n        const int nextDeficit = target - count[i + 1];\n        // Make the frequency of the i-th letter equal to the `target` or 0.\n        const int needToChange =\n            count[i] > target ? count[i] - target : count[i];\n        const int changeToTarget =\n            nextDeficit > needToChange\n                // 3. Change all the i-th letters to the next letter and then\n                // insert the remaining deficit for the next letter.\n                ? needToChange + (nextDeficit - needToChange)\n                // 4. Change `nextDeficit` i-th letters to the next letter and\n                // then delete the remaining i-th letters.\n                : nextDeficit + (needToChange - nextDeficit);\n        dp[i] = min(dp[i], changeToTarget + dp[i + 2]);\n      }\n    }\n\n    return dp[0];\n  }\n};\n", "339": "class Solution {\n public:\n  int depthSum(vector<NestedInteger>& nestedList) {\n    int ans = 0;\n    dfs(nestedList, 1, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<NestedInteger>& nestedList, int depth, int& ans) {\n    for (const NestedInteger& ni : nestedList)\n      if (ni.isInteger())\n        ans += ni.getInteger() * depth;\n      else\n        dfs(ni.getList(), depth + 1, ans);\n  }\n};\n", "3391": "class Matrix3D {\n public:\n  Matrix3D(int n) {\n    isSet = vector<vector<vector<bool>>>(\n        n, vector<vector<bool>>(n, vector<bool>(n)));\n    count = vector<int>(n);\n    for (int x = 0; x < n; ++x)\n      pairs.insert({0, x});\n  }\n\n  void setCell(int x, int y, int z) {\n    if (isSet[x][y][z])\n      return;\n    isSet[x][y][z] = true;\n    pairs.erase({count[x], x});\n    pairs.insert({++count[x], x});\n  }\n\n  void unsetCell(int x, int y, int z) {\n    if (!isSet[x][y][z])\n      return;\n    isSet[x][y][z] = false;\n    pairs.erase({count[x], x});\n    pairs.insert({--count[x], x});\n  }\n\n  int largestMatrix() {\n    return pairs.rbegin()->second;\n  }\n\n private:\n  vector<vector<vector<bool>>> isSet;\n  vector<int> count;  // count[x] := the number of cells set in the x-th layer\n\n  struct PairCompare {\n    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {\n      return a.first == b.first ? b.second > a.second : b.first > a.first;\n    }\n  };\n\n  set<pair<int, int>, PairCompare> pairs;  // (count[x], x)\n};\n", "3392": "class Solution {\n public:\n  int countSubarrays(vector<int>& nums) {\n    int ans = 0;\n\n    for (int i = 1; i + 1 < nums.size(); ++i)\n      if (nums[i] == (nums[i - 1] + nums[i + 1]) * 2)\n        ++ans;\n\n    return ans;\n  }\n};\n", "3393": "class Solution {\n public:\n  int countPathsWithXorValue(vector<vector<int>>& grid, int k) {\n    constexpr int kMod = 1'000'000'007;\n    constexpr int kMax = 15;\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // dp[i][j][xors] := the number of paths from (i, j) to (m - 1, n - 1) with\n    // XOR value `xors`\n    vector<vector<vector<int>>> dp(\n        m, vector<vector<int>>(n, vector<int>(kMax + 1)));\n\n    dp[m - 1][n - 1][grid[m - 1][n - 1]] = 1;\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j)\n        for (int xors = 0; xors <= kMax; ++xors) {\n          if (i - 1 >= 0) {\n            const int newXor = xors ^ grid[i - 1][j];\n            dp[i - 1][j][newXor] += dp[i][j][xors];\n            dp[i - 1][j][newXor] %= kMod;\n          }\n          if (j - 1 >= 0) {\n            const int newXor = xors ^ grid[i][j - 1];\n            dp[i][j - 1][newXor] += dp[i][j][xors];\n            dp[i][j - 1][newXor] %= kMod;\n          }\n        }\n\n    return dp[0][0][k];\n  }\n};\n", "3394": "class Solution {\n public:\n  bool checkValidCuts(int n, vector<vector<int>>& rectangles) {\n    vector<pair<int, int>> xs;\n    vector<pair<int, int>> ys;\n\n    for (const vector<int> rectangles : rectangles) {\n      const int startX = rectangles[0];\n      const int startY = rectangles[1];\n      const int endX = rectangles[2];\n      const int endY = rectangles[3];\n      xs.emplace_back(startX, endX);\n      ys.emplace_back(startY, endY);\n    }\n\n    return max(countMerged(xs), countMerged(ys)) >= 3;\n  }\n\n private:\n  int countMerged(vector<pair<int, int>>& intervals) {\n    int count = 0;\n    int prevEnd = 0;\n\n    ranges::sort(intervals);\n\n    for (const auto& [start, eend] : intervals)\n      if (start < prevEnd) {\n        prevEnd = max(prevEnd, eend);\n      } else {\n        prevEnd = eend;\n        ++count;\n      }\n\n    return count;\n  }\n};\n", "3395": "class Solution {\n public:\n  int subsequencesWithMiddleMode(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> p;  // prefix counter\n    unordered_map<int, int> s;  // suffix counter\n\n    for (const int num : nums)\n      ++s[num];\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int a = nums[i];\n      --s[a];\n\n      const int l = i;\n      const int r = nums.size() - i - 1;\n\n      // Start with all possible subsequences with `a` as the middle number.\n      ans = (ans + nC2(l) * nC2(r)) % kMod;\n\n      // Minus cases where frequency of `a` is 1, so it's not a mode.\n      ans = (ans - nC2(l - p[a]) * nC2(r - s[a])) % kMod;\n\n      for (const int b : getUniqueNums(p, s)) {\n        if (b == a)\n          continue;\n\n        // Minus cases where the middle number is not a \"unique\" mode\n        int subtract = 0;\n\n        // [a b] a [b c]\n        subtract = (subtract + p[a] * p[b] * s[b] * (r - s[a] - s[b])) % kMod;\n\n        // [b c] a [a b]\n        subtract = (subtract + s[a] * s[b] * p[b] * (l - p[a] - p[b])) % kMod;\n\n        // [b b] a [a c]\n        subtract = (subtract + nC2(p[b]) * s[a] * (r - s[a] - s[b])) % kMod;\n\n        // [a c] a [b b]\n        subtract = (subtract + nC2(s[b]) * p[a] * (l - p[a] - p[b])) % kMod;\n\n        // [b b] a [a b]\n        subtract = (subtract + nC2(p[b]) * s[a] * s[b]) % kMod;\n\n        // [a b] a [b b]\n        subtract = (subtract + nC2(s[b]) * p[a] * p[b]) % kMod;\n\n        ans = (ans - subtract + kMod) % kMod;\n      }\n\n      ++p[a];\n    }\n\n    return (ans + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns C(n, 2).\n  long nC2(long n) {\n    return n * (n - 1) / 2 % kMod;\n  }\n\n  unordered_set<int> getUniqueNums(const unordered_map<int, int>& p,\n                                   const unordered_map<int, int>& s) {\n    unordered_set<int> uniqueNums;\n    for (const auto& [num, _] : p)\n      uniqueNums.insert(num);\n    for (const auto& [num, _] : s)\n      uniqueNums.insert(num);\n    return uniqueNums;\n  }\n};\n", "3396": "class Solution {\n public:\n  int minimumOperations(vector<int>& nums) {\n    unordered_set<int> seen;\n    for (int i = nums.size() - 1; i >= 0; --i)\n      if (!seen.insert(nums[i]).second)\n        return (i + 1 + 2) / 3;  // ceil((i + 1) / 3)\n    return 0;\n  }\n};\n", "3397": "class Solution {\n public:\n  int maxDistinctElements(vector<int>& nums, int k) {\n    int ans = 0;\n    int occupied = INT_MIN;\n\n    ranges::sort(nums);\n\n    for (const int num : nums)\n      if (occupied < num + k) {\n        occupied = max(occupied + 1, num - k);\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3398": "class Solution {\n public:\n  int minLength(string s, int numOps) {\n    int l = 1;\n    int r = s.length();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (getMinOps(s, m) <= numOps)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the minimum number of operations needed to make all groups of\n  // identical characters of length k or less.\n  int getMinOps(const string& s, int k) {\n    if (k == 1) {\n      size_t res = 0;\n      for (int i = 0; i < s.length(); ++i)\n        if (s[i] - '0' == i % 2)\n          ++res;\n      return min(res, s.length() - res);\n    }\n\n    int res = 0;\n    int runningLen = 1;\n\n    for (int i = 1; i < s.length(); ++i)\n      if (s[i] == s[i - 1]) {\n        ++runningLen;\n      } else {\n        res += runningLen / (k + 1);\n        runningLen = 1;\n      }\n\n    return res + runningLen / (k + 1);\n  }\n};\n", "3399": "class Solution {\n public:\n  // Same as 3398. Smallest Substring With Identical Characters I\n  int minLength(string s, int numOps) {\n    int l = 1;\n    int r = s.length();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (getMinOps(s, m) <= numOps)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the minimum number of operations needed to make all groups of\n  // identical characters of length k or less.\n  int getMinOps(const string& s, int k) {\n    if (k == 1) {\n      size_t res = 0;\n      for (int i = 0; i < s.length(); ++i)\n        if (s[i] - '0' == i % 2)\n          ++res;\n      return min(res, s.length() - res);\n    }\n\n    int res = 0;\n    int runningLen = 1;\n\n    for (int i = 1; i < s.length(); ++i)\n      if (s[i] == s[i - 1]) {\n        ++runningLen;\n      } else {\n        res += runningLen / (k + 1);\n        runningLen = 1;\n      }\n\n    return res + runningLen / (k + 1);\n  }\n};\n", "34": "class Solution {\n public:\n  vector<int> searchRange(vector<int>& nums, int target) {\n    const int l = ranges::lower_bound(nums, target) - nums.begin();\n    if (l == nums.size() || nums[l] != target)\n      return {-1, -1};\n    const int r = ranges::upper_bound(nums, target) - nums.begin() - 1;\n    return {l, r};\n  }\n};\n", "340": "class Solution {\n public:\n  int lengthOfLongestSubstringKDistinct(string s, int k) {\n    int ans = 0;\n    map<int, char> lastSeen;          // {last index: letter}\n    unordered_map<char, int> window;  // {letter: index}\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      const int inChar = s[r];\n      if (const auto it = window.find(inChar); it != window.cend())\n        lastSeen.erase(it->second);\n      lastSeen[r] = inChar;\n      window[inChar] = r;\n      if (window.size() > k) {\n        const auto [lastIndex, outChar] = *lastSeen.begin();\n        lastSeen.erase(lastSeen.begin());\n        window.erase(outChar);\n        l = lastIndex + 1;\n      }\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "3400": "class Solution {\n public:\n  int maximumMatchingIndices(vector<int>& nums1, vector<int>& nums2) {\n    const int n = nums1.size();\n    int ans = 0;\n\n    for (int shift = 0; shift < n; ++shift) {\n      int matches = 0;\n      for (int i = 0; i < n; ++i)\n        if (nums1[(i + shift) % n] == nums2[i])\n          ++matches;\n      ans = max(ans, matches);\n    }\n\n    return ans;\n  }\n};\n", "3402": "class Solution {\n public:\n  int minimumOperations(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int j = 0; j < grid[0].size(); ++j)\n      for (int i = 1; i < grid.size(); ++i)\n        if (grid[i][j] <= grid[i - 1][j]) {\n          ans += grid[i - 1][j] - grid[i][j] + 1;\n          grid[i][j] = grid[i - 1][j] + 1;\n        }\n\n    return ans;\n  }\n};\n", "3403": "class Solution {\n public:\n  string answerString(string word, int numFriends) {\n    if (numFriends == 1)\n      return word;\n    const string s = lastSubstring(word);\n    const size_t sz = word.length() - numFriends + 1;\n    return s.substr(0, min(s.length(), sz));\n  }\n\n private:\n  // Same as 1163. Last Substring in Lexicographical Order\n  string lastSubstring(string s) {\n    int i = 0;\n    int j = 1;\n    int k = 0;\n\n    while (j + k < s.length())\n      if (s[i + k] == s[j + k]) {\n        ++k;\n      } else if (s[i + k] > s[j + k]) {\n        // Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        // lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        // and s[i + k] > s[j + k).\n        j = j + k + 1;\n        k = 0;\n      } else {\n        // Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        // possible lexicographically larger substring since\n        // s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        // Note that it's unnecessary to explore s[i + k + 1..j) if\n        // i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j);\n        j = i + 1;\n        k = 0;\n      }\n\n    return s.substr(i);\n  }\n};\n", "3404": "class Solution {\n public:\n  long long numberOfSubsequences(vector<int>& nums) {\n    const int n = nums.size();\n    const int mx = ranges::max(nums);\n    long ans = 0;\n    vector<vector<int>> count(mx + 1, vector<int>(mx + 1));\n\n    // nums[p] * nums[r] == nums[q] * nums[s]\n    // nums[p] / nums[q] == nums[s] / nums[r]\n    for (int r = 4; r <= n - 1 - 2; ++r) {\n      const int q = r - 2;\n      for (int p = 0; p <= q - 2; ++p) {\n        const int g = gcd(nums[p], nums[q]);\n        ++count[nums[p] / g][nums[q] / g];\n      }\n      for (int s = r + 2; s < n; ++s) {\n        const int g = gcd(nums[s], nums[r]);\n        ans += count[nums[s] / g][nums[r] / g];\n      }\n    }\n\n    return ans;\n  }\n};\n", "3405": "class Solution {\n public:\n  int countGoodArrays(int n, int m, int k) {\n    const auto [fact, invFact] = getFactAndInvFact(n);\n    return m * modPow(m - 1, n - k - 1) % kMod * nCk(n - 1, k, fact, invFact) %\n           kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n\n  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n    vector<long> fact(n + 1);\n    vector<long> invFact(n + 1);\n    vector<long> inv(n + 1);\n    fact[0] = invFact[0] = 1;\n    inv[0] = inv[1] = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (i >= 2)\n        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n      fact[i] = fact[i - 1] * i % kMod;\n      invFact[i] = invFact[i - 1] * inv[i] % kMod;\n    }\n    return {fact, invFact};\n  }\n\n  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {\n    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;\n  }\n};\n", "3406": "class Solution {\n public:\n  string answerString(string word, int numFriends) {\n    if (numFriends == 1)\n      return word;\n    const string s = lastSubstring(word);\n    const size_t sz = word.length() - numFriends + 1;\n    return s.substr(0, min(s.length(), sz));\n  }\n\n private:\n  // Same as 1163. Last Substring in Lexicographical Order\n  string lastSubstring(string s) {\n    int i = 0;\n    int j = 1;\n    int k = 0;\n\n    while (j + k < s.length())\n      if (s[i + k] == s[j + k]) {\n        ++k;\n      } else if (s[i + k] > s[j + k]) {\n        // Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        // lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        // and s[i + k] > s[j + k).\n        j = j + k + 1;\n        k = 0;\n      } else {\n        // Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        // possible lexicographically larger substring since\n        // s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        // Note that it's unnecessary to explore s[i + k + 1..j) if\n        // i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j);\n        j = i + 1;\n        k = 0;\n      }\n\n    return s.substr(i);\n  }\n};\n", "3407": "class Solution {\n public:\n  bool hasMatch(const string& s, const string& p) {\n    const int starPos = p.find('*');\n    const string prefix = p.substr(0, starPos);\n    const string suffix = p.substr(starPos + 1);\n    const int i = s.find(prefix);\n    return i != string::npos &&\n           s.find(suffix, i + prefix.size()) != string::npos;\n  }\n};\n", "3408": "struct Task {\n  int userId;\n  int taskId;\n  int priority;\n\n  Task() = default;\n  Task(int u, int t, int p) : userId(u), taskId(t), priority(p) {}\n\n  bool operator<(const Task& other) const {\n    return priority == other.priority ? taskId > other.taskId\n                                      : priority > other.priority;\n  }\n};\n\nclass TaskManager {\n public:\n  unordered_map<int, Task> taskMap;  // {taskId: Task}\n  set<Task> taskSet;  // Stores tasks sorted by priority and taskId.\n\n  TaskManager(vector<vector<int>>& tasks) {\n    for (const auto& task : tasks)\n      add(task[0], task[1], task[2]);\n  }\n\n  void add(int userId, int taskId, int priority) {\n    const Task task(userId, taskId, priority);\n    taskMap[taskId] = task;\n    taskSet.insert(task);\n  }\n\n  void edit(int taskId, int newPriority) {\n    const Task task = taskMap[taskId];\n    taskSet.erase(task);\n    const Task editedTask = Task(task.userId, task.taskId, newPriority);\n    taskSet.insert(editedTask);\n    taskMap[taskId] = editedTask;\n  }\n\n  void rmv(int taskId) {\n    const Task task = taskMap[taskId];\n    taskSet.erase(task);\n    taskMap.erase(taskId);\n  }\n\n  int execTop() {\n    if (taskSet.empty())\n      return -1;\n    const Task task = *taskSet.begin();\n    taskSet.erase(task);\n    taskMap.erase(task.taskId);\n    return task.userId;\n  }\n};\n", "3409": "class Solution {\n public:\n  int longestSubsequence(vector<int>& nums) {\n    const int mx = ranges::max(nums);\n    // dp[num][diff] := the length of the longest subsequence ending in `num`\n    // s.t. the last absolute difference between consecutive elements is `diff`\n    vector<vector<int>> dp(mx + 1, vector<int>(mx + 1));\n\n    for (const int num : nums) {\n      for (int prev = 1; prev <= mx; ++prev) {\n        const int diff = abs(num - prev);\n        dp[num][diff] = max(dp[num][diff], dp[prev][diff] + 1);\n      }\n      // dp[num][diff] := max(dp[num][j]), where j >= diff\n      for (int j = mx - 1; j >= 0; --j)\n        dp[num][j] = max(dp[num][j], dp[num][j + 1]);\n    }\n\n    return ranges::max_element(dp, ranges::less{}, [](const vector<int>& row) {\n      return row[0];\n    })->at(0);\n  }\n};\n", "341": "class NestedIterator {\n public:\n  NestedIterator(vector<NestedInteger>& nestedList) {\n    addInteger(nestedList);\n  }\n\n  int next() {\n    const int num = stack.top().getInteger();\n    stack.pop();\n    return num;\n  }\n\n  bool hasNext() {\n    while (!stack.empty() && !stack.top().isInteger()) {\n      vector<NestedInteger> nestedList = stack.top().getList();\n      stack.pop();\n      addInteger(nestedList);\n    }\n    return !stack.empty();\n  }\n\n private:\n  stack<NestedInteger> stack;\n\n  // addInteger([1, [4, [6]]]) -> stack = [[4, [6]], 1]\n  // addInteger([4, [6]]) -> stack = [[6], 4]\n  // addInteger([6]) -> stack = [6]\n  void addInteger(const vector<NestedInteger>& nestedList) {\n    for (int i = nestedList.size() - 1; i >= 0; --i)\n      stack.push(nestedList[i]);\n  }\n};\n", "3410": "class Solution {\n public:\n  long long maxSubarraySum(vector<int>& nums) {\n    long ans = ranges::max(nums);\n    long prefix = 0;\n    long minPrefix = 0;\n    // the minimum prefix sum that can have a negative number removed\n    long modifiedMinPrefix = 0;\n    unordered_map<int, int> count;\n    // minPrefixPlusRemoval[num] := the minimum prefix sum plus removed `num`\n    unordered_map<int, long> minPrefixPlusRemoval;\n\n    for (const int num : nums) {\n      prefix += num;\n      ans = max(ans, prefix - modifiedMinPrefix);\n      if (num < 0) {\n        ++count[num];\n        minPrefixPlusRemoval[num] =\n            min(minPrefixPlusRemoval[num], minPrefix) + num;\n        modifiedMinPrefix =\n            min({modifiedMinPrefix, count[num] * static_cast<long>(num),\n                 minPrefixPlusRemoval[num]});\n      }\n      minPrefix = min(minPrefix, prefix);\n      modifiedMinPrefix = min(modifiedMinPrefix, minPrefix);\n    }\n\n    return ans;\n  }\n};\n", "3411": "class Solution {\n public:\n  int maxLength(const vector<int>& nums) {\n    constexpr int kMaxLcm = 36'288'000;  // 10! x 10\n    const int n = nums.size();\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n      int prod = 1;\n      int l = 1;\n      int g = 0;\n      for (int j = i; j < n; ++j) {\n        prod *= nums[j];\n        if (prod > kMaxLcm)\n          break;\n        l = lcm(l, nums[j]);\n        g = gcd(g, nums[j]);\n        if (prod == l * g)\n          ans = max(ans, j - i + 1);\n      }\n    }\n\n    return ans;\n  }\n};\n", "3412": "class Solution {\n public:\n  long long calculateScore(string s) {\n    long ans = 0;\n    vector<stack<int>> indices(26);\n\n    for (int i = 0; i < s.length(); ++i) {\n      const int index = s[i] - 'a';\n      const int oppositeIndex = 25 - index;\n      if (!indices[oppositeIndex].empty())\n        ans += i - indices[oppositeIndex].top(), indices[oppositeIndex].pop();\n      else\n        indices[index].push(i);\n    }\n\n    return ans;\n  }\n};\n", "3413": "class Solution {\n public:\n  long long maximumCoins(vector<vector<int>>& coins, int k) {\n    vector<vector<int>> negatedCoins = negateLeftRight(coins);\n    return max(slide(coins, k), slide(negatedCoins, k));\n  }\n\n private:\n  vector<vector<int>> negateLeftRight(const vector<vector<int>> coins) {\n    vector<vector<int>> res;\n    for (const vector<int>& coin : coins) {\n      const int l = coin[0];\n      const int r = coin[1];\n      const int c = coin[2];\n      res.push_back({-r, -l, c});\n    }\n    return res;\n  }\n\n  long slide(vector<vector<int>>& coins, int k) {\n    long res = 0;\n    long windowSum = 0;\n    int j = 0;\n\n    ranges::sort(coins);\n\n    for (const vector<int>& coin : coins) {\n      const int li = coin[0];\n      const int ri = coin[1];\n      const int ci = coin[2];\n      const int rightBoundary = li + k;\n\n      // [lj, rj] is fully in [li..li + k)\n      while (j + 1 < coins.size() && coins[j + 1][0] < rightBoundary) {\n        const int lj = coins[j][0];\n        const int rj = coins[j][1];\n        const int cj = coins[j][2];\n        windowSum += static_cast<long>(rj - lj + 1) * cj;\n        ++j;\n      }\n\n      // [lj, rj] may be partially in [l..l + k)\n      long last = 0;\n      if (j < coins.size() && coins[j][0] < rightBoundary) {\n        const int lj = coins[j][0];\n        const int rj = coins[j][1];\n        const int cj = coins[j][2];\n        last = static_cast<long>(min(rightBoundary - 1, rj) - lj + 1) * cj;\n      }\n\n      res = max(res, windowSum + last);\n      windowSum -= static_cast<long>(ri - li + 1) * ci;\n    }\n\n    return res;\n  }\n};\n", "3414": "struct T {\n  long weight;\n  vector<int> selected;\n};\n\nclass Solution {\n public:\n  vector<int> maximumWeight(vector<vector<int>>& input) {\n    vector<Interval> intervals;\n    for (int i = 0; i < input.size(); ++i)\n      intervals.emplace_back(input[i][0], input[i][1], input[i][2], i);\n    ranges::sort(intervals);\n    vector<vector<T>> memo(intervals.size(), vector<T>(5));\n    return dp(intervals, memo, 0, 4).selected;\n  }\n\n private:\n  using Interval = tuple<int, int, int, int>;\n\n  T dp(const vector<Interval>& intervals, vector<vector<T>>& memo, int i,\n       int quota) {\n    if (i == intervals.size() || quota == 0)\n      return T();\n    if (memo[i][quota].weight > 0)\n      return memo[i][quota];\n\n    T skip = dp(intervals, memo, i + 1, quota);\n\n    auto [_, r, weight, originalIndex] = intervals[i];\n    const int j = findFirstGreater(intervals, i + 1, r);\n    T nextRes = dp(intervals, memo, j, quota - 1);\n\n    vector<int> newSelected = nextRes.selected;\n    newSelected.push_back(originalIndex);\n    ranges::sort(newSelected);\n    T pick(static_cast<long>(weight) + nextRes.weight, newSelected);\n    return memo[i][quota] =\n               (pick.weight > skip.weight ||\n                pick.weight == skip.weight && pick.selected < skip.selected)\n                   ? pick\n                   : skip;\n  }\n\n  // Binary searches the first interval that starts after `rightBoundary`.\n  int findFirstGreater(const vector<Interval>& intervals, int startFrom,\n                       int rightBoundary) {\n    int l = startFrom;\n    int r = intervals.size();\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (get<0>(intervals[m]) > rightBoundary)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n};\n", "3416": "// Recall from solution 1 that after counting all the subsequences with `a` as\n// the middle mode number, we need to subtract the cases where `a` is not a\n// unique mode or not a mode.\n//\n// To avoid the need of looping through all numbers that are not `a`, we can\n// maintain the sums that are not related to `a` in the loop.\n//\n// So, during the simplification of the formula, keep the running sums of\n// pss, spp, pp, ss, and ps as the first item.\n// (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n//\n//   sum(b != a) (p[a] * p * s) * (r - sa - s)\n//             + (sa * s * p) * (l - p[a] - p)\n//             + (p, 2) * sa * (r - sa)\n//             + (s, 2) * p[a] * (l - p[a])\n//\n//   sum(b != a) (p * s) * (p[a] * (r - sa)) + (p * s^2) * (-p[a])\n//             + (s * p) * (sa * (l - p[a])) + (s * p^2) * (-sa)\n//             + (p^2 - p) * (sa * (r - sa) / 2)\n//             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\nclass Solution {\n public:\n  // Same as 3395. Subsequences with a Unique Middle Mode I\n  int subsequencesWithMiddleMode(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> p;  // prefix counter\n    unordered_map<int, int> s;  // suffix counter\n\n    for (const int num : nums)\n      ++s[num];\n\n    long pss = 0;\n    long spp = 0;\n    long pp = 0;\n    long ss = 0;\n    long ps = 0;\n\n    for (const auto& [_, freq] : s)\n      ss = (ss + static_cast<long>(freq) * freq) % kMod;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int a = nums[i];\n      long sa = s[a];\n      const long pa = p[a];\n\n      // Update running sums after decrementing sa.\n      pss = (pss + pa * (-sa * sa + (sa - 1) * (sa - 1))) % kMod;\n      spp = (spp - pa * pa) % kMod;  // (-sa + (sa - 1)) * pa * pa\n      ss = (ss - sa * sa + (sa - 1) * (sa - 1)) % kMod;\n      ps = (ps - pa) % kMod;  // -pa * (-sa + (sa - 1))\n\n      sa = --s[a];\n\n      const int l = i;\n      const int r = nums.size() - i - 1;\n\n      // Start with all possible subsequences with `a` as the middle number.\n      ans = (ans + nC2(l) * nC2(r)) % kMod;\n\n      // Minus cases where frequency of `a` is 1, so it's not a mode.\n      ans = (ans - nC2(l - pa) * nC2(r - sa)) % kMod;\n\n      // Minus the values where `b != a`.\n      const long pss_ = (pss - pa * sa * sa) % kMod;\n      const long spp_ = (spp - sa * pa * pa) % kMod;\n      const long pp_ = (pp - pa * pa) % kMod;\n      const long ss_ = (ss - sa * sa) % kMod;\n      const long ps_ = (ps - pa * sa) % kMod;\n      const long p_ = l - pa;\n      const long s_ = r - sa;\n\n      // Minus cases where `a` is not a \"unique\" mode or not a mode.\n      long subtract = 0;\n      subtract = (subtract + ps_ * (pa * (r - sa))) % kMod;\n      subtract = (subtract + pss_ * (-pa)) % kMod;\n      subtract = (subtract + ps_ * (sa * (l - pa))) % kMod;\n      subtract = (subtract + spp_ * (-sa)) % kMod;\n      subtract = (subtract + (pp_ - p_) * sa * (r - sa) / 2) % kMod;\n      subtract = (subtract + (ss_ - s_) * pa * (l - pa) / 2) % kMod;\n      ans = (ans - subtract + kMod) % kMod;\n\n      // Update running sums after incrementing p[a].\n      pss = (pss + sa * sa) % kMod;  // (-pa + (pa + 1)) * sa * sa\n      spp = (spp + sa * (-pa * pa + (pa + 1) * (pa + 1))) % kMod;\n      pp = (pp - pa * pa + (pa + 1) * (pa + 1)) % kMod;\n      ps = (ps + sa) % kMod;  // (-pa + (pa + 1)) * sa\n\n      ++p[a];\n    }\n\n    return (ans + kMod) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Returns C(n, 2)\n  long nC2(long n) {\n    return n * (n - 1) / 2 % kMod;\n  }\n};\n", "3417": "class Solution {\n public:\n  vector<int> zigzagTraversal(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<int> ans;\n    vector<int> zigzag;\n\n    for (int i = 0; i < m; ++i)\n      if (i % 2 == 0) {\n        for (int j = 0; j < n; ++j)\n          zigzag.push_back(grid[i][j]);\n      } else {\n        for (int j = n - 1; j >= 0; --j)\n          zigzag.push_back(grid[i][j]);\n      }\n\n    for (int i = 0; i < zigzag.size(); i += 2)\n      ans.push_back(zigzag[i]);\n\n    return ans;\n  }\n};\n", "3418": "class Solution {\n public:\n  int maximumAmount(vector<vector<int>>& coins) {\n    const int m = coins.size();\n    const int n = coins[0].size();\n    // dp[i][j][k] := the maximum profit at position (i, j) with k remaining\n    // neutralizations\n    vector<vector<vector<int>>> dp(\n        m, vector<vector<int>>(n, vector<int>(4, -INT_MAX / 2)));\n\n    // Base case: the robot starts at the top-left corner.\n    dp[0][0][2] = coins[0][0];\n    if (coins[0][0] < 0)\n      dp[0][0][1] = 0;  // Neutralize the robber.\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int k = 0; k < 3; ++k) {\n          if (i > 0)\n            dp[i][j][k] = max({dp[i][j][k], dp[i - 1][j][k] + coins[i][j],\n                               dp[i - 1][j][k + 1]});\n          if (j > 0)\n            dp[i][j][k] = max({dp[i][j][k], dp[i][j - 1][k] + coins[i][j],\n                               dp[i][j - 1][k + 1]});\n        }\n\n    return ranges::max(dp[m - 1][n - 1]);\n  }\n};\n", "3419": "class Solution {\n public:\n  int minMaxWeight(int n, vector<vector<int>>& edges, int threshold) {\n    constexpr int kMax = 1'000'000;\n    vector<vector<pair<int, int>>> reversedGraph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      reversedGraph[v].push_back({u, w});\n    }\n\n    int l = 1;\n    int r = kMax + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (dfs(reversedGraph, 0, m, vector<bool>(n)) == n)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l == (kMax + 1) ? -1 : l;\n  }\n\n private:\n  // Returns the number of nodes reachable from u with weight <= m.\n  int dfs(const vector<vector<pair<int, int>>>& reversedGraph, int u,\n          int maxWeight, vector<bool>&& seen) {\n    int res = 1;\n    seen[u] = true;\n    for (const auto& [v, w] : reversedGraph[u]) {\n      if (w > maxWeight || seen[v])\n        continue;\n      res += dfs(reversedGraph, v, maxWeight, std::move(seen));\n    }\n    return res;\n  }\n};\n", "342": "class Solution {\n public:\n  bool isPowerOfFour(unsigned n) {\n    // Why (4^n - 1) % 3 == 0?\n    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    // three consecutive numbers; among one of them, there must be a multiple\n    // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    // Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 && popcount(n) == 1 && (n - 1) % 3 == 0;\n  }\n};\n", "3420": "class Solution {\n public:\n  long long countNonDecreasingSubarrays(vector<int>& nums, int k) {\n    long ans = 0;\n    long cost = 0;\n    // Store indices of `nums` with `nums[i]` in non-increasing order.\n    deque<int> dq;\n\n    for (int i = nums.size() - 1, j = nums.size() - 1; i >= 0; --i) {\n      const int num = nums[i];\n      while (!dq.empty() && nums[dq.back()] < num) {\n        const int l = dq.back();\n        dq.pop_back();\n        const int r = dq.empty() ? j + 1 : dq.back();\n        // Adjust `nums[l]` to `num`.\n        cost += static_cast<long>(r - l) * (num - nums[l]);\n      }\n      dq.push_back(i);\n      while (cost > k) {  // Remove the rightmost number.\n        cost -= nums[dq.front()] - nums[j];\n        if (dq.front() == j)\n          dq.pop_front();\n        --j;\n      }\n      ans += j - i + 1;\n    }\n\n    return ans;\n  }\n};\n", "3422": "struct SumMultiset {\n  multiset<int> nums;\n  long sum = 0;\n\n  void insert(int val) {\n    nums.insert(val);\n    sum += val;\n  }\n\n  void erase(int val) {\n    nums.erase(nums.find(val));\n    sum -= val;\n  }\n};\n\nclass MedianTracker {\n public:\n  MedianTracker(int k) : k(k) {}\n\n  void add(int val) {\n    below.insert(val);\n    balance();\n  }\n\n  void remove(int val) {\n    if (const auto it = below.nums.find(val); it != below.nums.cend())\n      below.erase(val);\n    else\n      above.erase(val);\n  }\n\n  long getCost() const {\n    return above.sum - below.sum - (k % 2 == 1 ? *above.nums.begin() : 0);\n  }\n\n private:\n  SumMultiset below;\n  SumMultiset above;\n  const int k;\n\n  void balance() {\n    // Move excessive numbers from `below` to `above`.\n    while (below.nums.size() > k / 2) {\n      const int mx = *prev(below.nums.end());\n      below.erase(mx);\n      above.insert(mx);\n    }\n\n    // Balance `below` and `above`.\n    while (!above.nums.empty()) {\n      const int mx = *prev(below.nums.end());\n      const int mn = *above.nums.begin();\n      if (mx <= mn)\n        break;\n      below.erase(mx);\n      above.erase(mn);\n      below.insert(mn);\n      above.insert(mx);\n    }\n  }\n};\n\nclass Solution {\n public:\n  long long minOperations(vector<int>& nums, int k) {\n    MedianTracker tracker(k);\n\n    for (int i = 0; i < k; ++i)\n      tracker.add(nums[i]);\n\n    long ans = tracker.getCost();\n\n    for (int i = k; i < nums.size(); ++i) {\n      tracker.remove(nums[i - k]);\n      tracker.add(nums[i]);\n      ans = min(ans, tracker.getCost());\n    }\n\n    return ans;\n  }\n};\n", "3423": "class Solution {\n public:\n  int maxAdjacentDistance(vector<int>& nums) {\n    int ans = abs(nums.front() - nums.back());\n\n    for (int i = 0; i + 1 < nums.size(); ++i)\n      ans = max(ans, abs(nums[i] - nums[i + 1]));\n\n    return ans;\n  }\n};\n", "3424": "class Solution {\n public:\n  long long minCost(vector<int>& arr, vector<int>& brr, long long k) {\n    return min(noSortCost(arr, brr), sortCost(arr, brr) + k);\n  }\n\n private:\n  long long noSortCost(const vector<int>& arr, const vector<int>& brr) {\n    long res = 0;\n    for (int i = 0; i < arr.size(); ++i)\n      res += abs(arr[i] - brr[i]);\n    return res;\n  }\n\n  long long sortCost(vector<int>& arr, vector<int>& brr) {\n    ranges::sort(arr);\n    ranges::sort(brr);\n    long res = 0;\n    for (int i = 0; i < arr.size(); ++i)\n      res += abs(arr[i] - brr[i]);\n    return res;\n  }\n};\n", "3425": "class Solution {\n public:\n  vector<int> longestSpecialPath(vector<vector<int>>& edges,\n                                 vector<int>& nums) {\n    vector<vector<pair<int, int>>> graph(nums.size());\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    int maxLength = 0;\n    int minNodes = 1;\n    dfs(graph, 0, -1, /*leftBoundary=*/0, /*prefix=*/{0},\n        /*lastSeenDepth=*/{}, nums, maxLength, minNodes);\n    return {maxLength, minNodes};\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev,\n           int leftBoundary, vector<int>&& prefix,\n           unordered_map<int, int>&& lastSeenDepth, const vector<int>& nums,\n           int& maxLength, int& minNodes) {\n    const int prevDepth = lastSeenDepth[nums[u]];\n    lastSeenDepth[nums[u]] = prefix.size();\n    leftBoundary = max(leftBoundary, prevDepth);\n\n    const int length = prefix.back() - prefix[leftBoundary];\n    const int nodes = prefix.size() - leftBoundary;\n    if (length > maxLength || (length == maxLength && nodes < minNodes)) {\n      maxLength = length;\n      minNodes = nodes;\n    }\n\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      prefix.push_back(prefix.back() + w);\n      dfs(graph, v, u, leftBoundary, std::move(prefix),\n          std::move(lastSeenDepth), nums, maxLength, minNodes);\n      prefix.pop_back();\n    }\n\n    lastSeenDepth[nums[u]] = prevDepth;\n  }\n};\n", "3426": "class Solution {\n public:\n  int distanceSum(int m, int n, int k) {\n    // For each distance d, where 1 < d < m, there are `m - d` ways to choose\n    // the two columns that the two pieces are on. For each of the two pieces,\n    // there are `n` ways to choose the row that the piece is on.\n    // Therefore, the contribution of row differences is\n    //   sum(d * (m - d) * n^2), where 1 < d <= m - 1\n    // = n^2 * sum(d * m - d^2)\n    // = n^2 * (d * m * (m - 1) / 2 - m * (m - 1) * (2m - 1) / 6)\n    // = n^2 * (m^3 - m) / 6\n    // Similarly, the contribution of column differences is\n    //   m^2 * (n^3 - n) / 6\n    const int rowContrib = 1L * n * n * (1L * m * m * m - m) / 6 % kMod;\n    const int colContrib = 1L * m * m * (1L * n * n * n - n) / 6 % kMod;\n    return (rowContrib + colContrib) * nCk(m * n - 2, k - 2) % kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long nCk(int n, int k) {\n    long res = 1;\n    for (int i = 1; i <= k; ++i)\n      // By Fermat's little theorem.\n      res = res * (n - i + 1) % kMod * modPow(i, kMod - 2) % kMod;\n    return res;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "3427": "class Solution {\n public:\n  int subarraySum(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    vector<int> prefix(n + 1);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n\n    for (int i = 0; i < n; ++i)\n      ans += prefix[i + 1] - prefix[max(0, i - nums[i])];\n\n    return ans;\n  }\n};\n", "3428": "class Solution {\n public:\n  int minMaxSums(vector<int>& nums, int k) {\n    // In a sorted array, nums[i] will be\n    //   1. The maximum for subsequences formed by nums[0..i].\n    //   2. The minimum for subsequences formed by nums[i..n - 1].\n    //\n    // The number of times nums[i] is the maximum is the same as the number of\n    // times nums[n - 1 - i] is the minimum, due to the symmetry in subsequences\n    // derived from the sorted order.\n    //\n    // To calculate the contribution of nums[i], we need to find the number of\n    // ways to select at most (k - 1) elements from the range of indices where\n    // nums[i] is the smallest or nums[n - 1 - i] is the largest.\n    const int n = nums.size();\n    const vector<vector<int>> comb = getComb(n, k - 1);\n    long ans = 0;\n\n    ranges::sort(nums);\n\n    // i := available numbers from the left of nums[i] or\n    //      available numbers from the right of nums[n - 1 - i]\n    for (int i = 0; i < n; ++i) {\n      int count = 0;\n      for (int j = 0; j <= k - 1; ++j)  // selected numbers\n        count = (count + comb[i][j]) % kMod;\n      ans += static_cast<long>(nums[i]) * count;\n      ans += static_cast<long>(nums[n - 1 - i]) * count;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  vector<vector<int>> getComb(int n, int k) {\n    vector<vector<int>> comb(n + 1, vector<int>(k + 1));\n    for (int i = 0; i <= n; ++i)\n      comb[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= k; ++j)\n        comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % kMod;\n    return comb;\n  }\n};\n", "3429": "class Solution {\n public:\n  long long minCost(int n, vector<vector<int>>& costs) {\n    constexpr int kInvalidColor = 3;\n    vector<vector<vector<long>>> mem(\n        n / 2, vector<vector<long>>(4, vector<long>(4, -1)));\n    return minCost(costs, 0, kInvalidColor, kInvalidColor, mem);\n  }\n\n private:\n  long minCost(const vector<vector<int>>& costs, int i, int prevLeftColor,\n               int prevRightColor, vector<vector<vector<long>>>& mem) {\n    if (i == costs.size() / 2)\n      return 0;\n    if (mem[i][prevLeftColor][prevRightColor] != -1)\n      return mem[i][prevLeftColor][prevRightColor];\n\n    long res = LONG_MAX;\n\n    for (const int leftColor : getValidColors(prevLeftColor))\n      for (const int rightColor : getValidColors(prevRightColor)) {\n        if (leftColor == rightColor)\n          continue;\n        const long leftCost = costs[i][leftColor];\n        const long rightCost = costs[costs.size() - 1 - i][rightColor];\n        res = min(res, leftCost + rightCost +\n                           minCost(costs, i + 1, leftColor, rightColor, mem));\n      }\n\n    return mem[i][prevLeftColor][prevRightColor] = res;\n  }\n\n  vector<int> getValidColors(int prevColor) {\n    vector<int> validColors;\n    for (int color = 0; color < 3; ++color)\n      if (color != prevColor)\n        validColors.push_back(color);\n    return validColors;\n  }\n};\n", "343": "class Solution {\n public:\n  int integerBreak(int n) {\n    // If an optimal product contains a factor f >= 4, then we can replace it\n    // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    // we never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    // (and 1 is wasteful).\n    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if (n == 2)  // 1 * 1\n      return 1;\n    if (n == 3)  // 1 * 2\n      return 2;\n\n    int ans = 1;\n\n    while (n > 4) {\n      n -= 3;\n      ans *= 3;\n    }\n    ans *= n;\n\n    return ans;\n  }\n};\n", "3430": "class Solution {\n public:\n  // Similar to 2104. Sum of Subarray Ranges\n  long long minMaxSubarraySum(const vector<int>& nums, int k) {\n    const auto [prevGt, nextGt] = getPrevNext(nums, less<>());\n    const auto [prevLt, nextLt] = getPrevNext(nums, greater<>());\n    return subarraySum(nums, prevGt, nextGt, k) +\n           subarraySum(nums, prevLt, nextLt, k);\n  }\n\n private:\n  // Returns the sum of all subarrays with a size <= k, The `prev` and `next`\n  // arrays are used to store the indices of the nearest numbers that are\n  // smaller or larger than the current number, respectively.\n  long subarraySum(const vector<int>& nums, const vector<int>& prev,\n                   const vector<int>& next, int k) {\n    long res = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      const int l = min(i - prev[i], k);\n      const int r = min(next[i] - i, k);\n      const int extra = max(0, l + r - 1 - k);\n      res += nums[i] * static_cast<long>(l * r - extra * (extra + 1) / 2);\n    }\n    return res;\n  }\n\n  // Returns `prev` and `next`, that store the indices of the nearest numbers\n  // that are smaller or larger than the current number depending on `op`.\n  pair<vector<int>, vector<int>> getPrevNext(\n      const vector<int>& nums, const function<bool(int, int)>& op) {\n    const int n = nums.size();\n    vector<int> prev(n, -1);\n    vector<int> next(n, n);\n    stack<int> stack;\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && op(nums[stack.top()], nums[i])) {\n        const int index = stack.top();\n        stack.pop();\n        next[index] = i;\n      }\n      if (!stack.empty())\n        prev[i] = stack.top();\n      stack.push(i);\n    }\n    return {prev, next};\n  }\n};\n", "3431": "class Solution {\n public:\n  int minUnlockedIndices(vector<int>& nums, vector<int>& locked) {\n    const auto first2It = ranges::find(nums, 2);\n    const auto first3It = ranges::find(nums, 3);\n    const auto last1It = ranges::find_last(nums, 1);\n    const auto last2It = ranges::find_last(nums, 2);\n    const int first2 =\n        first2It == nums.cend() ? -1 : distance(nums.begin(), first2It);\n    const int first3 =\n        first3It == nums.cend() ? -1 : distance(nums.begin(), first3It);\n    const int last1 = last1It.begin() == nums.cend()\n                          ? -1\n                          : distance(nums.begin(), last1It.begin());\n    const int last2 = last2It.begin() == nums.cend()\n                          ? -1\n                          : distance(nums.begin(), last2It.begin());\n    if (first3 != -1 && last1 != -1 && first3 < last1)\n      return -1;\n\n    int ans = 0;\n\n    // Unlocked indices between 2 and 1.\n    if (first2 != -1 && last1 != -1)\n      for (int i = first2; i < last1; ++i)\n        if (locked[i] == 1)\n          ++ans;\n\n    // Unlocked indices between 3 and 2.\n    if (first3 != -1 && last2 != -1)\n      for (int i = first3; i < last2; ++i)\n        if (locked[i] == 1)\n          ++ans;\n\n    return ans;\n  }\n};\n", "3432": "class Solution {\n public:\n  int countPartitions(std::vector<int>& nums) {\n    // If we add the same number in the left subarray and remove it from the\n    // right subarray, then the difference remains the same parity. So, just\n    // return the number of ways to partition the array into two subarrays when\n    // the array sum is even.\n    return accumulate(nums.begin(), nums.end(), 0) % 2 == 0 ? nums.size() - 1\n                                                            : 0;\n  }\n};\n", "3433": "struct OfflineUser {\n  int returnTimestamp;\n  int userId;\n  bool operator>(const OfflineUser& other) const {\n    return returnTimestamp > other.returnTimestamp;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> countMentions(int numberOfUsers, vector<vector<string>>& events) {\n    vector<int> ans(numberOfUsers);\n    vector<int> online(numberOfUsers, true);\n    // min-heap to track users that are offline\n    priority_queue<OfflineUser, vector<OfflineUser>, greater<>> offlineQueue;\n    int allMentionsCount = 0;\n\n    ranges::sort(events, ranges::less{}, [](const vector<string>& event) {\n      const int timestamp = stoi(event[1]);\n      const char eventType = event[0][0];\n      return pair<int, char>{timestamp, -eventType};\n    });\n\n    for (const vector<string>& event : events) {\n      const string eventType = event[0];\n      const int timestamp = stoi(event[1]);\n      // Bring users back online if their offline period has ended.\n      while (!offlineQueue.empty() &&\n             offlineQueue.top().returnTimestamp <= timestamp)\n        online[offlineQueue.top().userId] = true, offlineQueue.pop();\n      if (eventType == \"MESSAGE\") {\n        const string mentionsString = event[2];\n        if (mentionsString == \"ALL\") {\n          ++allMentionsCount;\n        } else if (mentionsString == \"HERE\") {\n          for (int userId = 0; userId < numberOfUsers; ++userId)\n            if (online[userId])\n              ++ans[userId];\n        } else {\n          for (const int userId : getUserIds(mentionsString))\n            ++ans[userId];\n        }\n      } else if (eventType == \"OFFLINE\") {\n        const int userId = stoi(event[2]);\n        online[userId] = false;\n        // Add to queue to bring back online after 60 units.\n        offlineQueue.emplace(timestamp + 60, userId);\n      }\n    }\n\n    // Add the \"ALL\" mentions to all users.\n    for (int userId = 0; userId < numberOfUsers; ++userId)\n      ans[userId] += allMentionsCount;\n    return ans;\n  }\n\n private:\n  vector<int> getUserIds(const string& s) {\n    vector<int> integers;\n    istringstream iss(s);\n    for (string id; iss >> id;)\n      integers.push_back(stoi(id.substr(2)));\n    return integers;\n  }\n};\n", "3434": "class Solution {\n public:\n  int maxFrequency(vector<int>& nums, int k) {\n    constexpr int kMax = 50;\n    int maxFreq = 0;\n    for (int target = 1; target <= kMax; ++target)\n      if (target != k)\n        maxFreq = max(maxFreq, kadane(nums, target, k));\n    return ranges::count(nums, k) + maxFreq;\n  }\n\n private:\n  // Returns the maximum achievable frequency of `k` by Kakane's algorithm,\n  // where each `target` in subarrays is transformed to `k`.\n  int kadane(const vector<int>& nums, int target, int k) {\n    int maxSum = 0;\n    int sum = 0;\n    for (const int num : nums) {\n      if (num == target)\n        ++sum;\n      else if (num == k)\n        --sum;\n      if (sum < 0)  // Reset if sum becomes negative (Kadane's spirit).\n        sum = 0;\n      maxSum = max(maxSum, sum);\n    }\n    return maxSum;\n  }\n};\n", "3435": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  vector<vector<int>> supersequences(vector<string>& words) {\n    vector<vector<int>> ans;\n    const vector<pair<int, int>> edges = getEdges(words);\n    const vector<int> nodes = getNodes(edges);\n    const vector<int> letterToIndex = getLetterToIndex(nodes);\n    vector<vector<int>> graph(nodes.size());\n\n    for (const auto& [u, v] : edges)\n      graph[letterToIndex[u]].push_back(letterToIndex[v]);\n\n    for (const auto& doubledSubset : getMinimumSubsets(graph)) {\n      vector<int> freq(26);\n      for (const int letter : nodes)\n        freq[letter] = 1;\n      for (const int index : doubledSubset)\n        freq[nodes[index]] = 2;\n      ans.push_back(freq);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns a list of the minimum subsets of nodes that do not create a cycle\n  // when skipped.\n  vector<vector<int>> getMinimumSubsets(const vector<vector<int>>& graph) {\n    const int n = graph.size();\n    vector<vector<int>> res;\n    for (int subsetSize = 0; subsetSize <= n; ++subsetSize) {\n      vector<bool> combination(n);\n      fill(combination.end() - subsetSize, combination.end(), true);\n      do {\n        vector<int> doubledSubset;\n        for (int i = 0; i < n; ++i)\n          if (combination[i])\n            doubledSubset.push_back(i);\n        if (!hasCycleSkipping(graph,\n                              {doubledSubset.begin(), doubledSubset.end()}))\n          res.push_back(doubledSubset);\n      } while (next_permutation(combination.begin(), combination.end()));\n      if (!res.empty())\n        return res;\n    }\n    return res;\n  }\n\n  // Returns true if there is a cycle in the `graph` when skipping any edges\n  // whose both endpoints are in `doubledSubset`.\n  bool hasCycleSkipping(const vector<vector<int>>& graph,\n                        const unordered_set<int>& doubledSubset) {\n    vector<State> states(graph.size());\n    for (int i = 0; i < graph.size(); ++i)\n      if (hasCycle(graph, i, states, doubledSubset))\n        return true;\n    return false;\n  }\n\n  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& states,\n                const unordered_set<int>& doubledSubset) {\n    if (states[u] == State::kVisiting)\n      return true;\n    if (states[u] == State::kVisited)\n      return false;\n    states[u] = State::kVisiting;\n    if (!doubledSubset.contains(u))\n      for (const int v : graph[u])\n        if (!doubledSubset.contains(v) &&\n            hasCycle(graph, v, states, doubledSubset))\n          return true;\n    states[u] = State::kVisited;\n    return false;\n  }\n\n  vector<pair<int, int>> getEdges(const vector<string>& words) {\n    vector<pair<int, int>> edges;\n    for (const string& word : words)\n      edges.push_back({word[0] - 'a', word[1] - 'a'});\n    return edges;\n  }\n\n  vector<int> getNodes(const vector<pair<int, int>>& edges) {\n    set<int> nodes;\n    for (const auto& [u, v] : edges) {\n      nodes.insert(u);\n      nodes.insert(v);\n    }\n    return {nodes.begin(), nodes.end()};\n  }\n\n  vector<int> getLetterToIndex(const vector<int>& nodes) {\n    vector<int> letterToIndex(26);\n    for (int i = 0; i < nodes.size(); ++i)\n      letterToIndex[nodes[i]] = i;\n    return letterToIndex;\n  }\n};\n", "3437": "class Solution {\n public:\n  vector<vector<int>> permute(int n) {\n    vector<vector<int>> ans;\n    dfs(n, vector<bool>(n + 1), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, vector<bool>&& used, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() == n) {\n      ans.push_back(path);\n      return;\n    }\n    for (int num = 1; num <= n; ++num) {\n      if (used[num])\n        continue;\n      if (!path.empty() && path.back() % 2 == num % 2)\n        continue;\n      used[num] = true;\n      path.push_back(num);\n      dfs(n, std::move(used), std::move(path), ans);\n      path.pop_back();\n      used[num] = false;\n    }\n  }\n};\n", "3438": "class Solution {\n public:\n  string findValidPair(string s) {\n    vector<int> count(10);\n\n    for (const char c : s)\n      ++count[c - '0'];\n\n    for (int i = 0; i < s.length() - 1; ++i) {\n      const int a = s[i] - '0';\n      const int b = s[i + 1] - '0';\n      if (a != b && count[a] == a && count[b] == b)\n        return s.substr(i, 2);\n    }\n\n    return \"\";\n  }\n};\n", "3439": "class Solution {\n public:\n  int maxFreeTime(int eventTime, int k, vector<int>& startTime,\n                  vector<int>& endTime) {\n    const vector<int> gaps = getGaps(eventTime, startTime, endTime);\n    int windowSum = accumulate(gaps.begin(), gaps.begin() + k + 1, 0);\n    int ans = windowSum;\n\n    for (int i = k + 1; i < gaps.size(); ++i) {\n      windowSum += gaps[i] - gaps[i - k - 1];\n      ans = max(ans, windowSum);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getGaps(int eventTime, const vector<int>& startTime,\n                      const vector<int>& endTime) {\n    vector<int> gaps{startTime[0]};\n    for (int i = 1; i < startTime.size(); ++i)\n      gaps.push_back(startTime[i] - endTime[i - 1]);\n    gaps.push_back(eventTime - endTime.back());\n    return gaps;\n  }\n};\n", "344": "class Solution {\n public:\n  void reverseString(vector<char>& s) {\n    int l = 0;\n    int r = s.size() - 1;\n\n    while (l < r)\n      swap(s[l++], s[r--]);\n  }\n};\n", "3440": "class Solution {\n public:\n  int maxFreeTime(int eventTime, vector<int>& startTime, vector<int>& endTime) {\n    const int n = startTime.size();\n    const vector<int> gaps = getGaps(eventTime, startTime, endTime);\n    int ans = 0;\n    vector<int> maxLeft(n + 1);   // maxLeft[i] := max(gaps[0..i])\n    vector<int> maxRight(n + 1);  // maxRight[i] := max(gaps[i..n])\n\n    maxLeft[0] = gaps[0];\n    maxRight[n] = gaps[n];\n\n    for (int i = 1; i < n + 1; ++i)\n      maxLeft[i] = max(gaps[i], maxLeft[i - 1]);\n\n    for (int i = n - 1; i >= 0; --i)\n      maxRight[i] = max(gaps[i], maxRight[i + 1]);\n\n    for (int i = 0; i < n; ++i) {\n      const int currMeetingTime = endTime[i] - startTime[i];\n      const int adjacentGapsSum = gaps[i] + gaps[i + 1];\n      const bool canMoveMeeting =\n          currMeetingTime <= max(i > 0 ? maxLeft[i - 1] : 0,  //\n                                 i + 2 < n + 1 ? maxRight[i + 2] : 0);\n      ans = max(ans, adjacentGapsSum + (canMoveMeeting ? currMeetingTime : 0));\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getGaps(int eventTime, const vector<int>& startTime,\n                      const vector<int>& endTime) {\n    vector<int> gaps{startTime[0]};\n    for (int i = 1; i < startTime.size(); ++i)\n      gaps.push_back(startTime[i] - endTime[i - 1]);\n    gaps.push_back(eventTime - endTime.back());\n    return gaps;\n  }\n};\n", "3441": "class Solution {\n public:\n  string minCostGoodCaption(string caption) {\n    const int n = caption.length();\n    if (n < 3)\n      return \"\";\n\n    constexpr int kMaxCost = 1'000'000'000;\n    // dp[i][j][k] := the minimum cost of caption[i..n - 1], where j is the last\n    // letter used, and k is the count of consecutive letters\n    vector<vector<vector<int>>> dp(\n        n, vector<vector<int>>(26, vector<int>(3, kMaxCost)));\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      dp[n - 1][c - 'a'][0] = abs(caption[n - 1] - c);\n\n    int minCost = kMaxCost;\n    for (int i = n - 2; i >= 0; --i) {\n      int newMinCost = kMaxCost;\n      for (char c = 'a'; c <= 'z'; ++c) {\n        const int j = c - 'a';\n        const int changeCost = abs(caption[i] - c);\n        dp[i][j][0] = changeCost + minCost;\n        dp[i][j][1] = changeCost + dp[i + 1][j][0];\n        dp[i][j][2] = changeCost + min(dp[i + 1][j][1], dp[i + 1][j][2]);\n        newMinCost = min(newMinCost, dp[i][j][2]);\n      }\n      minCost = newMinCost;\n    }\n\n    // Reconstruct the string.\n    string ans;\n    int cost = kMaxCost;\n    int letter = -1;\n\n    // Find the initial best letter.\n    for (int c = 25; c >= 0; --c)\n      if (dp[0][c][2] <= cost) {\n        letter = c;\n        cost = dp[0][c][2];\n      }\n\n    // Add the initial triplet.\n    cost -= appendLetter(caption, 0, 'a' + letter, ans);\n    cost -= appendLetter(caption, 1, 'a' + letter, ans);\n    cost -= appendLetter(caption, 2, 'a' + letter, ans);\n\n    // Build the rest of the string.\n    for (int i = 3; i < n;) {\n      // Check if we should switch to a new letter.\n      const int nextLetter = getNextLetter(dp, i, cost);\n      if (nextLetter < letter || ranges::min(dp[i][letter]) > cost) {\n        letter = nextLetter;\n        cost -= appendLetter(caption, i, 'a' + letter, ans);\n        cost -= appendLetter(caption, i + 1, 'a' + letter, ans);\n        cost -= appendLetter(caption, i + 2, 'a' + letter, ans);\n        i += 3;\n      } else {\n        cost -= appendLetter(caption, i, 'a' + letter, ans);\n        i += 1;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  int getNextLetter(const vector<vector<vector<int>>>& dp, int i, int cost) {\n    int nextLetter = 26;  // invalid letter as the sentinel\n    for (int c = 25; c >= 0; --c)\n      if (cost == dp[i][c][2])\n        nextLetter = c;\n    return nextLetter;\n  }\n\n  int appendLetter(const string& caption, int i, char letter, string& ans) {\n    ans += letter;\n    return abs(caption[i] - letter);\n  }\n};\n", "3442": "class Solution {\n public:\n  int maxDifference(string s) {\n    vector<int> count(26);\n    int maxOdd = 0;\n    int minEven = s.length();\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const int freq : count) {\n      if (freq == 0)\n        continue;\n      if (freq % 2 == 0)\n        minEven = min(minEven, freq);\n      else\n        maxOdd = max(maxOdd, freq);\n    }\n\n    return maxOdd - minEven;\n  }\n};\n", "3443": "class Solution {\n public:\n  int maxDistance(string s, int k) {\n    return max({flip(s, k, \"NE\"), flip(s, k, \"NW\"),  //\n                flip(s, k, \"SE\"), flip(s, k, \"SW\")});\n  }\n\n private:\n  int flip(const string& s, int k, const string& direction) {\n    int res = 0;\n    int pos = 0;\n    int opposite = 0;\n\n    for (const char c : s) {\n      if (direction.find(c) != string::npos) {\n        ++pos;\n      } else {\n        --pos;\n        ++opposite;\n      }\n      res = max(res, pos + 2 * min(k, opposite));\n    }\n\n    return res;\n  }\n};\n", "3444": "class Solution {\n public:\n  int minimumIncrements(vector<int>& nums, vector<int>& target) {\n    const int maxMask = 1 << target.size();\n    unordered_map<int, long> maskToLcm;\n\n    for (int mask = 1; mask < maxMask; ++mask) {\n      const vector<int> subset = getSubset(mask, target);\n      maskToLcm[mask] = getLcm(subset);\n    }\n\n    // dp[mask] := the minimum number of increments to make each number in the\n    // subset of target have at least one number that is a multiple in `num`,\n    // where `mask` is the bitmask of the subset of target\n    vector<long> dp(maxMask, LONG_MAX);\n    dp[0] = 0;\n\n    for (const int num : nums) {\n      // maskToCost := (mask, cost), where `mask` is the bitmask of the subset\n      // of target and `cost` is the minimum number of increments to make each\n      // number in the subset of target have at least one number that is a\n      // multiple in `num`\n      vector<pair<int, long>> maskToCost;\n      for (const auto& [mask, lcm] : maskToLcm) {\n        const int remainder = num % lcm;\n        maskToCost.emplace_back(mask, remainder == 0 ? 0 : lcm - remainder);\n      }\n      vector<long> newDp = dp;\n      for (int prevMask = 0; prevMask < maxMask; ++prevMask) {\n        if (dp[prevMask] == LONG_MAX)\n          continue;\n        for (const auto& [mask, cost] : maskToCost) {\n          const int newMask = prevMask | mask;\n          newDp[newMask] = min(newDp[newMask], dp[prevMask] + cost);\n        }\n      }\n      dp = std::move(newDp);\n    }\n\n    return dp.back() == LONG_MAX ? -1 : dp.back();\n  }\n\n private:\n  vector<int> getSubset(int mask, const vector<int>& target) {\n    vector<int> subset;\n    for (int i = 0; i < target.size(); ++i)\n      if (mask >> i & 1)\n        subset.push_back(target[i]);\n    return subset;\n  }\n\n  long getLcm(const vector<int>& nums) {\n    long res = 1;\n    for (const int num : nums)\n      res = lcm(res, num);\n    return res;\n  }\n};\n", "3445": "class Solution {\n public:\n  int maxDifference(string s, int k) {\n    int ans = INT_MIN;\n\n    for (const auto& [a, b] : getPermutations()) {\n      // minDiff[parityA][parityB] := min(a - b) of all valid windows with\n      // parityA and parityB\n      vector<vector<int>> minDiff(2, vector<int>(2, INT_MAX / 2));\n      vector<int> prefixA{0};  // prefixA[i] := the number of 'a's in s[0..i)\n      vector<int> prefixB{0};  // prefixB[i] := the number of 'b's in s[0..i)\n      for (int l = 0, r = 0; r < s.length(); ++r) {\n        prefixA.push_back(prefixA.back() + (s[r] == a ? 1 : 0));\n        prefixB.push_back(prefixB.back() + (s[r] == b ? 1 : 0));\n        while (r - l + 1 >= k &&               // the window size >= k\n               prefixA[l] < prefixA.back() &&  // the number of 'a's > 0\n               prefixB[l] < prefixB.back()) {  // the number of 'b's > 0\n          minDiff[prefixA[l] % 2][prefixB[l] % 2] = min(\n              minDiff[prefixA[l] % 2][prefixB[l] % 2], prefixA[l] - prefixB[l]);\n          ++l;\n        }\n        ans = max(ans, (prefixA.back() - prefixB.back()) -\n                           minDiff[1 - prefixA.back() % 2][prefixB.back() % 2]);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<char, char>> getPermutations() {\n    vector<pair<char, char>> permutations;\n    for (const char a : \"01234\")\n      for (const char b : \"01234\")\n        if (a != b)\n          permutations.emplace_back(a, b);\n    return permutations;\n  }\n};\n", "3446": "class Solution {\n public:\n  vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    vector<vector<int>> ans(n, vector<int>(n));\n    vector<vector<int>> diag(2 * n + 1);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        diag[i - j + n].push_back(grid[i][j]);\n\n    for (int i = 0; i < 2 * n + 1; ++i)\n      if (i < n)\n        ranges::sort(diag[i], greater<int>());\n      else\n        ranges::sort(diag[i]);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        ans[i][j] = diag[i - j + n].back(), diag[i - j + n].pop_back();\n\n    return ans;\n  }\n};\n", "3447": "class Solution {\n public:\n  vector<int> assignElements(vector<int>& groups, vector<int>& elements) {\n    vector<int> ans;\n    unordered_map<int, int> elementToMinIndex;\n\n    for (int i = 0; i < elements.size(); ++i)\n      if (!elementToMinIndex.contains(elements[i]))\n        elementToMinIndex[elements[i]] = i;\n\n    for (const int num : groups)\n      ans.push_back(getMinIndex(num, elementToMinIndex));\n\n    return ans;\n  }\n\n private:\n  int getMinIndex(int num, const unordered_map<int, int>& elementToMinIndex) {\n    int res = INT_MAX;\n    for (int i = 1; i * i <= num; ++i) {\n      if (num % i != 0)\n        continue;\n      if (elementToMinIndex.contains(i))\n        res = min(res, elementToMinIndex.at(i));\n      if (num / i != i && elementToMinIndex.contains(num / i))\n        res = min(res, elementToMinIndex.at(num / i));\n    }\n    return res == INT_MAX ? -1 : res;\n  }\n};\n", "3448": "class Solution {\n public:\n  long long countSubstrings(string s) {\n    long ans = 0;\n    // dp[num][rem] := the number of substrings so far that have a remainder of\n    // `rem` when divided by `num`\n    vector<vector<int>> dp(10, vector<int>(10));\n\n    for (const char c : s) {\n      const int digit = c - '0';\n      vector<vector<int>> newDp(10, vector<int>(10));\n      for (int num = 1; num < 10; ++num) {\n        for (int rem = 0; rem < num; ++rem)\n          newDp[num][(rem * 10 + digit) % num] += dp[num][rem];\n        ++newDp[num][digit % num];\n      }\n      dp = std::move(newDp);\n      ans += dp[digit][0];\n    }\n\n    return ans;\n  }\n};\n", "3449": "class Solution {\n public:\n  long long maxScore(vector<int>& points, int m) {\n    long l = 0;\n    long r = (m + 1L) / 2 * points[0] + 1;\n\n    while (l < r) {\n      const long mid = (l + r + 1) / 2;\n      if (isPossible(points, mid, m))\n        l = mid;\n      else\n        r = mid - 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if it is possible to achieve the maximum minimum value `x`\n  // with `m` number of moves.\n  bool isPossible(const vector<int>& points, long minVal, long m) {\n    long moves = 0;\n    long prevMoves = 0;  // to track remaining moves from the previous point\n    for (int i = 0; i < points.size(); ++i) {\n      // ceil(minVal / point)\n      const long required =\n          max(0L, (minVal + points[i] - 1) / points[i] - prevMoves);\n      if (required > 0) {\n        moves += 2L * required - 1;\n        prevMoves = required - 1;\n      } else if (i + 1 < points.size()) {\n        moves += 1;\n        prevMoves = 0;\n      }\n      if (moves > m)\n        return false;\n    }\n    return true;\n  };\n};\n", "345": "class Solution {\n public:\n  string reverseVowels(string s) {\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n      while (l < r && !isVowel(s[l]))\n        ++l;\n      while (l < r && !isVowel(s[r]))\n        --r;\n      swap(s[l++], s[r--]);\n    }\n\n    return s;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "3450": "class Solution {\n public:\n  int maxStudentsOnBench(vector<vector<int>>& students) {\n    constexpr int kMax = 100;\n    size_t ans = 0;\n    vector<unordered_set<int>> benchToStudents(kMax + 1);\n\n    for (const vector<int>& student : students) {\n      const int studentId = student[0];\n      const int benchId = student[1];\n      benchToStudents[benchId].insert(studentId);\n    }\n\n    for (const unordered_set<int>& students : benchToStudents)\n      ans = max(ans, students.size());\n\n    return ans;\n  }\n};\n", "3452": "class Solution {\n public:\n  int sumOfGoodNumbers(vector<int>& nums, int k) {\n    const int n = nums.size();\n    int sum = 0;\n\n    for (int i = 0; i < n; ++i)\n      if ((i - k < 0 || nums[i] > nums[i - k]) &&\n          (i + k >= n || nums[i] > nums[i + k]))\n        sum += nums[i];\n\n    return sum;\n  }\n};\n", "3453": "class Solution {\n public:\n  double separateSquares(vector<vector<int>>& squares) {\n    const double halfArea = accumulate(squares.begin(), squares.end(), 0.0,\n                                       [](double sum, vector<int>& square) {\n      return sum + static_cast<long>(square[2]) * square[2];\n    }) / 2;\n    vector<tuple<int, bool, int>> events;\n\n    for (const vector<int>& square : squares) {\n      const int y = square[1];\n      const int l = square[2];\n      events.push_back({y, true, l});       // start of square\n      events.push_back({y + l, false, l});  // end of square\n    }\n\n    ranges::sort(events);\n\n    double area = 0;\n    int width = 0;\n    int prevY = 0;\n\n    for (const auto& [y, isStart, l] : events) {\n      double areaGain = width * static_cast<long>(y - prevY);\n      if (area + areaGain >= halfArea)\n        return prevY + (halfArea - area) / width;\n      area += areaGain;\n      width += isStart ? l : -l;\n      prevY = y;\n    }\n\n    throw;\n  }\n};\n", "3454": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& xs)\n      : xs(xs), n(xs.size() - 1), coveredCount(4 * n), coveredWidth(4 * n) {}\n\n  // Adds val to the range [i, j].\n  void add(int i, int j, int val) {\n    add(0, 0, n - 1, i, j, val);\n  }\n\n  // Returns the covered width of xs[0..n - 1].\n  int getCoveredWidth() const {\n    return coveredWidth[0];\n  }\n\n private:\n  const int n;  // the number of segments (|xs| - 1)\n  vector<int> xs;\n  vector<int> coveredCount;\n  vector<int> coveredWidth;\n\n  void add(int treeIndex, int lo, int hi, int i, int j, int val) {\n    if (j <= xs[lo] || xs[hi + 1] <= i)\n      return;\n    if (i <= xs[lo] && xs[hi + 1] <= j) {\n      coveredCount[treeIndex] += val;\n    } else {\n      const int mid = (lo + hi) / 2;\n      add(2 * treeIndex + 1, lo, mid, i, j, val);\n      add(2 * treeIndex + 2, mid + 1, hi, i, j, val);\n    }\n    if (coveredCount[treeIndex] > 0) {\n      coveredWidth[treeIndex] = xs[hi + 1] - xs[lo];\n    } else if (lo == hi) {\n      coveredWidth[treeIndex] = 0;\n    } else {\n      coveredWidth[treeIndex] =\n          coveredWidth[2 * treeIndex + 1] + coveredWidth[2 * treeIndex + 2];\n    }\n  }\n};\n\nclass Solution {\n public:\n  double separateSquares(vector<vector<int>>& squares) {\n    vector<tuple<int, int, int, int>> events;  // (y, delta, xl, xr)\n    set<int> xs;\n\n    for (const vector<int>& square : squares) {\n      const int x = square[0];\n      const int y = square[1];\n      const int l = square[2];\n      events.emplace_back(y, 1, x, x + l);\n      events.emplace_back(y + l, -1, x, x + l);\n      xs.insert(x);\n      xs.insert(x + l);\n    }\n\n    ranges::sort(events);\n\n    const double halfArea = getArea(events, xs) / 2.0;\n    long area = 0;\n    int prevY = 0;\n    SegmentTree tree({xs.begin(), xs.end()});\n\n    for (const auto& [y, delta, xl, xr] : events) {\n      const int coveredWidth = tree.getCoveredWidth();\n      const long areaGain = coveredWidth * static_cast<long>(y - prevY);\n      if (area + areaGain >= halfArea)\n        return prevY + (halfArea - area) / coveredWidth;\n      area += areaGain;\n      tree.add(xl, xr, delta);\n      prevY = y;\n    }\n\n    throw;\n  }\n\n private:\n  // Returns the total area of the rectangles.\n  long getArea(const vector<tuple<int, int, int, int>>& events,\n               const set<int>& xs) {\n    long totalArea = 0;\n    int prevY = 0;\n    SegmentTree tree({xs.begin(), xs.end()});\n    for (const auto& [y, delta, xl, xr] : events) {\n      totalArea += tree.getCoveredWidth() * static_cast<long>(y - prevY);\n      tree.add(xl, xr, delta);\n      prevY = y;\n    }\n    return totalArea;\n  }\n};\n", "3455": "class Solution {\n public:\n  int shortestMatchingSubstring(string s, string p) {\n    const auto [a, b, c] = split(p);\n    const int ns = s.length();\n    const int na = a.length();\n    const int nb = b.length();\n    const int nc = c.length();\n    const vector<int> lpsA = getLPS(a + '#' + s);\n    const vector<int> lpsB = getLPS(b + '#' + s);\n    const vector<int> lpsC = getLPS(c + '#' + s);\n    int ans = INT_MAX;\n\n    for (int i = 0, j = 0, k = 0; i + nb + nc < ns; ++i) {\n      while (i < ns && lpsA[na + 1 + i] != na)\n        ++i;\n      while (j < ns && (j < i + nb || lpsB[nb + 1 + j] != nb))\n        ++j;\n      while (k < ns && (k < j + nc || lpsC[nc + 1 + k] != nc))\n        ++k;\n      if (k == ns)\n        break;\n      ans = min(ans, k - i + na);\n    }\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  // Returns the lps array, where lps[i] is the length of the longest prefix of\n  // pattern[0..i] which is also a suffix of this substring.\n  vector<int> getLPS(const string& pattern) {\n    vector<int> lps(pattern.length());\n    for (int i = 1, j = 0; i < pattern.length(); ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n\n  tuple<string, string, string> split(const string& p) {\n    const int i = p.find('*');\n    const int j = p.find('*', i + 1);\n    return {p.substr(0, i), p.substr(i + 1, j - i - 1), p.substr(j + 1)};\n  }\n};\n", "3456": "class Solution {\n public:\n  bool hasSpecialSubstring(string s, int k) {\n    int count = 1;\n\n    for (int i = 1; i < s.length(); ++i) {\n      if (s[i] == s[i - 1])\n        ++count;\n      else if (count == k)\n        return true;\n      else\n        count = 1;\n    }\n\n    return count == k;\n  }\n};\n", "3457": "class Solution {\n public:\n  long long maxWeight(vector<int>& pizzas) {\n    const int eat = pizzas.size() / 4;\n    const int odd = (eat - 1) / 2 + 1;  // ceil(eat / 2)\n    const int even = eat - odd;\n    long ans = 0;\n    int i = 0;  // pizzas' index\n\n    ranges::sort(pizzas, std::greater<>());\n\n    for (int j = 0; j < odd; ++j, i += 1)\n      ans += pizzas[i];\n\n    for (int j = 0; j < even; ++j, i += 2)\n      ans += pizzas[i + 1];\n\n    return ans;\n  }\n};\n", "3458": "class Solution {\n public:\n  bool maxSubstringLength(string s, int k) {\n    const int n = s.length();\n    vector<int> first(26, n);\n    vector<int> last(26, -1);\n    vector<char> seenOrder;\n    // dp[i] := the maximum disjoint special substrings for the first i letters\n    vector<int> dp(n + 1);\n\n    for (int i = 0; i < n; ++i) {\n      const char c = s[i];\n      const int a = c - 'a';\n      if (first[a] == n) {\n        first[a] = i;\n        seenOrder.push_back(c);\n      }\n      last[a] = i;\n    }\n\n    for (const char c : seenOrder) {\n      const int a = c - 'a';\n      for (int j = first[a]; j < last[a]; ++j) {\n        const int b = s[j] - 'a';\n        first[a] = min(first[a], first[b]);\n        last[a] = max(last[a], last[b]);\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      const char c = s[i];\n      const int a = c - 'a';\n      if (last[a] != i || (first[a] == 0 && i == n - 1))\n        dp[i + 1] = dp[i];\n      else  // Start a new special substring.\n        dp[i + 1] = max(dp[i], 1 + dp[first[a]]);\n    }\n\n    return dp[n] >= k;\n  }\n};\n", "3459": "class Solution {\n public:\n  int lenOfVDiagonal(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    vector<vector<vector<vector<vector<int>>>>> mem(\n        m, vector<vector<vector<vector<int>>>>(\n               n, vector<vector<vector<int>>>(\n                      2, vector<vector<int>>(2, vector<int>(4, -1)))));\n    int res = 0;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          for (int d = 0; d < 4; ++d) {\n            const auto& [dx, dy] = kDirs[d];\n            res = max(res, 1 + dfs(grid, i + dx, j + dy, /*turned=*/false, 2, d,\n                                   mem));\n          }\n\n    return res;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\n  int dfs(const vector<vector<int>>& grid, int i, int j, bool turned, int num,\n          int dir, vector<vector<vector<vector<vector<int>>>>>& mem) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return 0;\n    if (grid[i][j] != num)\n      return 0;\n\n    const int hashNum = max(0, num - 1);\n    if (mem[i][j][turned][hashNum][dir] != -1)\n      return mem[i][j][turned][hashNum][dir];\n\n    const int nextNum = num == 2 ? 0 : 2;\n    const auto& [dx, dy] = kDirs[dir];\n    int res = 1 + dfs(grid, i + dx, j + dy, turned, nextNum, dir, mem);\n\n    if (!turned) {\n      const int nextDir = (dir + 1) % 4;\n      const auto& [nextDx, nextDy] = kDirs[nextDir];\n      res = max(res, 1 + dfs(grid, i + nextDx, j + nextDy, /*turned=*/true,\n                             nextNum, nextDir, mem));\n    }\n\n    return mem[i][j][turned][hashNum][dir] = res;\n  }\n};\n", "346": "class MovingAverage {\n public:\n  MovingAverage(int size) : size(size) {}\n\n  double next(int val) {\n    if (q.size() == size)\n      sum -= q.front(), q.pop();\n    sum += val;\n    q.push(val);\n    return sum / q.size();\n  }\n\n private:\n  int size;\n  double sum = 0;\n  queue<int> q;\n};\n", "3460": "class Solution {\n public:\n  int longestCommonPrefix(string s, string t) {\n    int i = 0;  // s's index\n    int j = 0;  // t's index\n    bool canSkip = true;\n\n    while (i < s.length() && j < t.length())\n      if (s[i] == t[j]) {\n        ++i;\n        ++j;\n      } else if (canSkip) {\n        ++i;\n        canSkip = false;\n      } else {\n        return j;\n      }\n\n    return j;\n  }\n};\n", "3461": "class Solution {\n public:\n  bool hasSameDigits(const string& s) {\n    const int n = s.length();\n    int num1 = 0;\n    int num2 = 0;\n\n    for (int i = 0; i + 1 < n; ++i) {\n      const int coefficient = nCkMod10(n - 2, i);\n      num1 += (coefficient * (s[i] - '0')) % 10;\n      num1 %= 10;\n      num2 += (coefficient * (s[i + 1] - '0')) % 10;\n      num2 %= 10;\n    }\n\n    return num1 == num2;\n  }\n\n private:\n  // Returns (n, k) % 10.\n  int nCkMod10(int n, int k) {\n    const int mod2 = lucasTheorem(n, k, 2);\n    const int mod5 = lucasTheorem(n, k, 5);\n    static constexpr int lookup[2][5] = {\n        {0, 6, 2, 8, 4},  // mod2 == 0\n        {5, 1, 7, 3, 9}   // mod2 == 1\n    };\n    return lookup[mod2][mod5];\n  }\n\n  // Returns (n, k) % prime.\n  int lucasTheorem(int n, int k, int prime) {\n    int res = 1;\n    while (n > 0 || k > 0) {\n      const int nMod = n % prime;\n      const int kMod = k % prime;\n      res *= nCk(nMod, kMod);\n      res %= prime;\n      n /= prime;\n      k /= prime;\n    }\n    return res;\n  }\n\n  // Returns (n, k).\n  int nCk(int n, int k) {\n    int res = 1;\n    for (int i = 0; i < k; ++i) {\n      res *= (n - i);\n      res /= (i + 1);\n    }\n    return res;\n  }\n};\n", "3462": "class Solution {\n public:\n  long long maxSum(vector<vector<int>>& grid, vector<int>& limits, int k) {\n    long ans = 0;\n    priority_queue<int, vector<int>, greater<>> minHeap;\n\n    for (int i = 0; i < grid.size(); ++i) {\n      ranges::sort(grid[i], greater<>());\n      for (int j = 0; j < limits[i]; ++j) {\n        minHeap.push(grid[i][j]);\n        if (minHeap.size() == k + 1)\n          minHeap.pop();\n      }\n    }\n\n    while (!minHeap.empty())\n      ans += minHeap.top(), minHeap.pop();\n\n    return ans;\n  }\n};\n", "3463": "class Solution {\n public:\n  // Same as 3461. Check If Digits Are Equal in String After Operations I\n  bool hasSameDigits(const string& s) {\n    const int n = s.length();\n    int num1 = 0;\n    int num2 = 0;\n\n    for (int i = 0; i + 1 < n; ++i) {\n      const int coefficient = nCkMod10(n - 2, i);\n      num1 += (coefficient * (s[i] - '0')) % 10;\n      num1 %= 10;\n      num2 += (coefficient * (s[i + 1] - '0')) % 10;\n      num2 %= 10;\n    }\n\n    return num1 == num2;\n  }\n\n private:\n  // Returns (n, k) % 10.\n  int nCkMod10(int n, int k) {\n    const int mod2 = lucasTheorem(n, k, 2);\n    const int mod5 = lucasTheorem(n, k, 5);\n    static constexpr int lookup[2][5] = {\n        {0, 6, 2, 8, 4},  // mod2 == 0\n        {5, 1, 7, 3, 9}   // mod2 == 1\n    };\n    return lookup[mod2][mod5];\n  }\n\n  // Returns (n, k) % prime.\n  int lucasTheorem(int n, int k, int prime) {\n    int res = 1;\n    while (n > 0 || k > 0) {\n      const int nMod = n % prime;\n      const int kMod = k % prime;\n      res *= nCk(nMod, kMod);\n      res %= prime;\n      n /= prime;\n      k /= prime;\n    }\n    return res;\n  }\n\n  // Returns (n, k).\n  int nCk(int n, int k) {\n    int res = 1;\n    for (int i = 0; i < k; ++i) {\n      res *= (n - i);\n      res /= (i + 1);\n    }\n    return res;\n  }\n};\n", "3464": "struct Sequence {\n  int startX;\n  int startY;\n  int endX;\n  int endY;\n  int length;\n};\n\nclass Solution {\n public:\n  int maxDistance(int side, vector<vector<int>>& points, int k) {\n    const vector<pair<int, int>> ordered = getOrderedPoints(side, points);\n    int l = 0;\n    int r = side;\n\n    while (l < r) {\n      const int m = (l + r + 1) / 2;\n      if (isValidDistance(ordered, k, m))\n        l = m;\n      else\n        r = m - 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if we can select `k` points such that the minimum Manhattan\n  // distance between any two consecutive chosen points is at least `m`.\n  bool isValidDistance(const vector<pair<int, int>>& ordered, int k, int d) {\n    deque<Sequence> dq{{ordered[0].first, ordered[0].second, ordered[0].first,\n                        ordered[0].second, 1}};\n    int maxLength = 1;\n\n    for (int i = 1; i < ordered.size(); ++i) {\n      const auto& [x, y] = ordered[i];\n      int startX = x;\n      int startY = y;\n      int length = 1;\n      while (!dq.empty() &&\n             (abs(x - dq.front().endX) + abs(y - dq.front().endY) >= d)) {\n        if (abs(x - dq.front().startX) + abs(y - dq.front().startY) >= d &&\n            dq.front().length + 1 >= length) {\n          startX = dq.front().startX;\n          startY = dq.front().startY;\n          length = dq.front().length + 1;\n          maxLength = max(maxLength, length);\n        }\n        dq.pop_front();\n      }\n      dq.emplace_back(startX, startY, x, y, length);\n    }\n\n    return maxLength >= k;\n  }\n\n  // Returns the ordered points on the perimeter of a square of side length\n  // `side`, starting from left, top, right, and bottom boundaries.\n  vector<pair<int, int>> getOrderedPoints(int side,\n                                          vector<vector<int>>& points) {\n    vector<pair<int, int>> left;\n    vector<pair<int, int>> top;\n    vector<pair<int, int>> right;\n    vector<pair<int, int>> bottom;\n\n    for (const vector<int>& point : points) {\n      const int x = point[0];\n      const int y = point[1];\n      if (x == 0 && y > 0)\n        left.emplace_back(x, y);\n      else if (x > 0 && y == side)\n        top.emplace_back(x, y);\n      else if (x == side && y < side)\n        right.emplace_back(x, y);\n      else\n        bottom.emplace_back(x, y);\n    }\n\n    ranges::sort(left);\n    ranges::sort(top);\n    ranges::sort(right, greater<>());\n    ranges::sort(bottom, greater<>());\n    left.insert(left.end(), top.begin(), top.end());\n    left.insert(left.end(), right.begin(), right.end());\n    left.insert(left.end(), bottom.begin(), bottom.end());\n    return left;\n  }\n};\n", "3466": "class Solution {\n public:\n  long long maxCoins(vector<int>& lane1, vector<int>& lane2) {\n    // dp[k] := the maximum number of coins at mile so far with k switches\n    vector<long> dp = {lane1[0], lane2[0], LONG_MIN};\n    long ans = ranges::max(dp);\n\n    for (int i = 1; i < lane1.size(); ++i) {\n      dp = {max(0L, dp[0]) + lane1[i],           //\n            max({0L, dp[0], dp[1]}) + lane2[i],  //\n            max(dp[1], dp[2]) + lane1[i]};\n      ans = max(ans, ranges::max(dp));\n    }\n\n    return ans;\n  }\n};\n", "3467": "class Solution {\n public:\n  vector<int> transformArray(vector<int>& nums) {\n    vector<int> ans;\n    vector<int> count(2);\n\n    for (const int num : nums)\n      ++count[num % 2];\n\n    ans.insert(ans.end(), count[0], 0);\n    ans.insert(ans.end(), count[1], 1);\n    return ans;\n  }\n};\n", "3468": "class Solution {\n public:\n  int countArrays(vector<int>& original, vector<vector<int>>& bounds) {\n    int mn = bounds[0][0];\n    int mx = bounds[0][1];\n\n    for (int i = 1; i < original.size(); ++i) {\n      const int diff = original[i] - original[i - 1];\n      mn = max(mn + diff, bounds[i][0]);\n      mx = min(mx + diff, bounds[i][1]);\n    }\n\n    return max(0, mx - mn + 1);\n  }\n};\n", "3469": "class Solution {\n public:\n  // Main function to start the calculation\n  int minCost(vector<int>& nums) {\n    const int n = nums.size();\n    vector<vector<int>> mem(n + 1, vector<int>(n + 1, -1));\n    return minCost(/*last=*/0, 1, nums, mem);\n  }\n\n private:\n  int minCost(int last, int i, vector<int>& nums, vector<vector<int>>& mem) {\n    const int n = nums.size();\n    if (i == n)  // Single element left.\n      return nums[last];\n    if (i == n - 1)  // Two elements left.\n      return max(nums[last], nums[i]);\n    if (mem[i][last] != -1)\n      return mem[i][last];\n    const int a = max(nums[i], nums[i + 1]) + minCost(last, i + 2, nums, mem);\n    const int b = max(nums[last], nums[i]) + minCost(i + 1, i + 2, nums, mem);\n    const int c = max(nums[last], nums[i + 1]) + minCost(i, i + 2, nums, mem);\n    return mem[i][last] = min({a, b, c});\n  }\n};\n", "347": "class Solution {\n public:\n  vector<int> topKFrequent(vector<int>& nums, int k) {\n    const int n = nums.size();\n    vector<int> ans;\n    vector<vector<int>> bucket(n + 1);\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count)\n      bucket[freq].push_back(num);\n\n    for (int freq = n; freq > 0; --freq) {\n      for (const int num : bucket[freq])\n        ans.push_back(num);\n      if (ans.size() == k)\n        return ans;\n    }\n\n    throw;\n  }\n};\n", "3471": "class Solution {\n public:\n  int largestInteger(vector<int>& nums, int k) {\n    if (k == nums.size())\n      return ranges::max(nums);\n    const vector<int> count = getCount(nums);\n    if (k == 1)\n      return maxUnique(nums, count);\n    return max(count[nums.front()] == 1 ? nums.front() : -1,\n               count[nums.back()] == 1 ? nums.back() : -1);\n  }\n\n private:\n  // Returns the maximum unique integer in nums if any. Otherwise, returns -1.\n  int maxUnique(const vector<int>& nums, const vector<int>& count) {\n    int maxUnique = -1;\n    for (const int num : nums)\n      if (count[num] == 1)\n        maxUnique = max(maxUnique, num);\n    return maxUnique;\n  }\n\n  vector<int> getCount(const vector<int>& nums) {\n    constexpr int kMax = 50;\n    vector<int> count(kMax + 1);\n    for (const int num : nums)\n      ++count[num];\n    return count;\n  }\n};\n", "3472": "class Solution {\n public:\n  // Similar to 516. Longest Palindromic Subsequence\n  int longestPalindromicSubsequence(string s, int k) {\n    const int n = s.length();\n    // dp[i][j][op] := the length of LPS(s[i..j]) with at most `op` operations\n    vector<vector<vector<int>>> dp(n,\n                                   vector<vector<int>>(n, vector<int>(k + 1)));\n\n    for (int i = 0; i < n; ++i)\n      for (int op = 0; op <= k; ++op)\n        dp[i][i][op] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        for (int op = 0; op <= k; ++op) {\n          if (s[i] == s[j]) {\n            dp[i][j][op] = 2 + dp[i + 1][j - 1][op];\n          } else {\n            dp[i][j][op] = max(dp[i + 1][j][op], dp[i][j - 1][op]);\n            const int cost = getCost(s[i], s[j]);\n            if (cost <= op)\n              dp[i][j][op] = max(dp[i][j][op], 2 + dp[i + 1][j - 1][op - cost]);\n          }\n        }\n      }\n\n    return dp[0][n - 1][k];\n  }\n\n private:\n  int getCost(char a, char b) {\n    const int dist = abs(a - b);\n    return min(dist, 26 - dist);\n  }\n};\n", "3473": "class Solution {\n public:\n  int maxSum(vector<int>& nums, int k, int m) {\n    constexpr int kInf = 20000000;\n    const int n = nums.size();\n    vector<int> prefix(n + 1);\n    // dp[i][ongoing][r] := the maximum sum of nums[i..n - 1], with `ongoing`\n    // indicating if a subarray is currently being extended (1) or not (0), and\n    // `r` segments left to choose\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(2, vector<int>(k + 1, -kInf)));\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n\n    // Base case: At the end of the array, if no segments are left, score is 0.\n    dp[n][0][0] = dp[n][1][0] = 0;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int rem = 0; rem <= k; ++rem) {\n        // When no subarray is ongoing:\n        // 1. Skip nums[i].\n        dp[i][0][rem] = dp[i + 1][0][rem];\n        // 2. Start a new segment of length m (only if rem > 0 and there're\n        // enough elements)\n        if (rem > 0 && i + m <= n)\n          dp[i][0][rem] = max(dp[i][0][rem], dp[i + m][1][rem - 1] +\n                                                 (prefix[i + m] - prefix[i]));\n        // When a subarray is ongoing:\n        // 1. End the current subarray (transition to state 0, same index i)\n        // 2. Extend the current subarray by picking nums[i] and move to i + 1\n        dp[i][1][rem] = max(dp[i][0][rem], dp[i + 1][1][rem] + nums[i]);\n      }\n\n    return dp[0][0][k];\n  }\n};\n", "3474": "class Solution {\n public:\n  string generateString(string str1, string str2) {\n    const int n = str1.length();\n    const int m = str2.length();\n    const int sz = n + m - 1;\n    string ans(sz, '\\0');\n    vector<bool> modifiable(sz, true);\n\n    // 1. Handle all 'T' positions first.\n    for (int i = 0; i < n; ++i)\n      if (str1[i] == 'T')\n        for (int j = 0; j < m; ++j) {\n          const int pos = i + j;\n          if (ans[pos] && ans[pos] != str2[j])\n            return \"\";\n          ans[pos] = str2[j];\n          modifiable[pos] = false;\n        }\n\n    // 2. Fill all remaining positions with 'a'.\n    for (int i = 0; i < sz; ++i)\n      if (ans[i] == '\\0')\n        ans[i] = 'a';\n\n    // 3. Handle all 'F' positions.\n    for (int i = 0; i < n; ++i)\n      if (str1[i] == 'F' && match(ans, i, str2)) {\n        const int modifiablePos = lastModifiablePosition(i, m, modifiable);\n        if (modifiablePos == -1)\n          return \"\";\n        ans[modifiablePos] = 'b';\n        modifiable[modifiablePos] = false;\n      }\n\n    return ans;\n  }\n\n private:\n  // Returns true if the substring of ans starting at `i` matches `s`.\n  bool match(string& ans, int i, string& s) {\n    for (int j = 0; j < s.length(); ++j)\n      if (ans[i + j] != s[j])\n        return false;\n    return true;\n  }\n\n  // Finds the last modifiable position in the substring ans starting at `i`.\n  int lastModifiablePosition(int i, int m, vector<bool>& modifiable) {\n    int modifiablePos = -1;\n    for (int j = 0; j < m; ++j) {\n      const int pos = i + j;\n      if (modifiable[pos])\n        modifiablePos = pos;\n    }\n    return modifiablePos;\n  }\n};\n", "3476": "class Solution {\n public:\n  long long maxProfit(vector<int>& workers, vector<vector<int>>& tasks) {\n    long totalProfit = 0;\n    int maxRemainingProfit = 0;\n    unordered_map<int, vector<int>> skillToProfits;\n\n    for (const vector<int>& task : tasks) {\n      const int skill = task[0];\n      const int profit = task[1];\n      skillToProfits[skill].push_back(profit);\n    }\n\n    for (auto& [_, profits] : skillToProfits)\n      ranges::sort(profits, greater<int>());\n\n    for (const int workerSkill : workers)\n      if (skillToProfits.contains(workerSkill) &&\n          !skillToProfits[workerSkill].empty()) {\n        const int profit = skillToProfits[workerSkill][0];\n        skillToProfits[workerSkill].erase(skillToProfits[workerSkill].begin());\n        totalProfit += profit;\n      }\n\n    for (const auto& [_, profits] : skillToProfits)\n      if (!profits.empty())\n        maxRemainingProfit = max(maxRemainingProfit, profits[0]);\n\n    return totalProfit + maxRemainingProfit;\n  }\n};\n", "3477": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns the first index i where baskets[i] >= target, or -1 if not found.\n  int queryFirst(int target) {\n    return queryFirst(0, 0, n - 1, target);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = nums[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int queryFirst(int treeIndex, int lo, int hi, int target) {\n    if (tree[treeIndex] < target)\n      return -1;\n    if (lo == hi) {\n      // Found a valid position, mark it as used by setting to -1.\n      update(lo, -1);\n      return lo;\n    }\n    const int mid = (lo + hi) / 2;\n    const int leftChild = tree[2 * treeIndex + 1];\n    return leftChild >= target\n               ? queryFirst(2 * treeIndex + 1, lo, mid, target)\n               : queryFirst(2 * treeIndex + 2, mid + 1, hi, target);\n  }\n\n  int merge(int left, int right) const {\n    return max(left, right);\n  }\n};\n\nclass Solution {\n public:\n  int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {\n    int ans = 0;\n    SegmentTree tree(baskets);\n\n    for (const int fruit : fruits)\n      if (tree.queryFirst(fruit) == -1)\n        ++ans;\n\n    return ans;\n  }\n};\n", "3478": "class Solution {\n public:\n  vector<long long> findMaxSum(vector<int>& nums1, vector<int>& nums2, int k) {\n    const int n = nums1.size();\n    vector<long long> ans(n);\n    vector<pair<int, int>> numAndIndexes;\n    priority_queue<long long, vector<long long>, greater<long long>> minHeap;\n\n    for (int i = 0; i < n; i++)\n      numAndIndexes.emplace_back(nums1[i], i);\n\n    ranges::sort(numAndIndexes);\n\n    const int firstIndex = numAndIndexes[0].second;\n    minHeap.push(nums2[firstIndex]);\n    long sum = nums2[firstIndex];\n\n    for (int i = 1; i < n; ++i) {\n      const auto& [currNum, currIndex] = numAndIndexes[i];\n      const auto& [prevNum, prevIndex] = numAndIndexes[i - 1];\n      if (currNum == prevNum)\n        ans[currIndex] = ans[prevIndex];\n      else\n        ans[currIndex] = sum;\n      minHeap.push(nums2[currIndex]);\n      sum += nums2[currIndex];\n      if (minHeap.size() == k + 1)\n        sum -= minHeap.top(), minHeap.pop();\n    }\n\n    return ans;\n  }\n};\n", "3479": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns the first index i where baskets[i] >= target, or -1 if not found.\n  int queryFirst(int target) {\n    return queryFirst(0, 0, n - 1, target);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = nums[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int queryFirst(int treeIndex, int lo, int hi, int target) {\n    if (tree[treeIndex] < target)\n      return -1;\n    if (lo == hi) {\n      // Found a valid position, mark it as used by setting to -1.\n      update(lo, -1);\n      return lo;\n    }\n    const int mid = (lo + hi) / 2;\n    const int leftChild = tree[2 * treeIndex + 1];\n    return leftChild >= target\n               ? queryFirst(2 * treeIndex + 1, lo, mid, target)\n               : queryFirst(2 * treeIndex + 2, mid + 1, hi, target);\n  }\n\n  int merge(int left, int right) const {\n    return max(left, right);\n  }\n};\n\nclass Solution {\n public:\n  // Same as 3477. Fruits Into Baskets II\n  int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {\n    int ans = 0;\n    SegmentTree tree(baskets);\n\n    for (const int fruit : fruits)\n      if (tree.queryFirst(fruit) == -1)\n        ++ans;\n\n    return ans;\n  }\n};\n", "348": "class TicTacToe {\n public:\n  TicTacToe(int n) : n(n), rows(n), cols(n) {}\n\n  /**\n   * Player {player} makes a move at ({row}, {col}).\n   *\n   * @param row    The row of the board.\n   * @param col    The column of the board.\n   * @param player The player, can be either 1 or 2.\n   * @return The current winning condition, can be either:\n   *         0: No one wins.\n   *         1: Player 1 wins.\n   *         2: Player 2 wins.\n   */\n  int std::move(int row, int col, int player) {\n    const int toAdd = player == 1 ? 1 : -1;\n    const int target = player == 1 ? n : -n;\n\n    if (row == col) {\n      diag += toAdd;\n      if (diag == target)\n        return player;\n    }\n\n    if (row + col == n - 1) {\n      antiDiag += toAdd;\n      if (antiDiag == target)\n        return player;\n    }\n\n    rows[row] += toAdd;\n    if (rows[row] == target)\n      return player;\n\n    cols[col] += toAdd;\n    if (cols[col] == target)\n      return player;\n\n    return 0;\n  }\n\n private:\n  const int n;\n  // Record count('X') - count('O').\n  vector<int> rows;\n  vector<int> cols;\n  int diag = 0;\n  int antiDiag = 0;\n};\n", "3480": "class Solution {\n public:\n  long long maxSubarrays(int n, vector<vector<int>>& conflictingPairs) {\n    long validSubarrays = 0;\n    int maxLeft = 0;\n    int secondMaxLeft = 0;\n    // gains[i] := the number of additional valid subarrays we can gain if the\n    // restriction at index `i` is removed\n    vector<long> gains(n + 1);\n    // conflicts[r] := left endpoints that conflict with subarrays ending in r\n    vector<vector<int>> conflicts(n + 1);\n\n    for (const vector<int>& pair : conflictingPairs) {\n      const int a = pair[0];\n      const int b = pair[1];\n      conflicts[max(a, b)].push_back(min(a, b));\n    }\n\n    for (int right = 1; right <= n; ++right) {\n      for (const int left : conflicts[right]) {\n        if (left > maxLeft) {\n          secondMaxLeft = maxLeft;\n          maxLeft = left;\n        } else if (left > secondMaxLeft) {\n          secondMaxLeft = left;\n        }\n      }\n      // Subarrays [maxLeft + 1..right],\n      //           [maxLeft + 2..right],\n      //           ...\n      //           [right..right] are valid.\n      validSubarrays += right - maxLeft;\n      // If we remove `maxLeft` (the most restrictive conflict), we gain\n      // `maxLeft - secondMaxLeft` new subarrays:\n      // [secondMaxLeft + 1..right],\n      // [secondMaxLeft + 2..right],\n      // ...\n      // [maxLeft..right].\n      gains[maxLeft] += maxLeft - secondMaxLeft;\n    }\n\n    return validSubarrays + ranges::max(gains);\n  }\n};\n", "3481": "class Solution {\n public:\n  string applySubstitutions(vector<vector<string>>& replacements, string text) {\n    unordered_map<string, string> replaceMap;\n\n    for (const vector<string>& replacement : replacements) {\n      const string& key = replacement[0];\n      const string& value = replacement[1];\n      replaceMap[key] = value;\n    }\n\n    return evaluate(text, replaceMap);\n  }\n\n private:\n  // Evaluates the `text` and replaces the placeholders with the values\n  // from the `replaceMap` recursively.\n  string evaluate(const string& text,\n                  const unordered_map<string, string>& replaceMap) {\n    string res;\n    int i = 0;\n    while (i < text.length())\n      if (text[i] == '%') {\n        const int j = i + 1 + text.substr(i + 1).find('%');\n        const string key = text.substr(i + 1, j - i - 1);\n        const string value = replaceMap.at(key);\n        res += evaluate(value, replaceMap);\n        i = j + 1;\n      } else {\n        res += text[i++];\n      }\n    return res;\n  }\n};\n", "3483": "class Solution {\n public:\n  int totalNumbers(vector<int>& digits) {\n    unordered_set<int> nums;\n    vector<int> perm = digits;\n\n    ranges::sort(perm);\n\n    do {\n      const int a = perm[0];\n      const int b = perm[1];\n      const int c = perm[2];\n      if (a != 0 && c % 2 == 0)\n        nums.insert(a * 100 + b * 10 + c);\n    } while (next_permutation(perm.begin(), perm.end()));\n\n    return nums.size();\n  }\n};\n", "3484": "class Spreadsheet {\n public:\n  Spreadsheet(int rows) {}\n\n  void setCell(string cell, int value) {\n    spreadsheet[cell] = value;\n  }\n\n  void resetCell(string cell) {\n    spreadsheet[cell] = 0;\n  }\n\n  int getValue(string formula) {\n    const int i = formula.find('+');\n    return getToken(formula.substr(1, i - 1)) + getToken(formula.substr(i + 1));\n  }\n\n private:\n  unordered_map<string, int> spreadsheet;\n\n  int getToken(const string& token) {\n    return isdigit(token[0])\n               ? stoi(token)\n               : (spreadsheet.contains(token) ? spreadsheet[token] : 0);\n  }\n};\n", "3485": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int count = 0;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  Trie(int k) : k(k) {}\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = 0; i < word.length(); ++i) {\n      const int sz = i + 1;\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        node->children[index] = make_shared<TrieNode>();\n      node = node->children[index];\n      ++node->count;\n      if (node->count >= k && prefixLengthsCount[sz]++ == 0)\n        prefixLengths.insert(sz);\n    }\n  }\n\n  void erase(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = 0; i < word.length(); ++i) {\n      const int sz = i + 1;\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        node->children[index] = make_shared<TrieNode>();\n      node = node->children[index];\n      if (node->count == k && prefixLengthsCount[sz]-- == 1)\n        prefixLengths.erase(sz);\n      --node->count;\n    }\n  }\n\n  int getLongestCommonPrefix() const {\n    return prefixLengths.empty() ? 0 : *prefixLengths.begin();\n  }\n\n private:\n  const int k;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n  unordered_map<int, int> prefixLengthsCount;\n  set<int, greater<>> prefixLengths;\n};\n\nclass Solution {\n public:\n  vector<int> longestCommonPrefix(vector<string>& words, int k) {\n    vector<int> ans;\n    Trie trie(k);\n\n    for (const string& word : words)\n      trie.insert(word);\n\n    for (const string& word : words) {\n      trie.erase(word);\n      ans.push_back(trie.getLongestCommonPrefix());\n      trie.insert(word);\n    }\n\n    return ans;\n  }\n};\n", "3486": "class Solution {\n public:\n  vector<int> longestSpecialPath(vector<vector<int>>& edges,\n                                 vector<int>& nums) {\n    vector<vector<pair<int, int>>> graph(nums.size());\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    int maxLength = 0;\n    int minNodes = 1;\n    dfs(graph, 0, -1, /*leftBoundary=*/{0, 0}, /*prefix=*/{0},\n        /*lastSeenDepth=*/{}, nums, maxLength, minNodes);\n    return {maxLength, minNodes};\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev,\n           vector<int> leftBoundary, vector<int>&& prefix,\n           unordered_map<int, int>&& lastSeenDepth, const vector<int>& nums,\n           int& maxLength, int& minNodes) {\n    const int prevDepth = lastSeenDepth[nums[u]];\n    lastSeenDepth[nums[u]] = prefix.size();\n\n    if (prevDepth != 0) {\n      leftBoundary.push_back(prevDepth);\n      ranges::sort(leftBoundary);\n      leftBoundary = {leftBoundary[leftBoundary.size() - 2],\n                      leftBoundary.back()};\n    }\n\n    const int length = prefix.back() - prefix[leftBoundary[0]];\n    const int nodes = prefix.size() - leftBoundary[0];\n    if (length > maxLength || (length == maxLength && nodes < minNodes)) {\n      maxLength = length;\n      minNodes = nodes;\n    }\n\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      prefix.push_back(prefix.back() + w);\n      dfs(graph, v, u, leftBoundary, std::move(prefix),\n          std::move(lastSeenDepth), nums, maxLength, minNodes);\n      prefix.pop_back();\n    }\n\n    lastSeenDepth[nums[u]] = prevDepth;\n  }\n};\n", "3487": "class Solution {\n public:\n  int maxSum(vector<int>& nums) {\n    const int mx = ranges::max(nums);\n    if (mx <= 0)\n      return mx;\n    unordered_set<int> numsSet(nums.begin(), nums.end());\n    return accumulate(numsSet.begin(), numsSet.end(), 0,\n                      [](int acc, int num) { return acc + max(0, num); });\n  }\n};\n", "3488": "class Solution {\n public:\n  vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {\n    const int n = nums.size();\n    vector<int> ans;\n    // minDist[i] := the minimum distance between nums[i], and any other index j\n    // in the circular array, where nums[j] == nums[i]\n    vector<int> minDist(n, n);\n    unordered_map<int, int> lastSeen;\n\n    for (int i = 0; i < n * 2; ++i) {\n      const int index = i % n;\n      const int num = nums[index];\n      if (const auto it = lastSeen.find(num); it != lastSeen.cend()) {\n        const int prevIndex = it->second % n;\n        const int d = i - prevIndex;\n        minDist[index] = min(minDist[index], d);\n        minDist[prevIndex] = min(minDist[prevIndex], d);\n      }\n      lastSeen[num] = i;\n    }\n\n    for (const int query : queries)\n      ans.push_back(minDist[query] == n ? -1 : minDist[query]);\n\n    return ans;\n  }\n};\n", "3489": "class Solution {\n public:\n  int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n    if (all_of(nums.begin(), nums.end(), [](int num) { return num == 0; }))\n      return 0;\n\n    const int n = nums.size();\n    vector<unordered_set<int>> subsetSums(n);\n\n    for (int i = 0; i < n; ++i)\n      subsetSums[i].insert(0);\n\n    for (int k = 0; k < queries.size(); ++k) {\n      const int l = queries[k][0];\n      const int r = queries[k][1];\n      const int val = queries[k][2];\n      for (int i = l; i <= r; ++i) {\n        vector<int> sums;\n        for (const int subsetSum : subsetSums[i])\n          sums.push_back(subsetSum + val);\n        for (const int sum : sums)\n          subsetSums[i].insert(sum);\n      }\n      if (canFormAllNumbers(subsetSums, nums))\n        return k + 1;\n    }\n\n    return -1;\n  }\n\n  bool canFormAllNumbers(const vector<unordered_set<int>>& subsetSums,\n                         const vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (!subsetSums[i].contains(nums[i]))\n        return false;\n    return true;\n  }\n};\n", "349": "class Solution {\n public:\n  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> ans;\n    unordered_set<int> set{nums1.begin(), nums1.end()};\n\n    for (const int num : nums2)\n      if (set.erase(num))\n        ans.push_back(num);\n\n    return ans;\n  }\n};\n", "3490": "class Solution {\n public:\n  int beautifulNumbers(int l, int r) {\n    return count(to_string(r), 0, /*tight=*/true, /*isLeadingZero=*/true,\n                 /*hasZero=*/false, /*sum=*/0, /*prod=*/1, {}) -\n           count(to_string(l - 1), 0, /*tight=*/true, /*isLeadingZero=*/true,\n                 /*hasZero=*/false, /*sum=*/0, /*prod=*/1, {});\n  }\n\n private:\n  int count(const string& s, int i, bool tight, bool isLeadingZero,\n            bool hasZero, int sum, int prod, unordered_map<string, int>&& mem) {\n    if (i == s.length()) {\n      if (isLeadingZero)\n        return 0;\n      return (hasZero || prod % sum == 0) ? 1 : 0;\n    }\n    const string key = hash(i, tight, isLeadingZero, hasZero, sum, prod);\n    if (!isLeadingZero && hasZero && !tight)\n      return mem[key] = pow(10, s.length() - i);\n    if (const auto it = mem.find(key); it != mem.end())\n      return it->second;\n\n    int res = 0;\n    const int maxDigit = tight ? s[i] - '0' : 9;\n\n    for (int d = 0; d <= maxDigit; ++d) {\n      const bool nextTight = tight && (d == maxDigit);\n      const bool nextIsLeadingZero = isLeadingZero && d == 0;\n      const bool nextHasZero = !nextIsLeadingZero && d == 0;\n      const int nextProd = nextIsLeadingZero ? 1 : prod * d;\n      res += count(s, i + 1, nextTight, nextIsLeadingZero, nextHasZero, sum + d,\n                   nextProd, std::move(mem));\n    }\n\n    return mem[key] = res;\n  }\n\n  string hash(int i, bool tight, bool isLeadingZero, bool hasZero, int sum,\n              int prod) {\n    return to_string(i) + \"_\" + (tight ? \"1\" : \"0\") + \"_\" +\n           (isLeadingZero ? \"1\" : \"0\") + \"_\" + (hasZero ? \"1\" : \"0\") + \"_\" +\n           to_string(sum) + \"_\" + to_string(prod);\n  }\n};\n", "3491": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(10) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& number) {\n    shared_ptr<TrieNode> node = root;\n    for (const char d : number) {\n      const int i = d - '0';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  // Returns true if the number is a prefix of any number in the trie or any\n  // number in the trie is a prefix of the number.\n  bool search(const string& number) {\n    shared_ptr<TrieNode> node = root;\n    for (const char d : number) {\n      const int i = d - '0';\n      if (node->children[i] == nullptr)\n        return false;\n      node = node->children[i];\n      if (node->isWord)\n        return true;\n    }\n    return true;  // The number is a prefix of some number in the trie\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  bool phonePrefix(vector<string>& numbers) {\n    Trie trie;\n\n    for (const string& number : numbers) {\n      if (trie.search(number))\n        return false;\n      trie.insert(number);\n    }\n\n    return true;\n  }\n};\n", "3492": "class Solution {\n public:\n  int maxContainers(int n, int w, int maxWeight) {\n    return min(n * n, maxWeight / w);\n  }\n};\n", "3493": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int numberOfComponents(vector<vector<int>>& properties, int k) {\n    const int n = properties.size();\n    const vector<set<int>> propertySets = getPropertySets(properties);\n    UnionFind uf(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        vector<int> intersection;\n        std::set_intersection(propertySets[i].begin(), propertySets[i].end(),\n                              propertySets[j].begin(), propertySets[j].end(),\n                              std::back_inserter(intersection));\n        if (intersection.size() >= k)\n          uf.unionByRank(i, j);\n      }\n\n    return uf.getCount();\n  }\n\n private:\n  vector<set<int>> getPropertySets(const vector<vector<int>>& properties) {\n    vector<set<int>> propertySets;\n    for (const vector<int>& property : properties)\n      propertySets.push_back({property.begin(), property.end()});\n    return propertySets;\n  }\n};\n", "3494": "class Solution {\n public:\n  long long minTime(vector<int>& skill, vector<int>& mana) {\n    long sumSkill = accumulate(skill.begin(), skill.end(), 0L);\n    long prevWizardDone = sumSkill * mana[0];\n\n    for (int j = 1; j < mana.size(); ++j) {\n      long prevPotionDone = prevWizardDone;\n      for (int i = skill.size() - 2; i >= 0; --i) {\n        // start time for wizard i brewing potion j\n        // = max(end time for wizard i brewing potion j - 1,\n        //       the earliest start time for wizard i + 1 brewing potion j\n        //       (coming from previous iteration)\n        //       - time for wizard i brewing potion j)\n        prevPotionDone -= static_cast<long>(skill[i + 1]) * mana[j - 1];\n        prevWizardDone =\n            max(prevPotionDone,\n                prevWizardDone - static_cast<long>(skill[i]) * mana[j]);\n      }\n      prevWizardDone += sumSkill * mana[j];\n    }\n\n    return prevWizardDone;\n  }\n};\n", "3495": "class Solution {\n public:\n  long long minOperations(vector<vector<int>>& queries) {\n    long ans = 0;\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      ans += (getOperations(r) - getOperations(l - 1) + 1) / 2;\n    }\n    return ans;\n  }\n\n private:\n  // Returns the number of operations required for [1, n].\n  long getOperations(int n) {\n    long res = 0;\n    int ops = 0;\n    for (int powerOfFour = 1; powerOfFour <= n; powerOfFour *= 4) {\n      const int l = powerOfFour;\n      const int r = min(n, powerOfFour * 4 - 1);\n      res += static_cast<long>(r - l + 1) * ++ops;\n    }\n    return res;\n  }\n};\n", "3496": "class Solution {\n public:\n  int maxScore(vector<int>& nums) {\n    const int n = nums.size();\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (n % 2 == 1)\n      return sum - ranges::min(nums);\n    int minAdjacentSum = INT_MAX;\n    for (int i = 1; i < n; ++i)\n      minAdjacentSum = min(minAdjacentSum, nums[i - 1] + nums[i]);\n    return sum - minAdjacentSum;\n  }\n};\n", "3498": "class Solution {\n public:\n  int reverseDegree(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); ++i) {\n      const int reversePos = 26 - (s[i] - 'a');\n      ans += reversePos * (i + 1);\n    }\n    return ans;\n  }\n};\n", "3499": "#include <ranges>\n\nclass Solution {\n public:\n  int maxActiveSectionsAfterTrade(string s) {\n    vector<int> zeroGroupLengths;\n    int maxZeroMerge = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] == '0') {\n        if (i > 0 && s[i - 1] == '0')\n          ++zeroGroupLengths.back();\n        else\n          zeroGroupLengths.push_back(1);\n      }\n\n    for (const auto& [a, b] : zeroGroupLengths | views::pairwise)\n      maxZeroMerge = max(maxZeroMerge, a + b);\n\n    return ranges::count(s, '1') + maxZeroMerge;\n  }\n};\n", "35": "class Solution {\n public:\n  int searchInsert(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return m;\n      if (nums[m] < target)\n        l = m + 1;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n};\n", "350": "class Solution {\n public:\n  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    ranges::sort(nums1);\n    ranges::sort(nums2);\n\n    vector<int> ans;\n    int i = 0;  // nums1's index\n    int j = 0;  // nums2's index\n\n    while (i < nums1.size() && j < nums2.size())\n      if (nums1[i] < nums2[j]) {\n        ++i;\n      } else if (nums1[i] > nums2[j]) {\n        ++j;\n      } else {\n        ans.push_back(nums1[i]);\n        ++i;\n        ++j;\n      }\n\n    return ans;\n  }\n};\n", "3500": "class Solution {\n public:\n  long long minimumCost(vector<int>& nums, vector<int>& cost, int k) {\n    const int n = nums.size();\n    vector<long> prefixNums(n + 1);\n    vector<long> prefixCost(n + 1);\n    // dp[i] := the minimum cost to divide nums[i..n - 1] into subarrays\n    vector<long> dp(n + 1, LONG_MAX);\n\n    partial_sum(nums.begin(), nums.end(), prefixNums.begin() + 1);\n    partial_sum(cost.begin(), cost.end(), prefixCost.begin() + 1);\n    dp[n] = 0;\n\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i; j < n; ++j)\n        dp[i] =\n            min(dp[i], prefixNums[j + 1] * (prefixCost[j + 1] - prefixCost[i]) +\n                           k * (prefixCost[n] - prefixCost[i]) + dp[j + 1]);\n\n    return dp[0];\n  }\n};\n", "3501": "#include <ranges>\n\nstruct Group {\n  int start;\n  int length;\n};\n\nclass SparseTable {\n public:\n  SparseTable(const vector<int>& nums)\n      : n(nums.size()), st(std::bit_width(n) + 1, vector<int>(n + 1)) {\n    copy(nums.begin(), nums.end(), st[0].begin());\n    for (int i = 1; i <= bit_width(n); ++i)\n      for (int j = 0; j + (1 << i) <= n; ++j)\n        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n  }\n\n  // Returns max(nums[l..r]).\n  int query(unsigned l, unsigned r) const {\n    const int i = bit_width(r - l + 1) - 1;\n    return max(st[i][l], st[i][r - (1 << i) + 1]);\n  }\n\n private:\n  const unsigned n;\n  vector<vector<int>> st;  // st[i][j] := max(nums[j..j + 2^i - 1])\n};\n\nclass Solution {\n public:\n  vector<int> maxActiveSectionsAfterTrade(string s,\n                                          vector<vector<int>>& queries) {\n    const int n = s.length();\n    const int ones = ranges::count(s, '1');\n    const auto [zeroGroups, zeroGroupIndex] = getZeroGroups(s);\n    if (zeroGroups.empty())\n      return vector<int>(queries.size(), ones);\n\n    const SparseTable st(getZeroMergeLengths(zeroGroups));\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int l = query[0];\n      const int r = query[1];\n      const int left = zeroGroupIndex[l] == -1\n                           ? -1\n                           : (zeroGroups[zeroGroupIndex[l]].length -\n                              (l - zeroGroups[zeroGroupIndex[l]].start));\n      const int right = zeroGroupIndex[r] == -1\n                            ? -1\n                            : (r - zeroGroups[zeroGroupIndex[r]].start + 1);\n      const auto [startAdjacentGroupIndex, endAdjacentGroupIndex] =\n          mapToAdjacentGroupIndices(\n              zeroGroupIndex[l] + 1,\n              s[r] == '1' ? zeroGroupIndex[r] : zeroGroupIndex[r] - 1);\n      int activeSections = ones;\n      if (s[l] == '0' && s[r] == '0' &&\n          zeroGroupIndex[l] + 1 == zeroGroupIndex[r])\n        activeSections = max(activeSections, ones + left + right);\n      else if (startAdjacentGroupIndex <= endAdjacentGroupIndex)\n        activeSections = max(\n            activeSections,\n            ones + st.query(startAdjacentGroupIndex, endAdjacentGroupIndex));\n      if (s[l] == '0' &&\n          zeroGroupIndex[l] + 1 <=\n              (s[r] == '1' ? zeroGroupIndex[r] : zeroGroupIndex[r] - 1))\n        activeSections =\n            max(activeSections,\n                ones + left + zeroGroups[zeroGroupIndex[l] + 1].length);\n      if (s[r] == '0' && zeroGroupIndex[l] < zeroGroupIndex[r] - 1)\n        activeSections =\n            max(activeSections,\n                ones + right + zeroGroups[zeroGroupIndex[r] - 1].length);\n      ans.push_back(activeSections);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the zero groups and the index of the zero group that contains the\n  // i-th character.\n  pair<vector<Group>, vector<int>> getZeroGroups(const string& s) {\n    vector<Group> zeroGroups;\n    vector<int> zeroGroupIndex;\n    for (int i = 0; i < s.length(); i++) {\n      if (s[i] == '0') {\n        if (i > 0 && s[i - 1] == '0')\n          ++zeroGroups.back().length;\n        else\n          zeroGroups.push_back({i, 1});\n      }\n      zeroGroupIndex.push_back(zeroGroups.size() - 1);\n    }\n    return {zeroGroups, zeroGroupIndex};\n  }\n\n  // Returns the sums of the lengths of the adjacent groups.\n  vector<int> getZeroMergeLengths(const vector<Group>& zeroGroups) {\n    vector<int> zeroMergeLengths;\n    for (const auto& [a, b] : zeroGroups | views::pairwise)\n      zeroMergeLengths.push_back(a.length + b.length);\n    return zeroMergeLengths;\n  }\n\n  // Returns the indices of the adjacent groups that contain l and r completely.\n  //\n  // e.g.    groupIndices = [0, 1, 2, 3]\n  // adjacentGroupIndices = [0 (0, 1), 1 (1, 2), 2 (2, 3)]\n  // map(startGroupIndex = 1, endGroupIndex = 3) -> (1, 2)\n  pair<int, int> mapToAdjacentGroupIndices(int startGroupIndex,\n                                           int endGroupIndex) {\n    return {startGroupIndex, endGroupIndex - 1};\n  }\n};\n", "3502": "class Solution {\n public:\n  vector<int> minCosts(vector<int>& cost) {\n    vector<int> ans;\n    int minCost = INT_MAX;\n    for (const int c : cost) {\n      minCost = min(minCost, c);\n      ans.push_back(minCost);\n    }\n    return ans;\n  }\n};\n", "3503": "class Solution {\n public:\n  int longestPalindrome(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    vector<int> suffix = getPalindromeLengths(s, true);\n    vector<int> prefix = getPalindromeLengths(t, false);\n    int ans = max(ranges::max(suffix), ranges::max(prefix));\n    // dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    // in t[j]\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = n - 1; j >= 0; --j)\n        if (s[i] == t[j]) {\n          dp[i][j] = 2 + (i > 0 && j < n - 1 ? dp[i - 1][j + 1] : 0);\n          const int extend =\n              max(i + 1 < m ? suffix[i + 1] : 0, j > 0 ? prefix[j - 1] : 0);\n          ans = max(ans, dp[i][j] + extend);\n        }\n\n    return ans;\n  }\n\n private:\n  vector<int> getPalindromeLengths(const string& s, bool isSuffix) {\n    const int n = s.length();\n    // dp[i][j] := True if s[i..j] is a palindrome\n    vector<vector<bool>> dp(n, vector<bool>(n));\n    // lengths[i] := length of longest palindrome in s[i..n - 1]\n    vector<int> lengths(n);\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i; j < n; ++j)\n        if (s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1])) {\n          dp[i][j] = true;\n          const int index = isSuffix ? i : j;\n          lengths[index] = max(lengths[index], j - i + 1);\n        }\n    return lengths;\n  }\n};\n", "3504": "class Solution {\n public:\n  // 3503. Longest Palindrome After Substring Concatenation I\n  int longestPalindrome(string s, string t) {\n    const int m = s.length();\n    const int n = t.length();\n    vector<int> suffix = getPalindromeLengths(s, true);\n    vector<int> prefix = getPalindromeLengths(t, false);\n    int ans = max(ranges::max(suffix), ranges::max(prefix));\n    // dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    // in t[j]\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = n - 1; j >= 0; --j)\n        if (s[i] == t[j]) {\n          dp[i][j] = 2 + (i > 0 && j < n - 1 ? dp[i - 1][j + 1] : 0);\n          const int extend =\n              max(i + 1 < m ? suffix[i + 1] : 0, j > 0 ? prefix[j - 1] : 0);\n          ans = max(ans, dp[i][j] + extend);\n        }\n\n    return ans;\n  }\n\n private:\n  vector<int> getPalindromeLengths(const string& s, bool isSuffix) {\n    const int n = s.length();\n    // dp[i][j] := True if s[i..j] is a palindrome\n    vector<vector<bool>> dp(n, vector<bool>(n));\n    // lengths[i] := length of longest palindrome in s[i..n - 1]\n    vector<int> lengths(n);\n    for (int i = n - 1; i >= 0; --i)\n      for (int j = i; j < n; ++j)\n        if (s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1])) {\n          dp[i][j] = true;\n          const int index = isSuffix ? i : j;\n          lengths[index] = max(lengths[index], j - i + 1);\n        }\n    return lengths;\n  }\n};\n", "3505": "class Solution {\n public:\n  long long minOperations(vector<int>& nums, int x, int k) {\n    // minOps[i] := the minimum number of operations needed to make\n    // nums[i..i + x - 1] equal to the median\n    const vector<long> minOps = getMinOps(nums, x);\n    vector<vector<long>> mem(nums.size() + 1, vector<long>(k + 1, -1));\n    return minOperations(nums, x, 0, k, minOps, mem);\n  }\n\n private:\n  static constexpr long kInf = LONG_MAX / 2;\n\n  // Returns the minimum operations needed to have at least k non-overlapping\n  // subarrays of size x in nums[i..n - 1].\n  long minOperations(const vector<int>& nums, int x, int i, int k,\n                     const vector<long>& minOps, vector<vector<long>>& mem) {\n    if (k == 0)\n      return 0;\n    if (i == nums.size())\n      return kInf;\n    if (mem[i][k] != -1)\n      return mem[i][k];\n    const long skip = minOperations(nums, x, i + 1, k, minOps, mem);\n    const long pick =\n        i + x <= nums.size()\n            ? minOps[i] + minOperations(nums, x, i + x, k - 1, minOps, mem)\n            : kInf;\n    return mem[i][k] = min(skip, pick);\n  }\n\n  // Returns the minimum operations needed to make all elements in the window of\n  // size x equal to the median.\n  vector<long> getMinOps(const vector<int>& nums, int x) {\n    vector<long> minOps;\n    multiset<int> lower;\n    multiset<int> upper;\n    long lowerSum = 0;\n    long upperSum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      if (lower.empty() || nums[i] <= *lower.rbegin()) {\n        lower.insert(nums[i]);\n        lowerSum += nums[i];\n      } else {\n        upper.insert(nums[i]);\n        upperSum += nums[i];\n      }\n      if (i >= x) {\n        const int outNum = nums[i - x];\n        if (const auto it = lower.find(outNum); it != lower.cend()) {\n          lower.erase(it);\n          lowerSum -= outNum;\n        } else {\n          upper.erase(upper.find(outNum));\n          upperSum -= outNum;\n        }\n      }\n      // Balance the two multisets s.t.\n      // |lower| >= |upper| and |lower| - |upper| <= 1.\n      if (lower.size() < upper.size()) {\n        const int val = *upper.begin();\n        upper.erase(upper.begin());\n        lower.insert(val);\n        upperSum -= val;\n        lowerSum += val;\n      } else if (lower.size() - upper.size() > 1) {\n        const int val = *lower.rbegin();\n        lower.erase(prev(lower.end()));\n        upper.insert(val);\n        lowerSum -= val;\n        upperSum += val;\n      }\n      // Calculate operations needed to make all elements in the window equal\n      // to the median.\n      if (i >= x - 1) {\n        const int median = *lower.rbegin();\n        const long ops = (median * lower.size() - lowerSum) +\n                         (upperSum - median * upper.size());\n        minOps.push_back(ops);\n      }\n    }\n    return minOps;\n  }\n};\n", "3506": "class Solution {\n public:\n  long long minEliminationTime(vector<int>& timeReq, int splitTime) {\n    priority_queue<long, vector<long>, greater<>> minHeap{timeReq.begin(),\n                                                          timeReq.end()};\n    minHeap.pop();\n\n    while (true) {\n      const long bacterial = splitTime + minHeap.top();\n      minHeap.pop();\n      if (minHeap.empty())\n        return bacterial;\n      if (bacterial > minHeap.top()) {\n        minHeap.pop();\n        minHeap.push(bacterial);\n      }\n    }\n\n    throw;\n  }\n};\n", "3507": "#include <ranges>\n\nclass Solution {\n public:\n  int minimumPairRemoval(vector<int>& nums) {\n    int ans = 0;\n\n    while (hasInversion(nums)) {\n      vector<int> pairSums;\n      for (const auto& [a, b] : views::pairwise(nums))\n        pairSums.push_back(a + b);\n      const int minPairSum = ranges::min(pairSums);\n      const int minPairIndex =\n          ranges::find(pairSums, minPairSum) - pairSums.begin();\n      nums[minPairIndex] = minPairSum;\n      nums.erase(nums.begin() + minPairIndex + 1);\n      ++ans;\n    }\n\n    return ans;\n  }\n\n private:\n  bool hasInversion(const vector<int>& nums) {\n    for (const auto& [a, b] : views::pairwise(nums))\n      if (a > b)\n        return true;\n    return false;\n  }\n};\n", "3508": "struct Packet {\n  int source;\n  int destination;\n  int timestamp;\n\n  bool operator<(const Packet& other) const {\n    return source < other.source ||\n           (source == other.source && destination < other.destination) ||\n           (source == other.source && destination == other.destination &&\n            timestamp < other.timestamp);\n  }\n};\n\nclass Router {\n public:\n  Router(int memoryLimit) : memoryLimit(memoryLimit) {}\n\n  bool addPacket(int source, int destination, int timestamp) {\n    const Packet packet{source, destination, timestamp};\n    if (uniquePackets.find(packet) != uniquePackets.end())\n      return false;\n    if (packetQueue.size() == memoryLimit)\n      forwardPacket();\n    packetQueue.push(packet);\n    uniquePackets.insert(packet);\n    destinationTimestamps[destination].push_back(timestamp);\n    return true;\n  }\n\n  vector<int> forwardPacket() {\n    if (packetQueue.empty())\n      return {};\n    const Packet nextPacket = packetQueue.front();\n    packetQueue.pop();\n    uniquePackets.erase(nextPacket);\n    ++processedPacketIndex[nextPacket.destination];\n    return {nextPacket.source, nextPacket.destination, nextPacket.timestamp};\n  }\n\n  int getCount(int destination, int startTime, int endTime) {\n    if (destinationTimestamps.find(destination) == destinationTimestamps.end())\n      return 0;\n    const vector<int>& timestamps = destinationTimestamps[destination];\n    const int startIndex = processedPacketIndex[destination];\n    const auto lowerBound = lower_bound(timestamps.begin() + startIndex,\n                                        timestamps.end(), startTime);\n    const auto upperBound =\n        upper_bound(timestamps.begin() + startIndex, timestamps.end(), endTime);\n    return upperBound - lowerBound;\n  }\n\n private:\n  const int memoryLimit;\n  set<Packet> uniquePackets;\n  queue<Packet> packetQueue;\n  map<int, vector<int>> destinationTimestamps;\n  map<int, int> processedPacketIndex;\n};\n", "3509": "enum class State {\n  kFirst,     // first element - add to sum and start product\n  kSubtract,  // second element - subtract from sum and multiply product\n  kAdd        // third element - add to sum and multiply product\n};\n\nclass Solution {\n public:\n  int maxProduct(vector<int>& nums, int k, int limit) {\n    if (abs(k) > accumulate(nums.begin(), nums.end(), 0))\n      return -1;\n    unordered_map<string, int> mem;\n    const int ans = maxProduct(nums, 0, 1, State::kFirst, k, limit, mem);\n    return ans == kMin ? -1 : ans;\n  }\n\n private:\n  static constexpr int kMin = -5000;\n\n  int maxProduct(const vector<int>& nums, int i, int product, State state,\n                 int k, int limit, unordered_map<string, int>& mem) {\n    if (i == nums.size())\n      return k == 0 && state != State::kFirst && product <= limit ? product\n                                                                  : kMin;\n    const string key = to_string(i) + \",\" + to_string(k) + \",\" +\n                       to_string(product) + \",\" +\n                       to_string(static_cast<int>(state));\n    if (mem.contains(key))\n      return mem[key];\n    int res = maxProduct(nums, i + 1, product, state, k, limit, mem);\n    if (state == State::kFirst)\n      res = max(res, maxProduct(nums, i + 1, nums[i], State::kSubtract,\n                                k - nums[i], limit, mem));\n    if (state == State::kSubtract)\n      res = max(res, maxProduct(nums, i + 1, min(product * nums[i], limit + 1),\n                                State::kAdd, k + nums[i], limit, mem));\n    if (state == State::kAdd)\n      res = max(res, maxProduct(nums, i + 1, min(product * nums[i], limit + 1),\n                                State::kSubtract, k - nums[i], limit, mem));\n    return mem[key] = res;\n  }\n};\n", "351": "class Solution {\n public:\n  int numberOfPatterns(int m, int n) {\n    int ans = 0;\n    vector<vector<int>> across(10, vector<int>(10));\n    vector<bool> seen(10);\n\n    across[1][3] = across[3][1] = 2;\n    across[1][7] = across[7][1] = 4;\n    across[3][9] = across[9][3] = 6;\n    across[7][9] = across[9][7] = 8;\n    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] =\n        across[7][3] = across[4][6] = across[6][4] = 5;\n\n    ans += dfs(m, n, 1, 1, seen, across) * 4;  // 1, 3, 7, 9 are symmetric\n    ans += dfs(m, n, 2, 1, seen, across) * 4;  // 2, 4, 6, 8 are symmetric\n    ans += dfs(m, n, 5, 1, seen, across);      // 5\n    return ans;\n  }\n\n private:\n  int dfs(int m, int n, int u, int depth, vector<bool>& seen,\n          const vector<vector<int>>& across) {\n    if (depth > n)\n      return 0;\n\n    seen[u] = true;\n    int ans = depth >= m ? 1 : 0;\n\n    for (int v = 1; v <= 9; ++v) {\n      if (v == u || seen[v])\n        continue;\n      const int acrossed = across[u][v];\n      if (acrossed == 0 || seen[acrossed])\n        ans += dfs(m, n, v, depth + 1, seen, across);\n    }\n\n    seen[u] = false;\n    return ans;\n  }\n};\n", "3510": "class Solution {\n public:\n  int minimumPairRemoval(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    int inversionsCount = 0;\n    vector<int> nextIndices(n);\n    vector<int> prevIndices(n);\n    vector<long> values(nums.begin(), nums.end());\n\n    // Custom comparator for the set\n    auto comp = [](const pair<long, int>& a, const pair<long, int>& b) {\n      return a.first < b.first || (a.first == b.first && a.second < b.second);\n    };\n    set<pair<long, int>, decltype(comp)> pairSums(comp);\n\n    for (int i = 0; i < n; ++i) {\n      nextIndices[i] = i + 1;\n      prevIndices[i] = i - 1;\n    }\n\n    for (int i = 0; i < n - 1; ++i)\n      pairSums.insert({(long)nums[i] + nums[i + 1], i});\n\n    for (int i = 0; i < n - 1; ++i)\n      if (nums[i + 1] < nums[i])\n        ++inversionsCount;\n\n    while (inversionsCount > 0) {\n      ++ans;\n      auto smallestPair = *pairSums.begin();\n      pairSums.erase(pairSums.begin());\n\n      const long pairSum = smallestPair.first;\n      const int currIndex = smallestPair.second;\n      const int nextIndex = nextIndices[currIndex];\n      const int prevIndex = prevIndices[currIndex];\n\n      if (prevIndex >= 0) {\n        const long oldPairSum = values[prevIndex] + values[currIndex];\n        const long newPairSum = values[prevIndex] + pairSum;\n        pairSums.erase({oldPairSum, prevIndex});\n        pairSums.insert({newPairSum, prevIndex});\n        if (values[prevIndex] > values[currIndex])\n          --inversionsCount;\n        if (values[prevIndex] > pairSum)\n          ++inversionsCount;\n      }\n\n      if (values[nextIndex] < values[currIndex])\n        --inversionsCount;\n\n      const int nextNextIndex = (nextIndex < n) ? nextIndices[nextIndex] : n;\n      if (nextNextIndex < n) {\n        const long oldPairSum = values[nextIndex] + values[nextNextIndex];\n        const long newPairSum = pairSum + values[nextNextIndex];\n        pairSums.erase({oldPairSum, nextIndex});\n        pairSums.insert({newPairSum, currIndex});\n        if (values[nextNextIndex] < values[nextIndex])\n          --inversionsCount;\n        if (values[nextNextIndex] < pairSum)\n          ++inversionsCount;\n        prevIndices[nextNextIndex] = currIndex;\n      }\n\n      nextIndices[currIndex] = nextNextIndex;\n      values[currIndex] = pairSum;\n    }\n\n    return ans;\n  }\n};\n", "3511": "class Solution {\n public:\n  int makeArrayPositive(vector<int>& nums) {\n    constexpr long kMax = 1'000'000'000'000'000'000;\n    int ans = 0;\n    long minSum = nums[0] + nums[1];\n    vector<long> bigNums{nums.begin(), nums.end()};\n\n    for (int i = 2; i < bigNums.size(); ++i) {\n      const long a = bigNums[i - 2];\n      const long b = bigNums[i - 1];\n      const long c = bigNums[i];\n      minSum = min(minSum + c, a + b + c);\n      if (minSum <= 0) {\n        bigNums[i] = kMax;\n        minSum = kMax;\n        ++ans;\n      }\n    }\n\n    return ans;\n  }\n};\n", "3512": "class Solution {\n public:\n  int minOperations(vector<int>& nums, int k) {\n    return accumulate(nums.begin(), nums.end(), 0) % k;\n  }\n};\n", "3513": "class Solution {\n public:\n  int uniqueXorTriplets(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 3)\n      return n;\n    return 1 << (static_cast<int>(log2(n)) + 1);\n  }\n};\n", "3514": "class Solution {\n public:\n  int uniqueXorTriplets(vector<int>& nums) {\n    const int n = nums.size();\n    if (n == 1)\n      return 1;\n\n    unordered_set<int> pairs;\n    bitset<2048> triplets;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j)\n        pairs.insert(nums[i] ^ nums[j]);\n\n    for (const int pair : pairs)\n      for (const int num : nums)\n        triplets.set(pair ^ num);\n\n    return triplets.count();\n  }\n};\n", "3515": "class LazySegmentTree {\n public:\n  explicit LazySegmentTree(int n) : n(n), tree(4 * n), lazy(4 * n) {}\n\n  // Updates the range [l, r] by adding val.\n  void addRange(int l, int r, int val) {\n    addRange(0, 0, n - 1, l, r, val);\n  }\n\n  // Returns the value at index i.\n  int query(int i) {\n    return query(0, 0, n - 1, i);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n  vector<int> lazy;  // the lazy propagation array\n\n  void push(int treeIndex, int lo, int hi) {\n    if (lazy[treeIndex] == 0)\n      return;\n    tree[treeIndex] += lazy[treeIndex];\n    if (lo != hi) {\n      lazy[2 * treeIndex + 1] += lazy[treeIndex];\n      lazy[2 * treeIndex + 2] += lazy[treeIndex];\n    }\n    lazy[treeIndex] = 0;\n  }\n\n  void addRange(int treeIndex, int lo, int hi, int l, int r, int val) {\n    push(treeIndex, lo, hi);\n    if (r < lo || l > hi)  // [lo, hi] lies completely outside [l, r].\n      return;\n    if (l <= lo && hi <= r) {  // [lo, hi] lies completely inside [l, r].\n      lazy[treeIndex] += val;\n      push(treeIndex, lo, hi);\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    addRange(2 * treeIndex + 1, lo, mid, l, r, val);\n    addRange(2 * treeIndex + 2, mid + 1, hi, l, r, val);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i) {\n    push(treeIndex, lo, hi);\n    if (lo == hi)\n      return tree[treeIndex];\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      return query(2 * treeIndex + 1, lo, mid, i);\n    return query(2 * treeIndex + 2, mid + 1, hi, i);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> treeQueries(int n, vector<vector<int>>& edges,\n                          vector<vector<int>>& queries) {\n    LazySegmentTree tree(n);\n    vector<int> ans;\n    vector<vector<pair<int, int>>> graph(n + 1);\n    map<pair<int, int>, int> edgeWeights;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n      edgeWeights[{min(u, v), max(u, v)}] = w;\n    }\n\n    // DFS: Euler tour and parent/distance tracking\n    vector<int> inTime(n + 1);\n    vector<int> outTime(n + 1);\n    vector<int> dist(n + 1);\n    vector<int> parent(n + 1);\n    int time = 0;\n\n    dfs(graph, 1, /*prev=*/-1, time, inTime, outTime, dist, parent);\n\n    for (int i = 1; i <= n; ++i)\n      tree.addRange(inTime[i], inTime[i], dist[i]);\n\n    for (const vector<int>& query : queries) {\n      const int type = query[0];\n      if (type == 1) {\n        const int u = query[1];\n        const int v = query[2];\n        const int newWeight = query[3];\n        const auto key = pair<int, int>{min(u, v), max(u, v)};\n        const int oldWeight = edgeWeights[key];\n        const int delta = newWeight - oldWeight;\n        edgeWeights[key] = newWeight;\n        // Find child node (the one that's not the parent)\n        const int child = (parent[v] == u) ? v : u;\n        tree.addRange(inTime[child], outTime[child], delta);\n      } else {\n        const int x = query[1];\n        ans.push_back(tree.query(inTime[x]));\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev,\n           int& time, vector<int>& inTime, vector<int>& outTime,\n           vector<int>& dist, vector<int>& parent) {\n    inTime[u] = time++;\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      dist[v] = dist[u] + w;\n      parent[v] = u;\n      dfs(graph, v, u, time, inTime, outTime, dist, parent);\n    }\n    outTime[u] = time - 1;\n  }\n};\n", "3516": "class Solution {\n public:\n  int findClosest(int x, int y, int z) {\n    const int xz = abs(x - z);\n    const int yz = abs(y - z);\n    if (xz == yz)\n      return 0;\n    return xz < yz ? 1 : 2;\n  }\n};\n", "3517": "class Solution {\n public:\n  string smallestPalindrome(string s) {\n    const int n = s.length();\n    const string sortedHalf = getSortedHalf(s);\n    return sortedHalf + (n % 2 ? string(1, s[n / 2]) : \"\") +\n           reversed(sortedHalf);\n  }\n\n private:\n  string getSortedHalf(const string& s) {\n    string half = s.substr(0, s.length() / 2);\n    ranges::sort(half);\n    return half;\n  }\n\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n};\n", "3519": "class Solution {\n public:\n  int countNumbers(const string& l, const string& r, const int b) {\n    const vector<int> rDigits = convertToBaseB(r, b);\n    vector<int> lDigits = convertToBaseB(l, b);\n    vector<int> lMinus1Digits = convertToBaseB(decrement(l), b);\n    padToSameLength(lDigits, rDigits);\n    padToSameLength(lMinus1Digits, rDigits);\n    return (countWithMem(rDigits, b) - countWithMem(lMinus1Digits, b) + kMod) %\n           kMod;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  void padToSameLength(vector<int>& a, const vector<int>& b) {\n    a.insert(a.begin(), b.size() - a.size(), 0);\n  }\n\n  int countWithMem(const vector<int>& digits, const int b) {\n    vector<vector<vector<int>>> mem(digits.size(),\n                                    vector<vector<int>>(2, vector<int>(b, -1)));\n    return count(digits, 0, 0, true, b, mem);\n  }\n\n  int count(const vector<int>& num, int pos, int lastDigit, bool tight, int b,\n            vector<vector<vector<int>>>& mem) {\n    if (pos == num.size())\n      return 1;\n\n    if (mem[pos][tight][lastDigit] != -1)\n      return mem[pos][tight][lastDigit];\n\n    int res = 0;\n    const int limit = tight ? num[pos] : b - 1;\n\n    for (int d = lastDigit; d <= limit; d++) {\n      const bool newTight = tight && (d == limit);\n      res = (res + count(num, pos + 1, d, newTight, b, mem)) % kMod;\n    }\n\n    return mem[pos][tight][lastDigit] = res;\n  }\n\n  string decrement(string s) {\n    for (int i = s.length() - 1; i >= 0; --i) {\n      if (s[i] > '0') {\n        --s[i];\n        break;\n      } else {\n        s[i] = '9';\n      }\n    }\n    return s[0] == '0' && s.length() > 1 ? s.substr(1) : s;\n  }\n\n  vector<int> convertToBaseB(const string& numStr, const int b) {\n    vector<int> digits;\n    vector<int> currentNum(1, 0);\n\n    for (const char c : numStr) {\n      const int d = c - '0';\n\n      int carry = 0;\n      for (int i = 0; i < currentNum.size(); ++i) {\n        const long long product = (long long)currentNum[i] * 10 + carry;\n        currentNum[i] = product % b;\n        carry = product / b;\n      }\n\n      while (carry > 0) {\n        currentNum.push_back(carry % b);\n        carry /= b;\n      }\n\n      carry = d;\n      for (int i = 0; i < currentNum.size() && carry; ++i) {\n        const int sum = currentNum[i] + carry;\n        currentNum[i] = sum % b;\n        carry = sum / b;\n      }\n\n      while (carry > 0) {\n        currentNum.push_back(carry % b);\n        carry /= b;\n      }\n    }\n\n    for (int i = currentNum.size() - 1; i >= 0; --i)\n      digits.push_back(currentNum[i]);\n\n    if (digits.empty())\n      digits.push_back(0);\n\n    return digits;\n  }\n};\n", "352": "class SummaryRanges {\n public:\n  void addNum(int val) {\n    if (intervals.contains(val))\n      return;\n\n    const int lo = lowerKey(val);\n    const int hi = higherKey(val);\n\n    // {lo, intervals[lo][1]} + val + {hi, intervals[hi][1]} = {lo,\n    // intervals[hi][1]}\n    if (lo >= 0 && hi >= 0 && intervals[lo][1] + 1 == val && val + 1 == hi) {\n      intervals[lo][1] = intervals[hi][1];\n      intervals.erase(hi);\n      // {lo, intervals[lo][1]} + val = {lo, val}\n      // Prevent adding duplicate entry by using '>=' instead of '=='.\n    } else if (lo >= 0 && intervals[lo][1] + 1 >= val) {\n      intervals[lo][1] = max(intervals[lo][1], val);\n    } else if (hi >= 0 && val + 1 == hi) {\n      // val + {hi, intervals[hi][1]} = {val, intervals[hi][1]}\n      intervals[val] = {val, intervals[hi][1]};\n      intervals.erase(hi);\n    } else {\n      intervals[val] = {val, val};\n    }\n  }\n\n  vector<vector<int>> getIntervals() {\n    vector<vector<int>> res;\n    for (const auto& [_, interval] : intervals)\n      res.push_back(interval);\n    return res;\n  }\n\n private:\n  map<int, vector<int>> intervals;  // {start: (start, end)}\n\n  // Returns the maximum key in `intervals` < `key`.\n  int lowerKey(int key) {\n    auto it = intervals.lower_bound(key);\n    if (it == intervals.begin())\n      return -1;\n    return (--it)->first;\n  }\n\n  // Returns the minimum key in `intervals` > `key`.\n  int higherKey(int key) {\n    const auto it = intervals.upper_bound(key);\n    if (it == intervals.cend())\n      return -1;\n    return it->first;\n  }\n};\n", "3520": "class Solution {\n public:\n  int minThreshold(vector<int>& nums, int k) {\n    const int mx = ranges::max(nums);\n    int l = 0;\n    int r = mx + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (countInversionPairs(nums, k, m))\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l > mx ? -1 : l;\n  }\n\n private:\n  bool countInversionPairs(const vector<int>& nums, int k, int threshold) {\n    int inversionCount = 0;\n    vector<int> sortedNums;\n\n    for (const int num : nums) {\n      const auto lower = ranges::upper_bound(sortedNums, num);\n      const auto upper = ranges::upper_bound(sortedNums, num + threshold);\n      inversionCount += upper - lower;\n      sortedNums.insert(lower, num);\n    }\n\n    return inversionCount >= k;\n  }\n};\n", "3522": "class Solution {\n public:\n  long long calculateScore(vector<string>& instructions, vector<int>& values) {\n    const int n = instructions.size();\n    long ans = 0;\n    int i = 0;\n    vector<bool> seen(n);\n\n    while (i >= 0 && i < n && !seen[i]) {\n      seen[i] = true;\n      if (instructions[i] == \"add\") {\n        ans += values[i];\n        ++i;\n      } else if (instructions[i] == \"jump\") {\n        i += values[i];\n      }\n    }\n\n    return ans;\n  }\n};\n", "3523": "class Solution {\n public:\n  int maximumPossibleSize(vector<int>& nums) {\n    int ans = 0;\n    int prev = 0;\n\n    for (const int num : nums)\n      if (num >= prev) {\n        prev = num;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "3524": "class Solution {\n public:\n  vector<long long> resultArray(vector<int>& nums, int k) {\n    vector<long long> ans(k);\n    // dp[r] := the number of subarrays ending at current position with\n    // product % k == r\n    vector<long long> dp(k);\n\n    for (const int num : nums) {\n      vector<long long> newDp(k);\n      const int numMod = num % k;\n      // Start new subarray with only `num`.\n      newDp[numMod] = 1;\n      // Extend all previous subarrays.\n      for (int i = 0; i < k; ++i) {\n        const int newMod = (static_cast<long>(i) * numMod) % k;\n        newDp[newMod] += dp[i];\n      }\n      // Accumulate counts into ans.\n      for (int i = 0; i < k; ++i)\n        ans[i] += newDp[i];\n      dp = std::move(newDp);\n    }\n\n    return ans;\n  }\n};\n", "3525": "struct Node {\n  int remain[5] = {0};\n  int prod = 1;\n};\n\nclass SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums, int k)\n      : n(nums.size()), k(k), tree(4 * n) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Updates nums[i] to val.\n  void update(int i, int val) {\n    update(0, 0, n - 1, i, val);\n  }\n\n  // Returns the result of the range query from nums[i..j].\n  Node query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int n;        // the size of the input array\n  const int k;        // the modulo value\n  vector<Node> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int cur, int left, int right) {\n    if (left == right) {\n      tree[cur].remain[nums[left]] = 1;\n      tree[cur].prod = nums[left];\n      return;\n    }\n    const int mid = (left + right) / 2;\n    build(nums, 2 * cur + 1, left, mid);\n    build(nums, 2 * cur + 2, mid + 1, right);\n    tree[cur] = merge(tree[2 * cur + 1], tree[2 * cur + 2]);\n  }\n\n  void update(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      for (int j = 0; j < k; ++j)\n        tree[treeIndex].remain[j] = 0;\n      tree[treeIndex].remain[val] = 1;\n      tree[treeIndex].prod = val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      update(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      update(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  Node query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return Node();\n    const int mid = (lo + hi) / 2;\n    return merge(query(2 * treeIndex + 1, lo, mid, i, j),\n                 query(2 * treeIndex + 2, mid + 1, hi, i, j));\n  }\n\n  Node merge(const Node& left, const Node& right) const {\n    Node node;\n    node.prod = (left.prod * right.prod) % k;\n    for (int i = 0; i < k; ++i)\n      node.remain[i] = left.remain[i];\n    for (int i = 0; i < k; ++i)\n      node.remain[(i * left.prod) % k] += right.remain[i];\n    return node;\n  }\n};\n\nclass Solution {\n public:\n  vector<int> resultArray(vector<int>& nums, int k,\n                          vector<vector<int>>& queries) {\n    for (int& num : nums)\n      num %= k;\n\n    for (vector<int>& query : queries)\n      query[1] %= k;\n\n    const int n = nums.size();\n    vector<int> ans;\n    SegmentTree tree(nums, k);\n\n    for (const vector<int>& query : queries) {\n      const int index = query[0];\n      const int value = query[1];\n      const int start = query[2];\n      const int x = query[3];\n      tree.update(index, value);\n      ans.push_back(tree.query(start, n - 1).remain[x]);\n    }\n\n    return ans;\n  }\n};\n", "3526": "struct Node {\n  Node(int v) : val(v), subXor(v) {}\n  int val;\n  int subXor;\n  int sz = 1;\n  int rev = false;\n  int prior = rand();\n  Node* l = nullptr;\n  Node* r = nullptr;\n};\n\nclass AVLTree {\n public:\n  AVLTree(const vector<int>& nums) : root(nullptr) {\n    build(nums);\n  }\n\n  void updateValue(int index, int val) {\n    Node* l = nullptr;\n    Node* r = nullptr;\n    Node* m = nullptr;\n    split(root, index, l, r);\n    split(r, 1, m, r);\n    if (m != nullptr)\n      m->val = val;\n    update(m);\n    root = merge(merge(l, m), r);\n  }\n\n  int rangeXor(int left, int right) {\n    Node* l = nullptr;\n    Node* m = nullptr;\n    Node* r = nullptr;\n    split(root, left, l, r);\n    split(r, right - left + 1, m, r);\n    const int res = getXor(m);\n    root = merge(merge(l, m), r);\n    return res;\n  }\n\n  void reverseRange(int left, int right) {\n    Node* l = nullptr;\n    Node* m = nullptr;\n    Node* r = nullptr;\n    split(root, left, l, r);\n    split(r, right - left + 1, m, r);\n    if (m != nullptr)\n      m->rev = !m->rev;\n    root = merge(merge(l, m), r);\n  }\n\n private:\n  Node* root;\n\n  void build(const vector<int>& nums) {\n    for (const int num : nums)\n      root = merge(root, new Node(num));\n  }\n\n  int getSize(Node* t) {\n    return t ? t->sz : 0;\n  }\n\n  int getXor(Node* t) {\n    return t ? t->subXor : 0;\n  }\n\n  void push(Node* t) {\n    if (t == nullptr || !t->rev)\n      return;\n    swap(t->l, t->r);\n    if (t->l != nullptr)\n      t->l->rev ^= 1;\n    if (t->r != nullptr)\n      t->r->rev ^= 1;\n    t->rev = false;\n  }\n\n  void update(Node* t) {\n    if (t == nullptr)\n      return;\n    t->sz = 1 + getSize(t->l) + getSize(t->r);\n    t->subXor = t->val ^ getXor(t->l) ^ getXor(t->r);\n  }\n\n  void split(Node* t, int k, Node*& l, Node*& r) {\n    if (t == nullptr)\n      return void(l = r = nullptr);\n    push(t);\n    if (getSize(t->l) >= k) {\n      split(t->l, k, l, t->l);\n      r = t;\n    } else {\n      split(t->r, k - getSize(t->l) - 1, t->r, r);\n      l = t;\n    }\n    update(t);\n  }\n\n  Node* merge(Node* l, Node* r) {\n    push(l);\n    push(r);\n    if (l == nullptr || r == nullptr)\n      return l == nullptr ? r : l;\n    if (l->prior > r->prior) {\n      l->r = merge(l->r, r);\n      update(l);\n      return l;\n    } else {\n      r->l = merge(l, r->l);\n      update(r);\n      return r;\n    }\n  }\n};\n\nclass Solution {\n public:\n  vector<int> getResults(vector<int>& nums, vector<vector<int>>& queries) {\n    AVLTree tree(nums);\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int type = query[0];\n      if (type == 1)\n        tree.updateValue(/*index=*/query[1], /*val=*/query[2]);\n      else if (type == 2)\n        ans.push_back(tree.rangeXor(/*left=*/query[1], /*right=*/query[2]));\n      else if (type == 3)\n        tree.reverseRange(/*left=*/query[1], /*right=*/query[2]);\n    }\n\n    return ans;\n  }\n};\n", "3527": "class Solution {\n public:\n  string findCommonResponse(vector<vector<string>>& responses) {\n    string ans;\n    unordered_map<string, int> count;\n    int maxFreq = 0;\n\n    for (const vector<string>& response : responses)\n      for (const string& response :\n           unordered_set<string>{response.begin(), response.end()})\n        ++count[response];\n\n    for (const pair<const string, int>& entry : count)\n      maxFreq = max(maxFreq, entry.second);\n\n    for (const auto& [response, freq] : count)\n      if (freq == maxFreq && (ans.empty() || response < ans))\n        ans = response;\n\n    return ans;\n  }\n};\n", "3528": "class Solution {\n public:\n  vector<int> baseUnitConversions(vector<vector<int>>& conversions) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = conversions.size() + 1;\n    vector<int> ans(n);\n    ans[0] = 1;\n    queue<int> q{{0}};\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& conversion : conversions) {\n      const int u = conversion[0];\n      const int v = conversion[1];\n      const int factor = conversion[2];\n      graph[u].emplace_back(v, factor);\n    }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const auto& [v, factor] : graph[u]) {\n        ans[v] = (static_cast<long>(ans[u]) * factor) % kMod;\n        q.push(v);\n      }\n    }\n\n    return ans;\n  }\n};\n", "3529": "class Solution {\n public:\n  int countCells(vector<vector<char>>& grid, string pattern) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = 0;\n    string flattendGridRow;\n    string flattendGridCol;\n\n    // Flatten the grid for horizontal matching.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        flattendGridRow += grid[i][j];\n\n    // Flatten the grid for vertical matching.\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        flattendGridCol += grid[i][j];\n\n    // Find matching positions.\n    const vector<vector<bool>> horizontalMatches =\n        markMatchedCells(flattendGridRow, pattern, m, n, true);\n    const vector<vector<bool>> verticalMatches =\n        markMatchedCells(flattendGridCol, pattern, m, n, false);\n\n    // Count overlapping match positions.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (horizontalMatches[i][j] && verticalMatches[i][j])\n          ++ans;\n\n    return ans;\n  }\n\n private:\n  static constexpr long kBase = 13;\n  static constexpr long kHash = 1'000'000'007;\n\n  vector<vector<bool>> markMatchedCells(const string& flattenedGrid,\n                                        const string& pattern, int m, int n,\n                                        bool isHorizontal) {\n    vector<vector<bool>> matchMatrix(m, vector<bool>(n, false));\n    vector<int> matchPrefix(flattenedGrid.length() + 1);\n    vector<long> pows{1};  // pows[i] := kBase^i % kHash\n    long patternHash = 0;\n    long runningHash = 0;\n\n    for (int i = 1; i < pattern.length(); ++i)\n      pows.push_back((pows.back() * kBase) % kHash);\n\n    for (const char c : pattern)\n      patternHash = (patternHash * kBase + (c - 'a')) % kHash;\n\n    for (int i = 0; i < flattenedGrid.length(); ++i) {\n      runningHash = (runningHash * kBase + (flattenedGrid[i] - 'a')) % kHash;\n      if (i >= pattern.length() - 1) {\n        if (runningHash == patternHash) {  // Match found.\n          ++matchPrefix[i - pattern.length() + 1];\n          --matchPrefix[i + 1];\n        }\n        // Remove the contribution of the oldest letter.\n        const long oldestLetterHash =\n            (pows[pattern.length() - 1] *\n             (flattenedGrid[i - pattern.length() + 1] - 'a')) %\n            kHash;\n        runningHash = (runningHash - oldestLetterHash + kHash) % kHash;\n      }\n    }\n\n    for (int k = 0; k < flattenedGrid.length(); ++k) {\n      matchPrefix[k] += (k > 0) ? matchPrefix[k - 1] : 0;\n      if (matchPrefix[k] > 0) {\n        const int i = isHorizontal ? k / n : k % m;\n        const int j = isHorizontal ? k % n : k / m;\n        matchMatrix[i][j] = true;\n      }\n    }\n\n    return matchMatrix;\n  }\n};\n", "353": "class SnakeGame {\n public:\n  /** Initialize your data structure here.\n     @param width - screen width\n     @param height - screen height\n     @param food - A list of food positions\n     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the\n     second is at [1,0]. */\n  SnakeGame(int width, int height, vector<vector<int>>& food)\n      : width(width), height(height), food(food) {\n    lookup.insert(getId(0, 0));\n    body.push_back(getId(0, 0));\n  }\n\n  /** Moves the snake.\n      @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n      @return The game's score after the move. Return -1 if game over.\n      Game over when snake crosses the screen boundary or bites its body. */\n  int std::move(string direction) {\n    // the old head's position\n    int i = body.front() / width;\n    int j = body.front() % width;\n\n    // Update the head's position and check if it's out-of-bounds.\n    if (direction == \"U\" && --i < 0)\n      return -1;\n    if (direction == \"L\" && --j < 0)\n      return -1;\n    if (direction == \"R\" && ++j == width)\n      return -1;\n    if (direction == \"D\" && ++i == height)\n      return -1;\n\n    const int newHead = getId(i, j);\n\n    // 1. Eat food and increase the size by 1.\n    if (k < food.size() && i == food[k][0] && j == food[k][1]) {\n      lookup.insert(newHead);\n      body.push_front(newHead);\n      ++k;\n      return ++score;\n    }\n\n    // 2. new head != old tail and eat body!\n    if (newHead != body.back() && lookup.contains(newHead))\n      return -1;\n\n    // 3. normal case\n    // Remove the old tail first, then add new head because new head may be in\n    // old tail's position.\n    lookup.erase(body.back());\n    lookup.insert(newHead);\n    body.pop_back();\n    body.push_front(newHead);\n    return score;\n  }\n\n private:\n  int width;\n  int height;\n  int score = 0;\n  int k = 0;  // food's index\n  vector<vector<int>> food;\n  unordered_set<int> lookup;\n  deque<int> body;  // snake's body\n\n  int getId(int i, int j) {\n    return i * width + j;\n  }\n};\n", "3530": "class Solution {\n public:\n  int maxProfit(int n, vector<vector<int>>& edges, vector<int>& score) {\n    const int maxMask = 1 << n;\n    // need[i] := the bitmask representing all nodes that must be placed before\n    // node i\n    vector<int> need(n);\n    // dp[mask] := the maximum profit achievable by placing the set of nodes\n    // represented by `mask`\n    vector<int> dp(maxMask, -1);\n    dp[0] = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      need[v] |= 1 << u;\n    }\n\n    // Iterate over all subsets of nodes (represented by bitmask `mask`)\n    for (unsigned mask = 0; mask < maxMask; ++mask) {\n      if (dp[mask] == -1)\n        continue;\n      // Determine the position of the next node to be placed (1-based).\n      const int pos = popcount(mask) + 1;\n      // Try to place each node `i` that hasn't been placed yet.\n      for (int i = 0; i < n; ++i) {\n        if (mask >> i & 1)\n          continue;\n        // Check if all dependencies of node `i` are already placed.\n        if ((mask & need[i]) == need[i]) {\n          const int newMask = mask | 1 << i;  // Mark node `i` as placed.\n          dp[newMask] = max(dp[newMask], dp[mask] + score[i] * pos);\n        }\n      }\n    }\n\n    return dp.back();\n  }\n};\n", "3531": "class Solution {\n public:\n  int countCoveredBuildings(int n, vector<vector<int>>& buildings) {\n    int ans = 0;\n    vector<int> northernmost(n + 1, INT_MAX);\n    vector<int> southernmost(n + 1, 0);\n    vector<int> westernmost(n + 1, INT_MAX);\n    vector<int> easternmost(n + 1, 0);\n\n    for (const vector<int>& building : buildings) {\n      const int x = building[0];\n      const int y = building[1];\n      northernmost[x] = min(northernmost[x], y);\n      southernmost[x] = max(southernmost[x], y);\n      westernmost[y] = min(westernmost[y], x);\n      easternmost[y] = max(easternmost[y], x);\n    }\n\n    for (const vector<int>& building : buildings) {\n      const int x = building[0];\n      const int y = building[1];\n      if (northernmost[x] < y && y < southernmost[x]  //\n          && westernmost[y] < x && x < easternmost[y])\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "3532": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  vector<bool> pathExistenceQueries(int n, vector<int>& nums, int maxDiff,\n                                    vector<vector<int>>& queries) {\n    vector<bool> ans;\n    UnionFind uf(n);\n\n    for (int i = 1; i < n; ++i)\n      if (abs(nums[i] - nums[i - 1]) <= maxDiff)\n        uf.unionByRank(i, i - 1);\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      ans.push_back(uf.find(u) == uf.find(v));\n    }\n\n    return ans;\n  }\n};\n", "3533": "class Solution {\n public:\n  vector<int> concatenatedDivisibility(vector<int>& nums, int k) {\n    vector<int> lengths;\n    vector<int> pows;\n\n    ranges::sort(nums);\n\n    for (const int num : nums) {\n      lengths.push_back(to_string(num).length());\n      pows.push_back(static_cast<int>(pow(10, lengths.back())) % k);\n    }\n\n    vector<vector<int>> mem(1 << nums.size(), vector<int>(k, -1));\n    return dp(nums, pows, mem, k, 0, 0) ? reconstruct(nums, pows, mem, k, 0, 0)\n                                        : vector<int>();\n  }\n\n private:\n  // Returns true if there is a way to form a number divisible by `k` using the\n  // numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n  bool dp(const vector<int>& nums, const vector<int>& pows,\n          vector<vector<int>>& mem, int k, int mask, int mod) {\n    if (mem[mask][mod] != -1)\n      return mem[mask][mod] == 1;\n    if (mask == (1 << nums.size()) - 1)\n      return mod == 0;\n    for (int i = 0; i < nums.size(); ++i)\n      if ((mask >> i & 1) == 0) {\n        const int newMod = (mod * pows[i] + nums[i]) % k;\n        if (dp(nums, pows, mem, k, mask | 1 << i, newMod))\n          return mem[mask][mod] = 1;\n      }\n    return mem[mask][mod] = 0;\n  }\n\n  // Reconstructs the numbers that form a number divisible by `k` using the\n  // numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n  vector<int> reconstruct(const vector<int>& nums, const vector<int>& pows,\n                          vector<vector<int>>& mem, int k, int mask, int mod) {\n    for (int i = 0; i < nums.size(); ++i)\n      if ((mask >> i & 1) == 0) {\n        const int newMod = (mod * pows[i] + nums[i]) % k;\n        if (dp(nums, pows, mem, k, mask | 1 << i, newMod)) {\n          vector<int> res{nums[i]};\n          vector<int> rest =\n              reconstruct(nums, pows, mem, k, mask | 1 << i, newMod);\n          ranges::copy(rest, ranges::back_inserter(res));\n          return res;\n        }\n      }\n    return {};\n  }\n};\n", "3534": "class Solution {\n public:\n  vector<int> pathExistenceQueries(int n, vector<int>& nums, int maxDiff,\n                                   vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> sortedNums;\n    vector<int> indexMap(n);\n    vector<pair<int, int>> sortedNumAndIndexes;\n\n    for (int i = 0; i < n; ++i)\n      sortedNumAndIndexes.emplace_back(nums[i], i);\n\n    ranges::sort(sortedNumAndIndexes);\n\n    for (int i = 0; i < n; ++i) {\n      const auto& [num, sortedIndex] = sortedNumAndIndexes[i];\n      sortedNums.push_back(num);\n      indexMap[sortedIndex] = i;\n    }\n\n    const int maxLevel = std::bit_width(static_cast<unsigned>(n)) + 1;\n    // jump[i][j] := the index of the j-th ancestor of i\n    vector<vector<int>> jump(n, vector<int>(maxLevel));\n\n    int right = 0;\n    for (int i = 0; i < n; ++i) {\n      while (right + 1 < n && sortedNums[right + 1] - sortedNums[i] <= maxDiff)\n        ++right;\n      jump[i][0] = right;\n    }\n\n    for (int level = 1; level < maxLevel; ++level)\n      for (int i = 0; i < n; ++i) {\n        const int prevJump = jump[i][level - 1];\n        jump[i][level] = jump[prevJump][level - 1];\n      }\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      const int uIndex = indexMap[u];\n      const int vIndex = indexMap[v];\n      const int start = min(uIndex, vIndex);\n      const int end = max(uIndex, vIndex);\n      const int res = minJumps(jump, start, end, maxLevel - 1);\n      ans.push_back(res == INT_MAX ? -1 : res);\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the minimum number of jumps from `start` to `end` using binary\n  // lifting.\n  int minJumps(const vector<vector<int>>& jump, int start, int end, int level) {\n    if (start == end)\n      return 0;\n    if (jump[start][0] >= end)\n      return 1;\n    if (jump[start][level] < end)\n      return INT_MAX;\n    int j = level;\n    for (; j >= 0; --j)\n      if (jump[start][j] < end)\n        break;\n    return (1 << j) + minJumps(jump, jump[start][j], end, j);\n  }\n};\n", "3535": "class Solution {\n public:\n  vector<int> queryConversions(vector<vector<int>>& conversions,\n                               vector<vector<int>>& queries) {\n    const vector<int> units = baseUnitConversions(conversions);\n    vector<int> ans;\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      // By Fermat's little theorem.\n      ans.push_back(units[v] * modPow(units[u], kMod - 2) % kMod);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  // Same as 3528. Unit Conversion I\n  vector<int> baseUnitConversions(vector<vector<int>>& conversions) {\n    const int n = conversions.size() + 1;\n    vector<int> res(n);\n    res[0] = 1;\n    queue<int> q{{0}};\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& conversion : conversions) {\n      const int u = conversion[0];\n      const int v = conversion[1];\n      const int factor = conversion[2];\n      graph[u].emplace_back(v, factor);\n    }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const auto& [v, factor] : graph[u]) {\n        res[v] = (static_cast<long>(res[u]) * factor) % kMod;\n        q.push(v);\n      }\n    }\n\n    return res;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "3536": "class Solution {\n public:\n  int maxProduct(int n) {\n    string s = to_string(n);\n    ranges::sort(s);\n    const int sz = s.length();\n    return (s[sz - 1] - '0') * (s[sz - 2] - '0');\n  }\n};\n", "3537": "class Solution {\n public:\n  vector<vector<int>> specialGrid(int n) {\n    const int sz = 1 << n;\n    int count = 0;\n    vector<vector<int>> grid(sz, vector<int>(sz));\n    fill(grid, 0, sz, 0, sz, count);\n    return grid;\n  }\n\n  void fill(vector<vector<int>>& grid, int x1, int x2, int y1, int y2,\n            int& count) {\n    if (x2 - x1 == 1) {\n      grid[x1][y1] = count++;\n      return;\n    }\n    const int midRow = (x1 + x2) / 2;\n    const int midCol = (y1 + y2) / 2;\n    fill(grid, x1, midRow, midCol, y2, count);\n    fill(grid, midRow, x2, midCol, y2, count);\n    fill(grid, midRow, x2, y1, midCol, count);\n    fill(grid, x1, midRow, y1, midCol, count);\n  }\n};\n", "3539": "class Solution {\n public:\n  int magicalSum(int m, int k, vector<int>& nums) {\n    const vector<vector<int>> comb = getComb(m, m);\n    vector<vector<vector<vector<int>>>> mem(\n        m + 1, vector<vector<vector<int>>>(\n                   k + 1, vector<vector<int>>(nums.size() + 1,\n                                              vector<int>(m + 1, -1))));\n    return dp(m, k, 0, 0, nums, mem, comb);\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  int dp(int m, int k, int i, unsigned carry, const vector<int>& nums,\n         vector<vector<vector<vector<int>>>>& mem,\n         const vector<vector<int>>& comb) {\n    if (m < 0 || k < 0 || (m + popcount(carry) < k))\n      return 0;\n    if (m == 0)\n      return k == popcount(carry) ? 1 : 0;\n    if (i == nums.size())\n      return 0;\n    if (mem[m][k][i][carry] != -1)\n      return mem[m][k][i][carry];\n    int res = 0;\n    for (int count = 0; count <= m; ++count) {\n      const long contribution = comb[m][count] * modPow(nums[i], count) % kMod;\n      const int newCarry = carry + count;\n      res = (res + static_cast<long>(dp(m - count, k - (newCarry % 2), i + 1,\n                                        newCarry / 2, nums, mem, comb)) *\n                       contribution) %\n            kMod;\n    }\n    return mem[m][k][i][carry] = res;\n  }\n\n  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  vector<vector<int>> getComb(int n, int k) {\n    vector<vector<int>> comb(n + 1, vector<int>(k + 1));\n    for (int i = 0; i <= n; ++i)\n      comb[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= k; ++j)\n        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n    return comb;\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "354": "class Solution {\n public:\n  int maxEnvelopes(vector<vector<int>>& envelopes) {\n    ranges::sort(envelopes, ranges::less{}, [](const vector<int>& envelope) {\n      const int w = envelope[0];\n      const int h = envelope[1];\n      return pair<int, int>{w, -h};\n    });\n    return lengthOfLIS(envelopes);\n  }\n\n private:\n  // Same to 300. Longest Increasing Subsequence\n  int lengthOfLIS(vector<vector<int>>& envelopes) {\n    // tails[i] := the minimum tail of all the increasing subsequences having\n    // length i + 1\n    vector<int> tails;\n\n    for (const vector<int>& envelope : envelopes) {\n      const int h = envelope[1];\n      if (tails.empty() || h > tails.back())\n        tails.push_back(h);\n      else\n        tails[firstGreaterEqual(tails, h)] = h;\n    }\n\n    return tails.size();\n  }\n\n private:\n  int firstGreaterEqual(const vector<int>& arr, int target) {\n    return ranges::lower_bound(arr, target) - arr.begin();\n  }\n};\n", "3540": "class Solution {\n public:\n  long long minTotalTime(vector<int>& forward, vector<int>& backward,\n                         vector<int>& queries) {\n    const int n = forward.size();\n    const long sum = accumulate(backward.begin(), backward.end(), 0L);\n    long ans = 0;\n    int pos = 0;\n    vector<long> prefixF(n + 1);\n    vector<long> prefixB(n + 1);\n\n    for (int i = 0; i < n; ++i) {\n      prefixF[i + 1] = prefixF[i] + forward[i];\n      prefixB[i] = (i == 0 ? 0 : prefixB[i - 1]) + backward[i];\n    }\n\n    for (const int q : queries) {\n      const long r = (q < pos ? prefixF[n] : 0) + prefixF[q] - prefixF[pos];\n      const long l = (q > pos ? sum : 0) + prefixB[pos] - prefixB[q];\n      ans += min(l, r);\n      pos = q;\n    }\n\n    return ans;\n  }\n};\n", "3541": "class Solution {\n public:\n  int maxFreqSum(string s) {\n    vector<int> count(26);\n    int maxVowel = 0;\n    int maxConsonant = 0;\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : s)\n      if (isVowel(c))\n        maxVowel = max(maxVowel, count[c - 'a']);\n      else\n        maxConsonant = max(maxConsonant, count[c - 'a']);\n\n    return maxVowel + maxConsonant;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiou\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "3542": "class Solution {\n public:\n  int minOperations(vector<int>& nums) {\n    int ans = 0;\n    stack<int> stack;\n    stack.push(0);\n\n    for (const int num : nums) {\n      while (!stack.empty() && stack.top() > num)\n        stack.pop();\n      if (stack.empty() || stack.top() < num) {\n        ++ans;\n        stack.push(num);\n      }\n    }\n\n    return ans;\n  }\n};\n", "3543": "class Solution {\n public:\n  int maxWeight(int n, vector<vector<int>>& edges, int k, int t) {\n    vector<vector<pair<int, int>>> graph(n);\n    // dp[u][i] := the set of possible path sums ending at node u with i edges\n    vector<unordered_map<int, unordered_set<int>>> dp(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n    }\n\n    for (int u = 0; u < n; ++u)\n      dp[u][0].insert(0);  // zero edges = sum 0\n\n    for (int i = 0; i < k; ++i)\n      for (int u = 0; u < n; ++u)\n        if (dp[u].contains(i))\n          for (const int currSum : dp[u][i])\n            for (const auto& [v, w] : graph[u]) {\n              const int newSum = currSum + w;\n              if (newSum < t)\n                dp[v][i + 1].insert(newSum);\n            }\n\n    int ans = -1;\n\n    for (int u = 0; u < n; ++u)\n      if (dp[u].contains(k))\n        for (const int sum : dp[u][k])\n          ans = max(ans, sum);\n\n    return ans;\n  }\n};\n", "3544": "class Solution {\n public:\n  long long subtreeInversionSum(vector<vector<int>>& edges, vector<int>& nums,\n                                int k) {\n    const int n = edges.size() + 1;\n    vector<int> parent(n, -1);\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    vector<vector<vector<long>>> mem(\n        n, vector<vector<long>>(k + 1, vector<long>(2, -1)));\n    return dfs(graph, /*u=*/0, /*stepsSinceInversion=*/k,\n               /*inverted=*/false, nums, k, parent, mem);\n  }\n\n private:\n  // Returns the maximum sum for subtree rooted at u, with `stepsSinceInversion`\n  // steps of inversion and `inverted` is true if the subtree is inverted.\n  long dfs(const vector<vector<int>>& graph, int u, int stepsSinceInversion,\n           bool inverted, const vector<int>& nums, int k, vector<int>& parent,\n           vector<vector<vector<long>>>& mem) {\n    if (mem[u][stepsSinceInversion][inverted] != -1)\n      return mem[u][stepsSinceInversion][inverted];\n    long num = inverted ? -nums[u] : nums[u];\n    long negNum = -num;\n    for (const int v : graph[u]) {\n      if (v == parent[u])\n        continue;\n      parent[v] = u;\n      num += dfs(graph, v, min(k, stepsSinceInversion + 1), inverted, nums, k,\n                 parent, mem);\n      if (stepsSinceInversion == k)\n        negNum += dfs(graph, v, /*stepsSinceInversion=*/1, !inverted, nums, k,\n                      parent, mem);\n    }\n    return mem[u][stepsSinceInversion][inverted] =\n               (stepsSinceInversion == k) ? max(num, negNum) : num;\n  }\n};\n", "3545": "class Solution {\n public:\n  int minDeletion(string s, int k) {\n    unordered_map<char, int> count;\n\n    for (const char c : s)\n      ++count[c];\n\n    if (count.size() <= k)\n      return 0;\n\n    vector<int> freqs;\n\n    for (const auto& [_, freq] : count)\n      freqs.push_back(freq);\n\n    ranges::sort(freqs);\n    return accumulate(freqs.begin(), freqs.begin() + freqs.size() - k, 0);\n  }\n};\n", "3546": "class Solution {\n public:\n  bool canPartitionGrid(vector<vector<int>>& grid) {\n    const long totalSum = accumulate(grid.begin(), grid.end(), 0L,\n                                     [](long acc, const vector<int>& row) {\n      return acc + accumulate(row.begin(), row.end(), 0L);\n    });\n    return canPartition(grid, totalSum) ||\n           canPartition(transposed(grid), totalSum);\n  }\n\n private:\n  bool canPartition(const vector<vector<int>>& lines, long totalSum) {\n    long runningSum = 0;\n    for (const vector<int>& line : lines) {\n      runningSum += accumulate(line.begin(), line.end(), 0L);\n      if (runningSum * 2 == totalSum)\n        return true;\n    }\n    return false;\n  }\n\n  vector<vector<int>> transposed(const vector<vector<int>>& grid) {\n    vector<vector<int>> res(grid[0].size(), vector<int>(grid.size()));\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        res[j][i] = grid[i][j];\n    return res;\n  }\n};\n", "3547": "class Solution {\n public:\n  long long maxScore(int n, vector<vector<int>>& edges) {\n    long ans = 0;\n    vector<vector<int>> graph(n);\n    vector<int> cycleSizes;  // components where all nodes have degree 2\n    vector<int> pathSizes;   // components that are not cycleSizes\n    vector<bool> seen(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      if (seen[i])\n        continue;\n      const vector<int> component = getComponent(graph, i, seen);\n      const bool allDegree2 = ranges::all_of(\n          component, [&graph](int u) { return graph[u].size() == 2; });\n      if (allDegree2)\n        cycleSizes.push_back(component.size());\n      else if (component.size() > 1)\n        pathSizes.push_back(component.size());\n    }\n\n    for (const int cycleSize : cycleSizes) {\n      ans += calculateScore(n - cycleSize + 1, n, /*isCycle=*/true);\n      n -= cycleSize;\n    }\n\n    ranges::sort(pathSizes, greater<>());\n\n    for (const int pathSize : pathSizes) {\n      ans += calculateScore(n - pathSize + 1, n, /*isCycle=*/false);\n      n -= pathSize;\n    }\n\n    return ans;\n  }\n\n private:\n  vector<int> getComponent(const vector<vector<int>>& graph, int start,\n                           vector<bool>& seen) {\n    vector<int> component = {start};\n    seen[start] = true;\n    for (int i = 0; i < component.size(); ++i) {\n      const int u = component[i];\n      for (const int v : graph[u]) {\n        if (seen[v])\n          continue;\n        component.push_back(v);\n        seen[v] = true;\n      }\n    }\n    return component;\n  }\n\n  long calculateScore(int left, int right, bool isCycle) {\n    deque<long> window = {right, right};\n    long score = 0;\n    for (int value = right - 1; value >= left; --value) {\n      const long windowValue = window.front();\n      window.pop_front();\n      score += windowValue * value;\n      window.push_back(value);\n    }\n    return score + window[0] * window[1] * isCycle;\n  }\n};\n", "3548": "class Solution {\n public:\n  bool canPartitionGrid(vector<vector<int>>& grid) {\n    const long sum = accumulate(grid.begin(), grid.end(), 0L,\n                                [](long acc, const vector<int>& row) {\n      return acc + accumulate(row.begin(), row.end(), 0L);\n    });\n    return canPartition(grid, sum) || canPartition(reversed(grid), sum) ||\n           canPartition(reversed(transposed(grid)), sum) ||\n           canPartition(transposed(grid), sum);\n  }\n\n private:\n  bool canPartition(const vector<vector<int>>& grid, long sum) {\n    long topSum = 0;\n    unordered_set<int> seen;\n    for (int i = 0; i < grid.size(); ++i) {\n      topSum += accumulate(grid[i].begin(), grid[i].end(), 0L);\n      const long botSum = sum - topSum;\n      seen.insert(grid[i].begin(), grid[i].end());\n      if (topSum - botSum == 0 || topSum - botSum == grid[0][0] ||\n          topSum - botSum == grid[0].back() || topSum - botSum == grid[i][0])\n        return true;\n      if (grid[0].size() > 1 && i > 0 && seen.count(topSum - botSum))\n        return true;\n    }\n    return false;\n  }\n\n  vector<vector<int>> transposed(const vector<vector<int>>& grid) {\n    vector<vector<int>> res(grid[0].size(), vector<int>(grid.size()));\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        res[j][i] = grid[i][j];\n    return res;\n  }\n\n  vector<vector<int>> reversed(const vector<vector<int>>& grid) {\n    return {grid.rbegin(), grid.rend()};\n  }\n};\n", "3549": "class Solution {\n public:\n  vector<long long> multiply(vector<int>& poly1, vector<int>& poly2) {\n    const unsigned n1 = poly1.size();\n    const unsigned n2 = poly2.size();\n    const unsigned n = n1 + n2 - 1;\n    const unsigned sz = 1 << std::bit_width(n - 1);\n\n    // Prepare input arrays for FFT.\n    vector<complex<double>> a(sz);\n    vector<complex<double>> b(sz);\n\n    // Copy polynomial coefficients to complex arrays.\n    for (int i = 0; i < n1; ++i)\n      a[i] = poly1[i];\n\n    for (int i = 0; i < n2; ++i)\n      b[i] = poly2[i];\n\n    // Transform polynomials to frequency domain.\n    fft(a, false);\n    fft(b, false);\n\n    // Multiply in frequency domain.\n    for (int i = 0; i < sz; ++i)\n      a[i] *= b[i];\n\n    // Transform back to coefficient domain.\n    fft(a, true);\n\n    // Extract real parts as polynomial coefficients.\n    vector<long long> ans(n);\n\n    for (int i = 0; i < n; ++i)\n      ans[i] = round(a[i].real());\n\n    return ans;\n  }\n\n private:\n  // Fast Fourier Transform.\n  void fft(vector<complex<double>>& a, bool inverse) {\n    const unsigned n = a.size();\n\n    // Bit-reversal permutation.\n    for (int i = 1, j = 0; i < n; ++i) {\n      int bit = n >> 1;\n      for (; j & bit; bit >>= 1)\n        j ^= bit;\n      j ^= bit;\n      if (i < j)\n        swap(a[i], a[j]);\n    }\n\n    // FFT computation.\n    for (int len = 2; len <= n; len *= 2) {\n      const double angle = 2 * M_PI / len * (inverse ? -1 : 1);\n      const complex<double> w_len(cos(angle), sin(angle));\n      for (int i = 0; i < n; i += len) {\n        complex<double> w(1);\n        for (int j = 0; j < len / 2; ++j) {\n          const complex<double> u = a[i + j];\n          const complex<double> v = a[i + j + len / 2] * w;\n          a[i + j] = u + v;\n          a[i + j + len / 2] = u - v;\n          w *= w_len;\n        }\n      }\n    }\n\n    // Normalize if inverse transform.\n    if (inverse)\n      for (complex<double>& x : a)\n        x /= n;\n  }\n};\n", "355": "struct Tweet {\n  int id;\n  int time;\n  Tweet* next = nullptr;\n};\n\nstruct User {\n  int id;\n  unordered_set<int> followeeIds;\n  Tweet* tweetHead = nullptr;\n\n  User() {}\n\n  User(int id) : id(id) {\n    follow(id);\n  }\n\n  void follow(int followeeId) {\n    followeeIds.insert(followeeId);\n  }\n\n  void unfollow(int followeeId) {\n    followeeIds.erase(followeeId);\n  }\n\n  void post(int tweetId, int time) {\n    Tweet* oldTweetHead = tweetHead;\n    tweetHead = new Tweet(tweetId, time);\n    tweetHead->next = oldTweetHead;\n  }\n};\n\nclass Twitter {\n public:\n  /** Compose a new tweet. */\n  void postTweet(int userId, int tweetId) {\n    if (!users.contains(userId))\n      users[userId] = User(userId);\n    users[userId].post(tweetId, time++);\n  }\n\n  /**\n   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in\n   * the news feed must be posted by users who the user followed or by the user\n   * herself. Tweets must be ordered from most recent to least recent.\n   */\n  vector<int> getNewsFeed(int userId) {\n    if (!users.contains(userId))\n      return {};\n\n    vector<int> newsFeed;\n\n    auto compare = [](const Tweet* a, const Tweet* b) {\n      return a->time < b->time;\n    };\n    priority_queue<Tweet*, vector<Tweet*>, decltype(compare)> maxHeap(compare);\n\n    for (const int followeeId : users[userId].followeeIds) {\n      Tweet* tweetHead = users[followeeId].tweetHead;\n      if (tweetHead != nullptr)\n        maxHeap.push(tweetHead);\n    }\n\n    int count = 0;\n    while (!maxHeap.empty() && count++ < 10) {\n      Tweet* tweet = maxHeap.top();\n      maxHeap.pop();\n      newsFeed.push_back(tweet->id);\n      if (tweet->next)\n        maxHeap.push(tweet->next);\n    }\n\n    return newsFeed;\n  }\n\n  /**\n   * Follower follows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  void follow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (!users.contains(followerId))\n      users[followerId] = User(followerId);\n    if (!users.contains(followeeId))\n      users[followeeId] = User(followeeId);\n    users[followerId].follow(followeeId);\n  }\n\n  /**\n   * Follower unfollows a followee.\n   * If the operation is invalid, it should be a no-op.\n   */\n  void unfollow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (const auto it = users.find(followerId);\n        it != users.cend() && users.contains(followeeId))\n      it->second.unfollow(followeeId);\n  }\n\n private:\n  int time = 0;\n  unordered_map<int, User> users;  // {userId: User}\n};\n", "3550": "class Solution {\n public:\n  int smallestIndex(vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (getDigitSum(nums[i]) == i)\n        return i;\n    return -1;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    return sum;\n  }\n};\n", "3551": "class Solution {\n public:\n  int minSwaps(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> seen;\n    unordered_map<int, int> numToIndex;\n    vector<int> sortedNums = nums;\n\n    ranges::sort(sortedNums, ranges::less{}, [this](int num) {\n      return pair<int, int>{getDigitSum(num), num};\n    });\n\n    for (int i = 0; i < sortedNums.size(); ++i)\n      numToIndex[sortedNums[i]] = i;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (seen.contains(i) || numToIndex[nums[i]] == i)\n        continue;\n      int cycleSize = 0;\n      int j = i;\n      while (seen.insert(j).second) {\n        j = numToIndex[nums[j]];\n        ++cycleSize;\n      }\n      ans += max(cycleSize - 1, 0);\n    }\n\n    return ans;\n  }\n\n private:\n  int getDigitSum(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    return sum;\n  }\n};\n", "3552": "class Solution {\n public:\n  // Similar to 3341. Find Minimum Time to Reach Last Room I\n  int minMoves(vector<string>& matrix) {\n    if (matrix.back().back() == '#')\n      return -1;\n\n    vector<vector<pair<int, int>>> teleportPositions(26);\n\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        if (matrix[i][j] != '.' && matrix[i][j] != '#')\n          teleportPositions[matrix[i][j] - 'A'].emplace_back(i, j);\n\n    return dijkstra(matrix, teleportPositions, {0, 0},\n                    {matrix.size() - 1, matrix[0].size() - 1});\n  }\n\n private:\n  int dijkstra(const vector<string>& matrix,\n               const vector<vector<pair<int, int>>>& teleportPositions,\n               const pair<int, int>& src, const pair<int, int>& dst) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n    vector<bool> seen(26);\n\n    dist[0][0] = 0;\n    using T = pair<int, pair<int, int>>;  // (d, u)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.push({dist[0][0], src});\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return d;\n      const auto [i, j] = u;\n      if (d > dist[i][j])\n        continue;\n      const char c = matrix[i][j];\n      if (isupper(c) && !seen[c - 'A']) {\n        seen[c - 'A'] = true;\n        for (const auto& [x, y] : teleportPositions[c - 'A'])\n          if (d < dist[x][y]) {\n            dist[x][y] = d;\n            minHeap.push({d, {x, y}});\n          }\n      }\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (matrix[x][y] == '#')\n          continue;\n        if (d + 1 < dist[x][y]) {\n          dist[x][y] = d + 1;\n          minHeap.push({d + 1, {x, y}});\n        }\n      }\n    }\n\n    return -1;\n  }\n};\n", "3553": "class Solution {\n public:\n  // Similar to 2846. Minimum Edge Weight Equilibrium Queries in a Tree\n  vector<int> minimumWeight(vector<vector<int>>& edges,\n                            vector<vector<int>>& queries) {\n    const int n = edges.size() + 1;\n    const int m = ceil(log2(n));\n    vector<int> ans;\n    vector<vector<pair<int, int>>> graph(n);\n    // jump[i][j] := the 2^j-th ancestor of i\n    vector<vector<int>> jump(n, vector<int>(m));\n    // depth[i] := the depth of i\n    vector<int> depth(n);\n    // dist[i] := the distance from root to i\n    vector<int> dist(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int w = edge[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    dfs(graph, 0, /*prev=*/-1, jump, depth, dist);\n\n    for (int j = 1; j < m; ++j)\n      for (int i = 0; i < n; ++i)\n        jump[i][j] = jump[jump[i][j - 1]][j - 1];\n\n    for (const vector<int>& query : queries) {\n      const int src1 = query[0];\n      const int src2 = query[1];\n      const int dest = query[2];\n      ans.push_back((distance(src1, src2, jump, depth, dist) +\n                     distance(src1, dest, jump, depth, dist) +\n                     distance(src2, dest, jump, depth, dist)) /\n                    2);\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev,\n           vector<vector<int>>& jump, vector<int>& depth, vector<int>& dist) {\n    for (const auto& [v, w] : graph[u]) {\n      if (v == prev)\n        continue;\n      jump[v][0] = u;\n      depth[v] = depth[u] + 1;\n      dist[v] = dist[u] + w;\n      dfs(graph, v, u, jump, depth, dist);\n    }\n  }\n\n  // Returns the lca(u, v) by binary jump.\n  int getLCA(int u, int v, const vector<vector<int>>& jump,\n             const vector<int>& depth) {\n    // v is always deeper than u.\n    if (depth[u] > depth[v])\n      return getLCA(v, u, jump, depth);\n    // Jump v to the same height of u.\n    for (int j = 0; j < jump[0].size(); ++j)\n      if (depth[v] - depth[u] >> j & 1)\n        v = jump[v][j];\n    if (u == v)\n      return u;\n    // Jump u and v to the node right below the lca.\n    for (int j = jump[0].size() - 1; j >= 0; --j)\n      if (jump[u][j] != jump[v][j]) {\n        u = jump[u][j];\n        v = jump[v][j];\n      }\n    return jump[u][0];\n  }\n\n  // Returns the distance between u and v.\n  int distance(int u, int v, const vector<vector<int>>& jump,\n               const vector<int>& depth, const vector<int>& dist) {\n    const int lca = getLCA(u, v, jump, depth);\n    return dist[u] + dist[v] - 2 * dist[lca];\n  }\n};\n", "3555": "class Solution {\n public:\n  vector<int> minSubarraySort(vector<int>& nums, int k) {\n    const int n = nums.size();\n    vector<int> ans;\n\n    for (int i = 0; i <= n - k; ++i) {\n      vector<int> window(nums.begin() + i, nums.begin() + i + k);\n      vector<int> sortedWindow = window;\n      ranges::sort(sortedWindow);\n      int l = 0;\n      int r = k - 1;\n      while (l < k && window[l] == sortedWindow[l])\n        ++l;\n      while (r >= 0 && window[r] == sortedWindow[r])\n        --r;\n      ans.push_back(l > r ? 0 : r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "3556": "class Solution {\n public:\n  long long sumOfLargestPrimes(string s) {\n    const int n = s.length();\n    unordered_set<long> primes;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j <= n; ++j) {\n        const long num = stol(s.substr(i, j - i));\n        if (!primes.contains(num) && isPrime(num))\n          primes.insert(num);\n      }\n\n    vector<long> sortedPrimes{primes.begin(), primes.end()};\n    ranges::sort(sortedPrimes, greater<>());\n    return accumulate(\n        sortedPrimes.begin(),\n        sortedPrimes.begin() + min(3, static_cast<int>(sortedPrimes.size())),\n        0L);\n  }\n\n private:\n  bool isPrime(long num) {\n    if (num <= 1)\n      return false;\n    for (int i = 2; i <= sqrt(num); ++i)\n      if (num % i == 0)\n        return false;\n    return true;\n  }\n};\n", "3557": "class Solution {\n public:\n  int maxSubstrings(string word) {\n    int ans = 0;\n    unordered_map<char, int> firstSeen;\n\n    for (int i = 0; i < word.length(); ++i) {\n      const char c = word[i];\n      if (!firstSeen.contains(c)) {\n        firstSeen[c] = i;\n      } else if (i - firstSeen[c] + 1 >= 4) {\n        ++ans;\n        firstSeen.clear();\n      }\n    }\n\n    return ans;\n  }\n};\n", "3558": "class Solution {\n public:\n  int assignEdgeWeights(vector<vector<int>>& edges) {\n    const int n = edges.size() + 1;\n    vector<vector<int>> graph(n + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    queue<int> q{{1}};\n    vector<bool> seen(n + 1);\n    seen[1] = true;\n    int step = 0;\n\n    for (step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int u = q.front();\n        q.pop();\n        for (const int v : graph[u])\n          if (!seen[v]) {\n            q.push(v);\n            seen[v] = true;\n          }\n      }\n\n    return step > 0 ? modPow(2, step - 2) : 0;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "3559": "class Solution {\n public:\n  vector<int> assignEdgeWeights(vector<vector<int>>& edges,\n                                vector<vector<int>>& queries) {\n    const int n = edges.size() + 1;\n    vector<int> ans;\n    vector<int> depth(n + 1);\n    vector<vector<int>> graph(n + 1);\n    vector<vector<int>> parent(kLog, vector<int>(n + 1, -1));\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    dfs(1, -1, graph, parent, depth);\n\n    for (int k = 1; k < kLog; ++k)\n      for (int v = 1; v <= n; ++v)\n        if (parent[k - 1][v] != -1)\n          parent[k][v] = parent[k - 1][parent[k - 1][v]];\n\n    for (const vector<int>& query : queries) {\n      const int u = query[0];\n      const int v = query[1];\n      if (u == v) {\n        ans.push_back(0);\n      } else {\n        const int a = lca(u, v, parent, depth);\n        const int d = depth[u] + depth[v] - 2 * depth[a];\n        ans.push_back(modPow(2, d - 1));\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1'000'000'007;\n  static constexpr int kLog = 17;  // since 2^17 > 1e5\n\n  void dfs(int u, int p, const vector<vector<int>>& graph,\n           vector<vector<int>>& parent, vector<int>& depth) {\n    parent[0][u] = p;\n    for (const int v : graph[u])\n      if (v != p) {\n        depth[v] = depth[u] + 1;\n        dfs(v, u, graph, parent, depth);\n      }\n  }\n\n  int lca(int u, int v, const vector<vector<int>>& parent,\n          const vector<int>& depth) {\n    if (depth[u] < depth[v])\n      swap(u, v);\n\n    for (int k = kLog - 1; k >= 0; --k)\n      if (parent[k][u] != -1 && depth[parent[k][u]] >= depth[v])\n        u = parent[k][u];\n\n    if (u == v)\n      return u;\n\n    for (int k = kLog - 1; k >= 0; --k)\n      if (parent[k][u] != -1 && parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n\n    return parent[0][u];\n  }\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "356": "class Solution {\n public:\n  bool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n    unordered_set<pair<int, int>, PairHash> seen;\n\n    for (const vector<int>& p : points) {\n      const int x = p[0];\n      const int y = p[1];\n      minX = min(minX, x);\n      maxX = max(maxX, x);\n      seen.insert({x, y});\n    }\n\n    const int sum = minX + maxX;\n    // (leftX + rightX) / 2 = (minX + maxX) / 2\n    //  leftX = minX + maxX - rightX\n    // rightX = minX + maxX - leftX\n\n    for (const vector<int>& p : points)\n      if (!seen.contains({sum - p[0], p[1]}))\n        return false;\n\n    return true;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "3560": "class Solution {\n public:\n  long long minCuttingCost(long n, long m, int k) {\n    return max(0L, max(n, m) - k) * k;\n  }\n};\n", "3561": "class Solution {\n public:\n  string resultingString(string s) {\n    string ans;\n\n    for (const char c : s)\n      if (!ans.empty() &&\n          (abs(ans.back() - c) == 1 || abs(ans.back() - c) == 25))\n        ans.pop_back();\n      else\n        ans += c;\n\n    return ans;\n  }\n};\n", "3563": "class Solution {\n public:\n  string lexicographicallySmallestString(string s) {\n    const int n = s.size();\n    // dp[i][j] := the lexicographically smallest string by removing adjacent\n    // letters from s[i..j)\n    vector<vector<string>> dp(n + 1, vector<string>(n + 1));\n\n    for (int d = 1; d <= n; ++d)\n      for (int i = 0; i + d <= n; ++i) {\n        const int j = i + d;\n        // 1. Keep s[i].\n        string minString = s[i] + dp[i + 1][j];\n        // 2. Remove s[i] and s[k] if possible.\n        for (int k = i + 1; k < j; ++k)\n          if (isConsecutive(s[i], s[k]) && dp[i + 1][k].empty())\n            minString = min(minString, dp[k + 1][j]);\n        dp[i][j] = minString;\n      }\n\n    return dp[0][n];\n  }\n\n private:\n  bool isConsecutive(char a, char b) {\n    return abs(a - b) == 1 || abs(a - b) == 25;\n  }\n};\n", "357": "class Solution {\n public:\n  int countNumbersWithUniqueDigits(int n) {\n    if (n == 0)\n      return 1;\n\n    int ans = 10;\n    int uniqueDigits = 9;\n\n    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {\n      uniqueDigits *= availableNum;\n      ans += uniqueDigits;\n    }\n\n    return ans;\n  }\n};\n", "358": "class Solution {\n public:\n  string rearrangeString(string s, int k) {\n    const int n = s.length();\n    string ans;\n    vector<int> count(26);\n    // valid[i] := the leftmost index ('a' + i) can appear\n    vector<int> valid(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int i = 0; i < n; ++i) {\n      const char c = getBestLetter(count, valid, i);\n      if (c == '*')\n        return \"\";\n      ans += c;\n      --count[c - 'a'];\n      valid[c - 'a'] = i + k;\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns the valid letter that has the most count.\n  char getBestLetter(const vector<int>& count, const vector<int>& valid,\n                     int index) {\n    int maxCount = -1;\n    char bestLetter = '*';\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c - 'a'] > 0 && count[c - 'a'] > maxCount &&\n          index >= valid[c - 'a']) {\n        bestLetter = c;\n        maxCount = count[c - 'a'];\n      }\n\n    return bestLetter;\n  }\n};\n", "359": "class Logger {\n public:\n  bool shouldPrintMessage(int timestamp, string message) {\n    if (timestamp < okTime[message])\n      return false;\n\n    okTime[message] = timestamp + 10;\n    return true;\n  }\n\n private:\n  unordered_map<string, int> okTime;  // {message: ok time}\n};\n", "36": "class Solution {\n public:\n  bool isValidSudoku(vector<vector<char>>& board) {\n    unordered_set<string> seen;\n\n    for (int i = 0; i < 9; ++i)\n      for (int j = 0; j < 9; ++j) {\n        if (board[i][j] == '.')\n          continue;\n        const string c(1, board[i][j]);\n        if (!seen.insert(c + \"@row\" + to_string(i)).second ||\n            !seen.insert(c + \"@col\" + to_string(j)).second ||\n            !seen.insert(c + \"@box\" + to_string(i / 3) + to_string(j / 3))\n                 .second)\n          return false;\n      }\n\n    return true;\n  }\n};\n", "360": "class Solution {\n public:\n  vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    const int n = nums.size();\n    const bool upward = a > 0;\n    vector<int> ans(n);\n    vector<int> quad;\n\n    for (const int num : nums)\n      quad.push_back(f(num, a, b, c));\n\n    int i = upward ? n - 1 : 0;\n    for (int l = 0, r = n - 1; l <= r;)\n      if (upward)  // is the maximum in the both ends\n        ans[i--] = quad[l] > quad[r] ? quad[l++] : quad[r--];\n      else  // is the minimum in the both ends\n        ans[i++] = quad[l] < quad[r] ? quad[l++] : quad[r--];\n\n    return ans;\n  }\n\n private:\n  // The concavity of f only depends on a's sign.\n  int f(int x, int a, int b, int c) {\n    return (a * x + b) * x + c;\n  }\n};\n", "361": "class Solution {\n public:\n  int maxKilledEnemies(vector<vector<char>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int enemyCount = 0;\n    // dp[i][j] := the maximum enemies grid[i][j] can kill\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    auto update = [&](int i, int j) {\n      if (grid[i][j] == '0')\n        dp[i][j] += enemyCount;\n      else if (grid[i][j] == 'E')\n        ++enemyCount;\n      else  // grid[i][j] == 'W'\n        enemyCount = 0;\n    };\n\n    // Extend the four directions, if meet 'W', need to start over from 0.\n    for (int i = 0; i < m; ++i) {\n      enemyCount = 0;\n      for (int j = 0; j < n; ++j)\n        update(i, j);\n      enemyCount = 0;\n      for (int j = n - 1; j >= 0; --j)\n        update(i, j);\n    }\n\n    for (int j = 0; j < n; ++j) {\n      enemyCount = 0;\n      for (int i = 0; i < m; ++i)\n        update(i, j);\n      enemyCount = 0;\n      for (int i = m - 1; i >= 0; --i)\n        update(i, j);\n    }\n\n    return accumulate(dp.begin(), dp.end(), 0,\n                      [](int acc, const vector<int>& row) {\n      return max(acc, ranges::max(row));\n    });\n  }\n};\n", "362": "class HitCounter {\n public:\n  void hit(int timestamp) {\n    const int i = timestamp % 300;\n    if (timestamps[i] == timestamp) {\n      ++hits[i];\n    } else {\n      timestamps[i] = timestamp;\n      hits[i] = 1;  // Reset the hit count to 1.\n    }\n  }\n\n  int getHits(int timestamp) {\n    int countHits = 0;\n    for (int i = 0; i < 300; ++i)\n      if (timestamp - timestamps[i] < 300)\n        countHits += hits[i];\n    return countHits;\n  }\n\n private:\n  vector<int> timestamps = vector<int>(300);\n  vector<int> hits = vector<int>(300);\n};\n", "363": "class Solution {\n public:\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int ans = INT_MIN;\n\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\n      // sums[i] := sum(matrix[i][baseCol..j])\n      vector<int> sums(m, 0);\n      for (int j = baseCol; j < n; ++j) {\n        for (int i = 0; i < m; ++i)\n          sums[i] += matrix[i][j];\n        // Find the maximum sum <= k of all the subarrays.\n        set<int> accumulate{0};\n        int prefix = 0;\n        for (const int sum : sums) {\n          prefix += sum;\n          if (const auto it = accumulate.lower_bound(prefix - k);\n              it != accumulate.cend())\n            ans = max(ans, prefix - *it);\n          accumulate.insert(prefix);\n        }\n      }\n    }\n\n    return ans;\n  }\n};\n", "364": "class Solution {\n public:\n  int depthSumInverse(vector<NestedInteger>& nestedList) {\n    int ans = 0;\n    int prevSum = 0;\n    queue<NestedInteger> q{{nestedList.begin(), nestedList.end()}};\n\n    while (!q.empty()) {\n      for (int sz = q.size(); sz > 0; --sz) {\n        const NestedInteger ni = q.front();\n        q.pop();\n        if (ni.isInteger())\n          prevSum += ni.getInteger();\n        else {\n          for (const NestedInteger nextNi : ni.getList())\n            q.push(nextNi);\n        }\n      }\n      ans += prevSum;\n    }\n\n    return ans;\n  }\n};\n", "365": "class Solution {\n public:\n  bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    return targetCapacity == 0 ||\n           jug1Capacity + jug2Capacity >= targetCapacity &&\n               targetCapacity % __gcd(jug1Capacity, jug2Capacity) == 0;\n  }\n};\n", "366": "class Solution {\n public:\n  vector<vector<int>> findLeaves(TreeNode* root) {\n    vector<vector<int>> ans;\n    depth(root, ans);\n    return ans;\n  }\n\n private:\n  // Returns the depth of the root (0-indexed).\n  int depth(TreeNode* root, vector<vector<int>>& ans) {\n    if (root == nullptr)\n      return -1;\n\n    const int l = depth(root->left, ans);\n    const int r = depth(root->right, ans);\n    const int h = 1 + max(l, r);\n    if (ans.size() == h)  // Meet a leaf.\n      ans.push_back({});\n\n    ans[h].push_back(root->val);\n    return h;\n  }\n};\n", "367": "class Solution {\n public:\n  bool isPerfectSquare(int num) {\n    long l = 1;\n    long r = num;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (m >= num / m)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l * l == num;\n  }\n};\n", "368": "class Solution {\n public:\n  vector<int> largestDivisibleSubset(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans;\n    // sizeEndsAt[i] := the maximum size ends in nums[i]\n    vector<int> sizeEndsAt(n, 1);\n    // prevIndex[i] := the best index s.t.\n    // 1. nums[i] % nums[prevIndex[i]] == 0 and\n    // 2. can increase the size of the subset\n    vector<int> prevIndex(n, -1);\n    int maxSize = 0;  // Max size of the subset\n    int index = -1;   // Track the best ending index\n\n    ranges::sort(nums);\n\n    // Fix the maximum ending number in the subset.\n    for (int i = 0; i < n; ++i) {\n      for (int j = i - 1; j >= 0; --j)\n        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {\n          sizeEndsAt[i] = sizeEndsAt[j] + 1;\n          prevIndex[i] = j;\n        }\n      // Find a new subset that has a bigger size.\n      if (maxSize < sizeEndsAt[i]) {\n        maxSize = sizeEndsAt[i];\n        index = i;  // Update the best ending index.\n      }\n    }\n\n    // Loop from the back to the front.\n    while (index != -1) {\n      ans.push_back(nums[index]);\n      index = prevIndex[index];\n    }\n\n    return ans;\n  }\n};\n", "369": "class Solution {\n public:\n  ListNode* plusOne(ListNode* head) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* curr = dummy;\n    dummy->next = head;\n\n    while (head != nullptr) {\n      if (head->val != 9)\n        curr = head;\n      head = head->next;\n    }\n    // `curr` now points to the rightmost non-9 node.\n\n    ++curr->val;\n    while (curr->next != nullptr) {\n      curr->next->val = 0;\n      curr = curr->next;\n    }\n\n    return dummy->val == 0 ? dummy->next : dummy;\n  }\n};\n", "37": "class Solution {\n public:\n  void solveSudoku(vector<vector<char>>& board) {\n    solve(board, 0);\n  }\n\n private:\n  bool solve(vector<vector<char>>& board, int s) {\n    if (s == 81)\n      return true;\n\n    const int i = s / 9;\n    const int j = s % 9;\n\n    if (board[i][j] != '.')\n      return solve(board, s + 1);\n\n    for (char c = '1'; c <= '9'; ++c)\n      if (isValid(board, i, j, c)) {\n        board[i][j] = c;\n        if (solve(board, s + 1))\n          return true;\n        board[i][j] = '.';\n      }\n\n    return false;\n  }\n\n  bool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; ++i)\n      if (board[i][col] == c || board[row][i] == c ||\n          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n        return false;\n    return true;\n  }\n};\n", "370": "class Solution {\n public:\n  vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {\n    vector<int> ans;\n    vector<int> line(length);\n    int prefix = 0;\n\n    for (const vector<int>& update : updates) {\n      const int start = update[0];\n      const int end = update[1];\n      const int inc = update[2];\n      line[start] += inc;\n      if (end + 1 < length)\n        line[end + 1] -= inc;\n    }\n\n    for (const int diff : line) {\n      prefix += diff;\n      ans.push_back(prefix);\n    }\n\n    return ans;\n  }\n};\n", "371": "class Solution {\n public:\n  int getSum(unsigned a, unsigned b) {\n    while (b > 0) {                  // Still have carry bits.\n      const unsigned carry = a & b;  // Record the carry bits.\n      a ^= b;  // ^ works like + without handling carry bits.\n      b = carry << 1;\n    }\n    return a;\n  }\n};\n", "372": "class Solution {\n public:\n  int superPow(int a, vector<int>& b) {\n    int ans = 1;\n\n    a %= kMod;\n    for (const int i : b)\n      ans = modPow(ans, 10) * modPow(a, i) % kMod;\n\n    return ans;\n  }\n\n private:\n  static constexpr int kMod = 1337;\n\n  long modPow(long x, long n) {\n    if (n == 0)\n      return 1;\n    if (n % 2 == 1)\n      return x * modPow(x % kMod, (n - 1)) % kMod;\n    return modPow(x * x % kMod, (n / 2)) % kMod;\n  }\n};\n", "373": "struct T {\n  int i;\n  int j;\n  int sum;  // nums1[i] + nums2[j]\n};\n\nclass Solution {\n public:\n  vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,\n                                     int k) {\n    vector<vector<int>> ans;\n    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (int i = 0; i < k && i < nums1.size(); ++i)\n      minHeap.emplace(i, 0, nums1[i] + nums2[0]);\n\n    while (!minHeap.empty() && ans.size() < k) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      ans.push_back({nums1[i], nums2[j]});\n      if (j + 1 < nums2.size())\n        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);\n    }\n\n    return ans;\n  }\n};\n", "374": "/**\n * Forward declaration of guess API.\n * (The problem description is not clear, so I translate it into follows.)\n *\n * @param traget num\n *        guess num\n *\n * @return -1 if guess num >  target num\n *          0 if guess num == target num\n *          1 if guess num <  target num\n */\n\nclass Solution {\n public:\n  int guessNumber(int n) {\n    int l = 1;\n    int r = n;\n\n    // Find the first guess number that >= the target number\n    while (l < r) {\n      const int m = l + (r - l) / 2;\n      if (guess(m) <= 0)  // -1, 0\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n};\n", "375": "class Solution {\n public:\n  int getMoneyAmount(int n) {\n    // dp[i][j] := the minimum money you need to guarantee a win of picking i..j\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2));\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 1; i + d <= n; ++i) {\n        const int j = i + d;\n        dp[i][j] = INT_MAX;\n        for (int k = i; k <= j; ++k)\n          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k);\n      }\n\n    return dp[1][n];\n  }\n};\n", "376": "class Solution {\n public:\n  int wiggleMaxLength(vector<int>& nums) {\n    int increasing = 1;\n    int decreasing = 1;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1])\n        increasing = decreasing + 1;\n      else if (nums[i] < nums[i - 1])\n        decreasing = increasing + 1;\n\n    return max(increasing, decreasing);\n  }\n};\n", "377": "class Solution {\n public:\n  int combinationSum4(vector<int>& nums, int target) {\n    vector<unsigned long> dp(target + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= target; ++i)\n      for (const int num : nums)\n        if (i >= num)\n          dp[i] += dp[i - num];\n\n    return dp[target];\n  }\n};\n", "378": "class Solution {\n public:\n  int kthSmallest(vector<vector<int>>& matrix, int k) {\n    int l = matrix[0][0];\n    int r = matrix.back().back();\n\n    while (l < r) {\n      const int m = l + (r - l) / 2;\n      if (numsNoGreaterThan(matrix, m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numsNoGreaterThan(const vector<vector<int>>& matrix, int m) {\n    int count = 0;\n    int j = matrix[0].size() - 1;\n    // For each row, find the first index j s.t. row[j] <= m s.t. the number of\n    // numbers <= m for this row will be j + 1.\n    for (const vector<int>& row : matrix) {\n      while (j >= 0 && row[j] > m)\n        --j;\n      count += j + 1;\n    }\n    return count;\n  }\n};\n", "379": "class PhoneDirectory {\n public:\n  PhoneDirectory(int maxNumbers) : next(maxNumbers) {\n    for (int i = 0; i < maxNumbers - 1; ++i)\n      next[i] = i + 1;\n    next.back() = 0;\n  }\n\n  int get() {\n    if (next[number] == -1)\n      return -1;\n    const int ans = number;\n    number = next[number];\n    next[ans] = -1;  // Mark as used.\n    return ans;\n  }\n\n  bool check(int number) {\n    return next[number] != -1;\n  }\n\n  void release(int number) {\n    if (next[number] != -1)\n      return;\n    next[number] = this->number;\n    this->number = number;\n  }\n\n private:\n  int number = 0;    // the current possible available number\n  vector<int> next;  // the next available numbers\n};\n", "38": "class Solution {\n public:\n  string countAndSay(int n) {\n    string ans = \"1\";\n\n    while (--n > 0) {\n      string next;\n      for (int i = 0; i < ans.length(); ++i) {\n        int count = 1;\n        while (i + 1 < ans.length() && ans[i] == ans[i + 1]) {\n          ++count;\n          ++i;\n        }\n        next += to_string(count) + ans[i];\n      }\n      ans = std::move(next);\n    }\n\n    return ans;\n  }\n};\n", "380": "class RandomizedSet {\n public:\n  bool insert(int val) {\n    if (valToIndex.contains(val))\n      return false;\n    valToIndex[val] = vals.size();\n    vals.push_back(val);\n    return true;\n  }\n\n  bool remove(int val) {\n    if (!valToIndex.contains(val))\n      return false;\n    const int index = valToIndex[val];\n    // The order of the following two lines is important when vals.size() == 1.\n    valToIndex[vals.back()] = index;\n    valToIndex.erase(val);\n    vals[index] = vals.back();\n    vals.pop_back();\n    return true;\n  }\n\n  int getRandom() {\n    const int index = rand() % vals.size();\n    return vals[index];\n  }\n\n private:\n  unordered_map<int, int> valToIndex;  // {val: index in vals}\n  vector<int> vals;\n};\n", "381": "struct Item {\n  int val;\n  int indexInMap;\n};\n\nclass RandomizedCollection {\n public:\n  bool insert(int val) {\n    valToIndices[val].push_back(items.size());\n    items.emplace_back(val, valToIndices[val].size() - 1);\n    return valToIndices[val].size() == 1;\n  }\n\n  bool remove(int val) {\n    if (!valToIndices.contains(val))\n      return false;\n\n    const int index = valToIndices[val].back();\n    valToIndices[items.back().val][items.back().indexInMap] = index;\n    valToIndices[val].pop_back();\n    if (valToIndices[val].empty())\n      valToIndices.erase(val);\n    items[index] = items.back();\n    items.pop_back();\n    return true;\n  }\n\n  int getRandom() {\n    const int index = rand() % items.size();\n    return items[index].val;\n  }\n\n private:\n  unordered_map<int, vector<int>> valToIndices;\n  vector<Item> items;\n};\n", "382": "class Solution {\n public:\n  /** @param head The linked list's head.\n      Note that the head is guaranteed to be not null, so it contains at least\n     one node. */\n  Solution(ListNode* head) : head(head) {}\n\n  /** Returns a random node's value. */\n  int getRandom() {\n    int res = -1;\n    int i = 1;\n\n    for (ListNode* curr = head; curr; curr = curr->next, ++i)\n      if (rand() % i == 0)\n        res = curr->val;\n\n    return res;\n  }\n\n private:\n  ListNode* head;\n};\n", "383": "class Solution {\n public:\n  // Similar to 0242. Valid Anagram\n  bool canConstruct(string ransomNote, string magazine) {\n    vector<int> count(26);\n\n    for (const char c : magazine)\n      ++count[c - 'a'];\n\n    for (const char c : ransomNote) {\n      if (count[c - 'a'] == 0)\n        return false;\n      --count[c - 'a'];\n    }\n\n    return true;\n  }\n};\n", "384": "class Solution {\n public:\n  Solution(vector<int>& nums) : nums(std::move(nums)) {}\n\n  vector<int> reset() {\n    return nums;\n  }\n\n  vector<int> shuffle() {\n    vector<int> arr(nums);\n    for (int i = arr.size() - 1; i > 0; --i) {\n      const int j = rand() % (i + 1);\n      swap(arr[i], arr[j]);\n    }\n    return arr;\n  }\n\n private:\n  vector<int> nums;\n};\n", "385": "class Solution {\n public:\n  NestedInteger deserialize(string s) {\n    if (s[0] != '[')\n      return NestedInteger(stoi(s));\n\n    stack<NestedInteger> stack;\n    int start;  // the start index of a number\n\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s[i]) {\n        case '[':\n          stack.push(NestedInteger());\n          start = i + 1;\n          break;\n        case ',':\n          if (i > start) {\n            const int num = stoi(s.substr(start, i));\n            stack.top().add(NestedInteger(num));\n          }\n          start = i + 1;\n          break;\n        case ']':\n          NestedInteger popped = stack.top();\n          stack.pop();\n          if (i > start) {\n            const int num = stoi(s.substr(start, i));\n            popped.add(NestedInteger(num));\n          }\n          if (stack.empty())\n            return popped;\n          else\n            stack.top().add(popped);\n          start = i + 1;\n          break;\n      }\n    }\n\n    throw;\n  }\n};\n", "386": "class Solution {\n public:\n  vector<int> lexicalOrder(int n) {\n    vector<int> ans;\n    int curr = 1;\n\n    while (ans.size() < n) {\n      ans.push_back(curr);\n      if (curr * 10 <= n) {\n        curr *= 10;\n      } else {\n        while (curr % 10 == 9 || curr == n)\n          curr /= 10;\n        ++curr;\n      }\n    }\n\n    return ans;\n  }\n};\n", "387": "class Solution {\n public:\n  int firstUniqChar(string s) {\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (int i = 0; i < s.length(); ++i)\n      if (count[s[i] - 'a'] == 1)\n        return i;\n\n    return -1;\n  }\n};\n", "388": "struct T {\n  int depth;\n  size_t length;\n};\n\nclass Solution {\n public:\n  int lengthLongestPath(string input) {\n    size_t ans = 0;\n    stack<T> stack{{{-1, 0}}};  // placeholder\n    istringstream iss(input);\n\n    for (string token; getline(iss, token, '\\n');) {\n      const int depth = ranges::count(token, '\\t');\n      std::erase(token, '\\t');\n      while (depth <= stack.top().depth)\n        stack.pop();\n      if (isFile(token))\n        ans = max(ans, stack.top().length + token.length());\n      else  // directory + '/'\n        stack.emplace(depth, stack.top().length + token.length() + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  bool isFile(const string& token) {\n    return token.find('.') != string::npos;\n  }\n};\n", "389": "class Solution {\n public:\n  char findTheDifference(string s, string t) {\n    vector<int> count(26);\n\n    for (const char c : s)\n      ++count[c - 'a'];\n\n    for (const char c : t) {\n      if (count[c - 'a'] == 0)\n        return c;\n      --count[c - 'a'];\n    }\n\n    throw;\n  }\n};\n", "39": "class Solution {\n public:\n  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    vector<vector<int>> ans;\n    ranges::sort(candidates);\n    dfs(candidates, 0, target, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& candidates, int s, int target, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i < candidates.size(); ++i) {\n      path.push_back(candidates[i]);\n      dfs(candidates, i, target - candidates[i], std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "390": "class Solution {\n public:\n  int lastRemaining(int n) {\n    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));\n  }\n};\n", "391": "class Solution {\n public:\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\n    int area = 0;\n    int x1 = INT_MAX;\n    int y1 = INT_MAX;\n    int x2 = INT_MIN;\n    int y2 = INT_MIN;\n    unordered_set<string> corners;\n\n    for (const vector<int>& r : rectangles) {\n      area += (r[2] - r[0]) * (r[3] - r[1]);\n      x1 = min(x1, r[0]);\n      y1 = min(y1, r[1]);\n      x2 = max(x2, r[2]);\n      y2 = max(y2, r[3]);\n\n      // the four points of the current rectangle\n      const vector<string> points{to_string(r[0]) + \" \" + to_string(r[1]),\n                                  to_string(r[0]) + \" \" + to_string(r[3]),\n                                  to_string(r[2]) + \" \" + to_string(r[1]),\n                                  to_string(r[2]) + \" \" + to_string(r[3])};\n      for (const string& point : points)\n        if (!corners.insert(point).second)\n          corners.erase(point);\n    }\n\n    if (corners.size() != 4)\n      return false;\n    if (!corners.contains(to_string(x1) + \" \" + to_string(y1)) ||\n        !corners.contains(to_string(x1) + \" \" + to_string(y2)) ||\n        !corners.contains(to_string(x2) + \" \" + to_string(y1)) ||\n        !corners.contains(to_string(x2) + \" \" + to_string(y2)))\n      return false;\n    return area == (x2 - x1) * (y2 - y1);\n  }\n};\n", "392": "class Solution {\n public:\n  bool isSubsequence(string s, string t) {\n    if (s.empty())\n      return true;\n\n    int i = 0;\n    for (const char c : t)\n      if (s[i] == c && ++i == s.length())\n        return true;\n\n    return false;\n  }\n};\n", "393": "class Solution {\n public:\n  bool validUtf8(vector<int>& data) {\n    int followedBytes = 0;\n\n    for (const int d : data)\n      if (followedBytes == 0) {\n        if ((d >> 3) == 0b11110)\n          followedBytes = 3;\n        else if ((d >> 4) == 0b1110)\n          followedBytes = 2;\n        else if ((d >> 5) == 0b110)\n          followedBytes = 1;\n        else if ((d >> 7) == 0b0)\n          followedBytes = 0;\n        else\n          return false;\n      } else {\n        if ((d >> 6) != 0b10)\n          return false;\n        --followedBytes;\n      }\n\n    return followedBytes == 0;\n  }\n};\n", "394": "class Solution {\n public:\n  string decodeString(string s) {\n    string ans;\n\n    while (i < s.length() && s[i] != ']')\n      if (isdigit(s[i])) {\n        int k = 0;\n        while (i < s.length() && isdigit(s[i]))\n          k = k * 10 + (s[i++] - '0');\n        ++i;  // '['\n        const string& decodedString = decodeString(s);\n        ++i;  // ']'\n        while (k-- > 0)\n          ans += decodedString;\n      } else {\n        ans += s[i++];\n      }\n\n    return ans;\n  }\n\n private:\n  int i = 0;\n};\n", "395": "class Solution {\n public:\n  int longestSubstring(string s, int k) {\n    int ans = 0;\n    for (int n = 1; n <= 26; ++n)\n      ans = max(ans, longestSubstringWithNUniqueLetters(s, k, n));\n    return ans;\n  }\n\n private:\n  int longestSubstringWithNUniqueLetters(const string& s, int k, int n) {\n    int res = 0;\n    int uniqueLetters = 0;       // the number of unique letters\n    int lettersHavingKFreq = 0;  // the number of letters having frequency >= k\n    vector<int> count(26);\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (++count[s[r] - 'a'] == 1)\n        ++uniqueLetters;\n      if (count[s[r] - 'a'] == k)\n        ++lettersHavingKFreq;\n      while (uniqueLetters > n) {\n        if (count[s[l] - 'a'] == k)\n          --lettersHavingKFreq;\n        if (--count[s[l] - 'a'] == 0)\n          --uniqueLetters;\n        ++l;\n      }\n      // Since both the number of unique letters and the number of letters\n      // having frequency >= k are equal to n, this is a valid window.\n      if (lettersHavingKFreq == n)  // Implicit: uniqueLetters == n\n        res = max(res, r - l + 1);\n    }\n\n    return res;\n  }\n};\n", "396": "class Solution {\n public:\n  int maxRotateFunction(vector<int>& nums) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    int f = 0;\n\n    // Calculate F(0) first.\n    for (int i = 0; i < nums.size(); ++i)\n      f += i * nums[i];\n\n    int ans = f;\n\n    for (int i = nums.size() - 1; i > 0; --i) {\n      f += sum - nums.size() * nums[i];\n      ans = max(ans, f);\n    }\n\n    return ans;\n  }\n};\n", "397": "class Solution {\n public:\n  int integerReplacement(long n) {\n    int ans = 0;\n\n    for (; n > 1; ++ans)\n      if (n % 2 == 0)  // `n` ends in 0.\n        n >>= 1;\n      else if (n == 3 || (n >> 1 & 1) == 0)  // `n` = 3 or ends in 0b01.\n        --n;\n      else  // `n` ends in 0b11.\n        ++n;\n\n    return ans;\n  }\n};\n", "398": "class Solution {\n public:\n  Solution(vector<int>& nums) : nums(std::move(nums)) {}\n\n  int pick(int target) {\n    int ans = -1;\n    int range = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] == target && rand() % ++range == 0)\n        ans = i;\n\n    return ans;\n  }\n\n private:\n  vector<int> nums;\n};\n", "399": "class Solution {\n public:\n  vector<double> calcEquation(vector<vector<string>>& equations,\n                              vector<double>& values,\n                              vector<vector<string>>& queries) {\n    vector<double> ans;\n    // graph[A][B] := A / B\n    unordered_map<string, unordered_map<string, double>> graph;\n\n    for (int i = 0; i < equations.size(); ++i) {\n      const string& A = equations[i][0];\n      const string& B = equations[i][1];\n      graph[A][B] = values[i];\n      graph[B][A] = 1 / values[i];\n    }\n\n    for (const vector<string>& query : queries) {\n      const string& A = query[0];\n      const string& C = query[1];\n      if (!graph.contains(A) || !graph.contains(C))\n        ans.push_back(-1);\n      else\n        ans.push_back(divide(graph, A, C, unordered_set<string>()));\n    }\n\n    return ans;\n  }\n\n private:\n  // Returns A / C.\n  double divide(\n      const unordered_map<string, unordered_map<string, double>>& graph,\n      const string& A, const string& C, unordered_set<string>&& seen) {\n    if (A == C)\n      return 1.0;\n\n    seen.insert(A);\n\n    // value := A / B\n    for (const auto& [B, value] : graph.at(A)) {\n      if (seen.contains(B))\n        continue;\n      const double res = divide(graph, B, C, std::move(seen));  // B / C\n      if (res > 0)                                              // valid result\n        return value * res;  // A / C = (A / B) * (B / C)\n    }\n\n    return -1;  // invalid result\n  }\n};\n", "4": "class Solution {\n public:\n  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    const int n1 = nums1.size();\n    const int n2 = nums2.size();\n    if (n1 > n2)\n      return findMedianSortedArrays(nums2, nums1);\n\n    int l = 0;\n    int r = n1;\n\n    while (l <= r) {\n      const int partition1 = (l + r) / 2;\n      const int partition2 = (n1 + n2 + 1) / 2 - partition1;\n      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];\n      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];\n      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];\n      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];\n      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)\n        return (n1 + n2) % 2 == 0\n                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n                   : max(maxLeft1, maxLeft2);\n      else if (maxLeft1 > minRight2)\n        r = partition1 - 1;\n      else\n        l = partition1 + 1;\n    }\n\n    throw;\n  }\n};\n", "40": "class Solution {\n public:\n  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n    vector<vector<int>> ans;\n    ranges::sort(candidates);\n    dfs(candidates, 0, target, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& candidates, int s, int target, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (target < 0)\n      return;\n    if (target == 0) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i < candidates.size(); ++i) {\n      if (i > s && candidates[i] == candidates[i - 1])\n        continue;\n      path.push_back(candidates[i]);\n      dfs(candidates, i + 1, target - candidates[i], std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "400": "class Solution {\n public:\n  int findNthDigit(int n) {\n    int digitSize = 1;\n    int startNum = 1;\n    long count = 9;\n\n    while (digitSize * count < n) {\n      n -= digitSize * count;\n      ++digitSize;\n      startNum *= 10;\n      count *= 10;\n    }\n\n    const int targetNum = startNum + (n - 1) / digitSize;\n    const int index = (n - 1) % digitSize;\n    return to_string(targetNum)[index] - '0';\n  }\n};\n", "401": "class Solution {\n public:\n  vector<string> readBinaryWatch(int turnedOn) {\n    vector<string> ans;\n\n    for (unsigned h = 0; h < 12; ++h)\n      for (unsigned m = 0; m < 60; ++m)\n        if (popcount(h << 6 | m) == turnedOn)\n          ans.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\n\n    return ans;\n  }\n};\n", "402": "class Solution {\n public:\n  string removeKdigits(string num, int k) {\n    if (num.length() == k)\n      return \"0\";\n\n    string ans;\n    vector<char> stack;\n\n    for (int i = 0; i < num.length(); ++i) {\n      while (k > 0 && !stack.empty() && stack.back() > num[i]) {\n        stack.pop_back();\n        --k;\n      }\n      stack.push_back(num[i]);\n    }\n\n    while (k-- > 0)\n      stack.pop_back();\n\n    for (const char c : stack) {\n      if (c == '0' && ans.empty())\n        continue;\n      ans += c;\n    }\n\n    return ans.empty() ? \"0\" : ans;\n  }\n};\n", "403": "class Solution {\n public:\n  bool canCross(vector<int>& stones) {\n    const int n = stones.size();\n    // dp[i][j] := true if a frog can make a size j jump from stones[i]\n    vector<vector<bool>> dp(n, vector<bool>(n + 1));\n    dp[0][1] = true;\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const int k = stones[i] - stones[j];\n        if (k <= n && dp[j][k]) {\n          dp[i][k - 1] = true;\n          dp[i][k] = true;\n          dp[i][k + 1] = true;\n        }\n      }\n\n    return ranges::any_of(dp.back(), [](bool val) { return val; });\n  }\n};\n", "404": "class Solution {\n public:\n  int sumOfLeftLeaves(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n\n    int ans = 0;\n    stack<TreeNode*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      if (root->left) {\n        if (root->left->left == nullptr && root->left->right == nullptr)\n          ans += root->left->val;\n        else\n          stack.push(root->left);\n      }\n      if (root->right)\n        stack.push(root->right);\n    }\n\n    return ans;\n  }\n};\n", "405": "class Solution {\n public:\n  string toHex(unsigned num) {\n    if (num == 0)\n      return \"0\";\n\n    constexpr char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    string ans;\n\n    while (num != 0) {\n      ans += hex[num & 0xf];\n      num >>= 4;\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "406": "class Solution {\n public:\n  vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n    vector<vector<int>> ans;\n\n    ranges::sort(people, ranges::less{}, [](const vector<int>& person) {\n      const int h = person[0];\n      const int k = person[1];\n      return pair<int, int>{-h, k};\n    });\n\n    for (const vector<int>& person : people)\n      ans.insert(ans.begin() + person[1], person);\n\n    return ans;\n  }\n};\n", "407": "struct T {\n  int i;\n  int j;\n  int h;  // heightMap[i][j] or the height after filling water\n};\n\nclass Solution {\n public:\n  int trapRainWater(vector<vector<int>>& heightMap) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = heightMap.size();\n    const int n = heightMap[0].size();\n    int ans = 0;\n    auto compare = [](const T& a, const T& b) { return a.h > b.h; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i) {\n      minHeap.emplace(i, 0, heightMap[i][0]);\n      minHeap.emplace(i, n - 1, heightMap[i][n - 1]);\n      seen[i][0] = true;\n      seen[i][n - 1] = true;\n    }\n\n    for (int j = 1; j < n - 1; ++j) {\n      minHeap.emplace(0, j, heightMap[0][j]);\n      minHeap.emplace(m - 1, j, heightMap[m - 1][j]);\n      seen[0][j] = true;\n      seen[m - 1][j] = true;\n    }\n\n    while (!minHeap.empty()) {\n      const auto [i, j, h] = minHeap.top();\n      minHeap.pop();\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        if (heightMap[x][y] < h) {\n          ans += h - heightMap[x][y];\n          minHeap.emplace(x, y, h);  // Fill water in grid[x][y].\n        } else {\n          minHeap.emplace(x, y, heightMap[x][y]);\n        }\n        seen[x][y] = true;\n      }\n    }\n\n    return ans;\n  }\n};\n", "408": "class Solution {\n public:\n  bool validWordAbbreviation(const string& word, const string& abbr) {\n    int i = 0;  // word's index\n    int j = 0;  // abbr's index\n\n    while (i < word.length() && j < abbr.length()) {\n      if (word[i] == abbr[j]) {\n        ++i;\n        ++j;\n        continue;\n      }\n      if (abbr[j] <= '0' || abbr[j] > '9')\n        return false;\n      int num = 0;\n      while (j < abbr.length() && isdigit(abbr[j])) {\n        num = num * 10 + abbr[j] - '0';\n        ++j;\n      }\n      i += num;\n    }\n\n    return i == word.length() && j == abbr.length();\n  }\n};\n", "409": "class Solution {\n public:\n  int longestPalindrome(string s) {\n    int ans = 0;\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const int freq : count)\n      ans += freq % 2 == 0 ? freq : freq - 1;\n\n    const bool hasOddCount =\n        ranges::any_of(count, [](int c) { return c % 2 == 1; });\n    return ans + hasOddCount;\n  }\n};\n", "41": "class Solution {\n public:\n  int firstMissingPositive(vector<int>& nums) {\n    const int n = nums.size();\n\n    // Correct slot:\n    // nums[i] = i + 1\n    // nums[i] - 1 = i\n    // nums[nums[i] - 1] = nums[i]\n    for (int i = 0; i < n; ++i)\n      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n        swap(nums[i], nums[nums[i] - 1]);\n\n    for (int i = 0; i < n; ++i)\n      if (nums[i] != i + 1)\n        return i + 1;\n\n    return n + 1;\n  }\n};\n", "410": "class Solution {\n public:\n  int splitArray(vector<int>& nums, int k) {\n    const int n = nums.size();\n    // dp[i][k] := the minimum of the maximum sum to split the first i numbers\n    // into k groups\n    vector<vector<long>> dp(n + 1, vector<long>(k + 1, INT_MAX));\n    vector<long> prefix(n + 1);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n\n    for (int i = 1; i <= n; ++i)\n      dp[i][1] = prefix[i];\n\n    for (int l = 2; l <= k; ++l)\n      for (int i = l; i <= n; ++i)\n        for (int j = l - 1; j < i; ++j)\n          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]));\n\n    return dp[n][k];\n  }\n};\n", "411": "class Solution {\n public:\n  string minAbbreviation(string target, vector<string>& dictionary) {\n    const int m = target.length();\n    vector<int> masks;\n\n    for (const string& word : dictionary) {\n      if (word.length() != m)\n        continue;\n      masks.push_back(getMask(target, word));\n    }\n\n    if (masks.empty())\n      return to_string(m);\n\n    vector<string> abbrs;\n\n    const int maxCand = pow(2, m);\n    // all the candidate representation of the target\n    for (int cand = 0; cand < maxCand; ++cand)\n      // All the masks have at lease one bit different from the candidate.\n      if (ranges::all_of(masks, [cand](int mask) { return cand & mask; }))\n        abbrs.push_back(getAbbr(target, cand));\n\n    string ans = target;\n\n    for (const string& abbr : abbrs)\n      if (getAbbrLen(abbr) < getAbbrLen(ans))\n        ans = abbr;\n\n    return ans;\n  }\n\n private:\n  int getMask(const string& target, const string& word) {\n    const int m = target.length();\n    // mask[i] = 0 := target[i] == word[i]\n    // mask[i] = 1 := target[i] != word[i]\n    // e.g. target = \"apple\"\n    //        word = \"blade\"\n    //        mask =  11110\n    int mask = 0;\n    for (int i = 0; i < m; ++i)\n      if (word[i] != target[i])\n        mask |= 1 << m - 1 - i;\n    return mask;\n  }\n\n  string getAbbr(const string& target, int cand) {\n    const int m = target.length();\n    string abbr;\n    int replacedCount = 0;\n    for (int i = 0; i < m; ++i)\n      if (cand >> m - 1 - i & 1) {\n        // If cand[i] = 1, `abbr` should show the original character.\n        if (replacedCount > 0)\n          abbr += to_string(replacedCount);\n        abbr += target[i];\n        replacedCount = 0;\n      } else {\n        // If cand[i] = 0, `abbr` can be replaced.\n        ++replacedCount;\n      }\n    if (replacedCount > 0)\n      abbr += to_string(replacedCount);\n    return abbr;\n  }\n\n  int getAbbrLen(const string& abbr) {\n    int abbrLen = 0;\n    int i = 0;\n    int j = 0;\n    while (i < abbr.length()) {\n      if (isalpha(abbr[j]))\n        ++j;\n      else\n        while (j < abbr.length() && isdigit(abbr[j]))\n          ++j;\n      ++abbrLen;\n      i = j;\n    }\n    return abbrLen;\n  }\n};\n", "412": "class Solution {\n public:\n  vector<string> fizzBuzz(int n) {\n    vector<string> ans;\n\n    for (int i = 1; i <= n; ++i) {\n      string s;\n      if (i % 3 == 0)\n        s += \"Fizz\";\n      if (i % 5 == 0)\n        s += \"Buzz\";\n      ans.push_back(s.empty() ? to_string(i) : s);\n    }\n\n    return ans;\n  }\n};\n", "413": "class Solution {\n public:\n  int numberOfArithmeticSlices(vector<int>& nums) {\n    int ans = 0;\n    int dp = 0;  // the number of arithmetic slices ending in index i\n\n    for (int i = 2; i < nums.size(); ++i)\n      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\n        ans += ++dp;\n      else\n        dp = 0;\n\n    return ans;\n  }\n};\n", "414": "class Solution {\n public:\n  int thirdMax(vector<int>& nums) {\n    priority_queue<int, vector<int>, greater<>> minHeap;\n    unordered_set<int> seen;\n\n    for (const int num : nums)\n      if (!seen.contains(num)) {\n        seen.insert(num);\n        minHeap.push(num);\n        if (minHeap.size() > 3)\n          minHeap.pop();\n      }\n\n    if (minHeap.size() == 2)\n      minHeap.pop();\n\n    return minHeap.top();\n  }\n};\n", "415": "class Solution {\n public:\n  string addStrings(string num1, string num2) {\n    string ans;\n    int carry = 0;\n    int i = num1.length() - 1;\n    int j = num2.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += num1[i--] - '0';\n      if (j >= 0)\n        carry += num2[j--] - '0';\n      ans += carry % 10 + '0';\n      carry /= 10;\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "416": "class Solution {\n public:\n  bool canPartition(vector<int>& nums) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (sum % 2 == 1)\n      return false;\n    return knapsack(nums, sum / 2);\n  }\n\n private:\n  bool knapsack(const vector<int>& nums, int subsetSum) {\n    // dp[i] := true if i can be formed by nums so far\n    vector<bool> dp(subsetSum + 1);\n    dp[0] = true;\n\n    for (const int num : nums)\n      for (int i = subsetSum; i >= num; --i)\n        dp[i] = dp[i] || dp[i - num];\n\n    return dp[subsetSum];\n  }\n};\n", "417": "class Solution {\n public:\n  vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    const int m = heights.size();\n    const int n = heights[0].size();\n    vector<vector<int>> ans;\n    vector<vector<bool>> seenP(m, vector<bool>(n));\n    vector<vector<bool>> seenA(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i) {\n      dfs(heights, i, 0, seenP);\n      dfs(heights, i, n - 1, seenA);\n    }\n\n    for (int j = 0; j < n; ++j) {\n      dfs(heights, 0, j, seenP);\n      dfs(heights, m - 1, j, seenA);\n    }\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (seenP[i][j] && seenA[i][j])\n          ans.push_back({i, j});\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& heights, int i, int j,\n           vector<vector<bool>>& seen, int h = 0) {\n    if (i < 0 || i == heights.size() || j < 0 || j == heights[0].size())\n      return;\n    if (seen[i][j] || heights[i][j] < h)\n      return;\n\n    seen[i][j] = true;\n    dfs(heights, i + 1, j, seen, heights[i][j]);\n    dfs(heights, i - 1, j, seen, heights[i][j]);\n    dfs(heights, i, j + 1, seen, heights[i][j]);\n    dfs(heights, i, j - 1, seen, heights[i][j]);\n  }\n};\n", "418": "class Solution {\n public:\n  int wordsTyping(vector<string>& sentence, int rows, int cols) {\n    const string& combined = getCombined(sentence);\n    const int n = combined.length();\n    int i = 0;  // (i % n) points to the index of combined in each row\n\n    while (rows-- > 0) {\n      i += cols;\n      if (combined[i % n] == ' ') {\n        ++i;\n      } else {\n        while (i > 0 && combined[(i - 1) % n] != ' ')\n          --i;\n      }\n    }\n\n    return i / n;\n  }\n\n private:\n  string getCombined(const vector<string>& sentence) {\n    string combined;\n    for (const string& word : sentence)\n      combined += (word + ' ');\n    return combined;\n  }\n};\n", "419": "class Solution {\n public:\n  int countBattleships(vector<vector<char>>& board) {\n    int ans = 0;\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j) {\n        if (board[i][j] == '.')\n          continue;\n        if (i > 0 && board[i - 1][j] == 'X')\n          continue;\n        if (j > 0 && board[i][j - 1] == 'X')\n          continue;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "42": "class Solution {\n public:\n  int trap(vector<int>& height) {\n    if (height.empty())\n      return 0;\n\n    int ans = 0;\n    int l = 0;\n    int r = height.size() - 1;\n    int maxL = height[l];\n    int maxR = height[r];\n\n    while (l < r)\n      if (maxL < maxR) {\n        ans += maxL - height[l];\n        maxL = max(maxL, height[++l]);\n      } else {\n        ans += maxR - height[r];\n        maxR = max(maxR, height[--r]);\n      }\n\n    return ans;\n  }\n};\n", "420": "class Solution {\n public:\n  int strongPasswordChecker(string password) {\n    const int n = password.length();\n    const int missing = getMissing(password);\n    // the number of replacements to deal with 3 repeating characters\n    int replaces = 0;\n    // the number of sequences that can be substituted with 1 deletions,\n    // (3k)-seqs\n    int oneSeq = 0;\n    // the number of sequences that can be substituted with 2 deletions,\n    // (3k + 1)-seqs\n    int twoSeq = 0;\n\n    for (int i = 2; i < n;)\n      if (password[i] == password[i - 1] &&\n          password[i - 1] == password[i - 2]) {\n        int length = 2;  // the length of the repeating password\n        while (i < n && password[i] == password[i - 1]) {\n          ++length;\n          ++i;\n        }\n        replaces += length / 3;  // 'aaaaaaa' -> 'aaxaaxa'\n        if (length % 3 == 0)\n          ++oneSeq;\n        if (length % 3 == 1)\n          ++twoSeq;\n      } else {\n        ++i;\n      }\n\n    if (n < 6)\n      return max(6 - n, missing);\n    if (n <= 20)\n      return max(replaces, missing);\n\n    const int deletes = n - 20;\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions.\n    replaces -= min(oneSeq, deletes);\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\n    // Each replacement in other seqs can be substituted with 3 deletions.\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\n    return deletes + max(replaces, missing);\n  }\n\n private:\n  int getMissing(const string& password) {\n    return 3 -  //\n           ranges::any_of(password, [](char c) { return isupper(c); }) -\n           ranges::any_of(password, [](char c) { return islower(c); }) -\n           ranges::any_of(password, [](char c) { return isdigit(c); });\n  }\n};\n", "421": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(2) {}\n};\n\nclass BitTrie {\n public:\n  BitTrie(int maxBit) : maxBit(maxBit) {}\n\n  void insert(int num) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      if (node->children[bit] == nullptr)\n        node->children[bit] = make_shared<TrieNode>();\n      node = node->children[bit];\n    }\n  }\n\n  int getMaxXor(int num) {\n    int maxXor = 0;\n    shared_ptr<TrieNode> node = root;\n    for (int i = maxBit; i >= 0; --i) {\n      const int bit = num >> i & 1;\n      const int toggleBit = bit ^ 1;\n      if (node->children[toggleBit] != nullptr) {\n        maxXor = maxXor | 1 << i;\n        node = node->children[toggleBit];\n      } else if (node->children[bit] != nullptr) {\n        node = node->children[bit];\n      } else {  // There's nothing in the Bit Trie.\n        return 0;\n      }\n    }\n    return maxXor;\n  }\n\n private:\n  const int maxBit;\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass Solution {\n public:\n  int findMaximumXOR(vector<int>& nums) {\n    const int maxNum = ranges::max(nums);\n    if (maxNum == 0)\n      return 0;\n    const int maxBit = static_cast<int>(log2(maxNum));\n    int ans = 0;\n    BitTrie bitTrie(maxBit);\n\n    for (const int num : nums) {\n      ans = max(ans, bitTrie.getMaxXor(num));\n      bitTrie.insert(num);\n    }\n\n    return ans;\n  }\n};\n", "422": "class Solution {\n public:\n  bool validWordSquare(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j < words[i].size(); ++j) {\n        if (words.size() <= j || words[j].size() <= i)  // out-of-bounds\n          return false;\n        if (words[i][j] != words[j][i])\n          return false;\n      }\n    return true;\n  }\n};\n", "423": "class Solution {\n public:\n  string originalDigits(string s) {\n    string ans;\n    vector<int> count(10);\n\n    for (const char c : s) {\n      if (c == 'z')\n        ++count[0];\n      if (c == 'o')\n        ++count[1];\n      if (c == 'w')\n        ++count[2];\n      if (c == 'h')\n        ++count[3];\n      if (c == 'u')\n        ++count[4];\n      if (c == 'f')\n        ++count[5];\n      if (c == 'x')\n        ++count[6];\n      if (c == 's')\n        ++count[7];\n      if (c == 'g')\n        ++count[8];\n      if (c == 'i')\n        ++count[9];\n    }\n\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n\n    for (int i = 0; i < 10; ++i)\n      for (int j = 0; j < count[i]; ++j)\n        ans += i + '0';\n\n    return ans;\n  }\n};\n", "424": "class Solution {\n public:\n  int characterReplacement(string s, int k) {\n    int maxCount = 0;\n    vector<int> count(26);\n\n    // l and r track the maximum window instead of the valid window.\n    int l = 0;\n    int r = 0;\n\n    for (r = 0; r < s.length(); ++r) {\n      maxCount = max(maxCount, ++count[s[r] - 'A']);\n      if (maxCount + k < r - l + 1)\n        --count[s[l++] - 'A'];\n    }\n\n    return r - l;\n  }\n};\n", "425": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  vector<const string*> startsWith;\n  TrieNode() : children(26) {}\n};\n\nclass Trie {\n public:\n  Trie(const vector<string>& words) {\n    for (const string& word : words)\n      insert(word);\n  }\n\n  vector<const string*> findBy(const string& prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return {};\n      node = node->children[i];\n    }\n    return node->startsWith;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      node->startsWith.push_back(&word);\n    }\n  }\n};\n\nclass Solution {\n public:\n  vector<vector<string>> wordSquares(vector<string>& words) {\n    if (words.empty())\n      return {};\n\n    const int n = words[0].length();\n    vector<vector<string>> ans;\n    vector<string> path;\n    Trie trie(words);\n\n    for (const string& word : words) {\n      path.push_back(word);\n      dfs(trie, n, path, ans);\n      path.pop_back();\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(Trie& trie, const int n, vector<string>& path,\n           vector<vector<string>>& ans) {\n    if (path.size() == n) {\n      ans.push_back(path);\n      return;\n    }\n\n    const string prefix = getPrefix(path);\n\n    for (const string* s : trie.findBy(prefix)) {\n      path.push_back(*s);\n      dfs(trie, n, path, ans);\n      path.pop_back();\n    }\n  }\n\n  // e.g. path = [\"wall\",\n  //              \"area\"]\n  //    prefix =  \"le..\"\n  string getPrefix(const vector<string>& path) {\n    string prefix;\n    const int index = path.size();\n    for (const string& s : path)\n      prefix += s[index];\n    return prefix;\n  }\n};\n", "426": "class Solution {\n public:\n  // Similar to 94. Binary Tree Inorder Traversal\n  Node* treeToDoublyList(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    stack<Node*> stack;\n    Node* first = nullptr;\n    Node* pred = nullptr;\n\n    while (root != nullptr || !stack.empty()) {\n      while (root != nullptr) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      if (first == nullptr)\n        first = root;\n      if (pred != nullptr) {\n        pred->right = root;\n        root->left = pred;\n      }\n      pred = root;\n      root = root->right;\n    }\n\n    pred->right = first;\n    first->left = pred;\n    return first;\n  }\n};\n", "427": "class Solution {\n public:\n  Node* construct(vector<vector<int>>& grid) {\n    return helper(grid, 0, 0, grid.size());\n  }\n\n private:\n  Node* helper(const vector<vector<int>>& grid, int i, int j, int w) {\n    if (allSame(grid, i, j, w))\n      return new Node(grid[i][j] == 1, /*isLeaft=*/true);\n    const int half = w / 2;\n    return new Node(/*val=*/true, /*isLeaf=*/false,\n                    /*topLeft=*/helper(grid, i, j, half),\n                    /*topRight=*/helper(grid, i, j + half, half),\n                    /*bottomLeft=*/helper(grid, i + half, j, half),\n                    /*bottomRight=*/helper(grid, i + half, j + half, half));\n  }\n\n  bool allSame(const vector<vector<int>>& grid, int i, int j, int w) {\n    return all_of(grid.begin() + i, grid.begin() + i + w,\n                  [&](const vector<int>& row) {\n      return all_of(row.begin() + j, row.begin() + j + w,\n                    [&](int num) { return num == grid[i][j]; });\n    });\n  }\n};\n", "428": "class Codec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(Node* root) {\n    if (root == nullptr)\n      return \"\";\n\n    string s;\n    queue<Node*> q{{root}};\n    s += to_string(root->val) + \" \";\n\n    while (!q.empty())\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node* node = q.front();\n        q.pop();\n        if (node->children.empty()) {\n          s += \"n\";\n        } else {\n          for (Node* child : node->children) {\n            q.push(child);\n            s += to_string(child->val) + \"#\";\n          }\n        }\n        s += \" \";\n      }\n\n    return s;\n  }\n\n  // Decodes your encoded data to tree.\n  Node* deserialize(string data) {\n    if (data.empty())\n      return nullptr;\n\n    istringstream iss(data);\n    string word;\n    iss >> word;\n    Node* root = new Node(stoi(word));\n    queue<Node*> q{{root}};\n\n    while (iss >> word) {\n      Node* parent = q.front();\n      q.pop();\n      vector<Node*> children;\n      for (const string& kid : getKids(word)) {\n        if (kid == \"n\")\n          continue;\n        Node* child = new Node(stoi(kid));\n        children.push_back(child);\n        q.push(child);\n      }\n      parent->children = children;\n    }\n\n    return root;\n  }\n\n private:\n  vector<string> getKids(const string& word) {\n    vector<string> kids;\n    for (int i = 0, j = 0; j < word.length(); ++j)\n      if (word[j] == '#') {\n        kids.push_back(word.substr(i, j - i));\n        i = j + 1;\n      }\n    return kids;\n  }\n};\n", "429": "class Solution {\n public:\n  vector<vector<int>> levelOrder(Node* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<vector<int>> ans;\n    queue<Node*> q{{root}};\n\n    while (!q.empty()) {\n      vector<int> currLevel;\n      for (int sz = q.size(); sz > 0; --sz) {\n        Node* node = q.front();\n        q.pop();\n        currLevel.push_back(node->val);\n        for (Node* child : node->children)\n          q.push(child);\n      }\n      ans.push_back(currLevel);\n    }\n\n    return ans;\n  }\n};\n", "43": "class Solution {\n public:\n  string multiply(string num1, string num2) {\n    string s(num1.length() + num2.length(), '0');\n\n    for (int i = num1.length() - 1; i >= 0; --i)\n      for (int j = num2.length() - 1; j >= 0; --j) {\n        const int mult = (num1[i] - '0') * (num2[j] - '0');\n        const int sum = mult + (s[i + j + 1] - '0');\n        s[i + j] += sum / 10;\n        s[i + j + 1] = '0' + sum % 10;\n      }\n\n    const int i = s.find_first_not_of('0');\n    return i == string::npos ? \"0\" : s.substr(i);\n  }\n};\n", "430": "class Solution {\n public:\n  Node* flatten(Node* head) {\n    for (Node* curr = head; curr; curr = curr->next)\n      if (curr->child) {\n        Node* cachedNext = curr->next;\n        curr->next = curr->child;\n        curr->child->prev = curr;\n        curr->child = nullptr;\n        Node* tail = curr->next;\n        while (tail->next != nullptr)\n          tail = tail->next;\n        tail->next = cachedNext;\n        if (cachedNext != nullptr)\n          cachedNext->prev = tail;\n      }\n\n    return head;\n  }\n};\n", "431": "class Codec {\n public:\n  // Encodes an n-ary tree to a binary tree.\n  TreeNode* encode(Node* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    TreeNode* rootTreeNode = new TreeNode(root->val);\n    if (!root->children.empty())\n      rootTreeNode->left = encode(root->children[0]);\n\n    // The parent for the rest of the children\n    TreeNode* currTreeNode = rootTreeNode->left;\n\n    // Encode the rest of the children\n    for (int i = 1; i < root->children.size(); ++i) {\n      currTreeNode->right = encode(root->children[i]);\n      currTreeNode = currTreeNode->right;\n    }\n\n    return rootTreeNode;\n  }\n\n  // Decodes your binary tree to an n-ary tree.\n  Node* decode(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n\n    Node* rootNode = new Node(root->val);\n    TreeNode* currTreeNode = root->left;\n\n    while (currTreeNode != nullptr) {\n      rootNode->children.push_back(decode(currTreeNode));\n      currTreeNode = currTreeNode->right;\n    }\n\n    return rootNode;\n  }\n};\n", "432": "struct Node {\n  int count;\n  unordered_set<string> keys;\n};\n\nclass AllOne {\n public:\n  void inc(string key) {\n    if (const auto it = keyToIterator.find(key); it == keyToIterator.end())\n      addNewKey(key);\n    else\n      incrementExistingKey(it, key);\n  }\n\n  void dec(string key) {\n    const auto it = keyToIterator.find(key);\n    // It is guaranteed that key exists in the data structure before the\n    // decrement.\n    decrementExistingKey(it, key);\n  }\n\n  string getMaxKey() {\n    return nodeList.empty() ? \"\" : *nodeList.back().keys.begin();\n  }\n\n  string getMinKey() {\n    return nodeList.empty() ? \"\" : *nodeList.front().keys.begin();\n  }\n\n private:\n  list<Node> nodeList;  // list of nodes sorted by count\n  unordered_map<string, list<Node>::iterator> keyToIterator;\n\n  // Adds a new node with count 1.\n  void addNewKey(const string& key) {\n    if (nodeList.empty() || nodeList.front().count > 1)\n      nodeList.push_front({1, {key}});\n    else  // nodeList.front().count == 1\n      nodeList.front().keys.insert(key);\n    keyToIterator[key] = nodeList.begin();\n  }\n\n  // Increments the count of the key by 1.\n  void incrementExistingKey(\n      unordered_map<string, list<Node>::iterator>::iterator it,\n      const string& key) {\n    const auto listIt = it->second;\n\n    auto nextIt = next(listIt);\n    const int newCount = listIt->count + 1;\n    if (nextIt == nodeList.end() || nextIt->count > newCount)\n      nextIt = nodeList.insert(nextIt, {newCount, {key}});\n    else  // Node with count + 1 exists.\n      nextIt->keys.insert(key);\n\n    keyToIterator[key] = nextIt;\n    remove(listIt, key);\n  }\n\n  // Decrements the count of the key by 1.\n  void decrementExistingKey(\n      unordered_map<string, list<Node>::iterator>::iterator it,\n      const string& key) {\n    const auto listIt = it->second;\n    if (listIt->count == 1) {\n      keyToIterator.erase(it);\n      remove(listIt, key);\n      return;\n    }\n\n    auto prevIt = prev(listIt);\n    const int newCount = listIt->count - 1;\n    if (listIt == nodeList.begin() || prevIt->count < newCount)\n      prevIt = nodeList.insert(listIt, {newCount, {key}});\n    else  // Node with count - 1 exists.\n      prevIt->keys.insert(key);\n\n    keyToIterator[key] = prevIt;\n    remove(listIt, key);\n  }\n\n  // Removes the key from the node list.\n  void remove(list<Node>::iterator it, const string& key) {\n    it->keys.erase(key);\n    if (it->keys.empty())\n      nodeList.erase(it);\n  }\n};\n", "433": "class Solution {\n public:\n  int minMutation(string startGene, string endGene, vector<string>& bank) {\n    unordered_set<string> bankSet{bank.begin(), bank.end()};\n    if (!bankSet.contains(endGene))\n      return -1;\n\n    constexpr char kGenes[] = \"ACGT\";\n    queue<string> q{{startGene}};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        string word = q.front();\n        q.pop();\n        for (int j = 0; j < word.length(); ++j) {\n          const char cache = word[j];\n          for (const char c : kGenes) {\n            word[j] = c;\n            if (word == endGene)\n              return step;\n            if (bankSet.contains(word)) {\n              bankSet.erase(word);\n              q.push(word);\n            }\n          }\n          word[j] = cache;\n        }\n      }\n\n    return -1;\n  }\n};\n", "434": "class Solution {\n public:\n  int countSegments(string s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] != ' ' && (i == 0 || s[i - 1] == ' '))\n        ++ans;\n\n    return ans;\n  }\n};\n", "435": "class Solution {\n public:\n  int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n    if (intervals.empty())\n      return 0;\n\n    ranges::sort(intervals,\n                 [](const auto& a, const auto& b) { return a[1] < b[1]; });\n\n    int ans = 0;\n    int currentEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.size(); ++i)\n      if (intervals[i][0] >= currentEnd)\n        currentEnd = intervals[i][1];\n      else\n        ++ans;\n\n    return ans;\n  }\n};\n", "436": "class Solution {\n public:\n  vector<int> findRightInterval(vector<vector<int>>& intervals) {\n    vector<int> ans;\n    map<int, int> startToIndex;\n\n    for (int i = 0; i < intervals.size(); ++i)\n      startToIndex[intervals[i][0]] = i;\n\n    for (const vector<int>& interval : intervals) {\n      const auto it = startToIndex.lower_bound(interval[1]);\n      ans.push_back(it == startToIndex.cend() ? -1 : it->second);\n    }\n\n    return ans;\n  }\n};\n", "437": "class Solution {\n public:\n  int pathSum(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return 0;\n    return dfs(root, sum) +            //\n           pathSum(root->left, sum) +  //\n           pathSum(root->right, sum);\n  }\n\n private:\n  int dfs(TreeNode* root, int sum) {\n    if (root == nullptr)\n      return 0;\n    return (sum == root->val) +                //\n           dfs(root->left, sum - root->val) +  //\n           dfs(root->right, sum - root->val);\n  }\n};\n", "438": "class Solution {\n public:\n  vector<int> findAnagrams(string s, string p) {\n    vector<int> ans;\n    vector<int> count(128);\n    int required = p.length();\n\n    for (const char c : p)\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s[r]] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 == p.length())\n          ans.push_back(l);\n        if (++count[s[l++]] > 0)\n          ++required;\n      }\n    }\n\n    return ans;\n  }\n};\n", "439": "class Solution {\n public:\n  string parseTernary(string expression) {\n    const char c = expression[i];\n\n    if (i + 1 == expression.length() || expression[i + 1] == ':') {\n      i += 2;  // Skip ':'s.\n      return string(1, c);\n    }\n\n    i += 2;  // Skip '?'s.\n    const string& first = parseTernary(expression);\n    const string& second = parseTernary(expression);\n    return c == 'T' ? first : second;\n  }\n\n private:\n  int i = 0;\n};\n", "44": "class Solution {\n public:\n  bool isMatch(string s, string p) {\n    const int m = s.length();\n    const int n = p.length();\n    // dp[i][j] := true if s[0..i) matches p[0..j)\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    auto isMatch = [&](int i, int j) -> bool {\n      return j >= 0 && p[j] == '?' || s[i] == p[j];\n    };\n\n    for (int j = 0; j < p.length(); ++j)\n      if (p[j] == '*')\n        dp[0][j + 1] = dp[0][j];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (p[j] == '*') {\n          const bool matchEmpty = dp[i + 1][j];\n          const bool matchSome = dp[i][j + 1];\n          dp[i + 1][j + 1] = matchEmpty || matchSome;\n        } else if (isMatch(i, j)) {\n          dp[i + 1][j + 1] = dp[i][j];\n        }\n\n    return dp[m][n];\n  }\n};\n", "440": "class Solution {\n public:\n  int findKthNumber(int n, int k) {\n    long ans = 1;\n\n    for (int i = 1; i < k;) {\n      const long gap = getGap(ans, ans + 1, n);\n      if (i + gap <= k) {\n        i += gap;\n        ++ans;\n      } else {\n        ++i;\n        ans *= 10;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  long getGap(long a, long b, long n) {\n    long gap = 0;\n    while (a <= n) {\n      gap += min(n + 1, b) - a;\n      a *= 10;\n      b *= 10;\n    }\n    return gap;\n  };\n};\n", "441": "class Solution {\n public:\n  int arrangeCoins(long n) {\n    return (-1 + sqrt(8 * n + 1)) / 2;\n  }\n};\n", "442": "class Solution {\n public:\n  vector<int> findDuplicates(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums) {\n      nums[abs(num) - 1] *= -1;\n      if (nums[abs(num) - 1] > 0)\n        ans.push_back(abs(num));\n    }\n\n    return ans;\n  }\n};\n", "443": "class Solution {\n public:\n  int compress(vector<char>& chars) {\n    int ans = 0;\n\n    for (int i = 0; i < chars.size();) {\n      const char letter = chars[i];\n      int count = 0;\n      while (i < chars.size() && chars[i] == letter) {\n        ++count;\n        ++i;\n      }\n      chars[ans++] = letter;\n      if (count > 1)\n        for (const char c : to_string(count))\n          chars[ans++] = c;\n    }\n\n    return ans;\n  }\n};\n", "444": "class Solution {\n public:\n  bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\n    if (seqs.empty())\n      return false;\n\n    const int n = org.size();\n    vector<vector<int>> graph(n);\n    vector<int> inDegrees(n);\n\n    // Build the graph.\n    for (const vector<int>& seq : seqs) {\n      if (seq.size() == 1 && seq[0] < 1 || seq[0] > n)\n        return false;\n      for (int i = 0; i + 1 < seq.size(); ++i) {\n        const int u = seq[i];\n        const int v = seq[i + 1];\n        if (u < 1 || u > n || v < 1 || v > n)\n          return false;\n        graph[u - 1].push_back(v - 1);\n        ++inDegrees[v - 1];\n      }\n    }\n\n    // Perform topological sorting.\n    queue<int> q;\n\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    int i = 0;  // org's index\n\n    while (!q.empty()) {\n      if (q.size() > 1)\n        return false;\n      const int u = q.front();\n      q.pop();\n      if (u != org[i] - 1)\n        return false;\n      ++i;\n      for (const int v : graph[u])\n        if (--inDegrees[v] == 0)\n          q.push(v);\n    }\n\n    return i == n;\n  }\n};\n", "445": "class Solution {\n public:\n  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    stack<ListNode*> stack1;\n    stack<ListNode*> stack2;\n\n    while (l1) {\n      stack1.push(l1);\n      l1 = l1->next;\n    }\n\n    while (l2) {\n      stack2.push(l2);\n      l2 = l2->next;\n    }\n\n    ListNode* head = nullptr;\n    int carry = 0;\n\n    while (carry || !stack1.empty() || !stack2.empty()) {\n      if (!stack1.empty())\n        carry += stack1.top()->val, stack1.pop();\n      if (!stack2.empty())\n        carry += stack2.top()->val, stack2.pop();\n      ListNode* node = new ListNode(carry % 10);\n      node->next = head;\n      head = node;\n      carry /= 10;\n    }\n\n    return head;\n  }\n};\n", "446": "class Solution {\n public:\n  int numberOfArithmeticSlices(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    // dp[i][j] := the number of subsequences end in nums[j] nums[i]\n    vector<vector<int>> dp(n, vector<int>(n));\n    unordered_map<long, vector<int>> numToIndices;\n\n    for (int i = 0; i < n; ++i)\n      numToIndices[nums[i]].push_back(i);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const long target = nums[j] * 2L - nums[i];\n        if (const auto it = numToIndices.find(target);\n            it != numToIndices.cend())\n          for (const int k : it->second)\n            if (k < j)\n              dp[i][j] += (dp[j][k] + 1);\n        ans += dp[i][j];\n      }\n\n    return ans;\n  }\n};\n", "447": "class Solution {\n public:\n  int numberOfBoomerangs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    for (const vector<int>& p : points) {\n      unordered_map<int, int> distCount;\n      for (const vector<int>& q : points) {\n        const int dist = getDist(p, q);\n        ++distCount[dist];\n      }\n      for (const auto& [_, freq] : distCount)\n        ans += freq * (freq - 1);  // C(freq, 2)\n    }\n\n    return ans;\n  }\n\n private:\n  int getDist(const vector<int>& p, const vector<int>& q) {\n    return pow(p[0] - q[0], 2) + pow(p[1] - q[1], 2);\n  }\n};\n", "448": "class Solution {\n public:\n  vector<int> findDisappearedNumbers(vector<int>& nums) {\n    vector<int> ans;\n\n    for (const int num : nums) {\n      const int index = abs(num) - 1;\n      nums[index] = -abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] > 0)\n        ans.push_back(i + 1);\n\n    return ans;\n  }\n};\n", "449": "class Codec {\n public:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode* root) {\n    if (root == nullptr)\n      return \"\";\n    string s;\n    serialize(root, s);\n    return s;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode* deserialize(string data) {\n    if (data.empty())\n      return nullptr;\n\n    istringstream iss(data);\n    queue<int> q;\n\n    for (string s; iss >> s;)\n      q.push(stoi(s));\n\n    return deserialize(INT_MIN, INT_MAX, q);\n  }\n\n private:\n  void serialize(TreeNode* root, string& s) {\n    if (root == nullptr)\n      return;\n    s += to_string(root->val) + \" \";\n    serialize(root->left, s);\n    serialize(root->right, s);\n  }\n\n  TreeNode* deserialize(int mn, int mx, queue<int>& q) {\n    if (q.empty())\n      return nullptr;\n\n    const int val = q.front();\n    if (val < mn || val > mx)\n      return nullptr;\n\n    q.pop();\n    TreeNode* root = new TreeNode(val);\n    root->left = deserialize(mn, val, q);\n    root->right = deserialize(val, mx, q);\n    return root;\n  }\n};\n", "45": "class Solution {\n public:\n  int jump(vector<int>& nums) {\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    // Start an implicit BFS.\n    for (int i = 0; i < nums.size() - 1; ++i) {\n      farthest = max(farthest, i + nums[i]);\n      if (farthest >= nums.size() - 1) {\n        ++ans;\n        break;\n      }\n      if (i == end) {    // Visited all the items on the current level.\n        ++ans;           // Increment the level.\n        end = farthest;  // Make the queue size for the next level.\n      }\n    }\n\n    return ans;\n  }\n};\n", "450": "class Solution {\n public:\n  TreeNode* deleteNode(TreeNode* root, int key) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val == key) {\n      if (root->left == nullptr)\n        return root->right;\n      if (root->right == nullptr)\n        return root->left;\n      TreeNode* minNode = getMin(root->right);\n      root->right = deleteNode(root->right, minNode->val);\n      minNode->left = root->left;\n      minNode->right = root->right;\n      root = minNode;\n    } else if (root->val < key) {\n      root->right = deleteNode(root->right, key);\n    } else {  // root->val > key\n      root->left = deleteNode(root->left, key);\n    }\n    return root;\n  }\n\n private:\n  TreeNode* getMin(TreeNode* node) {\n    while (node->left != nullptr)\n      node = node->left;\n    return node;\n  }\n};\n", "451": "class Solution {\n public:\n  string frequencySort(string s) {\n    const int n = s.length();\n    string ans;\n    vector<int> count(128);\n    // buckets[i] := characters that appear i times in s\n    vector<vector<char>> buckets(n + 1);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (int i = 0; i < 128; ++i) {\n      const int freq = count[i];\n      if (freq > 0)\n        buckets[freq].push_back((char)i);\n    }\n\n    for (int freq = n; freq > 0; --freq)\n      for (const char c : buckets[freq])\n        ans += string(freq, c);\n\n    return ans;\n  }\n};\n", "452": "class Solution {\n public:\n  int findMinArrowShots(vector<vector<int>>& points) {\n    ranges::sort(points,\n                 [](const auto& a, const auto& b) { return a[1] < b[1]; });\n\n    int ans = 1;\n    int arrowX = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i)\n      if (points[i][0] > arrowX) {\n        arrowX = points[i][1];\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "453": "class Solution {\n public:\n  int minMoves(vector<int>& nums) {\n    const int mn = ranges::min(nums);\n    return accumulate(nums.begin(), nums.end(), 0,\n                      [&](int acc, int num) { return acc + (num - mn); });\n  }\n};\n", "454": "class Solution {\n public:\n  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,\n                   vector<int>& nums4) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int a : nums1)\n      for (const int b : nums2)\n        ++count[a + b];\n\n    for (const int c : nums3)\n      for (const int d : nums4)\n        if (const auto it = count.find(-c - d); it != count.cend())\n          ans += it->second;\n\n    return ans;\n  }\n};\n", "455": "class Solution {\n public:\n  int findContentChildren(vector<int>& g, vector<int>& s) {\n    ranges::sort(g);\n    ranges::sort(s);\n\n    int i = 0;\n    for (const int cookie : s)\n      if (i < g.size() && g[i] <= cookie)\n        ++i;\n\n    return i;\n  }\n};\n", "456": "class Solution {\n public:\n  bool find132pattern(vector<int>& nums) {\n    stack<int> stack;  // a decreasing stack\n    int ak = INT_MIN;  // Find a seq, where ai < ak < aj.\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      // If ai < ak, done because ai must < aj.\n      if (nums[i] < ak)\n        return true;\n      while (!stack.empty() && stack.top() < nums[i])\n        ak = stack.top(), stack.pop();\n      stack.push(nums[i]);  // `nums[i]` is a candidate of aj.\n    }\n\n    return false;\n  }\n};\n", "457": "class Solution {\n public:\n  bool circularArrayLoop(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 2)\n      return false;\n\n    auto advance = [&](int i) {\n      const int val = (i + nums[i]) % n;\n      return i + nums[i] >= 0 ? val : n + val;\n    };\n\n    for (int i = 0; i < n; ++i) {\n      if (nums[i] == 0)\n        continue;\n      int slow = i;\n      int fast = advance(slow);\n      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {\n        if (slow == fast) {\n          if (slow == advance(slow))\n            break;\n          return true;\n        }\n        slow = advance(slow);\n        fast = advance(advance(fast));\n      }\n\n      slow = i;\n      const int sign = nums[i];\n      while (sign * nums[slow] > 0) {\n        const int next = advance(slow);\n        nums[slow] = 0;\n        slow = next;\n      }\n    }\n\n    return false;\n  }\n};\n", "458": "class Solution {\n public:\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    const int base = minutesToTest / minutesToDie + 1;\n    int ans = 0;\n    for (int x = 1; x < buckets; x *= base)\n      ++ans;\n    return ans;\n  }\n};\n", "459": "class Solution {\n public:\n  bool repeatedSubstringPattern(string s) {\n    const string ss = s + s;\n    return ss.substr(1, ss.length() - 2).find(s) != string::npos;\n  }\n};\n", "46": "class Solution {\n public:\n  vector<vector<int>> permute(vector<int>& nums) {\n    vector<vector<int>> ans;\n    dfs(nums, vector<bool>(nums.size()), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() == nums.size()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (used[i])\n        continue;\n      used[i] = true;\n      path.push_back(nums[i]);\n      dfs(nums, std::move(used), std::move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n};\n", "460": "struct Node {\n  int key;\n  int value;\n  int freq;\n  list<int>::const_iterator it;\n};\n\nclass LFUCache {\n public:\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\n\n  int get(int key) {\n    const auto it = keyToNode.find(key);\n    if (it == keyToNode.cend())\n      return -1;\n\n    Node& node = it->second;\n    touch(node);\n    return node.value;\n  }\n\n  void put(int key, int value) {\n    if (capacity == 0)\n      return;\n    if (const auto it = keyToNode.find(key); it != keyToNode.cend()) {\n      Node& node = it->second;\n      node.value = value;\n      touch(node);\n      return;\n    }\n\n    if (keyToNode.size() == capacity) {\n      // Evict an LRU key from `minFreq` list.\n      const int keyToEvict = freqToList[minFreq].back();\n      freqToList[minFreq].pop_back();\n      keyToNode.erase(keyToEvict);\n    }\n\n    minFreq = 1;\n    freqToList[1].push_front(key);\n    keyToNode[key] = {key, value, 1, freqToList[1].cbegin()};\n  }\n\n private:\n  int capacity;\n  int minFreq;\n  unordered_map<int, Node> keyToNode;\n  unordered_map<int, list<int>> freqToList;\n\n  void touch(Node& node) {\n    // Update the node's frequency.\n    const int prevFreq = node.freq;\n    const int newFreq = ++node.freq;\n\n    // Remove the iterator from `prevFreq`'s list\n    freqToList[prevFreq].erase(node.it);\n    if (freqToList[prevFreq].empty()) {\n      freqToList.erase(prevFreq);\n      // Update `minFreq` if needed.\n      if (prevFreq == minFreq)\n        ++minFreq;\n    }\n\n    // Insert the key to the front of `newFreq`'s list.\n    freqToList[newFreq].push_front(node.key);\n    node.it = freqToList[newFreq].cbegin();\n  }\n};\n", "461": "class Solution {\n public:\n  int hammingDistance(int x, int y) {\n    int ans = 0;\n\n    while (x > 0 || y > 0) {\n      ans += (x & 1) ^ (y & 1);\n      x >>= 1;\n      y >>= 1;\n    }\n\n    return ans;\n  }\n};\n", "462": "class Solution {\n public:\n  int minMoves2(vector<int>& nums) {\n    const int n = nums.size();\n    nth_element(nums.begin(), nums.begin() + n / 2, nums.end());\n    const int median = nums[n / 2];\n    return accumulate(nums.begin(), nums.end(), 0, [&](int acc, int num) {\n      return acc + abs(num - median);\n    });\n  }\n};\n", "463": "class Solution {\n public:\n  int islandPerimeter(vector<vector<int>>& grid) {\n    int islands = 0;\n    int neighbors = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j]) {\n          ++islands;\n          if (i - 1 >= 0 && grid[i - 1][j])\n            ++neighbors;\n          if (j - 1 >= 0 && grid[i][j - 1])\n            ++neighbors;\n        }\n\n    return islands * 4 - neighbors * 2;\n  }\n};\n", "464": "class Solution {\n public:\n  bool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (desiredTotal <= 0)\n      return true;\n\n    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\n    if (sum < desiredTotal)\n      return false;\n\n    unordered_map<int, bool> mem;\n    return canIWin(desiredTotal, 0, maxChoosableInteger, mem);\n  }\n\n private:\n  // Returns true if the first player can we, where `used` represents the used\n  // numbers.\n  bool canIWin(int total, int used, const int& maxChoosableInteger,\n               unordered_map<int, bool>& mem) {\n    if (total <= 0)\n      return false;\n    if (const auto it = mem.find(used); it != mem.cend())\n      return it->second;\n\n    for (int i = 1; i <= maxChoosableInteger; ++i) {\n      if (used >> i & 1)  // Integer i is used.\n        continue;\n      if (!canIWin(total - i, used | 1 << i, maxChoosableInteger, mem))\n        return true;\n    }\n\n    return mem[used] = false;\n  }\n};\n", "465": "class Solution {\n public:\n  int minTransfers(vector<vector<int>>& transactions) {\n    vector<int> balance(21);\n    vector<int> debts;\n\n    for (const vector<int>& t : transactions) {\n      const int from = t[0];\n      const int to = t[1];\n      const int amount = t[2];\n      balance[from] -= amount;\n      balance[to] += amount;\n    }\n\n    for (const int b : balance)\n      if (b > 0)\n        debts.push_back(b);\n\n    return dfs(debts, 0);\n  }\n\n private:\n  int dfs(vector<int>& debts, int s) {\n    while (s < debts.size() && !debts[s])\n      ++s;\n    if (s == debts.size())\n      return 0;\n\n    int ans = INT_MAX;\n\n    for (int i = s + 1; i < debts.size(); ++i)\n      if (debts[i] * debts[s] < 0) {\n        debts[i] += debts[s];  // `debts[s]` is settled.\n        ans = min(ans, 1 + dfs(debts, s + 1));\n        debts[i] -= debts[s];  // Backtrack.\n      }\n\n    return ans;\n  }\n};\n", "466": "struct Record {\n  int count;\n  int nextIndex;\n};\n\nclass Solution {\n public:\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    // records[i].count := the number of times that s2 starting from index i has\n    // been fully matched with s1\n    // records[i].nextIndex := the next index in s2 to be matched after\n    // completing a full match starting from index i\n    vector<Record> records;\n\n    for (int i = 0; i < s2.length(); ++i) {\n      int count = 0;\n      int nextIndex = i;\n      for (const char c : s1)\n        if (s2[nextIndex] == c)\n          if (++nextIndex == s2.length()) {  // There's a match.\n            ++count;\n            nextIndex = 0;\n          }\n      records.emplace_back(count, nextIndex);\n    }\n\n    int matches = 0;  // the number of matches between `s1` x n1 and `s2`\n    int i = 0;        // the index in `s2` to start matching\n\n    while (n1-- > 0) {\n      matches += records[i].count;\n      i = records[i].nextIndex;\n    }\n\n    return matches / n2;\n  }\n};\n", "467": "class Solution {\n public:\n  int findSubstringInWraproundString(string s) {\n    int maxLength = 1;\n    // count[i] := the number of substrings ending in ('a' + i)\n    vector<int> count(26);\n\n    for (int i = 0; i < s.length(); ++i) {\n      if (i > 0 && (s[i] - s[i - 1] == 1 || s[i - 1] - s[i] == 25))\n        ++maxLength;\n      else\n        maxLength = 1;\n      const int index = s[i] - 'a';\n      count[index] = max(count[index], maxLength);\n    }\n\n    return accumulate(count.begin(), count.end(), 0);\n  }\n};\n", "468": "class Solution {\n public:\n  string validIPAddress(string queryIP) {\n    string digit;\n    istringstream iss(queryIP);\n\n    if (ranges::count(queryIP, '.') == 3) {\n      for (int i = 0; i < 4; ++i)  // Make sure that we have four parts.\n        if (!getline(iss, digit, '.') || !isIPv4(digit))\n          return \"Neither\";\n      return \"IPv4\";\n    }\n\n    if (ranges::count(queryIP, ':') == 7) {\n      for (int i = 0; i < 8; ++i)  // Make sure that we have eight parts.\n        if (!getline(iss, digit, ':') || !isIPv6(digit))\n          return \"Neither\";\n      return \"IPv6\";\n    }\n\n    return \"Neither\";\n  }\n\n private:\n  static inline string validIPv6Chars = \"0123456789abcdefABCDEF\";\n\n  bool isIPv4(const string& digit) {\n    if (digit.empty() || digit.length() > 3)\n      return false;\n    if (digit.length() > 1 && digit[0] == '0')\n      return false;\n\n    for (const char c : digit)\n      if (c < '0' || c > '9')\n        return false;\n\n    const int num = stoi(digit);\n    return 0 <= num && num <= 255;\n  }\n\n  bool isIPv6(const string& digit) {\n    if (digit.empty() || digit.length() > 4)\n      return false;\n\n    for (const char c : digit)\n      if (validIPv6Chars.find(c) == string::npos)\n        return false;\n\n    return true;\n  }\n};\n", "469": "class Solution {\n public:\n  bool isConvex(vector<vector<int>>& points) {\n    const int n = points.size();\n    long sign = 0;\n\n    for (int i = 0; i < points.size(); ++i) {\n      const int cross =\n          getCross(points[i], points[(i + 1) % n], points[(i + 2) % n]);\n      if (cross == 0)  // p, q, r are collinear.\n        continue;\n      if (sign == 0)  // Find the first cross that's not 0.\n        sign = cross;\n      else if (cross * sign < 0)\n        return false;\n    }\n\n    return true;\n  }\n\n private:\n  // Returns pq x qr.\n  int getCross(const vector<int>& p, const vector<int>& q,\n               const vector<int>& r) {\n    return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);\n  }\n};\n", "47": "class Solution {\n public:\n  vector<vector<int>> permuteUnique(vector<int>& nums) {\n    vector<vector<int>> ans;\n    ranges::sort(nums);\n    dfs(nums, vector<bool>(nums.size()), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() == nums.size()) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.push_back(nums[i]);\n      dfs(nums, std::move(used), std::move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n};\n", "470": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\n public:\n  int rand10() {\n    int num = 40;\n    while (num >= 40)\n      num = (rand7() - 1) * 7 + rand7() - 1;\n    return num % 10 + 1;\n  }\n};\n", "471": "class Solution {\n public:\n  string encode(string s) {\n    const int n = s.length();\n    // dp[i][j] := the shortest encoded string of s[i..j]\n    vector<vector<string>> dp(n, vector<string>(n));\n\n    for (int d = 0; d < n; ++d) {\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        const string& curr = s.substr(i, j - i + 1);\n        dp[i][j] = curr;\n\n        if (dp[i][j].length() < 5)\n          continue;\n\n        // Try all the possible partitions.\n        for (int k = i; k < j; ++k)\n          if (dp[i][k].length() + dp[k + 1][j].length() < dp[i][j].length())\n            dp[i][j] = dp[i][k] + dp[k + 1][j];\n\n        // Try to compress the string.\n        // e.g. s = aabaabaab -> 3[aab]\n        for (int k = i; k < j; ++k) {\n          const string& pattern = s.substr(i, k - i + 1);\n          if (curr.length() % pattern.length() == 0 &&\n              regex_replace(curr, regex(pattern), \"\").empty()) {\n            const string candidate =\n                to_string(curr.length() / pattern.length()) + '[' + dp[i][k] +\n                ']';\n            if (candidate.length() < dp[i][j].length())\n              dp[i][j] = candidate;\n          }\n        }\n      }\n    }\n\n    return dp[0][n - 1];\n  }\n};\n", "472": "class Solution {\n public:\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n    vector<string> ans;\n    unordered_set<string> wordSet{words.begin(), words.end()};\n    unordered_map<string, bool> mem;\n\n    for (const string& word : words)\n      if (isConcat(word, wordSet, mem))\n        ans.push_back(word);\n\n    return ans;\n  }\n\n private:\n  bool isConcat(const string& s, const unordered_set<string>& wordSet,\n                unordered_map<string, bool>& mem) {\n    if (const auto it = mem.find(s); it != mem.cend())\n      return it->second;\n\n    for (int i = 1; i < s.length(); ++i) {\n      const string prefix = s.substr(0, i);\n      const string suffix = s.substr(i);\n      if (wordSet.contains(prefix) &&\n          (wordSet.contains(suffix) || isConcat(suffix, wordSet, mem)))\n        return mem[s] = true;\n    }\n\n    return mem[s] = false;\n  }\n};\n", "473": "class Solution {\n public:\n  bool makesquare(vector<int>& matchsticks) {\n    if (matchsticks.size() < 4)\n      return false;\n\n    const int perimeter = accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (perimeter % 4 != 0)\n      return false;\n\n    ranges::sort(matchsticks, greater<>());\n    return dfs(matchsticks, 0, vector<int>(4, perimeter / 4));\n  }\n\n private:\n  bool dfs(const vector<int>& matchsticks, int selected, vector<int>&& edges) {\n    if (selected == matchsticks.size())\n      return ranges::all_of(edges, [](int edge) { return edge == 0; });\n\n    for (int i = 0; i < 4; ++i) {\n      if (matchsticks[selected] > edges[i])\n        continue;\n      edges[i] -= matchsticks[selected];\n      if (dfs(matchsticks, selected + 1, std::move(edges)))\n        return true;\n      edges[i] += matchsticks[selected];\n    }\n\n    return false;\n  }\n};\n", "474": "class Solution {\n public:\n  int findMaxForm(vector<string>& strs, int m, int n) {\n    // dp[i][j] := the maximum size of the subset given i 0s and j 1s are\n    // available\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (const string& s : strs) {\n      const int zeros = ranges::count(s, '0');\n      const int ones = s.length() - zeros;\n      for (int i = m; i >= zeros; --i)\n        for (int j = n; j >= ones; --j)\n          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);\n    }\n\n    return dp[m][n];\n  }\n};\n", "475": "class Solution {\n public:\n  int findRadius(vector<int>& houses, vector<int>& heaters) {\n    ranges::sort(houses);\n    ranges::sort(heaters);\n\n    int ans = 0;\n    int i = 0;  // heaters' index (currently used)\n\n    for (const int house : houses) {\n      while (i + 1 < heaters.size() &&\n             house - heaters[i] > heaters[i + 1] - house)\n        ++i;  // The next heater is better.\n      ans = max(ans, abs(heaters[i] - house));\n    }\n\n    return ans;\n  }\n};\n", "476": "class Solution {\n public:\n  int findComplement(long num) {\n    for (long i = 1; i <= num; i <<= 1)\n      num ^= i;\n    return num;\n  }\n};\n", "477": "class Solution {\n public:\n  int totalHammingDistance(vector<int>& nums) {\n    constexpr int maxMask = 1 << 30;\n    int ans = 0;\n\n    for (int mask = 1; mask < maxMask; mask <<= 1) {\n      const int ones =\n          ranges::count_if(nums, [mask](int num) { return num & mask; });\n      const int zeros = nums.size() - ones;\n      ans += ones * zeros;\n    }\n\n    return ans;\n  }\n};\n", "478": "class Solution {\n public:\n  Solution(double radius, double x_center, double y_center)\n      : radius(radius), x_center(x_center), y_center(y_center) {}\n\n  vector<double> randPoint() {\n    const double length = sqrt(distribution(generator)) * radius;\n    const double degree = distribution(generator) * 2 * M_PI;\n    const double x = x_center + length * cos(degree);\n    const double y = y_center + length * sin(degree);\n    return {x, y};\n  }\n\n private:\n  const double radius;\n  const double x_center;\n  const double y_center;\n  default_random_engine generator;\n  uniform_real_distribution<double> distribution =\n      uniform_real_distribution<double>(0.0, 1.0);\n};\n", "479": "class Solution {\n public:\n  int largestPalindrome(int n) {\n    if (n == 1)\n      return 9;\n\n    constexpr int kMod = 1337;\n    const int upper = pow(10, n) - 1;\n    const int lower = pow(10, n - 1) - 1;\n\n    for (int i = upper; i > lower; --i) {\n      const long cand = getPalindromeCandidate(i);\n      for (long j = upper; j * j >= cand; --j)\n        if (cand % j == 0)\n          return cand % kMod;\n    }\n\n    throw;\n  }\n\n private:\n  long getPalindromeCandidate(int i) {\n    string reversed = to_string(i);\n    ranges::reverse(reversed);\n    return stol(to_string(i) + reversed);\n  }\n};\n", "48": "class Solution {\n public:\n  void rotate(vector<vector<int>>& matrix) {\n    for (int mn = 0; mn < matrix.size() / 2; ++mn) {\n      const int mx = matrix.size() - mn - 1;\n      for (int i = mn; i < mx; ++i) {\n        const int offset = i - mn;\n        const int top = matrix[mn][i];\n        matrix[mn][i] = matrix[mx - offset][mn];\n        matrix[mx - offset][mn] = matrix[mx][mx - offset];\n        matrix[mx][mx - offset] = matrix[i][mx];\n        matrix[i][mx] = top;\n      }\n    }\n  }\n};\n", "480": "class Solution {\n public:\n  vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n    vector<double> ans;\n    multiset<double> window(nums.begin(), nums.begin() + k);\n    auto it = next(window.begin(), (k - 1) / 2);\n\n    for (int i = k;; ++i) {\n      const double median = k % 2 == 0 ? (*it + *next(it)) / 2.0 : *it;\n      ans.push_back(median);\n      if (i == nums.size())\n        break;\n      window.insert(nums[i]);\n      if (nums[i] < *it)\n        --it;\n      if (nums[i - k] <= *it)\n        ++it;\n      window.erase(window.lower_bound(nums[i - k]));\n    }\n\n    return ans;\n  }\n};\n", "481": "class Solution {\n public:\n  int magicalString(int n) {\n    string s = \" 122\";\n\n    for (int i = 3; i <= n; ++i)\n      if (i % 2 == 1)\n        s.append(s[i] - '0', '1');\n      else\n        s.append(s[i] - '0', '2');\n\n    return count(s.begin(), s.begin() + n + 1, '1');\n  }\n};\n", "482": "class Solution {\n public:\n  string licenseKeyFormatting(string s, int k) {\n    string ans;\n    int length = 0;\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      if (s[i] == '-')\n        continue;\n      if (length > 0 && length % k == 0)\n        ans += \"-\";\n      ans += toupper(s[i]);\n      ++length;\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "483": "class Solution {\n public:\n  string smallestGoodBase(string n) {\n    const long num = stol(n);\n\n    for (int m = log2(num); m >= 2; --m) {\n      const int k = pow(num, 1.0 / m);\n      long sum = 1;\n      long prod = 1;\n      for (int i = 0; i < m; ++i) {\n        prod *= k;\n        sum += prod;\n      }\n      if (sum == num)\n        return to_string(k);\n    }\n\n    return to_string(num - 1);\n  }\n};\n", "484": "class Solution {\n public:\n  vector<int> findPermutation(string s) {\n    vector<int> ans(s.length() + 1);\n\n    iota(ans.begin(), ans.end(), 1);\n\n    // For each D* group (s[i..j]), reverse ans[i..j + 1].\n    int i = -1;\n    int j = -1;\n\n    while (true) {\n      i = getNextIndex(s, 'D', j + 1);\n      if (i == s.length())\n        break;\n      j = getNextIndex(s, 'I', i + 1);\n      reverse(ans.begin() + i, ans.begin() + j + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  int getNextIndex(const string& s, char c, int start) {\n    for (int i = start; i < s.length(); ++i)\n      if (s[i] == c)\n        return i;\n    return s.length();\n  }\n};\n", "485": "class Solution {\n public:\n  int findMaxConsecutiveOnes(vector<int>& nums) {\n    int ans = 0;\n    int sum = 0;\n\n    for (const int num : nums)\n      if (num == 1)\n        ans = max(ans, ++sum);\n      else\n        sum = 0;\n\n    return ans;\n  }\n};\n", "486": "class Solution {\n public:\n  bool PredictTheWinner(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> dp = nums;\n\n    for (int d = 1; d < n; ++d)\n      for (int j = n - 1; j - d >= 0; --j) {\n        const int i = j - d;\n        dp[j] = max(nums[i] - dp[j],       // Pick the leftmost number.\n                    nums[j] - dp[j - 1]);  // Pick the rightmost number.\n      }\n\n    return dp[n - 1] >= 0;\n  }\n};\n", "487": "class Solution {\n public:\n  int findMaxConsecutiveOnes(vector<int>& nums) {\n    constexpr int maxZeros = 1;\n    int ans = 0;\n    queue<int> q;  // Store indices of zero.\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (nums[r] == 0)\n        q.push(r);\n      if (q.size() > maxZeros)\n        l = q.front() + 1, q.pop();\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "488": "class Solution {\n public:\n  int findMinStep(string board, string hand) {\n    const int ans = dfs(board + \"#\", hand, {});\n    return ans == INT_MAX ? -1 : ans;\n  }\n\n private:\n  int dfs(string&& board, const string& hand,\n          unordered_map<string, int>&& mem) {\n    const string hashKey = board + '#' + hand;\n    if (const auto it = mem.find(hashKey); it != mem.cend())\n      return it->second;\n    board = deDup(board);\n    if (board == \"#\")\n      return 0;\n\n    unordered_set<char> boardSet = unordered_set(board.begin(), board.end());\n\n    string hs;  // hand that is in board\n    for (const char h : hand)\n      if (boardSet.contains(h))\n        hs += h;\n    if (hs.empty())  // infeasible\n      return INT_MAX;\n\n    int ans = INT_MAX;\n\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < hs.size(); ++j) {\n        // Place hs[j] in board[i].\n        const string& newHand = hs.substr(0, j) + hs.substr(j + 1);\n        string newBoard = board.substr(0, i) + hs[j] + board.substr(i);\n        const int res = dfs(std::move(newBoard), newHand, std::move(mem));\n        if (res < INT_MAX)\n          ans = min(ans, 1 + res);\n      }\n\n    return mem[hashKey] = ans;\n  }\n\n  string deDup(string board) {\n    int start = 0;  // the start index of a color sequenece\n    for (int i = 0; i < board.size(); ++i)\n      if (board[i] != board[start]) {\n        if (i - start >= 3)\n          return deDup(board.substr(0, start) + board.substr(i));\n        start = i;  // Meet a new sequence.\n      }\n    return board;\n  }\n};\n", "489": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * class Robot {\n *  public:\n *   // Returns true if the cell in front is open and robot moves into the cell.\n *   // Returns false if the cell in front is blocked and robot stays in the\n *   // Current cell. bool std::move();\n *\n *   // Robot will stay in the same cell after calling turnLeft/turnRight.\n *   // Each turn will be 90 degrees.\n *   void turnLeft();\n *   void turnRight();\n *\n *   // Clean the current cell.\n *   void clean();\n * };\n */\n\nclass Solution {\n public:\n  void cleanRoom(Robot& robot) {\n    dfs(robot, 0, 0, 0, unordered_set<pair<int, int>, PairHash>());\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n\n  void dfs(Robot& robot, int i, int j, int d,\n           unordered_set<pair<int, int>, PairHash>&& seen) {\n    seen.insert({i, j});\n    robot.clean();\n\n    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <\n    // The order is important since the idea is always turning right.\n    for (int k = 0; k < 4; ++k) {\n      const int newD = (d + k) % 4;\n      const int x = i + kDirs[newD][0];\n      const int y = j + kDirs[newD][1];\n      if (!seen.contains({x, y}) && robot.move()) {\n        dfs(robot, x, y, newD, std::move(seen));\n        // Go back to the previous cell.\n        robot.turnRight();\n        robot.turnRight();\n        robot.move();\n        // Go back to the original direction.\n        robot.turnRight();\n        robot.turnRight();\n      }\n      robot.turnRight();  // Always turn the robot clockwise.\n    }\n  }\n};\n", "49": "class Solution {\n public:\n  vector<vector<string>> groupAnagrams(vector<string>& strs) {\n    vector<vector<string>> ans;\n    unordered_map<string, vector<string>> keyToAnagrams;\n\n    for (const string& str : strs) {\n      string key = str;\n      ranges::sort(key);\n      keyToAnagrams[key].push_back(str);\n    }\n\n    for (const auto& [_, anagrams] : keyToAnagrams)\n      ans.push_back(anagrams);\n\n    return ans;\n  }\n};\n", "490": "class Solution {\n public:\n  bool hasPath(vector<vector<int>>& maze, vector<int>& start,\n               vector<int>& destination) {\n    return dfs(maze,\n               vector<vector<bool>>(maze.size(), vector<bool>(maze[0].size())),\n               start[0], start[1], destination);\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  bool dfs(vector<vector<int>>& maze, vector<vector<bool>>&& seen, int i, int j,\n           const vector<int>& destination) {\n    if (i == destination[0] && j == destination[1])\n      return true;\n    if (seen[i][j])\n      return false;\n\n    seen[i][j] = true;\n\n    for (const auto& [dx, dy] : kDirs) {\n      int x = i;\n      int y = j;\n      while (isValid(maze, x + dx, y + dy)) {\n        x += dx;\n        y += dy;\n      }\n      if (dfs(maze, std::move(seen), x, y, destination))\n        return true;\n    }\n\n    return false;\n  }\n\n  bool isValid(const vector<vector<int>>& maze, int x, int y) {\n    return 0 <= x && x < maze.size() && 0 <= y && y < maze[0].size() &&\n           maze[x][y] == 0;\n  }\n};\n", "491": "class Solution {\n public:\n  vector<vector<int>> findSubsequences(vector<int>& nums) {\n    vector<vector<int>> ans;\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (path.size() > 1)\n      ans.push_back(path);\n\n    unordered_set<int> used;\n\n    for (int i = s; i < nums.size(); ++i) {\n      if (used.contains(nums[i]))\n        continue;\n      if (path.empty() || nums[i] >= path.back()) {\n        used.insert(nums[i]);\n        path.push_back(nums[i]);\n        dfs(nums, i + 1, std::move(path), ans);\n        path.pop_back();\n      }\n    }\n  }\n};\n", "492": "class Solution {\n public:\n  vector<int> constructRectangle(int area) {\n    int width = sqrt(area);\n\n    while (area % width)\n      --width;\n\n    return {area / width, width};\n  }\n};\n", "493": "class SegmentTree {\n public:\n  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {\n    build(nums, 0, 0, n - 1);\n  }\n\n  // Adds val to nums[i].\n  void add(int i, int val) {\n    add(0, 0, n - 1, i, val);\n  }\n\n  // Returns sum(nums[i..j]).\n  int query(int i, int j) const {\n    return query(0, 0, n - 1, i, j);\n  }\n\n private:\n  const int n;       // the size of the input array\n  vector<int> tree;  // the segment tree\n\n  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n    if (lo == hi) {\n      tree[treeIndex] = nums[lo];\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    build(nums, 2 * treeIndex + 1, lo, mid);\n    build(nums, 2 * treeIndex + 2, mid + 1, hi);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  void add(int treeIndex, int lo, int hi, int i, int val) {\n    if (lo == hi) {\n      tree[treeIndex] += val;\n      return;\n    }\n    const int mid = (lo + hi) / 2;\n    if (i <= mid)\n      add(2 * treeIndex + 1, lo, mid, i, val);\n    else\n      add(2 * treeIndex + 2, mid + 1, hi, i, val);\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n  }\n\n  int query(int treeIndex, int lo, int hi, int i, int j) const {\n    if (i <= lo && hi <= j)  // [lo, hi] lies completely inside [i, j].\n      return tree[treeIndex];\n    if (j < lo || hi < i)  // [lo, hi] lies completely outside [i, j].\n      return 0;\n    const int mid = (lo + hi) / 2;\n    return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                 query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n  }\n\n  int merge(int left, int right) const {\n    return left + right;\n  }\n};\n\nclass Solution {\n public:\n  int reversePairs(vector<int>& nums) {\n    int ans = 0;\n    const unordered_map<long, int> ranks = getRanks(nums);\n    SegmentTree tree(vector<int>(ranks.size() + 1));\n\n    for (int i = nums.size() - 1; i >= 0; --i) {\n      const long num = nums[i];\n      ans += tree.query(0, ranks.at(num) - 1);\n      tree.add(ranks.at(num * 2), 1);\n    }\n\n    return ans;\n  }\n\n private:\n  unordered_map<long, int> getRanks(const vector<int>& nums) {\n    unordered_map<long, int> ranks;\n    set<long> sorted(nums.begin(), nums.end());\n    for (const long num : nums)\n      sorted.insert(num * 2);\n    int rank = 0;\n    for (const long num : sorted)\n      ranks[num] = ++rank;\n    return ranks;\n  }\n};\n", "494": "class Solution {\n public:\n  int findTargetSumWays(vector<int>& nums, int target) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (sum < abs(target) || (sum + target) % 2 == 1)\n      return 0;\n    return knapsack(nums, (sum + target) / 2);\n  }\n\n private:\n  int knapsack(const vector<int>& nums, int target) {\n    // dp[i] := the number of ways to sum to i by nums so far\n    vector<int> dp(target + 1);\n    dp[0] = 1;\n\n    for (const int num : nums)\n      for (int i = target; i >= num; --i)\n        dp[i] += dp[i - num];\n\n    return dp[target];\n  }\n};\n", "495": "class Solution {\n public:\n  int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (duration == 0)\n      return 0;\n\n    int ans = 0;\n\n    for (int i = 0; i + 1 < timeSeries.size(); ++i)\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration);\n\n    return ans + duration;\n  }\n};\n", "496": "class Solution {\n public:\n  vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> ans;\n    unordered_map<int, int> numToNextGreater;\n    stack<int> stack;  // a decreasing stack\n\n    for (const int num : nums2) {\n      while (!stack.empty() && stack.top() < num)\n        numToNextGreater[stack.top()] = num, stack.pop();\n      stack.push(num);\n    }\n\n    for (const int num : nums1)\n      if (const auto it = numToNextGreater.find(num);\n          it != numToNextGreater.cend())\n        ans.push_back(it->second);\n      else\n        ans.push_back(-1);\n\n    return ans;\n  }\n};\n", "497": "class Solution {\n public:\n  Solution(vector<vector<int>>& rects) : rects(std::move(rects)) {\n    for (const vector<int>& r : this->rects)\n      areas.push_back(getArea(r));\n    partial_sum(areas.begin(), areas.end(), areas.begin());\n  }\n\n  vector<int> pick() {\n    const int target = rand() % areas.back();\n    const int index = ranges::upper_bound(areas, target) - areas.begin();\n    const vector<int>& r = rects[index];\n    return {rand() % (r[2] - r[0] + 1) + r[0],\n            rand() % (r[3] - r[1] + 1) + r[1]};\n  }\n\n private:\n  const vector<vector<int>> rects;\n  vector<int> areas;\n\n  int getArea(const vector<int>& r) {\n    return (r[2] - r[0] + 1) * (r[3] - r[1] + 1);\n  }\n};\n", "498": "class Solution {\n public:\n  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> ans(m * n);\n    int d = 1;  // left-bottom -> right-top\n    int row = 0;\n    int col = 0;\n\n    for (int i = 0; i < m * n; ++i) {\n      ans[i] = matrix[row][col];\n      row -= d;\n      col += d;\n      // out-of-bounds\n      if (row == m)\n        row = m - 1, col += 2, d = -d;\n      if (col == n)\n        col = n - 1, row += 2, d = -d;\n      if (row < 0)\n        row = 0, d = -d;\n      if (col < 0)\n        col = 0, d = -d;\n    }\n\n    return ans;\n  }\n};\n", "499": "class Solution {\n public:\n  string findShortestWay(vector<vector<int>>& maze, vector<int>& ball,\n                         vector<int>& hole) {\n    string ans = \"impossible\";\n    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, INT_MAX, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& maze, int i, int j, const vector<int>& hole,\n           int dx, int dy, int steps, int&& minSteps, string&& path,\n           string& ans) {\n    if (steps >= minSteps)\n      return;\n\n    if (dx != 0 || dy != 0) {  // Both are zeros for the initial ball position.\n      while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 &&\n             j + dy < maze[0].size() && maze[i + dx][j + dy] != 1) {\n        i += dx;\n        j += dy;\n        ++steps;\n        if (i == hole[0] && j == hole[1] && steps < minSteps) {\n          minSteps = steps;\n          ans = path;\n        }\n      }\n    }\n\n    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {\n      maze[i][j] = steps + 2;  // +2 because maze[i][j] == 0 || 1.\n      if (dx == 0)\n        dfs(maze, i, j, hole, 1, 0, steps, std::move(minSteps), path + \"d\",\n            ans);\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, -1, steps, std::move(minSteps), path + \"l\",\n            ans);\n      if (dy == 0)\n        dfs(maze, i, j, hole, 0, 1, steps, std::move(minSteps), path + \"r\",\n            ans);\n      if (dx == 0)\n        dfs(maze, i, j, hole, -1, 0, steps, std::move(minSteps), path + \"u\",\n            ans);\n    }\n  }\n};\n", "5": "class Solution {\n public:\n  string longestPalindrome(string s) {\n    const string t = join('@' + s + '$', /*delimiter=*/'#');\n    const vector<int> p = manacher(t);\n    int maxPalindromeLength = 0;\n    int bestCenter = -1;\n\n    for (int i = 0; i < p.size(); ++i)\n      if (p[i] > maxPalindromeLength) {\n        maxPalindromeLength = p[i];\n        bestCenter = i;\n      }\n\n    const int l = (bestCenter - maxPalindromeLength) / 2;\n    const int r = (bestCenter + maxPalindromeLength) / 2;\n    return s.substr(l, r - l);\n  }\n\n private:\n  // Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n  // centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n  vector<int> manacher(const string& t) {\n    vector<int> p(t.length());\n    int center = 0;\n    for (int i = 1; i < t.length() - 1; ++i) {\n      const int rightBoundary = center + p[center];\n      const int mirrorIndex = center - (i - center);\n      if (rightBoundary > i)\n        p[i] = min(rightBoundary - i, p[mirrorIndex]);\n      // Try to expand the palindrome centered at i.\n      while (t[i + 1 + p[i]] == t[i - 1 - p[i]])\n        ++p[i];\n      // If a palindrome centered at i expands past `rightBoundary`, adjust\n      // the center based on the expanded palindrome.\n      if (i + p[i] > rightBoundary)\n        center = i;\n    }\n    return p;\n  }\n\n  string join(const string& s, char delimiter) {\n    string joined;\n    for (int i = 0; i < s.length() - 1; ++i) {\n      joined += s[i];\n      joined += delimiter;\n    }\n    joined += s.back();\n    return joined;\n  }\n};\n", "50": "class Solution {\n public:\n  double myPow(double x, long n) {\n    if (n == 0)\n      return 1;\n    if (n < 0)\n      return 1 / myPow(x, -n);\n    if (n % 2 == 1)\n      return x * myPow(x, n - 1);\n    return myPow(x * x, n / 2);\n  }\n};\n", "500": "class Solution {\n public:\n  vector<string> findWords(vector<string>& words) {\n    vector<string> ans;\n    const vector<int> rows{2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3,\n                           3, 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3};\n\n    for (const string& word : words) {\n      string lowerWord = word;\n      ranges::transform(lowerWord, lowerWord.begin(), ::tolower);\n      const int row = rows[lowerWord[0] - 'a'];\n      const bool isValid = ranges::all_of(\n          lowerWord, [&](int c) { return rows[c - 'a'] == row; });\n      if (isValid)\n        ans.push_back(word);\n    }\n\n    return ans;\n  }\n};\n", "501": "class Solution {\n public:\n  vector<int> findMode(TreeNode* root) {\n    vector<int> ans;\n    int count = 0;\n    int maxCount = 0;\n\n    inorder(root, count, maxCount, ans);\n    return ans;\n  }\n\n private:\n  TreeNode* pred = nullptr;\n\n  void inorder(TreeNode* root, int& count, int& maxCount, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left, count, maxCount, ans);\n    updateCount(root, count, maxCount, ans);\n    inorder(root->right, count, maxCount, ans);\n  }\n\n  void updateCount(TreeNode* root, int& count, int& maxCount,\n                   vector<int>& ans) {\n    if (pred && pred->val == root->val)\n      ++count;\n    else\n      count = 1;\n\n    if (count > maxCount) {\n      maxCount = count;\n      ans = {root->val};\n    } else if (count == maxCount) {\n      ans.push_back(root->val);\n    }\n\n    pred = root;\n  }\n};\n", "502": "struct T {\n  int pro;\n  int cap;\n};\n\nclass Solution {\n public:\n  int findMaximizedCapital(int k, int w, vector<int>& profits,\n                           vector<int>& capital) {\n    auto compareC = [](const T& a, const T& b) { return a.cap > b.cap; };\n    auto compareP = [](const T& a, const T& b) { return a.pro < b.pro; };\n    priority_queue<T, vector<T>, decltype(compareC)> minHeap(compareC);\n    priority_queue<T, vector<T>, decltype(compareP)> maxHeap(compareP);\n\n    for (int i = 0; i < capital.size(); ++i)\n      minHeap.emplace(profits[i], capital[i]);\n\n    while (k-- > 0) {\n      while (!minHeap.empty() && minHeap.top().cap <= w)\n        maxHeap.push(minHeap.top()), minHeap.pop();\n      if (maxHeap.empty())\n        break;\n      w += maxHeap.top().pro, maxHeap.pop();\n    }\n\n    return w;\n  }\n};\n", "503": "class Solution {\n public:\n  vector<int> nextGreaterElements(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n, -1);\n    stack<int> stack;  // a decreasing stack storing indices\n\n    for (int i = 0; i < n * 2; ++i) {\n      const int num = nums[i % n];\n      while (!stack.empty() && nums[stack.top()] < num)\n        ans[stack.top()] = num, stack.pop();\n      if (i < n)\n        stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "504": "class Solution {\n public:\n  string convertToBase7(int num) {\n    if (num < 0)\n      return \"-\" + convertToBase7(-num);\n    if (num < 7)\n      return to_string(num);\n    return convertToBase7(num / 7) + to_string(num % 7);\n  }\n};\n", "505": "class Solution {\n public:\n  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,\n                       vector<int>& destination) {\n    vector<vector<int>> dist(maze.size(), vector<int>(maze[0].size(), INT_MAX));\n    dist[start[0]][start[1]] = 0;\n\n    dfs(maze, dist, start[0], start[1], destination);\n\n    return dist[destination[0]][destination[1]] == INT_MAX\n               ? -1\n               : dist[destination[0]][destination[1]];\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  void dfs(vector<vector<int>>& maze, vector<vector<int>>& dist, int i, int j,\n           const vector<int>& destination) {\n    if (i == destination[0] && j == destination[1])\n      return;\n\n    for (const auto& [dx, dy] : kDirs) {\n      int x = i;\n      int y = j;\n      int step = dist[i][j];\n      while (isValid(maze, x + dx, y + dy)) {\n        x += dx;\n        y += dy;\n        ++step;\n      }\n      if (step < dist[x][y]) {\n        dist[x][y] = step;\n        dfs(maze, dist, x, y, destination);\n      }\n    }\n  }\n\n  bool isValid(const vector<vector<int>>& maze, int x, int y) {\n    return x >= 0 && x < maze.size() && y >= 0 && y < maze[0].size() &&\n           maze[x][y] == 0;\n  }\n};\n", "506": "class Solution {\n public:\n  vector<string> findRelativeRanks(vector<int>& nums) {\n    const int n = nums.size();\n    vector<string> ans(n);\n    vector<int> indices(n);\n\n    iota(indices.begin(), indices.end(), 0);\n\n    ranges::sort(indices,\n                 [&](const int a, const int b) { return nums[a] > nums[b]; });\n\n    for (int i = 0; i < n; ++i)\n      if (i == 0)\n        ans[indices[0]] = \"Gold Medal\";\n      else if (i == 1)\n        ans[indices[1]] = \"Silver Medal\";\n      else if (i == 2)\n        ans[indices[2]] = \"Bronze Medal\";\n      else\n        ans[indices[i]] = to_string(i + 1);\n\n    return ans;\n  }\n};\n", "507": "class Solution {\n public:\n  bool checkPerfectNumber(int num) {\n    if (num == 1)\n      return false;\n\n    int sum = 1;\n\n    for (int i = 2; i <= sqrt(num); ++i)\n      if (num % i == 0)\n        sum += i + num / i;\n\n    return sum == num;\n  }\n};\n", "508": "class Solution {\n public:\n  vector<int> findFrequentTreeSum(TreeNode* root) {\n    vector<int> ans;\n    unordered_map<int, int> count;\n    int maxCount = 0;\n\n    sumDownFrom(root, count);\n\n    for (const auto& [_, freq] : count)\n      maxCount = max(maxCount, freq);\n\n    for (const auto& [sum, freq] : count)\n      if (freq == maxCount)\n        ans.push_back(sum);\n\n    return ans;\n  }\n\n private:\n  int sumDownFrom(TreeNode* root, unordered_map<int, int>& count) {\n    if (root == nullptr)\n      return 0;\n\n    const int sum = root->val + sumDownFrom(root->left, count) +\n                    sumDownFrom(root->right, count);\n    ++count[sum];\n    return sum;\n  }\n};\n", "509": "class Solution {\n public:\n  int fib(int n) {\n    if (n < 2)\n      return n;\n\n    vector<int> dp{0, 0, 1};\n\n    for (int i = 2; i <= n; ++i) {\n      dp[0] = dp[1];\n      dp[1] = dp[2];\n      dp[2] = dp[0] + dp[1];\n    }\n\n    return dp.back();\n  }\n};\n", "51": "class Solution {\n public:\n  vector<vector<string>> solveNQueens(int n) {\n    vector<vector<string>> ans;\n    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),\n        vector<string>(n, string(n, '.')), ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,\n           vector<bool>&& diag2, vector<string>&& board,\n           vector<vector<string>>& ans) {\n    if (i == n) {\n      ans.push_back(board);\n      return;\n    }\n\n    for (int j = 0; j < n; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      board[i][j] = 'Q';\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, std::move(cols), std::move(diag1), std::move(diag2),\n          std::move(board), ans);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n      board[i][j] = '.';\n    }\n  }\n};\n", "510": "class Solution {\n public:\n  Node* inorderSuccessor(Node* node) {\n    // The successor is somewhere lower in the right subtree.\n    if (node->right != nullptr) {\n      node = node->right;\n      while (node->left != nullptr)\n        node = node->left;\n      return node;\n    }\n\n    // The successor is somewhere upper in the tree.\n    while (node->parent && node->parent->left != node)\n      node = node->parent;\n    return node->parent;\n  }\n};\n", "513": "class Solution {\n public:\n  int findBottomLeftValue(TreeNode* root) {\n    int ans = 0;\n    dfs(root, 1, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int depth, int&& maxDepth, int& ans) {\n    if (root == nullptr)\n      return;\n    if (depth > maxDepth) {\n      maxDepth = depth;\n      ans = root->val;\n    }\n\n    dfs(root->left, depth + 1, std::move(maxDepth), ans);\n    dfs(root->right, depth + 1, std::move(maxDepth), ans);\n  }\n};\n", "514": "class Solution {\n public:\n  int findRotateSteps(string ring, string key) {\n    return dfs(ring, key, 0, {}) + key.length();\n  }\n\n private:\n  // Returns the number of rotates of ring to match key[index..n).\n  int dfs(const string& ring, const string& key, int index,\n          unordered_map<string, int>&& mem) {\n    if (index == key.length())\n      return 0;\n    // Add the index to prevent duplication.\n    const string hashKey = ring + to_string(index);\n    if (const auto it = mem.find(hashKey); it != mem.cend())\n      return it->second;\n\n    int ans = INT_MAX;\n\n    // For each ring[i] == key[index], we rotate the ring to match the ring[i]\n    // with the key[index], then recursively match the newRing with the\n    // key[index + 1..n).\n    for (size_t i = 0; i < ring.length(); ++i)\n      if (ring[i] == key[index]) {\n        const int minRotates = min(i, ring.length() - i);\n        const string& newRing = ring.substr(i) + ring.substr(0, i);\n        const int remainingRotates =\n            dfs(newRing, key, index + 1, std::move(mem));\n        ans = min(ans, minRotates + remainingRotates);\n      }\n\n    return mem[hashKey] = ans;\n  }\n};\n", "515": "class Solution {\n public:\n  vector<int> largestValues(TreeNode* root) {\n    vector<int> ans;\n    dfs(root, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int depth, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n    if (depth + 1 > ans.size())\n      ans.push_back(root->val);\n    else\n      ans[depth] = max(ans[depth], root->val);\n\n    dfs(root->left, depth + 1, ans);\n    dfs(root->right, depth + 1, ans);\n  }\n};\n", "516": "class Solution {\n public:\n  int longestPalindromeSubseq(string s) {\n    const int n = s.length();\n    // dp[i][j] := the length of LPS(s[i..j])\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j])\n          dp[i][j] = 2 + dp[i + 1][j - 1];\n        else\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "517": "class Solution {\n public:\n  int findMinMoves(vector<int>& machines) {\n    const int dresses = accumulate(machines.begin(), machines.end(), 0);\n    if (dresses % machines.size() != 0)\n      return -1;\n\n    int ans = 0;\n    int inout = 0;\n    const int average = dresses / machines.size();\n\n    for (const int dress : machines) {\n      inout += dress - average;\n      ans = max({ans, abs(inout), dress - average});\n    }\n\n    return ans;\n  }\n};\n", "518": "class Solution {\n public:\n  int change(int amount, vector<int>& coins) {\n    vector<int> dp(amount + 1);\n    dp[0] = 1;\n\n    for (const int coin : coins)\n      for (int i = coin; i <= amount; ++i)\n        dp[i] += dp[i - coin];\n\n    return dp[amount];\n  }\n};\n", "519": "class Solution {\n public:\n  Solution(int n_rows, int n_cols)\n      : rows(n_rows), cols(n_cols), total(n_rows * n_cols) {}\n\n  vector<int> flip() {\n    // All the candidates are used out.\n    if (used.size() == total)\n      return {};\n    int index = rand() % total;\n    while (used.contains(index))\n      index = ++index % total;\n    used.insert(index);\n    return {index / cols, index % cols};\n  }\n\n  void reset() {\n    used = {};\n  }\n\n private:\n  unordered_set<int> used;\n  int rows;\n  int cols;\n  int total;\n};\n", "52": "class Solution {\n public:\n  int totalNQueens(int n) {\n    int ans = 0;\n    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),\n        ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,\n           vector<bool>&& diag2, int& ans) {\n    if (i == n) {\n      ++ans;\n      return;\n    }\n\n    for (int j = 0; j < n; ++j) {\n      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])\n        continue;\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;\n      dfs(n, i + 1, std::move(cols), std::move(diag1), std::move(diag2), ans);\n      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;\n    }\n  }\n};\n", "520": "class Solution {\n public:\n  bool detectCapitalUse(string word) {\n    for (int i = 1; i < word.length(); ++i)\n      if (isupper(word[1]) != isupper(word[i]) ||\n          islower(word[0]) && isupper(word[i]))\n        return false;\n    return true;\n  }\n};\n", "521": "class Solution {\n public:\n  int findLUSlength(string a, string b) {\n    return a == b ? -1 : max(a.length(), b.length());\n  }\n};\n", "522": "class Solution {\n public:\n  int findLUSlength(vector<string>& strs) {\n    unordered_set<string> seen;\n    unordered_set<string> duplicates;\n\n    for (const string& str : strs)\n      if (seen.contains(str))\n        duplicates.insert(str);\n      else\n        seen.insert(str);\n\n    ranges::sort(strs, ranges::greater{},\n                 [](const string& s) { return s.length(); });\n\n    for (int i = 0; i < strs.size(); ++i) {\n      if (duplicates.contains(strs[i]))\n        continue;\n      bool isASubsequence = false;\n      for (int j = 0; j < i; ++j)\n        isASubsequence |= isSubsequence(strs[i], strs[j]);\n      if (!isASubsequence)\n        return strs[i].length();\n    }\n\n    return -1;\n  }\n\n private:\n  // Returns true if a is a subsequence of b.\n  bool isSubsequence(const string& a, const string& b) {\n    int i = 0;\n    for (const char c : b)\n      if (i < a.length() && c == a[i])\n        ++i;\n    return i == a.length();\n  };\n};\n", "523": "class Solution {\n public:\n  bool checkSubarraySum(vector<int>& nums, int k) {\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i];\n      if (k != 0)\n        prefix %= k;\n      if (const auto it = prefixToIndex.find(prefix);\n          it != prefixToIndex.cend()) {\n        if (i - it->second > 1)\n          return true;\n      } else {\n        // Set a new key if it's absent because the previous index is better.\n        prefixToIndex[prefix] = i;\n      }\n    }\n\n    return false;\n  }\n};\n", "524": "class Solution {\n public:\n  string findLongestWord(string s, vector<string>& d) {\n    string ans;\n\n    for (const string& word : d)\n      if (isSubsequence(word, s))\n        if (word.length() > ans.length() ||\n            word.length() == ans.length() && word.compare(ans) < 0)\n          ans = word;\n\n    return ans;\n  }\n\n private:\n  // Returns true if a is a subsequence of b.\n  bool isSubsequence(const string& a, const string& b) {\n    int i = 0;\n    for (const char c : b)\n      if (i < a.length() && c == a[i])\n        ++i;\n    return i == a.length();\n  };\n};\n", "525": "class Solution {\n public:\n  int findMaxLength(vector<int>& nums) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> prefixToIndex{{0, -1}};\n\n    for (int i = 0; i < nums.size(); ++i) {\n      prefix += nums[i] ? 1 : -1;\n      if (const auto it = prefixToIndex.find(prefix);\n          it != prefixToIndex.cend())\n        ans = max(ans, i - it->second);\n      else\n        prefixToIndex[prefix] = i;\n    }\n\n    return ans;\n  }\n};\n", "526": "class Solution {\n public:\n  int countArrangement(int n) {\n    return dfs(n, 1, string(n + 1, 'x'), {});\n  }\n\n private:\n  int dfs(int n, int num, string&& filled, unordered_map<string, int>&& mem) {\n    if (num == n + 1)\n      return 1;\n    if (const auto it = mem.find(filled); it != mem.cend())\n      return it->second;\n\n    int count = 0;\n\n    for (int i = 1; i <= n; ++i)\n      if (filled[i] == 'x' && (num % i == 0 || i % num == 0)) {\n        filled[i] = 'o';\n        count += dfs(n, num + 1, std::move(filled), std::move(mem));\n        filled[i] = 'x';\n      }\n\n    return mem[filled] = count;\n  }\n};\n", "527": "struct IndexedWord {\n  string word;\n  int index;\n};\n\nclass Solution {\n public:\n  vector<string> wordsAbbreviation(vector<string>& words) {\n    const int n = words.size();\n    vector<string> ans(n);\n    unordered_map<string, vector<IndexedWord>> abbrevToIndexedWords;\n\n    for (int i = 0; i < n; ++i) {\n      const string abbrev = getAbbrev(words[i], 0);\n      abbrevToIndexedWords[abbrev].emplace_back(words[i], i);\n    }\n\n    for (auto& [_, indexedWords] : abbrevToIndexedWords) {\n      ranges::sort(indexedWords, ranges::less{},\n                   [](const IndexedWord& iw) { return iw.word; });\n      vector<int> lcp(indexedWords.size());\n      for (int i = 1; i < indexedWords.size(); ++i) {\n        const int k =\n            longestCommonPrefix(indexedWords[i - 1].word, indexedWords[i].word);\n        lcp[i - 1] = max(lcp[i - 1], k);\n        lcp[i] = k;\n      }\n      for (int i = 0; i < indexedWords.size(); ++i)\n        ans[indexedWords[i].index] = getAbbrev(indexedWords[i].word, lcp[i]);\n    }\n\n    return ans;\n  }\n\n private:\n  string getAbbrev(const string& s, int prefixIndex) {\n    const int n = s.length();\n    const int num = n - (prefixIndex + 1) - 1;\n    const int numLength = num < 10 ? 1 : num < 100 ? 2 : 3;\n    const int abbrevLength = (prefixIndex + 1) + numLength + 1;\n    if (abbrevLength >= n)\n      return s;\n    return s.substr(0, prefixIndex + 1) + to_string(num) + s.back();\n  }\n\n  int longestCommonPrefix(const string& s1, const string& s2) {\n    int i = 0;\n    while (i < s1.length() && i < s2.length() && s1[i] == s2[i])\n      ++i;\n    return i;\n  }\n};\n", "528": "class Solution {\n public:\n  Solution(vector<int>& w) : prefix(w.size()) {\n    partial_sum(w.begin(), w.end(), prefix.begin());\n  }\n\n  int pickIndex() {\n    const int target = rand() % prefix.back();\n    return ranges::upper_bound(prefix, target) - prefix.begin();\n  }\n\n private:\n  vector<int> prefix;\n};\n", "529": "class Solution {\n public:\n  vector<vector<char>> updateBoard(vector<vector<char>>& board,\n                                   vector<int>& click) {\n    const int i = click[0];\n    const int j = click[1];\n    if (board[i][j] == 'M') {\n      board[i][j] = 'X';\n      return board;\n    }\n\n    dfs(board, i, j);\n    return board;\n  }\n\n private:\n  static constexpr int kDirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n\n  void dfs(vector<vector<char>>& board, int i, int j) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return;\n    if (board[i][j] != 'E')\n      return;\n\n    const int minesCount = getMinesCount(board, i, j);\n    board[i][j] = minesCount == 0 ? 'B' : '0' + minesCount;\n\n    if (minesCount == 0)\n      for (const auto& [dx, dy] : kDirs)\n        dfs(board, i + dx, j + dy);\n  }\n\n  int getMinesCount(const vector<vector<char>>& board, int i, int j) {\n    int minesCount = 0;\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == board.size() || y < 0 || y == board[0].size())\n        continue;\n      if (board[x][y] == 'M')\n        ++minesCount;\n    }\n    return minesCount;\n  }\n};\n", "53": "class Solution {\n public:\n  int maxSubArray(vector<int>& nums) {\n    int ans = INT_MIN;\n    int sum = 0;\n\n    for (const int num : nums) {\n      sum = max(num, sum + num);\n      ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};\n", "530": "class Solution {\n public:\n  // Similar to 94. Binary Tree Inorder Traversal\n  int getMinimumDifference(TreeNode* root) {\n    int ans = INT_MAX;\n    int prev = -1;\n    stack<TreeNode*> stack;\n\n    while (root != nullptr || !stack.empty()) {\n      while (root != nullptr) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      if (prev >= 0)\n        ans = min(ans, root->val - prev);\n      prev = root->val;\n      root = root->right;\n    }\n\n    return ans;\n  }\n};\n", "531": "class Solution {\n public:\n  int findLonelyPixel(vector<vector<char>>& picture) {\n    const int m = picture.size();\n    const int n = picture[0].size();\n    int ans = 0;\n    vector<int> rows(m);  // rows[i] := the number of B's in rows i\n    vector<int> cols(n);  // cols[i] := the number of B's in cols i\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (picture[i][j] == 'B') {\n          ++rows[i];\n          ++cols[j];\n        }\n\n    for (int i = 0; i < m; ++i)\n      if (rows[i] == 1)  // Only have to examine the rows if rows[i] == 1.\n        for (int j = 0; j < n; ++j)\n          // After meeting a 'B' in this rows, break and search the next row.\n          if (picture[i][j] == 'B') {\n            if (cols[j] == 1)\n              ++ans;\n            break;\n          }\n\n    return ans;\n  }\n};\n", "532": "class Solution {\n public:\n  int findPairs(vector<int>& nums, int k) {\n    int ans = 0;\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < nums.size(); ++i)\n      numToIndex[nums[i]] = i;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int target = nums[i] + k;\n      if (const auto it = numToIndex.find(target);\n          it != numToIndex.cend() && it->second != i) {\n        ++ans;\n        numToIndex.erase(target);\n      }\n    }\n\n    return ans;\n  }\n};\n", "533": "class Solution {\n public:\n  int findBlackPixel(vector<vector<char>>& picture, int target) {\n    const int m = picture.size();\n    const int n = picture[0].size();\n    int ans = 0;\n    vector<int> rows(m);\n    vector<int> cols(n);\n    vector<string> rowStrings(m);\n    unordered_map<string, int> countRowStrings;\n\n    for (int i = 0; i < m; ++i) {\n      string s;\n      for (int j = 0; j < n; ++j) {\n        if (picture[i][j] == 'B') {\n          ++rows[i];\n          ++cols[j];\n        }\n        s += picture[i][j];\n      }\n      rowStrings[i] = s;\n      ++countRowStrings[s];\n    }\n\n    for (int i = 0; i < m; ++i)\n      if (rows[i] == target && countRowStrings[rowStrings[i]] == target)\n        for (int j = 0; j < n; ++j)\n          if (picture[i][j] == 'B' && cols[j] == target)\n            ++ans;\n\n    return ans;\n  }\n};\n", "535": "class Solution {\n public:\n  string encode(string longUrl) {\n    while (!urlToCode.contains(longUrl)) {\n      string code;\n      for (int i = 0; i < 6; ++i)\n        code += alphabets[rand() % alphabets.size()];\n      if (!codeToUrl.contains(code)) {\n        codeToUrl[code] = longUrl;\n        urlToCode[longUrl] = code;\n        return \"http://tinyurl.com/\" + code;\n      }\n    }\n\n    throw;\n  }\n\n  string decode(string shortUrl) {\n    return codeToUrl[shortUrl.substr(19)];\n  }\n\n private:\n  const string alphabets =\n      \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n  unordered_map<string, string> urlToCode;\n  unordered_map<string, string> codeToUrl;\n};\n", "536": "class Solution {\n public:\n  TreeNode* str2tree(string s) {\n    if (s.empty())\n      return nullptr;\n\n    stack<TreeNode*> stack;\n\n    for (int l = 0, r = 0; r < s.length(); l = ++r)\n      if (s[r] == ')') {\n        stack.pop();\n      } else if (isdigit(s[r]) || s[r] == '-') {\n        while (r + 1 < s.length() && isdigit(s[r + 1]))\n          ++r;\n        const int val = stoi(s.substr(l, r - l + 1));\n        TreeNode* node = new TreeNode(val);\n        if (!stack.empty()) {\n          TreeNode* parent = stack.top();\n          if (parent->left)\n            parent->right = node;\n          else\n            parent->left = node;\n        }\n        stack.push(node);\n      }\n\n    return stack.top();\n  }\n};\n", "537": "class Solution {\n public:\n  string complexNumberMultiply(string num1, string num2) {\n    const auto& [a0, a1] = getReala0ndImag(num1);\n    const auto& [b0, b1] = getReala0ndImag(num2);\n    return to_string(a0 * b0 - a1 * b1) + \"+\" + to_string(a0 * b1 + a1 * b0) +\n           \"i\";\n  }\n\n private:\n  pair<int, int> getReala0ndImag(const string& s) {\n    const string& real = s.substr(0, s.find_first_of('+'));\n    const string& imag = s.substr(s.find_first_of('+') + 1);\n    return {stoi(real), stoi(imag)};\n  };\n};\n", "538": "class Solution {\n public:\n  TreeNode* convertBST(TreeNode* root) {\n    int prefix = 0;\n    reversedInorder(root, prefix);\n    return root;\n  }\n\n private:\n  void reversedInorder(TreeNode* root, int& prefix) {\n    if (root == nullptr)\n      return;\n\n    reversedInorder(root->right, prefix);\n    prefix += root->val;\n    root->val = prefix;\n    reversedInorder(root->left, prefix);\n  }\n};\n", "539": "class Solution {\n public:\n  int findMinDifference(vector<string>& timePoints) {\n    int ans = 24 * 60;\n    int first = 24 * 60;\n    vector<bool> bucket(24 * 60);\n\n    for (const string& time : timePoints) {\n      const int num = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3));\n      first = min(first, num);\n      if (bucket[num])\n        return 0;\n      bucket[num] = true;\n    }\n\n    int prev = first;\n\n    for (int i = first + 1; i < bucket.size(); ++i)\n      if (bucket[i]) {\n        ans = min(ans, i - prev);\n        prev = i;\n      }\n\n    return min(ans, 24 * 60 - prev + first);\n  }\n};\n", "54": "class Solution {\n public:\n  vector<int> spiralOrder(vector<vector<int>>& matrix) {\n    if (matrix.empty())\n      return {};\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> ans;\n    int r1 = 0;\n    int c1 = 0;\n    int r2 = m - 1;\n    int c2 = n - 1;\n\n    // Repeatedly add matrix[r1..r2][c1..c2] to `ans`.\n    while (ans.size() < m * n) {\n      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)\n        ans.push_back(matrix[r1][j]);\n      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)\n        ans.push_back(matrix[i][c2]);\n      for (int j = c2; j >= c1 && ans.size() < m * n; --j)\n        ans.push_back(matrix[r2][j]);\n      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)\n        ans.push_back(matrix[i][c1]);\n      ++r1, ++c1, --r2, --c2;\n    }\n\n    return ans;\n  }\n};\n", "540": "class Solution {\n public:\n  int singleNonDuplicate(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      int m = (l + r) / 2;\n      if (m % 2 == 1)\n        --m;\n      if (nums[m] == nums[m + 1])\n        l = m + 2;\n      else\n        r = m;\n    }\n\n    return nums[l];\n  }\n};\n", "541": "class Solution {\n public:\n  string reverseStr(string s, int k) {\n    for (size_t i = 0; i < s.length(); i += 2 * k) {\n      int l = i;\n      int r = min(i + k - 1, s.length() - 1);\n      while (l < r)\n        swap(s[l++], s[r--]);\n    }\n\n    return s;\n  }\n};\n", "542": "class Solution {\n public:\n  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = mat.size();\n    const int n = mat[0].size();\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 0)\n          q.emplace(i, j);\n        else\n          mat[i][j] = INT_MAX;\n\n    while (!q.empty()) {\n      const auto [i, j] = q.front();\n      q.pop();\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (mat[x][y] <= mat[i][j] + 1)\n          continue;\n        q.emplace(x, y);\n        mat[x][y] = mat[i][j] + 1;\n      }\n    }\n\n    return mat;\n  }\n};\n", "543": "class Solution {\n public:\n  int diameterOfBinaryTree(TreeNode* root) {\n    int ans = 0;\n    maxDepth(root, ans);\n    return ans;\n  }\n\n private:\n  int maxDepth(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = maxDepth(root->left, ans);\n    const int r = maxDepth(root->right, ans);\n    ans = max(ans, l + r);\n    return 1 + max(l, r);\n  }\n};\n", "544": "class Solution {\n public:\n  string findContestMatch(int n) {\n    vector<string> matches(n);\n\n    for (int i = 0; i < n; ++i)\n      matches[i] = to_string(i + 1);\n\n    while (n > 1) {\n      for (int i = 0; i < n / 2; ++i)\n        matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n      n /= 2;\n    }\n\n    return matches[0];\n  }\n};\n", "545": "class Solution {\n public:\n  vector<int> boundaryOfBinaryTree(TreeNode* root) {\n    if (root == nullptr)\n      return {};\n    vector<int> ans{root->val};\n    dfs(root->left, true, false, ans);\n    dfs(root->right, false, true, ans);\n    return ans;\n  }\n\n private:\n  // 1. root->left is left boundary if root is left boundary.\n  //    root->right if left boundary if root->left == nullptr.\n  // 2. Same applys for right boundary.\n  // 3. If root is left boundary, add it before 2 children - preorder.\n  //    If root is right boundary, add it after 2 children - postorder.\n  // 4. A leaf that is neighter left/right boundary belongs to the bottom.\n  void dfs(TreeNode* root, bool lb, bool rb, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n    if (lb)\n      ans.push_back(root->val);\n    if (!lb && !rb && root->left == nullptr && root->right != nullptr)\n      ans.push_back(root->val);\n\n    dfs(root->left, lb, rb && root->right == nullptr, ans);\n    dfs(root->right, lb && root->left == nullptr, rb, ans);\n    if (rb)\n      ans.push_back(root->val);\n  }\n};\n", "546": "class Solution {\n public:\n  int removeBoxes(vector<int>& boxes) {\n    const int n = boxes.size();\n    vector<vector<vector<int>>> mem(n, vector<vector<int>>(n, vector<int>(n)));\n    return removeBoxes(boxes, 0, n - 1, 0, mem);\n  }\n\n private:\n  // Returns the maximum score of boxes[i..j] if k boxes eqaul to boxes[j].\n  int removeBoxes(const vector<int>& boxes, int i, int j, int k,\n                  vector<vector<vector<int>>>& mem) {\n    if (i > j)\n      return 0;\n    if (mem[i][j][k] > 0)\n      return mem[i][j][k];\n\n    int r = j;\n    int sameBoxes = k + 1;\n    while (r > 0 && boxes[r - 1] == boxes[r]) {\n      --r;\n      ++sameBoxes;\n    }\n    mem[i][j][k] = removeBoxes(boxes, i, r - 1, 0, mem) + sameBoxes * sameBoxes;\n\n    for (int p = i; p < r; ++p)\n      if (boxes[p] == boxes[r])\n        mem[i][j][k] =\n            max(mem[i][j][k], removeBoxes(boxes, i, p, sameBoxes, mem) +\n                                  removeBoxes(boxes, p + 1, r - 1, 0, mem));\n\n    return mem[i][j][k];\n  }\n};\n", "547": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int findCircleNum(vector<vector<int>>& isConnected) {\n    const int n = isConnected.size();\n    UnionFind uf(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i; j < n; ++j)\n        if (isConnected[i][j] == 1)\n          uf.unionByRank(i, j);\n\n    return uf.getCount();\n  }\n};\n", "548": "class Solution {\n public:\n  bool splitArray(vector<int>& nums) {\n    const int n = nums.size();\n    if (n < 7)\n      return false;\n\n    vector<int> prefix(n);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin());\n\n    for (int j = 3; j < n - 3; ++j) {\n      unordered_set<int> seen;\n      for (int i = 1; i < j - 1; ++i)\n        if (prefix[i - 1] == prefix[j - 1] - prefix[i])\n          seen.insert(prefix[i - 1]);\n      for (int k = j + 2; k < n - 1; ++k)\n        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&\n            seen.contains(prefix[k - 1] - prefix[j]))\n          return true;\n    }\n\n    return false;\n  }\n};\n", "549": "struct T {\n  int inc;  // the length of longest incrementing branch\n  int dec;  // the length of longest decrementing branch\n};\n\nclass Solution {\n public:\n  int longestConsecutive(TreeNode* root) {\n    int ans = 0;\n    longestPath(root, ans);\n    return ans;\n  }\n\n private:\n  T longestPath(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return {0, 0};\n\n    int inc = 1;\n    int dec = 1;\n\n    if (root->left) {\n      T l = longestPath(root->left, ans);\n      if (root->val + 1 == root->left->val)\n        inc = l.inc + 1;\n      else if (root->val - 1 == root->left->val)\n        dec = l.dec + 1;\n    }\n\n    if (root->right) {\n      T r = longestPath(root->right, ans);\n      if (root->val + 1 == root->right->val)\n        inc = max(inc, r.inc + 1);\n      else if (root->val - 1 == root->right->val)\n        dec = max(dec, r.dec + 1);\n    }\n\n    ans = max(ans, inc + dec - 1);\n    return {inc, dec};\n  }\n};\n", "55": "class Solution {\n public:\n  bool canJump(vector<int>& nums) {\n    int i = 0;\n\n    for (int reach = 0; i < nums.size() && i <= reach; ++i)\n      reach = max(reach, i + nums[i]);\n\n    return i == nums.size();\n  }\n};\n", "551": "class Solution {\n public:\n  bool checkRecord(string s) {\n    int countA = 0;\n    int countL = 0;\n\n    for (const char c : s) {\n      if (c == 'A' && ++countA > 1)\n        return false;\n      if (c != 'L')\n        countL = 0;\n      else if (++countL > 2)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "552": "class Solution {\n public:\n  int checkRecord(int n) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j] := the length so far with i A's and the last letters are j L's\n    vector<vector<long>> dp(2, vector<long>(3));\n    dp[0][0] = 1;\n\n    while (n-- > 0) {\n      const auto prev(dp);\n\n      // Append a P.\n      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % kMod;\n\n      // Append an L.\n      dp[0][1] = prev[0][0];\n\n      // Append an L.\n      dp[0][2] = prev[0][1];\n\n      // Append an A or append a P.\n      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +  //\n                  prev[1][0] + prev[1][1] + prev[1][2]) %\n                 kMod;\n\n      // Append an L.\n      dp[1][1] = prev[1][0];\n\n      // Append an L.\n      dp[1][2] = prev[1][1];\n    }\n\n    return accumulate(dp.begin(), dp.end(), 0, [](int acc, vector<long>& row) {\n      return (acc + accumulate(row.begin(), row.end(), 0L)) % kMod;\n    });\n  }\n};\n", "553": "class Solution {\n public:\n  string optimalDivision(vector<int>& nums) {\n    string ans = to_string(nums[0]);\n\n    if (nums.size() == 1)\n      return ans;\n    if (nums.size() == 2)\n      return ans + \"/\" + to_string(nums[1]);\n\n    ans += \"/(\" + to_string(nums[1]);\n    for (int i = 2; i < nums.size(); ++i)\n      ans += \"/\" + to_string(nums[i]);\n    ans += \")\";\n    return ans;\n  }\n};\n", "554": "class Solution {\n public:\n  int leastBricks(vector<vector<int>>& wall) {\n    int maxCount = 0;\n    unordered_map<int, int> count;\n\n    for (const vector<int>& row : wall) {\n      int prefix = 0;\n      for (int i = 0; i < row.size() - 1; ++i) {\n        prefix += row[i];\n        maxCount = max(maxCount, ++count[prefix]);\n      }\n    }\n\n    return wall.size() - maxCount;\n  }\n};\n", "555": "class Solution {\n public:\n  string splitLoopedString(vector<string>& strs) {\n    string ans;\n    vector<string> sortedStrs;\n\n    for (const string& s : strs)\n      sortedStrs.push_back(max(s, {s.rbegin(), s.rend()}));\n\n    for (int i = 0; i < sortedStrs.size(); ++i)\n      for (const string& s :\n           {sortedStrs[i], {sortedStrs[i].rbegin(), sortedStrs[i].rend()}})\n        for (int j = 0; j <= s.length(); ++j)\n          ans = max(ans, s.substr(j) + join(sortedStrs, i) + s.substr(0, j));\n\n    return ans;\n  }\n\n private:\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n\n  string join(const vector<string>& sortedStrs, int i) {\n    string joined;\n    for (int j = i + 1; j < sortedStrs.size(); ++j)\n      joined += sortedStrs[j];\n    for (int j = 0; j < i; ++j)\n      joined += sortedStrs[j];\n    return joined;\n  }\n};\n", "556": "class Solution {\n public:\n  int nextGreaterElement(int n) {\n    string s = to_string(n);\n    ranges::next_permutation(s);\n    const long ans = stol(s);\n    return ans > INT_MAX || ans <= n ? -1 : ans;\n  }\n};\n", "557": "class Solution {\n public:\n  string reverseWords(string s) {\n    int i = 0;\n    int j = 0;\n\n    while (i < s.length()) {\n      while (i < j || i < s.length() && s[i] == ' ')\n        ++i;\n      while (j < i || j < s.length() && s[j] != ' ')\n        ++j;\n      reverse(s.begin() + i, s.begin() + j);\n    }\n\n    return s;\n  }\n};\n", "558": "class Solution {\n public:\n  Node* intersect(Node* quadTree1, Node* quadTree2) {\n    if (quadTree1->isLeaf)\n      return quadTree1->val ? quadTree1 : quadTree2;\n    if (quadTree2->isLeaf)\n      return quadTree2->val ? quadTree2 : quadTree1;\n\n    Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\n    Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);\n    Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n    Node* bottomRight =\n        intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n\n    if (topLeft->val == topRight->val &&        //\n        topLeft->val == bottomLeft->val &&      //\n        topLeft->val == bottomRight->val &&     //\n        topLeft->isLeaf && topRight->isLeaf &&  //\n        bottomLeft->isLeaf && bottomRight->isLeaf)\n      return new Node(topLeft->val, true);\n    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);\n  }\n};\n", "559": "class Solution {\n public:\n  int maxDepth(Node* root) {\n    if (root == nullptr)\n      return 0;\n\n    int ans = 0;\n\n    for (Node* child : root->children)\n      ans = max(ans, maxDepth(child));\n\n    return 1 + ans;\n  }\n};\n", "56": "class Solution {\n public:\n  vector<vector<int>> merge(vector<vector<int>>& intervals) {\n    vector<vector<int>> ans;\n\n    ranges::sort(intervals);\n\n    for (const vector<int>& interval : intervals)\n      if (ans.empty() || ans.back()[1] < interval[0])\n        ans.push_back(interval);\n      else\n        ans.back()[1] = max(ans.back()[1], interval[1]);\n\n    return ans;\n  }\n};\n", "560": "class Solution {\n public:\n  int subarraySum(vector<int>& nums, int k) {\n    int ans = 0;\n    int prefix = 0;\n    unordered_map<int, int> count{{0, 1}};  // {prefix sum: count}\n\n    for (const int num : nums) {\n      prefix += num;\n      const int target = prefix - k;\n      if (const auto it = count.find(target); it != count.cend())\n        ans += it->second;\n      ++count[prefix];\n    }\n\n    return ans;\n  }\n};\n", "561": "class Solution {\n public:\n  int arrayPairSum(vector<int>& nums) {\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i < nums.size(); i += 2)\n      ans += nums[i];\n\n    return ans;\n  }\n};\n", "562": "class Solution {\n public:\n  int longestLine(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n    int ans = 0;\n    // dp[i][j][0] := horizontal\n    // dp[i][j][1] := vertical\n    // dp[i][j][2] := diagonal\n    // dp[i][j][3] := anti-diagonal\n    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(4)));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 1) {\n          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;\n          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;\n          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;\n          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;\n          ans = max(ans, ranges::max(dp[i][j]));\n        }\n\n    return ans;\n  }\n};\n", "563": "class Solution {\n public:\n  int findTilt(TreeNode* root) {\n    int ans = 0;\n    sum(root, ans);\n    return ans;\n  }\n\n private:\n  int sum(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = sum(root->left, ans);\n    const int r = sum(root->right, ans);\n    ans += abs(l - r);\n    return root->val + l + r;\n  }\n};\n", "564": "class Solution {\n public:\n  string nearestPalindromic(string n) {\n    const auto& [prevPalindrome, nextPalindrome] = getPalindromes(n);\n    return abs(prevPalindrome - stol(n)) <= abs(nextPalindrome - stol(n))\n               ? to_string(prevPalindrome)\n               : to_string(nextPalindrome);\n  }\n\n private:\n  // Returns the two closest palindromes to the given number.\n  pair<long, long> getPalindromes(const string& s) {\n    const long num = stol(s);\n    const int n = s.length();\n    pair<long, long> palindromes;\n    const string half = s.substr(0, (n + 1) / 2);\n    const string reversedHalf = reversed(half.substr(0, n / 2));\n    const long candidate = stol(half + reversedHalf);\n\n    if (candidate < num)\n      palindromes.first = candidate;\n    else {\n      const string prevHalf = to_string(stol(half) - 1);\n      const string reversedPrevHalf = reversed(prevHalf.substr(0, n / 2));\n      if (n % 2 == 0 && stol(prevHalf) == 0)\n        palindromes.first = 9;\n      else if (n % 2 == 0 && prevHalf == \"9\")\n        palindromes.first = stol(prevHalf + '9' + reversedPrevHalf);\n      else\n        palindromes.first = stol(prevHalf + reversedPrevHalf);\n    }\n\n    if (candidate > num)\n      palindromes.second = candidate;\n    else {\n      const string& nextHalf = to_string(stol(half) + 1);\n      const string& reversedNextHalf = reversed(nextHalf.substr(0, n / 2));\n      palindromes.second = stol(nextHalf + reversedNextHalf);\n    }\n\n    return palindromes;\n  }\n\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n};\n", "565": "class Solution {\n public:\n  int arrayNesting(vector<int>& nums) {\n    int ans = 0;\n\n    for (const int num : nums) {\n      if (num == -1)\n        continue;\n      int index = num;\n      int count = 0;\n      while (nums[index] != -1) {\n        const int cache = index;\n        index = nums[index];\n        nums[cache] = -1;\n        ++count;\n      }\n      ans = max(ans, count);\n    }\n\n    return ans;\n  }\n};\n", "566": "class Solution {\n public:\n  vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n    if (nums.empty() || r * c != nums.size() * nums[0].size())\n      return nums;\n\n    vector<vector<int>> ans(r, vector<int>(c));\n    int k = 0;\n\n    for (const vector<int>& row : nums)\n      for (const int num : row) {\n        ans[k / c][k % c] = num;\n        ++k;\n      }\n\n    return ans;\n  }\n};\n", "567": "class Solution {\n public:\n  bool checkInclusion(string s1, string s2) {\n    vector<int> count(26);\n    int required = s1.length();\n\n    for (const char c : s1)\n      ++count[c - 'a'];\n\n    for (int r = 0; r < s2.length(); ++r) {\n      if (--count[s2[r] - 'a'] >= 0)\n        --required;\n      if (r >= s1.length())  // The window is oversized.\n        if (++count[s2[r - s1.length()] - 'a'] > 0)\n          ++required;\n      if (required == 0)\n        return true;\n    }\n\n    return false;\n  }\n};\n", "568": "class Solution {\n public:\n  int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\n    const int N = days.size();\n    const int K = days[0].size();\n    // dp[i][k] := the number of vacations that can be taken from the i-th city\n    // and the k-th week\n    vector<vector<int>> dp(N, vector<int>(K + 1));\n\n    for (int k = K - 1; k >= 0; --k)\n      for (int i = 0; i < N; ++i) {\n        dp[i][k] = days[i][k] + dp[i][k + 1];\n        for (int j = 0; j < N; ++j)\n          if (flights[i][j] == 1)\n            dp[i][k] = max(dp[i][k], days[j][k] + dp[j][k + 1]);\n      }\n\n    return dp[0][0];\n  }\n};\n", "57": "class Solution {\n public:\n  vector<vector<int>> insert(vector<vector<int>>& intervals,\n                             vector<int>& newInterval) {\n    const int n = intervals.size();\n    vector<vector<int>> ans;\n    int i = 0;\n\n    while (i < n && intervals[i][1] < newInterval[0])\n      ans.push_back(intervals[i++]);\n\n    // Merge overlapping intervals.\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n      newInterval[0] = min(newInterval[0], intervals[i][0]);\n      newInterval[1] = max(newInterval[1], intervals[i][1]);\n      ++i;\n    }\n\n    ans.push_back(newInterval);\n\n    while (i < n)\n      ans.push_back(intervals[i++]);\n\n    return ans;\n  }\n};\n", "572": "class Solution {\n public:\n  bool isSubtree(TreeNode* s, TreeNode* t) {\n    if (s == nullptr)\n      return false;\n    if (isSameTree(s, t))\n      return true;\n    return isSubtree(s->left, t) || isSubtree(s->right, t);\n  }\n\n private:\n  bool isSameTree(TreeNode* p, TreeNode* q) {\n    if (!p || !q)\n      return p == q;\n    return p->val == q->val &&              //\n           isSameTree(p->left, q->left) &&  //\n           isSameTree(p->right, q->right);\n  }\n};\n", "573": "class Solution {\n public:\n  int minDistance(int height, int width, vector<int>& tree,\n                  vector<int>& squirrel, vector<vector<int>>& nuts) {\n    int totDist = 0;\n    int maxSave = INT_MIN;\n\n    for (const vector<int>& nut : nuts) {\n      totDist += dist(nut, tree) * 2;\n      maxSave = max(maxSave, dist(nut, tree) - dist(nut, squirrel));\n    }\n\n    return totDist - maxSave;\n  }\n\n private:\n  int dist(const vector<int>& a, const vector<int>& b) {\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]);\n  }\n};\n", "575": "class Solution {\n public:\n  int distributeCandies(vector<int>& candies) {\n    bitset<200001> bitset;\n\n    for (const int candy : candies)\n      bitset.set(candy + 100000);\n\n    return min(candies.size() / 2, bitset.contains());\n  }\n};\n", "576": "class Solution {\n public:\n  int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    // dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds\n    vector<vector<int>> dp(m, vector<int>(n));\n    dp[startRow][startColumn] = 1;\n\n    while (maxMove--) {\n      vector<vector<int>> newDp(m, vector<int>(n));\n      for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n          if (dp[i][j] > 0)\n            for (const auto& [dx, dy] : kDirs) {\n              const int x = i + dx;\n              const int y = j + dy;\n              if (x < 0 || x == m || y < 0 || y == n)\n                ans = (ans + dp[i][j]) % kMod;\n              else\n                newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod;\n            }\n      dp = std::move(newDp);\n    }\n\n    return ans;\n  }\n};\n", "58": "class Solution {\n public:\n  int lengthOfLastWord(string s) {\n    int i = s.length() - 1;\n\n    while (i >= 0 && s[i] == ' ')\n      --i;\n    const int lastIndex = i;\n    while (i >= 0 && s[i] != ' ')\n      --i;\n\n    return lastIndex - i;\n  }\n};\n", "581": "class Solution {\n public:\n  int findUnsortedSubarray(vector<int>& nums) {\n    const int n = nums.size();\n    int mn = INT_MAX;\n    int mx = INT_MIN;\n    bool meetDecrease = false;\n    bool meetIncrease = false;\n\n    for (int i = 1; i < n; ++i) {\n      if (nums[i] < nums[i - 1])\n        meetDecrease = true;\n      if (meetDecrease)\n        mn = min(mn, nums[i]);\n    }\n\n    for (int i = n - 2; i >= 0; --i) {\n      if (nums[i] > nums[i + 1])\n        meetIncrease = true;\n      if (meetIncrease)\n        mx = max(mx, nums[i]);\n    }\n\n    int l;\n    for (l = 0; l < n; ++l)\n      if (nums[l] > mn)\n        break;\n\n    int r;\n    for (r = n - 1; r >= 0; --r)\n      if (nums[r] < mx)\n        break;\n\n    return l < r ? r - l + 1 : 0;\n  }\n};\n", "582": "class Solution {\n public:\n  vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {\n    vector<int> ans;\n    unordered_map<int, vector<int>> tree;\n\n    for (int i = 0; i < pid.size(); ++i) {\n      if (ppid[i] == 0)\n        continue;\n      tree[ppid[i]].push_back(pid[i]);\n    }\n\n    dfs(tree, kill, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const unordered_map<int, vector<int>>& tree, int u,\n           vector<int>& ans) {\n    ans.push_back(u);\n    if (!tree.contains(u))\n      return;\n    for (const int v : tree.at(u))\n      dfs(tree, v, ans);\n  }\n};\n", "583": "class Solution {\n public:\n  int minDistance(string word1, string word2) {\n    const int k = lcs(word1, word2);\n    return (word1.length() - k) + (word2.length() - k);\n  }\n\n private:\n  int lcs(const string& a, const string& b) {\n    const int m = a.length();\n    const int n = b.length();\n    // dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (a[i - 1] == b[j - 1])\n          dp[i][j] = 1 + dp[i - 1][j - 1];\n        else\n          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n    return dp[m][n];\n  }\n};\n", "587": "// Monotone Chain\nclass Solution {\n public:\n  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\n    vector<vector<int>> hull;\n\n    ranges::sort(trees, ranges::less{}, [](const vector<int>& tree) {\n      const int x = tree[0];\n      const int y = tree[1];\n      return pair<int, int>{x, y};\n    });\n\n    // Build the lower hull: left-to-right scan.\n    for (const vector<int>& tree : trees) {\n      while (hull.size() > 1 &&\n             cross(hull.back(), hull[hull.size() - 2], tree) > 0)\n        hull.pop_back();\n      hull.push_back(tree);\n    }\n    hull.pop_back();\n\n    // Build the upper hull: right-to-left scan.\n    for (int i = trees.size() - 1; i >= 0; --i) {\n      while (hull.size() > 1 &&\n             cross(hull.back(), hull[hull.size() - 2], trees[i]) > 0)\n        hull.pop_back();\n      hull.push_back(trees[i]);\n    }\n\n    // Remove the redundant elements from the stack.\n    ranges::sort(hull, ranges::less{}, [](const vector<int>& tree) {\n      const int x = tree[0];\n      const int y = tree[1];\n      return pair<int, int>{y, x};\n    });\n    hull.erase(unique(hull.begin(), hull.end(),\n                      [](const vector<int>& a, const vector<int>& b) {\n      return a[0] == b[0] && a[1] == b[1];\n    }),\n               hull.end());\n    return hull;\n  }\n\n private:\n  int cross(const vector<int>& p, const vector<int>& q, const vector<int>& r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  }\n};\n", "588": "struct TrieNode {\n  map<string, shared_ptr<TrieNode>> children;  // lexicographical\n  bool isFile = false;\n  string content;\n};\n\nclass FileSystem {\n public:\n  vector<string> ls(string path) {\n    auto [node, lastDir] = createDirAndGetPair(path);\n    if (node->isFile)\n      return {lastDir};\n\n    vector<string> ans;\n\n    for (const auto& [file, _] : node->children)\n      ans.push_back(file);\n\n    return ans;\n  }\n\n  void mkdir(string path) {\n    createDirAndGetPair(path);\n  }\n\n  void addContentToFile(string filePath, string content) {\n    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;\n    node->isFile = true;\n    node->content += content;\n  }\n\n  string readContentFromFile(string filePath) {\n    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;\n    return node->content;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  // e.g. createDirAndGetPair(\"/a//b\") -> {TrieNode b, string \"b\"}\n  pair<shared_ptr<TrieNode>, string> createDirAndGetPair(const string& path) {\n    const vector<string> dirs = getDirs(path);\n    shared_ptr<TrieNode> node = root;\n\n    for (const string& dir : dirs) {\n      if (!node->children.contains(dir))\n        node->children[dir] = make_shared<TrieNode>();\n      node = node->children[dir];\n    }\n\n    return {node, dirs.empty() ? \"\" : dirs.back()};\n  }\n\n  // e.g. getDirs(\"/a//b\") -> [\"a\", \"b\"]\n  vector<string> getDirs(const string& path) {\n    vector<string> dirs;\n    istringstream iss(path);\n\n    for (string dir; getline(iss, dir, '/');)\n      if (!dir.empty())  // Make sure that \"/a//b\" == \"/a/b\".\n        dirs.push_back(dir);\n\n    return dirs;\n  }\n};\n", "589": "class Solution {\n public:\n  vector<int> preorder(Node* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> ans;\n    stack<Node*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      for (auto it = root->children.rbegin(); it != root->children.rend(); ++it)\n        stack.push(*it);\n    }\n\n    return ans;\n  }\n};\n", "59": "class Solution {\n public:\n  vector<vector<int>> generateMatrix(int n) {\n    vector<vector<int>> ans(n, vector<int>(n));\n    int count = 1;\n\n    for (int mn = 0; mn < n / 2; ++mn) {\n      const int mx = n - mn - 1;\n      for (int i = mn; i < mx; ++i)\n        ans[mn][i] = count++;\n      for (int i = mn; i < mx; ++i)\n        ans[i][mx] = count++;\n      for (int i = mx; i > mn; --i)\n        ans[mx][i] = count++;\n      for (int i = mx; i > mn; --i)\n        ans[i][mn] = count++;\n    }\n\n    if (n % 2 == 1)\n      ans[n / 2][n / 2] = count;\n\n    return ans;\n  }\n};\n", "590": "class Solution {\n public:\n  vector<int> postorder(Node* root) {\n    if (root == nullptr)\n      return {};\n\n    vector<int> ans;\n    stack<Node*> stack{{root}};\n\n    while (!stack.empty()) {\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      for (Node* child : root->children)\n        stack.push(child);\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "591": "class Solution {\n public:\n  bool isValid(string code) {\n    if (code[0] != '<' || code.back() != '>')\n      return false;\n\n    stack<string> stack;\n\n    for (int i = 0; i < code.length(); ++i) {\n      int closeIndex = 0;\n      if (stack.empty() && containsTag)\n        return false;\n      if (code[i] == '<') {\n        // It's inside a tag, so check if it's a cdata.\n        if (!stack.empty() && code[i + 1] == '!') {\n          closeIndex = code.find(\"]]>\", i + 2);\n          if (closeIndex == string::npos ||\n              !isValidCdata(code.substr(i + 2, closeIndex - i - 2)))\n            return false;\n        } else if (code[i + 1] == '/') {  // the end tag\n          closeIndex = code.find('>', i + 2);\n          if (closeIndex == string::npos ||\n              !isValidTagName(stack, code.substr(i + 2, closeIndex - i - 2),\n                              true))\n            return false;\n        } else {  // the start tag\n          closeIndex = code.find('>', i + 1);\n          if (closeIndex == string::npos ||\n              !isValidTagName(stack, code.substr(i + 1, closeIndex - i - 1),\n                              false))\n            return false;\n        }\n        i = closeIndex;\n      }\n    }\n\n    return stack.empty() && containsTag;\n  }\n\n private:\n  bool containsTag = false;\n\n  bool isValidCdata(const string& s) {\n    return s.find(\"[CDATA[\") == 0;\n  }\n\n  bool isValidTagName(stack<string>& stack, const string& tagName,\n                      bool isEndTag) {\n    if (tagName.empty() || tagName.length() > 9)\n      return false;\n\n    for (const char c : tagName)\n      if (!isupper(c))\n        return false;\n\n    if (isEndTag) {\n      if (stack.empty())\n        return false;\n      if (stack.top() != tagName)\n        return false;\n      stack.pop();\n      return true;\n    }\n\n    containsTag = true;\n    stack.push(tagName);\n    return true;\n  }\n};\n", "592": "class Solution {\n public:\n  string fractionAddition(string expression) {\n    istringstream iss(expression);\n    char _;\n    int a;\n    int b;\n    int A = 0;\n    int B = 1;\n\n    // Init: A / B = 0 / 1\n    // A / B + a / b = (Ab + aB) / Bb\n    // So, in each round, set A = Ab + aB, B = Bb.\n    while (iss >> a >> _ >> b) {\n      A = A * b + a * B;\n      B *= b;\n      const int g = abs(__gcd(A, B));\n      A /= g;\n      B /= g;\n    }\n\n    return to_string(A) + \"/\" + to_string(B);\n  }\n};\n", "593": "class Solution {\n public:\n  bool validSquare(vector<int>& p1, vector<int>& p2,  //\n                   vector<int>& p3, vector<int>& p4) {\n    unordered_set<int> distSet;\n    vector<vector<int>> points{p1, p2, p3, p4};\n\n    for (int i = 0; i < 4; ++i)\n      for (int j = i + 1; j < 4; ++j)\n        distSet.insert(dist(points[i], points[j]));\n\n    return !distSet.contains(0) && distSet.size() == 2;\n  }\n\n private:\n  int dist(vector<int>& p1, vector<int>& p2) {\n    return (p1[0] - p2[0]) * (p1[0] - p2[0]) +\n           (p1[1] - p2[1]) * (p1[1] - p2[1]);\n  }\n};\n", "594": "class Solution {\n public:\n  int findLHS(vector<int>& nums) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (const auto& [num, freq] : count)\n      if (const auto it = count.find(num + 1); it != count.cend())\n        ans = max(ans, freq + it->second);\n\n    return ans;\n  }\n};\n", "598": "class Solution {\n public:\n  int maxCount(int m, int n, vector<vector<int>>& ops) {\n    int minY = m;\n    int minX = n;\n\n    for (const vector<int>& op : ops) {\n      minY = min(minY, op[0]);\n      minX = min(minX, op[1]);\n    }\n\n    return minX * minY;\n  }\n};\n", "599": "class Solution {\n public:\n  vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    vector<string> ans;\n    unordered_map<string, int> restaurantToIndex;\n    int minSum = INT_MAX;\n\n    for (int i = 0; i < list1.size(); ++i)\n      restaurantToIndex[list1[i]] = i;\n\n    for (int i = 0; i < list2.size(); ++i) {\n      const string& restaurant = list2[i];\n      if (const auto it = restaurantToIndex.find(restaurant);\n          it != restaurantToIndex.cend()) {\n        const int sum = it->second + i;\n        if (sum < minSum) {\n          minSum = sum;\n          ans = {restaurant};\n        } else if (sum == minSum) {\n          ans.push_back(restaurant);\n        }\n      }\n    }\n\n    return ans;\n  }\n};\n", "6": "class Solution {\n public:\n  string convert(string s, int numRows) {\n    string ans;\n    vector<vector<char>> rows(numRows);\n    int k = 0;\n    int direction = (numRows == 1) - 1;\n\n    for (const char c : s) {\n      rows[k].push_back(c);\n      if (k == 0 || k == numRows - 1)\n        direction *= -1;\n      k += direction;\n    }\n\n    for (const vector<char>& row : rows)\n      for (const char c : row)\n        ans += c;\n\n    return ans;\n  }\n};\n", "60": "class Solution {\n public:\n  string getPermutation(int n, int k) {\n    string ans;\n    vector<int> nums(n);\n    vector<int> fact(n + 1, 1);  // fact[i] := i!\n\n    iota(nums.begin(), nums.end(), 1);\n\n    for (int i = 2; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n\n    --k;  // 0-indexed\n\n    for (int i = n - 1; i >= 0; --i) {\n      const int j = k / fact[i];\n      k %= fact[i];\n      ans += to_string(nums[j]);\n      nums.erase(nums.begin() + j);\n    }\n\n    return ans;\n  }\n};\n", "600": "class Solution {\n public:\n  int findIntegers(int num) {\n    string bits;\n    for (; num; num >>= 1)\n      bits += to_string(num & 1);\n\n    const int n = bits.length();\n    vector<int> zero(n, 1);\n    vector<int> one(n, 1);\n\n    for (int i = 1; i < n; ++i) {\n      zero[i] = zero[i - 1] + one[i - 1];\n      one[i] = zero[i - 1];\n    }\n\n    int ans = zero[n - 1] + one[n - 1];\n\n    for (int i = n - 2; i >= 0; --i) {\n      // The numbers > num and <= 2^n - 1 are invalid.\n      if (bits[i] == '1' && bits[i + 1] == '1')\n        break;\n      if (bits[i] == '0' && bits[i + 1] == '0')\n        ans -= one[i];\n    }\n\n    return ans;\n  }\n};\n", "604": "class StringIterator {\n public:\n  StringIterator(string compressedString) {\n    int i = 0;  // compressedString's index\n    while (i < compressedString.length()) {\n      const char c = compressedString[i++];\n      int num = 0;\n      while (i < compressedString.length() && isdigit(compressedString[i]))\n        num = num * 10 + (compressedString[i++] - '0');\n      q.emplace(c, num);\n    }\n  }\n\n  char next() {\n    if (!hasNext())\n      return ' ';\n    const char c = q.front().first;\n    if (--q.front().second == 0)\n      q.pop();\n    return c;\n  }\n\n  bool hasNext() {\n    return !q.empty();\n  }\n\n private:\n  queue<pair<char, int>> q;  // (currentChar, num)\n};\n", "605": "class Solution {\n public:\n  bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n    if (n == 0)\n      return true;\n\n    for (int i = 0; i < flowerbed.size(); ++i)\n      if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) &&\n          (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n        flowerbed[i] = 1;\n        if (--n == 0)\n          return true;\n      }\n\n    return false;\n  }\n};\n", "606": "class Solution {\n public:\n  string tree2str(TreeNode* t) {\n    return dfs(t);\n  }\n\n private:\n  string dfs(TreeNode* root) {\n    if (root == nullptr)\n      return \"\";\n\n    const string& rootStr = to_string(root->val);\n    if (root->right)\n      return rootStr + \"(\" + dfs(root->left) + \")(\" + dfs(root->right) + \")\";\n    if (root->left)\n      return rootStr + \"(\" + dfs(root->left) + \")\";\n    return rootStr + \"\";\n  }\n};\n", "609": "class Solution {\n public:\n  vector<vector<string>> findDuplicate(vector<string>& paths) {\n    vector<vector<string>> ans;\n    unordered_map<string, vector<string>> contentToFilePaths;\n\n    for (const string& path : paths) {\n      istringstream iss(path);\n      string rootPath;\n      iss >> rootPath;  // \"root/d1/d2/.../dm\"\n\n      string fileAndContent;\n      while (iss >> fileAndContent) {  // \"fn.txt(fn_content)\"\n        const int l = fileAndContent.find('(');\n        const int r = fileAndContent.find(')');\n        // \"fn.txt\"\n        const string file = fileAndContent.substr(0, l);\n        // \"fn_content\"\n        const string content = fileAndContent.substr(l + 1, r - l - 1);\n        // \"root/d1/d2/.../dm/fn.txt\"\n        const string filePath = rootPath + '/' + file;\n        contentToFilePaths[content].push_back(filePath);\n      }\n    }\n\n    for (const auto& [_, filePaths] : contentToFilePaths)\n      if (filePaths.size() > 1)\n        ans.push_back(filePaths);\n\n    return ans;\n  }\n};\n", "61": "class Solution {\n public:\n  ListNode* rotateRight(ListNode* head, int k) {\n    if (!head || !head->next || k == 0)\n      return head;\n\n    ListNode* tail;\n    int length = 1;\n    for (tail = head; tail->next; tail = tail->next)\n      ++length;\n    tail->next = head;  // Circle the list.\n\n    const int t = length - k % length;\n    for (int i = 0; i < t; ++i)\n      tail = tail->next;\n    ListNode* newHead = tail->next;\n    tail->next = nullptr;\n\n    return newHead;\n  }\n};\n", "611": "class Solution {\n public:\n  int triangleNumber(vector<int>& nums) {\n    if (nums.size() < 3)\n      return 0;\n\n    int ans = 0;\n\n    ranges::sort(nums);\n\n    for (int k = nums.size() - 1; k > 1; --k) {\n      int i = 0;\n      int j = k - 1;\n      while (i < j)\n        if (nums[i] + nums[j] > nums[k]) {\n          // (nums[i], nums[j], nums[k])\n          // (nums[i + 1], nums[j], nums[k])\n          // ...\n          // (nums[j - 1], nums[j], nums[k])\n          ans += j - i;\n          --j;\n        } else {\n          ++i;\n        }\n    }\n\n    return ans;\n  }\n};\n", "616": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(128) {}\n};\n\nclass Solution {\n public:\n  string addBoldTag(string s, vector<string>& words) {\n    const int n = s.length();\n    string ans;\n    // bold[i] := true if s[i] should be bolded\n    vector<bool> bold(n);\n\n    for (const string& word : words)\n      insert(word);\n\n    int boldEnd = -1;  // `s[i..boldEnd]` should be bolded.\n    for (int i = 0; i < n; ++i) {\n      boldEnd = max(boldEnd, find(s, i));\n      bold[i] = boldEnd >= i;\n    }\n\n    // Construct the string with the bold tags.\n    int i = 0;\n    while (i < n)\n      if (bold[i]) {\n        int j = i;\n        while (j < n && bold[j])\n          ++j;\n        // `s[i..j)` should be bolded.\n        ans += \"<b>\" + s.substr(i, j - i) + \"</b>\";\n        i = j;\n      } else {\n        ans += s[i++];\n      }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      if (node->children[c] == nullptr)\n        node->children[c] = make_shared<TrieNode>();\n      node = node->children[c];\n    }\n    node->isWord = true;\n  }\n\n  int find(const string& s, int i) {\n    shared_ptr<TrieNode> node = root;\n    int ans = -1;\n    for (int j = i; j < s.length(); ++j) {\n      if (node->children[s[j]] == nullptr)\n        return ans;\n      node = node->children[s[j]];\n      if (node->isWord)\n        ans = j;\n    }\n    return ans;\n  }\n};\n", "617": "class Solution {\n public:\n  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n    if (root1 == nullptr && root2 == nullptr)\n      return nullptr;\n    const int val = (root1 == nullptr ? 0 : root1->val) +\n                    (root2 == nullptr ? 0 : root2->val);\n    TreeNode* root = new TreeNode(val);\n    root->left = mergeTrees(root1 == nullptr ? nullptr : root1->left,\n                            root2 == nullptr ? nullptr : root2->left);\n    root->right = mergeTrees(root1 == nullptr ? nullptr : root1->right,\n                             root2 == nullptr ? nullptr : root2->right);\n    return root;\n  }\n};\n", "62": "class Solution {\n public:\n  int uniquePaths(int m, int n) {\n    vector<int> dp(n, 1);\n\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        dp[j] += dp[j - 1];\n\n    return dp[n - 1];\n  }\n};\n", "621": "class Solution {\n public:\n  int leastInterval(vector<char>& tasks, int n) {\n    if (n == 0)\n      return tasks.size();\n\n    vector<int> count(26);\n\n    for (const char task : tasks)\n      ++count[task - 'A'];\n\n    const int maxFreq = ranges::max(count);\n    // Put the most frequent task in the slot first.\n    const int maxFreqTaskOccupy = (maxFreq - 1) * (n + 1);\n    // Get the number of tasks with the same frequency as `maxFreq`, we'll\n    // append them after `maxFreqTaskOccupy`.\n    const int nMaxFreq = ranges::count(count, maxFreq);\n    // max(\n    //   the most frequent task is frequent enough to force some idle slots,\n    //   the most frequent task is not frequent enough to force idle slots\n    // )\n    return max(maxFreqTaskOccupy + nMaxFreq, static_cast<int>(tasks.size()));\n  }\n};\n", "622": "class MyCircularQueue {\n public:\n  /** Initialize your data structure here. Set the size of the queue to be k. */\n  MyCircularQueue(int k) : k(k), q(k), rear(k - 1) {}\n\n  /** Insert an element into the circular queue. Return true if the operation is\n   * successful. */\n  bool enQueue(int value) {\n    if (isFull())\n      return false;\n\n    rear = ++rear % k;\n    q[rear] = value;\n    ++size;\n    return true;\n  }\n\n  /** Delete an element from the circular queue. Return true if the operation is\n   * successful. */\n  bool deQueue() {\n    if (isEmpty())\n      return false;\n\n    front = ++front % k;\n    --size;\n    return true;\n  }\n\n  /** Get the front item from the queue. */\n  int Front() {\n    return isEmpty() ? -1 : q[front];\n  }\n\n  /** Get the last item from the queue. */\n  int Rear() {\n    return isEmpty() ? -1 : q[rear];\n  }\n\n  /** Checks whether the circular queue is empty or not. */\n  bool isEmpty() {\n    return size == 0;\n  }\n\n  /** Checks whether the circular queue is full or not. */\n  bool isFull() {\n    return size == k;\n  }\n\n private:\n  const int k;\n  vector<int> q;\n  int size = 0;\n  int front = 0;\n  int rear;\n};\n", "623": "class Solution {\n public:\n  TreeNode* addOneRow(TreeNode* root, int v, int d) {\n    if (d == 1) {\n      TreeNode* newRoot = new TreeNode(v);\n      newRoot->left = root;\n      return newRoot;\n    }\n\n    int depth = 0;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      ++depth;\n      for (int sz = q.size(); sz > 0; --sz) {\n        TreeNode* node = q.front();\n        q.pop();\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n        if (depth == d - 1) {\n          TreeNode* cachedLeft = node->left;\n          TreeNode* cachedRight = node->right;\n          node->left = new TreeNode(v);\n          node->right = new TreeNode(v);\n          node->left->left = cachedLeft;\n          node->right->right = cachedRight;\n        }\n      }\n      if (depth == d - 1)\n        break;\n    }\n\n    return root;\n  }\n};\n", "624": "class Solution {\n public:\n  int mxDistance(vector<vector<int>>& arrays) {\n    int ans = 0;\n    int mn = 10000;\n    int mx = -10000;\n\n    for (const vector<int>& A : arrays) {\n      ans = max({ans, A.back() - mn, mx - A.front()});\n      mn = min(mn, A.front());\n      mx = max(mx, A.back());\n    }\n\n    return ans;\n  }\n};\n", "625": "class Solution {\n public:\n  int smallestFactorization(int num) {\n    if (num == 1)\n      return 1;\n\n    long ans = 0;\n    long base = 1;\n\n    for (int i = 9; i > 1; --i)\n      while (num % i == 0) {\n        num /= i;\n        ans = base * i + ans;\n        base *= 10;\n      }\n\n    return num == 1 && ans <= INT_MAX ? ans : 0;\n  }\n};\n", "628": "class Solution {\n public:\n  int maximumProduct(vector<int>& nums) {\n    int min1 = INT_MAX;  // the minimum\n    int min2 = INT_MAX;  // the second minimum\n    int max1 = INT_MIN;  // the maximum\n    int max2 = INT_MIN;  // the second maximum\n    int max3 = INT_MIN;  // the third maximum\n\n    for (const int num : nums) {\n      if (num <= min1) {\n        min2 = min1;\n        min1 = num;\n      } else if (num <= min2) {\n        min2 = num;\n      }\n      if (num >= max1) {\n        max3 = max2;\n        max2 = max1;\n        max1 = num;\n      } else if (num >= max2) {\n        max3 = max2;\n        max2 = num;\n      } else if (num >= max3) {\n        max3 = num;\n      }\n    }\n\n    return max(max1 * min1 * min2, max1 * max2 * max3);\n  }\n};\n", "629": "class Solution {\n public:\n  int kInversePairs(int n, int k) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j] := the number of permutations of numbers 1..i with j inverse\n    // pairs\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\n\n    // If there's no inverse pair, the permutation is unique \"123..i\".\n    for (int i = 0; i <= n; ++i)\n      dp[i][0] = 1;\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= k; ++j) {\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod;\n        if (j - i >= 0)\n          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod;\n      }\n\n    return dp[n][k];\n  }\n};\n", "63": "class Solution {\n public:\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n    const int m = obstacleGrid.size();\n    const int n = obstacleGrid[0].size();\n    vector<long> dp(n);\n    dp[0] = 1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (obstacleGrid[i][j])\n          dp[j] = 0;\n        else if (j > 0)\n          dp[j] += dp[j - 1];\n\n    return dp[n - 1];\n  }\n};\n", "630": "class Solution {\n public:\n  int scheduleCourse(vector<vector<int>>& courses) {\n    int time = 0;\n    priority_queue<int> maxHeap;\n\n    ranges::sort(courses, ranges::less{},\n                 [](const vector<int>& course) { return course[1]; });\n\n    for (const vector<int>& course : courses) {\n      const int duration = course[0];\n      const int lastDay = course[1];\n      maxHeap.push(duration);\n      time += duration;\n      // If the current course cannot be taken, check if it can be swapped with\n      // a previously taken course that has a larger duration to increase the\n      // time available to take upcoming courses.\n      if (time > lastDay)\n        time -= maxHeap.top(), maxHeap.pop();\n    }\n\n    return maxHeap.size();\n  }\n};\n", "631": "struct Cell {\n  int val = 0;\n  unordered_map<int, int> posCount;  // {pos: count}\n};\n\nclass Excel {\n public:\n  Excel(int height, char width)\n      : width(width), sheet(height, vector<Cell>(width)) {}\n\n  void set(int row, char column, int val) {\n    getCell(row, column) = {val, {}};\n  }\n\n  int get(int row, char column) {\n    const Cell& cell = getCell(row, column);\n    if (cell.posCount.empty())\n      return cell.val;\n\n    int val = 0;\n    for (const auto& [pos, count] : cell.posCount)\n      val += get(pos / width + 1, pos % width + 'A') * count;\n    return val;\n  }\n\n  int sum(int row, char column, vector<string> numbers) {\n    getCell(row, column).posCount = parse(numbers);\n    return get(row, column);\n  }\n\n private:\n  int width;\n  vector<vector<Cell>> sheet;\n\n  Cell& getCell(int row, char column) {\n    return sheet[row - 1][column - 'A'];\n  }\n\n  unordered_map<int, int> parse(const vector<string>& numbers) {\n    unordered_map<int, int> count;\n    for (const string& s : numbers) {\n      const auto [startRow, startCol, endRow, endCol] = parse(s);\n      for (int i = startRow - 1; i < endRow; ++i)\n        for (int j = startCol - 'A'; j < endCol - 'A' + 1; ++j)\n          ++count[i * width + j];\n    }\n    return count;\n  }\n\n  tuple<int, char, int, char> parse(const string& s) {\n    if (s.find(':') == string::npos)\n      return {stoi(s.substr(1)), s[0], stoi(s.substr(1)), s[0]};\n\n    const int colonIndex = s.find_first_of(':');\n    const string& l = s.substr(0, colonIndex);\n    const string& r = s.substr(colonIndex + 1);\n    return {stoi(l.substr(1)), l[0], stoi(r.substr(1)), r[0]};\n  }\n};\n", "632": "struct T {\n  int i;\n  int j;\n  int num;  // nums[i][j]\n};\n\nclass Solution {\n public:\n  vector<int> smallestRange(vector<vector<int>>& nums) {\n    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n    int mn = INT_MAX;\n    int mx = INT_MIN;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int num = nums[i][0];\n      minHeap.emplace(i, 0, num);\n      mn = min(mn, num);\n      mx = max(mx, num);\n    }\n\n    int minRange = mn;\n    int maxRange = mx;\n\n    while (minHeap.size() == nums.size()) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      if (j + 1 < nums[i].size()) {\n        minHeap.emplace(i, j + 1, nums[i][j + 1]);\n        mx = max(mx, nums[i][j + 1]);\n        mn = minHeap.top().num;\n        if (mx - mn < maxRange - minRange) {\n          minRange = mn;\n          maxRange = mx;\n        }\n      }\n    }\n\n    return {minRange, maxRange};\n  }\n};\n", "633": "class Solution {\n public:\n  bool judgeSquareSum(int c) {\n    unsigned l = 0;\n    unsigned r = sqrt(c);\n\n    while (l <= r) {\n      const unsigned sum = l * l + r * r;\n      if (sum == c)\n        return true;\n      if (sum < c)\n        ++l;\n      else\n        --r;\n    }\n\n    return false;\n  }\n};\n", "634": "class Solution {\n public:\n  int findDerangement(int n) {\n    constexpr int kMod = 1'000'000'007;\n    vector<int> dp(n + 1);\n\n    dp[0] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      dp[i] = (i - 1L) * (dp[i - 1] + dp[i - 2]) % kMod;\n\n    return dp[n];\n  }\n};\n", "635": "class LogSystem {\n public:\n  void put(int id, string timestamp) {\n    idAndTimestamps.emplace_back(id, timestamp);\n  }\n\n  vector<int> retrieve(string start, string end, string granularity) {\n    vector<int> ans;\n    const int index = granularityToIndices.at(granularity);\n    const string s = start.substr(0, index);\n    const string e = end.substr(0, index);\n\n    for (const auto& [id, timestamp] : idAndTimestamps) {\n      const string& t = timestamp.substr(0, index);\n      if (s <= t && t <= e)\n        ans.push_back(id);\n    }\n\n    return ans;\n  }\n\n private:\n  const unordered_map<string, int> granularityToIndices{\n      {\"Year\", 4},  {\"Month\", 7},   {\"Day\", 10},\n      {\"Hour\", 13}, {\"Minute\", 16}, {\"Second\", 19}};\n  vector<pair<int, string>> idAndTimestamps;\n};\n", "636": "class Solution {\n public:\n  vector<int> exclusiveTime(int n, vector<string>& logs) {\n    vector<int> ans(n);\n    stack<int> stack;  // [oldest_id, ..., latest_id]\n    int prevTime;\n\n    for (const string& log : logs) {\n      // Get the seperators' indices.\n      const int colon1 = log.find_first_of(':');\n      const int colon2 = log.find_last_of(':');\n      // Get the function_id, the label, and the timestamp.\n      const int id = stoi(log.substr(0, colon1));  // {function_id}\n      const char label = log[colon1 + 1];  // {\"s\" (\"start\") | \"e\" (\"end\") }\n      const int timestamp = stoi(log.substr(colon2 + 1));  // {timestamp}\n      if (label == 's') {\n        if (!stack.empty())\n          ans[stack.top()] += timestamp - prevTime;\n        stack.push(id);\n        prevTime = timestamp;\n      } else {\n        ans[stack.top()] += timestamp - prevTime + 1, stack.pop();\n        prevTime = timestamp + 1;\n      }\n    }\n\n    return ans;\n  }\n};\n", "637": "class Solution {\n public:\n  vector<double> averageOfLevels(TreeNode* root) {\n    vector<double> ans;\n    queue<TreeNode*> q{{root}};\n\n    while (!q.empty()) {\n      long sum = 0;\n      const int size = q.size();\n      for (int i = 0; i < size; ++i) {\n        TreeNode* node = q.front();\n        q.pop();\n        sum += node->val;\n        if (node->left)\n          q.push(node->left);\n        if (node->right)\n          q.push(node->right);\n      }\n      ans.push_back(sum / (double)size);\n    }\n\n    return ans;\n  }\n};\n", "638": "class Solution {\n public:\n  int shoppingOffers(vector<int>& price, vector<vector<int>>& special,\n                     vector<int>& needs) {\n    return dfs(price, special, needs, 0);\n  }\n\n private:\n  int dfs(const vector<int>& price, const vector<vector<int>>& special,\n          vector<int>& needs, int s) {\n    int ans = 0;\n    for (int i = 0; i < price.size(); ++i)\n      ans += price[i] * needs[i];\n\n    for (int i = s; i < special.size(); ++i)\n      if (isValid(special[i], needs)) {\n        // Use the special[i].\n        for (int j = 0; j < needs.size(); ++j)\n          needs[j] -= special[i][j];\n        ans = min(ans, special[i].back() + dfs(price, special, needs, i));\n        // Unuse the special[i] (backtracking).\n        for (int j = 0; j < needs.size(); ++j)\n          needs[j] += special[i][j];\n      }\n\n    return ans;\n  }\n\n  // Returns true if this special offer is a valid one.\n  bool isValid(const vector<int>& offer, const vector<int>& needs) {\n    for (int i = 0; i < needs.size(); ++i)\n      if (needs[i] < offer[i])\n        return false;\n    return true;\n  }\n};\n", "639": "class Solution {\n public:\n  int numDecodings(string s) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = s.length();\n    long prev2 = 1;\n    long prev1 = count(s[n - 1]);\n\n    for (int i = n - 2; i >= 0; --i) {\n      long dp = count(s[i], s[i + 1]) * prev2 + count(s[i]) * prev1;\n      dp %= kMod;\n      prev2 = prev1;\n      prev1 = dp;\n    }\n\n    return prev1;\n  }\n\n private:\n  int count(char c) {\n    if (c == '*')\n      return 9;\n    return c != '0';\n  }\n\n  int count(char c1, char c2) {\n    if (c1 == '*' && c2 == '*')  // c1c2: [11-19, 21-26]\n      return 15;\n    if (c1 == '*') {\n      if ('0' <= c2 && c2 <= '6')  // c1: [1-2]\n        return 2;\n      else  // c1: [1]\n        return 1;\n    }\n    if (c2 == '*') {\n      if (c1 == '1')  // c2: [1-9]\n        return 9;\n      if (c1 == '2')  // c2: [1-6]\n        return 6;\n      return 0;\n    }\n    return c1 == '1' || (c1 == '2' && c2 <= '6');\n  }\n};\n", "64": "class Solution {\n public:\n  int minPathSum(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i > 0 && j > 0)\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        else if (i > 0)\n          grid[i][0] += grid[i - 1][0];\n        else if (j > 0)\n          grid[0][j] += grid[0][j - 1];\n\n    return grid[m - 1][n - 1];\n  }\n};\n", "640": "class Solution {\n public:\n  string solveEquation(string equation) {\n    const string lhsEquation = equation.substr(0, equation.find('='));\n    const string rhsEquation = equation.substr(equation.find('=') + 1);\n    const auto& [lhsCoefficient, lhsConstant] = calculate(lhsEquation);\n    const auto& [rhsCoefficient, rhsConstant] = calculate(rhsEquation);\n    const int coefficient = lhsCoefficient - rhsCoefficient;\n    const int constant = rhsConstant - lhsConstant;\n\n    if (coefficient == 0 && constant == 0)\n      return \"Infinite solutions\";\n    if (coefficient == 0 && constant != 0)\n      return \"No solution\";\n    return \"x=\" + to_string(constant / coefficient);\n  }\n\n private:\n  pair<int, int> calculate(const string& s) {\n    int coefficient = 0;\n    int constant = 0;\n    int num = 0;\n    int sign = 1;\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (isdigit(c))\n        num = num * 10 + (c - '0');\n      else if (c == '+' || c == '-') {\n        constant += sign * num;\n        sign = c == '+' ? 1 : -1;\n        num = 0;\n      } else {\n        if (i > 0 && num == 0 && s[i - 1] == '0')\n          continue;\n        coefficient += num == 0 ? sign : sign * num;\n        num = 0;\n      }\n    }\n\n    return {coefficient, constant + sign * num};\n  }\n};\n", "641": "class MyCircularDeque {\n public:\n  /** Initialize your data structure here. Set the size of the deque to be k. */\n  MyCircularDeque(int k) : k(k), q(k), rear(k - 1) {}\n\n  /** Adds an item at the front of Deque. Return true if the operation is\n   * successful. */\n  bool insertFront(int value) {\n    if (isFull())\n      return false;\n\n    front = (--front + k) % k;\n    q[front] = value;\n    ++size;\n    return true;\n  }\n\n  /** Adds an item at the rear of Deque. Return true if the operation is\n   * successful. */\n  bool insertLast(int value) {\n    if (isFull())\n      return false;\n\n    rear = ++rear % k;\n    q[rear] = value;\n    ++size;\n    return true;\n  }\n\n  /** Deletes an item from the front of Deque. Return true if the operation is\n   * successful. */\n  bool deleteFront() {\n    if (isEmpty())\n      return false;\n\n    front = ++front % k;\n    --size;\n    return true;\n  }\n\n  /** Deletes an item from the rear of Deque. Return true if the operation is\n   * successful. */\n  bool deleteLast() {\n    if (isEmpty())\n      return false;\n\n    rear = (--rear + k) % k;\n    --size;\n    return true;\n  }\n\n  /** Get the front item from the deque. */\n  int getFront() {\n    return isEmpty() ? -1 : q[front];\n  }\n\n  /** Get the last item from the deque. */\n  int getRear() {\n    return isEmpty() ? -1 : q[rear];\n  }\n\n  /** Checks whether the circular deque is empty or not. */\n  bool isEmpty() {\n    return size == 0;\n  }\n\n  /** Checks whether the circular deque is full or not. */\n  bool isFull() {\n    return size == k;\n  }\n\n private:\n  const int k;\n  vector<int> q;\n  int size = 0;\n  int front = 0;\n  int rear;\n};\n", "643": "class Solution {\n public:\n  double findMaxAverage(vector<int>& nums, int k) {\n    double sum = accumulate(nums.begin(), nums.begin() + k, 0);\n    double ans = sum;\n\n    for (int i = k; i < nums.size(); ++i) {\n      sum += nums[i] - nums[i - k];\n      ans = max(ans, sum);\n    }\n\n    return ans / k;\n  }\n};\n", "644": "class Solution {\n public:\n  double findMaxAverage(vector<int>& nums, int k) {\n    constexpr double kErr = 1e-5;\n    double l = ranges::min(nums);\n    double r = ranges::max(nums);\n\n    while (r - l > kErr) {\n      const double m = (l + r) / 2;\n      if (check(nums, k, m))\n        l = m;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if there's a subarray, where its length >= k and its average\n  // sum >= m.\n  bool check(const vector<int>& nums, int k, double m) {\n    double sum = 0;\n    double prevSum = 0;\n    double minPrevSum = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      // Need to substract m for each `num` so that we can check if the sum of\n      // the subarray >= 0.\n      sum += nums[i] - m;\n      if (i >= k) {\n        prevSum += nums[i - k] - m;\n        minPrevSum = min(minPrevSum, prevSum);\n      }\n      if (i + 1 >= k && sum >= minPrevSum)\n        return true;\n    }\n\n    return false;\n  };\n};\n", "645": "class Solution {\n public:\n  vector<int> findErrorNums(vector<int>& nums) {\n    int duplicate;\n\n    for (const int num : nums)\n      if (nums[abs(num) - 1] < 0)\n        duplicate = abs(num);\n      else\n        nums[abs(num) - 1] *= -1;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] > 0)\n        return {duplicate, i + 1};\n\n    throw;\n  }\n};\n", "646": "class Solution {\n public:\n  int findLongestChain(vector<vector<int>>& pairs) {\n    int ans = 0;\n    int prevEnd = INT_MIN;\n\n    ranges::sort(pairs,\n                 [](const auto& a, const auto& b) { return a[1] < b[1]; });\n\n    for (const vector<int>& pair : pairs)\n      if (pair[0] > prevEnd) {\n        ++ans;\n        prevEnd = pair[1];\n      }\n\n    return ans;\n  }\n};\n", "647": "class Solution {\n public:\n  int countSubstrings(string s) {\n    int ans = 0;\n\n    for (int i = 0; i < s.length(); ++i) {\n      ans += extendPalindromes(s, i, i);\n      ans += extendPalindromes(s, i, i + 1);\n    }\n\n    return ans;\n  }\n\n private:\n  int extendPalindromes(const string& s, int l, int r) {\n    int count = 0;\n\n    while (l >= 0 && r < s.length() && s[l] == s[r]) {\n      ++count;\n      --l;\n      ++r;\n    }\n\n    return count;\n  }\n};\n", "648": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  const string* word = nullptr;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  string replaceWords(vector<string>& dictionary, string sentence) {\n    for (const string& word : dictionary)\n      insert(word);\n\n    string ans;\n    istringstream iss(sentence);\n\n    for (string s; iss >> s;)\n      ans += search(s) + ' ';\n    ans.pop_back();\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->word = &word;\n  }\n\n  string search(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      if (node->word)\n        return *node->word;\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return word;\n      node = node->children[i];\n    }\n    return word;\n  }\n};\n", "649": "class Solution {\n public:\n  string predictPartyVictory(string senate) {\n    const int n = senate.length();\n    queue<int> qR;\n    queue<int> qD;\n\n    for (int i = 0; i < n; ++i)\n      if (senate[i] == 'R')\n        qR.push(i);\n      else\n        qD.push(i);\n\n    while (!qR.empty() && !qD.empty()) {\n      const int indexR = qR.front();\n      qR.pop();\n      const int indexD = qD.front();\n      qD.pop();\n      if (indexR < indexD)\n        qR.push(indexR + n);\n      else\n        qD.push(indexD + n);\n    }\n\n    return qR.empty() ? \"Dire\" : \"Radiant\";\n  }\n};\n", "65": "class Solution {\n public:\n  bool isNumber(string s) {\n    trim(s);\n    if (s.empty())\n      return false;\n\n    bool seenNum = false;\n    bool seenDot = false;\n    bool seenE = false;\n\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s[i]) {\n        case '.':\n          if (seenDot || seenE)\n            return false;\n          seenDot = true;\n          break;\n        case 'e':\n        case 'E':\n          if (seenE || !seenNum)\n            return false;\n          seenE = true;\n          seenNum = false;\n          break;\n        case '+':\n        case '-':\n          if (i > 0 && s[i - 1] != 'e' && s[i - 1] != 'E')\n            return false;\n          seenNum = false;\n          break;\n        default:\n          if (!isdigit(s[i]))\n            return false;\n          seenNum = true;\n      }\n    }\n\n    return seenNum;\n  }\n\n private:\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n};\n", "650": "class Solution {\n public:\n  int minSteps(int n) {\n    if (n <= 1)\n      return 0;\n\n    // dp[i] := the minimum steps to get i 'A's\n    vector<int> dp(n + 1);\n\n    // Copy 'A', then paste 'A' i - 1 times.\n    iota(dp.begin(), dp.end(), 0);\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = i / 2; j > 2; --j)\n        if (i % j == 0) {\n          dp[i] = dp[j] + i / j;  // Paste dp[j] i / j times.\n          break;\n        }\n\n    return dp[n];\n  }\n};\n", "651": "class Solution {\n public:\n  int maxA(int n) {\n    // dp[i] := the maximum 'A' can be printed with i pressings\n    vector<int> dp(n + 1);\n\n    // 'A' * i\n    iota(dp.begin(), dp.end(), 0);\n\n    for (int i = 0; i <= n; ++i)\n      for (int j = 0; j <= i - 3; ++j)\n        dp[i] = max(dp[i], dp[j] * (i - j - 1));\n\n    return dp[n];\n  }\n};\n", "652": "class Solution {\n public:\n  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n    vector<TreeNode*> ans;\n    unordered_map<string, int> count;\n    encode(root, count, ans);\n    return ans;\n  }\n\n private:\n  string encode(TreeNode* root, unordered_map<string, int>& count,\n                vector<TreeNode*>& ans) {\n    if (root == nullptr)\n      return \"\";\n\n    const string encoded = to_string(root->val) + \"#\" +\n                           encode(root->left, count, ans) + \"#\" +\n                           encode(root->right, count, ans);\n    if (++count[encoded] == 2)\n      ans.push_back(root);\n    return encoded;\n  }\n};\n", "653": "class BSTIterator {\n public:\n  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {\n    pushUntilNull(root);\n  }\n\n  int next() {\n    TreeNode* root = stack.top();\n    stack.pop();\n    pushUntilNull(leftToRight ? root->right : root->left);\n    return root->val;\n  }\n\n private:\n  stack<TreeNode*> stack;\n  bool leftToRight;\n\n  void pushUntilNull(TreeNode* root) {\n    while (root != nullptr) {\n      stack.push(root);\n      root = leftToRight ? root->left : root->right;\n    }\n  }\n};\n\nclass Solution {\n public:\n  bool findTarget(TreeNode* root, int k) {\n    if (root == nullptr)\n      return false;\n\n    BSTIterator left(root, true);\n    BSTIterator right(root, false);\n\n    for (int l = left.next(), r = right.next(); l < r;) {\n      const int sum = l + r;\n      if (sum == k)\n        return true;\n      if (sum < k)\n        l = left.next();\n      else\n        r = right.next();\n    }\n\n    return false;\n  }\n};\n", "654": "class Solution {\n public:\n  TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n    return build(nums, 0, nums.size() - 1);\n  }\n\n private:\n  TreeNode* build(const vector<int>& nums, int i, int j) {\n    if (i > j)\n      return nullptr;\n\n    const auto it = max_element(nums.begin() + i, nums.begin() + j + 1);\n    const int maxNum = *it;\n    const int maxIndex = it - nums.begin();\n\n    TreeNode* root = new TreeNode(maxNum);\n    root->left = build(nums, i, maxIndex - 1);\n    root->right = build(nums, maxIndex + 1, j);\n    return root;\n  }\n};\n", "655": "class Solution {\n public:\n  vector<vector<string>> printTree(TreeNode* root) {\n    const int m = maxHeight(root);\n    const int n = pow(2, m) - 1;\n    vector<vector<string>> ans(m, vector<string>(n));\n    dfs(root, 0, 0, ans[0].size() - 1, ans);\n    return ans;\n  }\n\n private:\n  int maxHeight(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + max(maxHeight(root->left), maxHeight(root->right));\n  }\n\n  void dfs(TreeNode* root, int row, int left, int right,\n           vector<vector<string>>& ans) {\n    if (root == nullptr)\n      return;\n\n    const int mid = (left + right) / 2;\n    ans[row][mid] = to_string(root->val);\n    dfs(root->left, row + 1, left, mid - 1, ans);\n    dfs(root->right, row + 1, mid + 1, right, ans);\n  }\n};\n", "656": "class Solution {\n public:\n  vector<int> cheapestJump(vector<int>& coins, int maxJump) {\n    if (coins.back() == -1)\n      return {};\n\n    const int n = coins.size();\n    // dp[i] := the minimum cost to jump from i to n - 1\n    vector<int> dp(n, INT_MAX);\n    vector<int> next(n, -1);\n\n    dp.back() = coins.back();\n\n    for (int i = n - 2; i >= 0; --i) {\n      if (coins[i] == -1)\n        continue;\n      for (int j = i + 1; j < min(i + maxJump + 1, n); ++j) {\n        if (dp[j] == INT_MAX)\n          continue;\n        const int cost = coins[i] + dp[j];\n        if (cost < dp[i]) {\n          dp[i] = cost;\n          next[i] = j;\n        }\n      }\n    }\n\n    if (dp[0] == INT_MAX)\n      return {};\n    return constructPath(next, 0);\n  }\n\n private:\n  vector<int> constructPath(const vector<int>& next, int i) {\n    vector<int> ans;\n    while (i != -1) {\n      ans.push_back(i + 1);  // 1-indexed\n      i = next[i];\n    }\n    return ans;\n  }\n};\n", "657": "class Solution {\n public:\n  bool judgeCircle(string moves) {\n    int right = 0;\n    int up = 0;\n\n    for (const char move : moves) {\n      switch (move) {\n        case 'R':\n          ++right;\n          break;\n        case 'L':\n          --right;\n          break;\n        case 'U':\n          ++up;\n          break;\n        case 'D':\n          --up;\n          break;\n      }\n    }\n\n    return right == 0 && up == 0;\n  }\n};\n", "658": "class Solution {\n public:\n  vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n    int l = 0;\n    int r = arr.size() - k;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (x - arr[m] <= arr[m + k] - x)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return {arr.begin() + l, arr.begin() + l + k};\n  }\n};\n", "659": "class Solution {\n public:\n  bool isPossible(vector<int>& nums) {\n    unordered_map<int, int> count;\n    vector<int> starts;  // the start indices of each subsequence\n    vector<int> ends;    // the end indices of each subsequence\n\n    for (const int num : nums)\n      ++count[num];\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i > 0 && nums[i] == nums[i - 1])\n        continue;\n      const int num = nums[i];\n      const int currCount = count[num];\n      const int prevCount = count.contains(num - 1) ? count[num - 1] : 0;\n      const int nextCount = count.contains(num + 1) ? count[num + 1] : 0;\n      for (int j = 0; j < currCount - prevCount; ++j)\n        starts.push_back(num);\n      for (int j = 0; j < currCount - nextCount; ++j)\n        ends.push_back(num);\n    }\n\n    for (int i = 0; i < starts.size(); ++i)\n      if (ends[i] - starts[i] < 2)\n        return false;\n\n    return true;\n  }\n};\n", "66": "class Solution {\n public:\n  vector<int> plusOne(vector<int>& digits) {\n    for (int i = digits.size() - 1; i >= 0; --i) {\n      if (digits[i] < 9) {\n        ++digits[i];\n        return digits;\n      }\n      digits[i] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n  }\n};\n", "660": "class Solution {\n public:\n  int newInteger(int n) {\n    string ans;\n    while (n > 0) {\n      ans = to_string(n % 9) + ans;\n      n /= 9;\n    }\n    return stoi(ans);\n  }\n};\n", "661": "class Solution {\n public:\n  vector<vector<int>> imageSmoother(vector<vector<int>>& M) {\n    const int m = M.size();\n    const int n = M[0].size();\n    vector<vector<int>> ans(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        int ones = 0;\n        int count = 0;\n        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)\n          for (int y = max(0, j - 1); y < min(n, j + 2); ++y) {\n            ones += M[x][y];\n            ++count;\n          }\n        ans[i][j] = ones / count;\n      }\n\n    return ans;\n  }\n};\n", "662": "class Solution {\n public:\n  int widthOfBinaryTree(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n\n    long ans = 0;\n    dfs(root, 0, 1, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int level, long index, vector<long>&& startOfLevel,\n           long& ans) {\n    if (root == nullptr)\n      return;\n    if (startOfLevel.size() == level)\n      startOfLevel.push_back(index);\n\n    ans = max(ans, index - startOfLevel[level] + 1);\n    dfs(root->left, level + 1, index * 2, std::move(startOfLevel), ans);\n    dfs(root->right, level + 1, index * 2 + 1, std::move(startOfLevel), ans);\n  }\n};\n", "663": "class Solution {\n public:\n  bool checkEqualTree(TreeNode* root) {\n    if (root == nullptr)\n      return false;\n\n    unordered_set<int> seen;\n    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);\n    return sum % 2 == 0 && seen.contains(sum / 2);\n  }\n\n private:\n  int dfs(TreeNode* root, unordered_set<int>& seen) {\n    if (root == nullptr)\n      return 0;\n\n    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);\n    seen.insert(sum);\n    return sum;\n  }\n};\n", "664": "class Solution {\n public:\n  int strangePrinter(string s) {\n    if (s.empty())\n      return 0;\n\n    const int n = s.size();\n    // dp[i][j] := the minimum number of turns to print s[i..j]\n    vector<vector<int>> dp(n, vector<int>(n, n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int j = 0; j < n; ++j)\n      for (int i = j; i >= 0; --i)\n        for (int k = i; k < j; ++k)\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] - (s[k] == s[j]));\n\n    return dp[0][n - 1];\n  }\n};\n", "665": "class Solution {\n public:\n  bool checkPossibility(vector<int>& nums) {\n    bool modified = false;\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] < nums[i - 1]) {\n        if (modified)\n          return false;\n        if (i == 1 || nums[i] >= nums[i - 2])\n          nums[i - 1] = nums[i];  // Decrease the previous value.\n        else\n          nums[i] = nums[i - 1];  // Increase the current value.\n        modified = true;\n      }\n\n    return true;\n  }\n};\n", "666": "class Solution {\n public:\n  int pathSum(vector<int>& nums) {\n    int ans = 0;\n    vector<vector<int>> tree(4, vector<int>(8, -1));\n\n    for (const int num : nums) {\n      const int d = num / 100 - 1;\n      const int p = (num % 100) / 10 - 1;\n      const int v = num % 10;\n      tree[d][p] = v;\n    }\n\n    dfs(tree, 0, 0, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& tree, int i, int j, int path, int& ans) {\n    if (tree[i][j] == -1)\n      return;\n    if (i == 3 || max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1) {\n      ans += path + tree[i][j];\n      return;\n    }\n\n    dfs(tree, i + 1, j * 2, path + tree[i][j], ans);\n    dfs(tree, i + 1, j * 2 + 1, path + tree[i][j], ans);\n  }\n};\n", "667": "class Solution {\n public:\n  vector<int> constructArray(int n, int k) {\n    vector<int> ans;\n\n    for (int i = 0; i < n - k; ++i)\n      ans.push_back(i + 1);\n\n    for (int i = 0; i < k; ++i)\n      if (i % 2 == 0)\n        ans.push_back(n - i / 2);\n      else\n        ans.push_back(n - k + (i + 1) / 2);\n\n    return ans;\n  }\n};\n", "668": "class Solution {\n public:\n  int findKthNumber(int m, int n, int k) {\n    int l = 1;\n    int r = m * n;\n\n    auto numsNoGreaterThan = [&](int target) {\n      int count = 0;\n      // For each row i, count the number of numbers <= target.\n      for (int i = 1; i <= m; ++i)\n        count += min(target / i, n);\n      return count;\n    };\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      if (numsNoGreaterThan(mid) >= k)\n        r = mid;\n      else\n        l = mid + 1;\n    }\n\n    return l;\n  }\n};\n", "669": "class Solution {\n public:\n  TreeNode* trimBST(TreeNode* root, int L, int R) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val < L)\n      return trimBST(root->right, L, R);\n    if (root->val > R)\n      return trimBST(root->left, L, R);\n    root->left = trimBST(root->left, L, R);\n    root->right = trimBST(root->right, L, R);\n    return root;\n  }\n};\n", "67": "class Solution {\n public:\n  string addBinary(string a, string b) {\n    string ans;\n    int carry = 0;\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n      if (i >= 0)\n        carry += a[i--] - '0';\n      if (j >= 0)\n        carry += b[j--] - '0';\n      ans += carry % 2 + '0';\n      carry /= 2;\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "670": "class Solution {\n public:\n  int maximumSwap(int num) {\n    string s = to_string(num);\n    vector<int> lastIndex(10, -1);  // {digit: last index}\n\n    for (int i = 0; i < s.length(); ++i)\n      lastIndex[s[i] - '0'] = i;\n\n    for (int i = 0; i < s.length(); ++i)\n      for (int d = 9; d > s[i] - '0'; --d)\n        if (lastIndex[d] > i) {\n          swap(s[i], s[lastIndex[d]]);\n          return stoi(s);\n        }\n\n    return num;\n  }\n};\n", "671": "class Solution {\n public:\n  int findSecondMinimumValue(TreeNode* root) {\n    if (root == nullptr)\n      return -1;\n    return findSecondMinimumValue(root, root->val);\n  }\n\n private:\n  int findSecondMinimumValue(TreeNode* root, int mn) {\n    if (root == nullptr)\n      return -1;\n    if (root->val > mn)\n      return root->val;\n\n    const int leftMin = findSecondMinimumValue(root->left, mn);\n    const int rightMin = findSecondMinimumValue(root->right, mn);\n\n    if (leftMin == -1 || rightMin == -1)\n      return max(leftMin, rightMin);\n    return min(leftMin, rightMin);\n  }\n};\n", "672": "class Solution {\n public:\n  int flipLights(int n, int m) {\n    n = min(n, 3);\n\n    if (m == 0)\n      return 1;\n    if (m == 1)\n      return vector{2, 3, 4}[n - 1];\n    if (m == 2)\n      return vector{2, 4, 7}[n - 1];\n\n    return pow(2, n);\n  }\n};\n", "673": "class Solution {\n public:\n  int findNumberOfLIS(vector<int>& nums) {\n    const int n = nums.size();\n    int ans = 0;\n    int maxLength = 0;\n    // length[i] := the length of LIS's ending in nums[i]\n    vector<int> length(n, 1);\n    // count[i] := the number of LIS's ending in nums[i]\n    vector<int> count(n, 1);\n\n    // Calculate `length` and `count` arrays.\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < i; ++j)\n        if (nums[j] < nums[i])\n          if (length[i] < length[j] + 1) {\n            length[i] = length[j] + 1;\n            count[i] = count[j];\n          } else if (length[i] == length[j] + 1) {\n            count[i] += count[j];\n          }\n\n    // Get the number of LIS.\n    for (int i = 0; i < n; ++i)\n      if (length[i] > maxLength) {\n        maxLength = length[i];\n        ans = count[i];\n      } else if (length[i] == maxLength) {\n        ans += count[i];\n      }\n\n    return ans;\n  }\n};\n", "674": "class Solution {\n public:\n  int findLengthOfLCIS(vector<int>& nums) {\n    int ans = 0;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (r > 0 && nums[r] <= nums[r - 1])\n        l = r;\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "675": "struct T {\n  int i;\n  int j;\n  int height;\n};\n\nclass Solution {\n public:\n  int cutOffTree(vector<vector<int>>& forest) {\n    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };\n    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);\n\n    for (int i = 0; i < forest.size(); ++i)\n      for (int j = 0; j < forest[0].size(); ++j)\n        if (forest[i][j] > 1)\n          minHeap.emplace(i, j, forest[i][j]);\n\n    int ans = 0;\n    int x = 0;\n    int y = 0;\n\n    while (!minHeap.empty()) {\n      const auto [i, j, _] = minHeap.top();\n      minHeap.pop();\n      // Walk from (x, y) to (i, j).\n      const int step = bfs(forest, x, y, i, j);\n      if (step < 0)\n        return -1;\n      ans += step;\n      x = i;\n      y = j;\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {\n    const int m = forest.size();\n    const int n = forest[0].size();\n    queue<pair<int, int>> q{{{si, sj}}};\n    vector<vector<bool>> seen(m, vector<bool>(n));\n    seen[si][sj] = true;\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        if (i == ei && j == ej)\n          return step;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (seen[x][y] || forest[x][y] == 0)\n            continue;\n          q.emplace(x, y);\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  };\n};\n", "676": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass MagicDictionary {\n public:\n  void buildDict(vector<string> dictionary) {\n    for (const string& word : dictionary)\n      insert(word);\n  }\n\n  bool search(string searchWord) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = 0; i < searchWord.length(); ++i) {\n      const int index = searchWord[i] - 'a';\n      for (int j = 0; j < 26; ++j) {\n        if (j == index)\n          continue;\n        shared_ptr<TrieNode> child = node->children[j];\n        if (child == nullptr)\n          continue;\n        // Replace the searchWord[i] with ('a' + j), then check if\n        // searchWord[i + 1..n) matches `child`.\n        if (find(child, searchWord, i + 1))\n          return true;\n      }\n      if (node->children[index] == nullptr)\n        return false;\n      node = node->children[index];\n    }\n    return false;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  bool find(shared_ptr<TrieNode> node, const string& word, int s) {\n    for (int i = s; i < word.length(); ++i) {\n      const int index = word[i] - 'a';\n      if (node->children[index] == nullptr)\n        return false;\n      node = node->children[index];\n    }\n    return node->isWord;\n  }\n};\n", "677": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int sum = 0;\n  TrieNode() : children(26) {}\n};\n\nclass MapSum {\n public:\n  void insert(string key, int val) {\n    const int diff = val - keyToVal[key];\n    shared_ptr<TrieNode> node = root;\n    for (const char c : key) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      node->sum += diff;\n    }\n    keyToVal[key] = val;\n  }\n\n  int sum(string prefix) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : prefix) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return 0;\n      node = node->children[i];\n    }\n    return node->sum;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n  unordered_map<string, int> keyToVal;\n};\n", "678": "class Solution {\n public:\n  bool checkValidString(const string& s) {\n    int low = 0;   // the lower bound of the number of valid '('s\n    int high = 0;  // the upper bound of the number of valid '('s\n\n    for (const char c : s) {\n      switch (c) {\n        case '(':\n          ++low;\n          ++high;\n          break;\n        case ')':\n          low = max(0, --low);\n          --high;\n          break;\n        case '*':\n          low = max(0, --low);\n          ++high;\n          break;\n      }\n      if (high < 0)\n        return false;\n    }\n\n    return low == 0;\n  }\n};\n", "679": "class Solution {\n public:\n  bool judgePoint24(vector<int>& nums) {\n    vector<double> doubleNums;\n\n    for (const int num : nums)\n      doubleNums.push_back(num);\n\n    return dfs(doubleNums);\n  }\n\n private:\n  bool dfs(vector<double>& nums) {\n    if (nums.size() == 1)\n      return abs(nums[0] - 24) < 0.001;\n\n    for (int i = 0; i < nums.size(); ++i)\n      for (int j = 0; j < i; ++j) {\n        for (const double num : generate(nums[i], nums[j])) {\n          vector<double> nextRound{num};\n          for (int k = 0; k < nums.size(); ++k) {\n            if (k == i || k == j)  // It is used in `generate()`.\n              continue;\n            nextRound.push_back(nums[k]);\n          }\n          if (dfs(nextRound))\n            return true;\n        }\n      }\n\n    return false;\n  }\n\n  vector<double> generate(double a, double b) {\n    return {a * b, a / b, b / a, a + b, a - b, b - a};\n  }\n};\n", "68": "class Solution {\n public:\n  vector<string> fullJustify(vector<string>& words, size_t maxWidth) {\n    vector<string> ans;\n    vector<string> row;\n    size_t rowLetters = 0;\n\n    for (const string& word : words) {\n      // If we place the word in this row, it will exceed the maximum width.\n      // Therefore, we cannot put the word in this row and have to pad spaces\n      // for each word in this row.\n      if (rowLetters + row.size() + word.length() > maxWidth) {\n        const int spaces = maxWidth - rowLetters;\n        if (row.size() == 1) {\n          // Pad all the spaces after row[0].\n          for (int i = 0; i < spaces; ++i)\n            row[0] += \" \";\n        } else {\n          // Evenly pad all the spaces to each word (expect the last one) in\n          // this row.\n          for (int i = 0; i < spaces; ++i)\n            row[i % (row.size() - 1)] += \" \";\n        }\n        ans.push_back(join(row, \"\"));\n        row.clear();\n        rowLetters = 0;\n      }\n      row.push_back(word);\n      rowLetters += word.length();\n    }\n    ans.push_back(ljust(join(row, \" \"), maxWidth));\n\n    return ans;\n  }\n\n private:\n  string join(const vector<string>& words, const string& s) {\n    string joined;\n    for (int i = 0; i < words.size(); ++i) {\n      joined += words[i];\n      if (i != words.size() - 1)\n        joined += s;\n    }\n    return joined;\n  }\n\n  string ljust(string s, int width) {\n    for (int i = 0; i < s.length() - width; ++i)\n      s += \" \";\n    return s;\n  }\n};\n", "680": "class Solution {\n public:\n  bool validPalindrome(string s) {\n    for (int l = 0, r = s.length() - 1; l < r; ++l, --r)\n      if (s[l] != s[r])\n        return validPalindrome(s, l + 1, r) ||  //\n               validPalindrome(s, l, r - 1);\n    return true;\n  }\n\n private:\n  bool validPalindrome(const string& s, int l, int r) {\n    while (l < r)\n      if (s[l++] != s[r--])\n        return false;\n    return true;\n  }\n};\n", "681": "class Solution {\n public:\n  string nextClosestTime(string time) {\n    const set<char> digitsSet{time[0], time[1], time[3], time[4]};\n    string ans = time;\n\n    ans[4] = nextClosest(digitsSet, ans[4], '9');\n    if (time[4] < ans[4])\n      return ans;\n\n    ans[3] = nextClosest(digitsSet, ans[3], '5');\n    if (time[3] < ans[3])\n      return ans;\n\n    ans[1] = nextClosest(digitsSet, ans[1], ans[0] == '2' ? '3' : '9');\n    if (time[1] < ans[1])\n      return ans;\n\n    ans[0] = nextClosest(digitsSet, ans[0], '2');\n    return ans;\n  }\n\n private:\n  char nextClosest(const set<char>& digitsSet, char digit, char limit) {\n    auto it = digitsSet.upper_bound(digit);\n    return it == digitsSet.end() || *it > limit ? *digitsSet.begin() : *it;\n  }\n};\n", "682": "class Solution {\n public:\n  int calPoints(vector<string>& operations) {\n    vector<int> scores;\n\n    for (const string& operation : operations)\n      if (operation == \"+\")\n        scores.push_back(scores.back() + scores[scores.size() - 2]);\n      else if (operation == \"D\")\n        scores.push_back(scores.back() * 2);\n      else if (operation == \"C\")\n        scores.pop_back();\n      else\n        scores.push_back(stoi(operation));\n\n    return accumulate(scores.begin(), scores.end(), 0);\n  }\n};\n", "683": "class Solution {\n public:\n  int kEmptySlots(vector<int>& bulbs, int k) {\n    const int n = bulbs.size();\n    int ans = INT_MAX;\n    // day[i] := the day when bulbs[i] is turned on\n    vector<int> day(n);\n\n    for (int i = 0; i < n; ++i)\n      day[bulbs[i] - 1] = i + 1;\n\n    // Find a subarray of day[l..r], where its length is k + 2.\n    // For each l < i < r, day[i] > max(day[l], day[r]).\n    int l = 0;\n    int r = l + k + 1;\n    for (int i = 1; r < n; ++i)\n      if (i == r) {\n        ans = min(ans, max(day[l], day[r]));\n        l = i;\n        r = i + k + 1;\n      } else if (day[i] < max(day[l], day[r])) {\n        l = i;\n        r = i + k + 1;\n      }\n\n    return ans == INT_MAX ? -1 : ans;\n  }\n};\n", "684": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  bool unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return false;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    return true;\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    UnionFind uf(edges.size() + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      if (!uf.unionByRank(u, v))\n        return edge;\n    }\n\n    throw;\n  }\n};\n", "685": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  bool unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return false;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    return true;\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n    vector<int> ids(edges.size() + 1);\n    int nodeWithTwoParents = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int v = edge[1];\n      if (++ids[v] == 2) {\n        nodeWithTwoParents = v;\n        break;\n      }\n    }\n\n    // If there is no edge with two ids, don't skip any edge.\n    if (nodeWithTwoParents == 0)\n      return findRedundantDirectedConnection(edges, -1);\n\n    for (int i = edges.size() - 1; i >= 0; --i)\n      if (edges[i][1] == nodeWithTwoParents)\n        // Try to delete the edges[i].\n        if (findRedundantDirectedConnection(edges, i).empty())\n          return edges[i];\n\n    throw;\n  }\n\n  vector<int> findRedundantDirectedConnection(const vector<vector<int>>& edges,\n                                              int skippedEdgeIndex) {\n    UnionFind uf(edges.size() + 1);\n\n    for (int i = 0; i < edges.size(); ++i) {\n      if (i == skippedEdgeIndex)\n        continue;\n      if (!uf.unionByRank(edges[i][0], edges[i][1]))\n        return edges[i];\n    }\n\n    return {};\n  }\n};\n", "686": "class Solution {\n public:\n  int repeatedStringMatch(string a, string b) {\n    const int n = ceil((double)b.length() / a.length());\n    string s;\n\n    for (int i = 0; i < n; ++i)\n      s += a;\n\n    if (s.find(b) != string::npos)\n      return n;\n    if ((s + a).find(b) != string::npos)\n      return n + 1;\n    return -1;\n  }\n};\n", "687": "class Solution {\n public:\n  int longestUnivaluePath(TreeNode* root) {\n    int ans = 0;\n    longestUnivaluePathDownFrom(root, ans);\n    return ans;\n  }\n\n private:\n  int longestUnivaluePathDownFrom(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = longestUnivaluePathDownFrom(root->left, ans);\n    const int r = longestUnivaluePathDownFrom(root->right, ans);\n    const int arrowLeft =\n        root->left && root->left->val == root->val ? l + 1 : 0;\n    const int arrowRight =\n        root->right && root->right->val == root->val ? r + 1 : 0;\n    ans = max(ans, arrowLeft + arrowRight);\n    return max(arrowLeft, arrowRight);\n  }\n};\n", "688": "class Solution {\n public:\n  double knightProbability(int n, int k, int row, int column) {\n    constexpr int kDirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},\n                                 {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\n    constexpr double kProb = 0.125;\n    // dp[i][j] := the probability to stand on (i, j)\n    vector<vector<double>> dp(n, vector<double>(n));\n    dp[row][column] = 1.0;\n\n    for (int move = 0; move < k; ++move) {\n      vector<vector<double>> newDp(n, vector<double>(n));\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n          if (dp[i][j] > 0.0) {\n            for (const auto& [dx, dy] : kDirs) {\n              const int x = i + dx;\n              const int y = j + dy;\n              if (x < 0 || x >= n || y < 0 || y >= n)\n                continue;\n              newDp[x][y] += dp[i][j] * kProb;\n            }\n          }\n      dp = std::move(newDp);\n    }\n\n    return accumulate(dp.begin(), dp.end(), 0.0,\n                      [](double acc, const vector<double>& row) {\n      return acc + accumulate(row.begin(), row.end(), 0.0);\n    });\n  }\n};\n", "689": "class Solution {\n public:\n  vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {\n    const int n = nums.size() - k + 1;\n    // sums[i] := sum(nums[i..i + k))\n    vector<int> sums(n);\n    // l[i] := the index in [0..i] that has the maximum sums[i]\n    vector<int> l(n);\n    // r[i] := the index in [i..n) that has the maximum sums[i]\n    vector<int> r(n);\n\n    int sum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      sum += nums[i];\n      if (i >= k)\n        sum -= nums[i - k];\n      if (i >= k - 1)\n        sums[i - k + 1] = sum;\n    }\n\n    int maxIndex = 0;\n    for (int i = 0; i < n; ++i) {\n      if (sums[i] > sums[maxIndex])\n        maxIndex = i;\n      l[i] = maxIndex;\n    }\n\n    maxIndex = n - 1;\n    for (int i = n - 1; i >= 0; --i) {\n      if (sums[i] >= sums[maxIndex])\n        maxIndex = i;\n      r[i] = maxIndex;\n    }\n\n    vector<int> ans{-1, -1, -1};\n\n    for (int i = k; i < n - k; ++i)\n      if (ans[0] == -1 || sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <\n                              sums[l[i - k]] + sums[i] + sums[r[i + k]]) {\n        ans[0] = l[i - k];\n        ans[1] = i;\n        ans[2] = r[i + k];\n      }\n\n    return ans;\n  }\n};\n", "69": "class Solution {\n public:\n  int mySqrt(int x) {\n    unsigned l = 1;\n    unsigned r = x + 1u;\n\n    while (l < r) {\n      const unsigned m = (l + r) / 2;\n      if (m > x / m)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    // l := the minimum number s.t. l * l > x\n    return l - 1;\n  }\n};\n", "690": "class Solution {\n public:\n  int getImportance(vector<Employee*> employees, int id) {\n    unordered_map<int, Employee*> idToEmployee;\n\n    for (Employee* employee : employees)\n      idToEmployee[employee->id] = employee;\n\n    return dfs(id, idToEmployee);\n  }\n\n private:\n  int dfs(int id, const unordered_map<int, Employee*>& idToEmployee) {\n    int values = 0;\n\n    for (const int subId : idToEmployee.at(id)->subordinates)\n      values += dfs(subId, idToEmployee);\n\n    return idToEmployee.at(id)->importance + values;\n  }\n};\n", "691": "class Solution {\n public:\n  int minStickers(vector<string>& stickers, string target) {\n    const int n = target.size();\n    const int maxMask = 1 << n;\n    // dp[i] := the minimum number of stickers to spell out i, where i is the\n    // bit mask of target\n    vector<int> dp(maxMask, INT_MAX);\n    dp[0] = 0;\n\n    for (int mask = 0; mask < maxMask; ++mask) {\n      if (dp[mask] == INT_MAX)\n        continue;\n      // Try to expand from `mask` by using each sticker.\n      for (const string& sticker : stickers) {\n        int superMask = mask;\n        for (const char c : sticker)\n          for (int i = 0; i < n; ++i)\n            // Try to apply it on a missing letter.\n            if (c == target[i] && (superMask >> i & 1) == 0) {\n              superMask |= 1 << i;\n              break;\n            }\n        dp[superMask] = min(dp[superMask], dp[mask] + 1);\n      }\n    }\n\n    return dp.back() == INT_MAX ? -1 : dp.back();\n  }\n};\n", "692": "struct T {\n  string word;\n  int freq;\n};\n\nclass Solution {\n public:\n  vector<string> topKFrequent(vector<string>& words, int k) {\n    vector<string> ans;\n    unordered_map<string, int> count;\n    // Words with higher frequency and lower alphabetical order are in the\n    // bottom of the heap because we'll pop words with lower frequency and\n    // higher alphabetical order if the heap's size > k.\n    auto compare = [](const T& a, const T& b) {\n      return a.freq == b.freq ? a.word < b.word : a.freq > b.freq;\n    };\n    priority_queue<T, vector<T>, decltype(compare)> heap(compare);\n\n    for (const string& word : words)\n      ++count[word];\n\n    for (const auto& [word, freq] : count) {\n      heap.emplace(word, freq);\n      if (heap.size() > k)\n        heap.pop();\n    }\n\n    while (!heap.empty())\n      ans.push_back(heap.top().word), heap.pop();\n\n    ranges::reverse(ans);\n    return ans;\n  }\n};\n", "693": "class Solution {\n public:\n  bool hasAlternatingBits(int n) {\n    //            n = 0b010101\n    //       n >> 2 = 0b000101\n    // n ^ (n >> 2) = 0b010000 = a\n    //        a - 1 = 0b001111\n    //  a & (a - 1) = 0\n    const int a = n ^ (n >> 2);\n    return (a & (a - 1)) == 0;\n  }\n};\n", "694": "class Solution {\n public:\n  int numDistinctIslands(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    set<vector<pair<int, int>>> islands;  // all the different islands\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        vector<pair<int, int>> island;\n        dfs(grid, i, j, i, j, seen, island);\n        if (!island.empty())\n          islands.insert(island);\n      }\n\n    return islands.size();\n  }\n\n private:\n  void dfs(const vector<vector<int>>& grid, int i, int j, int i0, int j0,\n           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] == 0 || seen[i][j])\n      return;\n\n    seen[i][j] = true;\n    island.emplace_back(i - i0, j - j0);\n\n    dfs(grid, i + 1, j, i0, j0, seen, island);\n    dfs(grid, i - 1, j, i0, j0, seen, island);\n    dfs(grid, i, j + 1, i0, j0, seen, island);\n    dfs(grid, i, j - 1, i0, j0, seen, island);\n  }\n};\n", "695": "class Solution {\n public:\n  int maxAreaOfIsland(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        ans = max(ans, dfs(grid, i, j));\n\n    return ans;\n  }\n\n private:\n  int dfs(vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return 0;\n    if (grid[i][j] != 1)\n      return 0;\n\n    grid[i][j] = 2;\n\n    return 1 +                                          //\n           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //\n           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);\n  }\n};\n", "696": "class Solution {\n public:\n  int countBinarySubstrings(string s) {\n    int ans = 0;\n    int prevEquals = 0;\n    int currEquals = 1;\n\n    for (int i = 0; i + 1 < s.length(); ++i)\n      if (s[i] == s[i + 1])\n        ++currEquals;\n      else {\n        ans += min(prevEquals, currEquals);\n        prevEquals = currEquals;\n        currEquals = 1;\n      }\n\n    return ans + min(prevEquals, currEquals);\n  }\n};\n", "697": "class Solution {\n public:\n  int findShortestSubArray(vector<int>& nums) {\n    int ans = 0;\n    int degree = 0;\n    unordered_map<int, int> debut;\n    unordered_map<int, int> count;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      const int num = nums[i];\n      if (!debut.contains(num))\n        debut[num] = i;\n      if (++count[num] > degree) {\n        degree = count[num];\n        ans = i - debut[num] + 1;\n      } else if (count[num] == degree) {\n        ans = min(ans, i - debut[num] + 1);\n      }\n    }\n\n    return ans;\n  }\n};\n", "698": "class Solution {\n public:\n  bool canPartitionKSubsets(vector<int>& nums, int k) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (sum % k != 0)\n      return false;\n\n    const int target = sum / k;  // the target sum of each subset\n    if (ranges::any_of(nums, [target](const int num) { return num > target; }))\n      return false;\n\n    ranges::sort(nums, greater<>());\n    return dfs(nums, 0, k, /*currSum=*/0, target, /*used=*/0);\n  }\n\n private:\n  bool dfs(const vector<int>& nums, int s, int remainingGroups, int currSum,\n           const int subsetTargetSum, int used) {\n    if (remainingGroups == 0)\n      return true;\n    if (currSum > subsetTargetSum)\n      return false;\n    if (currSum == subsetTargetSum)  // Find a valid group, so fresh start.\n      return dfs(nums, 0, remainingGroups - 1, 0, subsetTargetSum, used);\n\n    for (int i = s; i < nums.size(); ++i) {\n      if (used >> i & 1)\n        continue;\n      if (dfs(nums, i + 1, remainingGroups, currSum + nums[i], subsetTargetSum,\n              used | 1 << i))\n        return true;\n    }\n\n    return false;\n  }\n};\n", "699": "class Solution {\n public:\n  vector<int> fallingSquares(vector<vector<int>>& positions) {\n    vector<int> ans;\n    map<pair<int, int>, int> xsToHeight;  // {(xStart, xEnd), height}\n    int maxHeight = INT_MIN;\n\n    for (const vector<int>& p : positions) {\n      const int left = p[0];\n      const int sideLength = p[1];\n      const int right = left + sideLength;\n      // Find the first range that intersects with [left, right).\n      auto it = xsToHeight.upper_bound({left, right});\n      if (it != xsToHeight.begin() && (--it)->first.second <= left)\n        ++it;\n      int maxHeightInRange = 0;\n      vector<tuple<int, int, int>> ranges;\n      while (it != xsToHeight.end() && it->first.first < right) {\n        const int l = it->first.first;\n        const int r = it->first.second;\n        const int h = it->second;\n        if (l < left)\n          ranges.emplace_back(l, left, h);\n        if (right < r)\n          ranges.emplace_back(right, r, h);\n        maxHeightInRange = max(maxHeightInRange, h);\n        it = xsToHeight.erase(it);\n      }\n      const int newHeight = maxHeightInRange + sideLength;\n      xsToHeight[{left, right}] = newHeight;\n      for (const auto& [l, r, h] : ranges)\n        xsToHeight[{l, r}] = h;\n      maxHeight = max(maxHeight, newHeight);\n      ans.push_back(maxHeight);\n    }\n\n    return ans;\n  }\n};\n", "7": "class Solution {\n public:\n  int reverse(int x) {\n    long ans = 0;\n\n    while (x != 0) {\n      ans = ans * 10 + x % 10;\n      x /= 10;\n    }\n\n    return (ans < INT_MIN || ans > INT_MAX) ? 0 : ans;\n  }\n};\n", "70": "class Solution {\n public:\n  int climbStairs(int n) {\n    int prev1 = 1;  // dp[i - 1]\n    int prev2 = 1;  // dp[i - 2]\n\n    for (int i = 2; i <= n; ++i) {\n      const int dp = prev1 + prev2;\n      prev2 = prev1;\n      prev1 = dp;\n    }\n\n    return prev1;\n  }\n};\n", "700": "class Solution {\n public:\n  TreeNode* searchBST(TreeNode* root, int val) {\n    if (root == nullptr)\n      return nullptr;\n    if (root->val == val)\n      return root;\n    if (root->val > val)\n      return searchBST(root->left, val);\n    return searchBST(root->right, val);\n  }\n};\n", "701": "class Solution {\n public:\n  TreeNode* insertIntoBST(TreeNode* root, int val) {\n    if (root == nullptr)\n      return new TreeNode(val);\n    if (root->val > val)\n      root->left = insertIntoBST(root->left, val);\n    else\n      root->right = insertIntoBST(root->right, val);\n    return root;\n  }\n};\n", "702": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *  public:\n *   int get(int index);\n * };\n */\n\nclass Solution {\n public:\n  int search(const ArrayReader& reader, int target) {\n    int l = 0;\n    int r = 10'000;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (reader.get(m) >= target)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return reader.get(l) == target ? l : -1;\n  }\n};\n", "703": "class KthLargest {\n public:\n  KthLargest(int k, vector<int>& nums) : k(k) {\n    for (const int num : nums)\n      heapify(num);\n  }\n\n  int add(int val) {\n    heapify(val);\n    return minHeap.top();\n  }\n\n private:\n  const int k;\n  priority_queue<int, vector<int>, greater<>> minHeap;\n\n  void heapify(int val) {\n    minHeap.push(val);\n    if (minHeap.size() > k)\n      minHeap.pop();\n  }\n};\n", "704": "class Solution {\n public:\n  int search(vector<int>& nums, int target) {\n    const auto it = ranges::lower_bound(nums, target);\n    return (it == nums.cend() || *it != target) ? -1\n                                                : distance(nums.begin(), it);\n  }\n};\n", "705": "class MyHashSet {\n public:\n  /** Initialize your data structure here. */\n  MyHashSet() : set(1000001) {}\n\n  void add(int key) {\n    set[key] = true;\n  }\n\n  void remove(int key) {\n    set[key] = false;\n  }\n\n  /** Returns true if this set contains the specified element */\n  bool contains(int key) {\n    return set[key];\n  }\n\n private:\n  vector<bool> set;\n};\n", "706": "class MyHashMap {\n public:\n  MyHashMap() : lists(kSize) {}\n\n  void put(int key, int value) {\n    auto& pairs = lists[key % kSize];\n    for (auto& [k, v] : pairs)\n      if (k == key) {\n        v = value;\n        return;\n      }\n    pairs.emplace_back(key, value);\n  }\n\n  int get(int key) {\n    const list<pair<int, int>>& pairs = lists[key % kSize];\n    for (const auto& [k, v] : pairs)\n      if (k == key)\n        return v;\n    return -1;\n  }\n\n  void remove(int key) {\n    auto& pairs = lists[key % kSize];\n    for (auto it = pairs.begin(); it != pairs.end(); ++it)\n      if (it->first == key) {\n        pairs.erase(it);\n        return;\n      }\n  }\n\n private:\n  static constexpr int kSize = 10000;\n  // Each slot stores the (key, value) list.\n  vector<list<pair<int, int>>> lists;\n};\n", "707": "class MyLinkedList {\n  struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n  };\n\n public:\n  int get(int index) {\n    if (index < 0 || index >= length)\n      return -1;\n    ListNode* curr = dummy.next;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    return curr->val;\n  }\n\n  void addAtHead(int val) {\n    ListNode* head = dummy.next;\n    ListNode* node = new ListNode(val);\n    node->next = head;\n    dummy.next = node;\n    ++length;\n  }\n\n  void addAtTail(int val) {\n    ListNode* curr = &dummy;\n    while (curr->next != nullptr)\n      curr = curr->next;\n    curr->next = new ListNode(val);\n    ++length;\n  }\n\n  void addAtIndex(int index, int val) {\n    if (index > length)\n      return;\n    ListNode* curr = &dummy;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    ListNode* cache = curr->next;\n    ListNode* node = new ListNode(val);\n    node->next = cache;\n    curr->next = node;\n    ++length;\n  }\n\n  void deleteAtIndex(int index) {\n    if (index < 0 || index >= length)\n      return;\n    ListNode* curr = &dummy;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    ListNode* cache = curr->next;\n    curr->next = cache->next;\n    --length;\n    delete cache;\n  }\n\n private:\n  int length = 0;\n  ListNode dummy = ListNode(0);\n};\n", "708": "class Solution {\n public:\n  Node* insert(Node* head, int insertVal) {\n    if (head == nullptr) {\n      Node* newNode = new Node(insertVal);\n      newNode->next = newNode;\n      return newNode;\n    }\n\n    Node* prev = head;\n    Node* curr = head->next;\n\n    while (curr != head) {\n      // 1. the minimum <= insertVal <= the maximum\n      // 2. insertVal >= the maximum or insertVal <= the minimum\n      if ((prev->val <= insertVal && insertVal <= curr->val) ||\n          // `prev` is the maximum and `curr` is the minimum\n          (prev->val > curr->val &&\n           (insertVal >= prev->val || insertVal <= curr->val))) {\n        // Insert the node between `prev` and `curr`.\n        prev->next = new Node(insertVal, curr);\n        return head;\n      }\n      prev = prev->next;\n      curr = curr->next;\n    }\n\n    // All the values in the list are identical.\n    prev->next = new Node(insertVal, curr);\n    return head;\n  }\n};\n", "709": "class Solution {\n public:\n  string toLowerCase(string str) {\n    const int diff = 'A' - 'a';\n\n    for (char& c : str)\n      if (c >= 'A' && c <= 'Z')\n        c -= diff;\n\n    return str;\n  }\n};\n", "71": "class Solution {\n public:\n  string simplifyPath(string path) {\n    string ans;\n    istringstream iss(path);\n    vector<string> stack;\n\n    for (string dir; getline(iss, dir, '/');) {\n      if (dir.empty() || dir == \".\")\n        continue;\n      if (dir == \"..\") {\n        if (!stack.empty())\n          stack.pop_back();\n      } else {\n        stack.push_back(dir);\n      }\n    }\n\n    for (const string& s : stack)\n      ans += \"/\" + s;\n\n    return ans.empty() ? \"/\" : ans;\n  }\n};\n", "710": "class Solution {\n public:\n  Solution(int n, vector<int>& blacklist) : validRange(n - blacklist.size()) {\n    for (const int b : blacklist)\n      map[b] = -1;\n\n    int maxAvailable = n - 1;\n\n    for (const int b : blacklist)\n      if (b < validRange) {\n        // Find the slot that haven't been used.\n        while (map.contains(maxAvailable))\n          --maxAvailable;\n        map[b] = maxAvailable--;\n      }\n  }\n\n  int pick() {\n    const int num = rand() % validRange;\n    const auto it = map.find(num);\n    return it == map.cend() ? num : it->second;\n  }\n\n private:\n  const int validRange;\n  unordered_map<int, int> map;\n};\n", "711": "class Solution {\n public:\n  int numDistinctIslands2(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // all the islands with different shapes\n    set<vector<pair<int, int>>> islands;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        vector<pair<int, int>> island;\n        dfs(grid, i, j, seen, island);\n        if (!island.empty())\n          islands.insert(normalize(island));\n      }\n\n    return islands.size();\n  }\n\n private:\n  void dfs(const vector<vector<int>>& grid, int i, int j,\n           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] == 0 || seen[i][j])\n      return;\n\n    seen[i][j] = true;\n    island.emplace_back(i, j);\n\n    dfs(grid, i + 1, j, seen, island);\n    dfs(grid, i - 1, j, seen, island);\n    dfs(grid, i, j + 1, seen, island);\n    dfs(grid, i, j - 1, seen, island);\n  }\n\n  vector<pair<int, int>> normalize(const vector<pair<int, int>>& island) {\n    // points[i] := 8 different rotations/reflections of an island\n    vector<vector<pair<int, int>>> points(8);\n\n    for (const auto& [i, j] : island) {\n      points[0].emplace_back(i, j);\n      points[1].emplace_back(i, -j);\n      points[2].emplace_back(-i, j);\n      points[3].emplace_back(-i, -j);\n      points[4].emplace_back(j, i);\n      points[5].emplace_back(j, -i);\n      points[6].emplace_back(-j, i);\n      points[7].emplace_back(-j, -i);\n    }\n\n    for (vector<pair<int, int>>& p : points)\n      ranges::sort(p);\n\n    // Normalize each p by substracting p[1..7] with p[0].\n    for (vector<pair<int, int>>& p : points) {\n      for (int i = 1; i < island.size(); ++i)\n        p[i] = {p[i].first - p[0].first, p[i].second - p[0].second};\n      p[0] = {0, 0};\n    }\n\n    ranges::sort(points);\n    return points[0];\n  }\n};\n", "712": "class Solution {\n public:\n  int minimumDeleteSum(string s1, string s2) {\n    const int m = s1.length();\n    const int n = s2.length();\n    // dp[i][j] := the minimum cost to make s1[0..i) and s2[0..j) equal\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    // Delete s1[i - 1].\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = dp[i - 1][0] + s1[i - 1];\n\n    // Delete s2[j - 1].\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = dp[0][j - 1] + s2[j - 1];\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s1[i - 1] == s2[j - 1])\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n\n    return dp[m][n];\n  }\n};\n", "713": "class Solution {\n public:\n  int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n    if (k <= 1)\n      return 0;\n\n    int ans = 0;\n    int prod = 1;\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      prod *= nums[r];\n      while (prod >= k)\n        prod /= nums[l++];\n      ans += r - l + 1;\n    }\n\n    return ans;\n  }\n};\n", "714": "class Solution {\n public:\n  int maxProfit(vector<int>& prices, int fee) {\n    int sell = 0;\n    int hold = INT_MIN;\n\n    for (const int price : prices) {\n      sell = max(sell, hold + price);\n      hold = max(hold, sell - price - fee);\n    }\n\n    return sell;\n  }\n};\n", "715": "class RangeModule {\n public:\n  void addRange(int left, int right) {\n    const auto [l, r] = getOverlapRanges(left, right);\n    if (l == r) {            // There's no overlap.\n      ranges[left] = right;  // Add a new range.\n      return;\n    }\n\n    auto last = r;\n    const int newLeft = min(l->first, left);\n    const int newRight = max((--last)->second, right);\n    ranges.erase(l, r);\n    ranges[newLeft] = newRight;  // Add a new range.\n  }\n\n  bool queryRange(int left, int right) {\n    auto it = ranges.upper_bound(left);\n    return it != ranges.begin() && (--it)->second >= right;\n  }\n\n  void removeRange(int left, int right) {\n    const auto [l, r] = getOverlapRanges(left, right);\n    if (l == r)  // There's no overlap.\n      return;\n\n    auto last = r;\n    const int newLeft = min(l->first, left);\n    const int newRight = max((--last)->second, right);\n    ranges.erase(l, r);\n    // Add new ranges if needed.\n    if (newLeft < left)\n      ranges[newLeft] = left;\n    if (right < newRight)\n      ranges[right] = newRight;\n  }\n\n private:\n  using IT = map<int, int>::iterator;\n  map<int, int> ranges;\n\n  pair<IT, IT> getOverlapRanges(int left, int right) {\n    // Point to the first element with `second` >= `left`.\n    IT l = ranges.upper_bound(left);\n    // Point to the first element with `first` > `right`.\n    IT r = ranges.upper_bound(right);\n    if (l != ranges.begin() && (--l)->second < left)\n      ++l;\n    return {l, r};\n  }\n};\n", "716": "class MaxStack {\n public:\n  void push(int x) {\n    list.push_front(x);\n    keyToIterators[x].push_back(list.begin());\n  }\n\n  int pop() {\n    const int x = list.front();\n    list.pop_front();\n    auto& iterators = keyToIterators[x];\n    iterators.pop_back();\n    if (iterators.empty())\n      keyToIterators.erase(x);\n    return x;\n  }\n\n  int top() {\n    return list.front();\n  }\n\n  int peekMax() {\n    return keyToIterators.begin()->first;\n  }\n\n  int popMax() {\n    const int x = peekMax();\n    auto& iterators = keyToIterators.begin()->second;\n    auto it = iterators.back();\n    list.erase(it);\n    iterators.pop_back();\n    if (iterators.empty())\n      keyToIterators.erase(keyToIterators.begin());\n    return x;\n  }\n\n private:\n  std::list<int> list;\n  map<int, vector<std::list<int>::iterator>, greater<>> keyToIterators;\n};\n", "717": "class Solution {\n public:\n  bool isOneBitCharacter(vector<int>& bits) {\n    const int n = bits.size();\n\n    int i = 0;\n    while (i < n - 1)\n      if (bits[i] == 0)\n        i += 1;\n      else\n        i += 2;\n\n    return i == n - 1;\n  }\n};\n", "718": "class Solution {\n public:\n  int findLength(vector<int>& nums1, vector<int>& nums2) {\n    const int m = nums1.size();\n    const int n = nums2.size();\n    int ans = 0;\n    vector<int> dp(n + 1);\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = 0; j < n; ++j) {  // The order is important.\n        dp[j] = nums1[i] == nums2[j] ? dp[j + 1] + 1 : 0;\n        ans = max(ans, dp[j]);\n      }\n\n    return ans;\n  }\n};\n", "719": "class Solution {\n public:\n  int smallestDistancePair(vector<int>& nums, int k) {\n    ranges::sort(nums);\n\n    int l = 0;\n    int r = nums.back() - nums.front();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (numPairDistancesNoGreaterThan(nums, m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  int numPairDistancesNoGreaterThan(const vector<int>& nums, int m) {\n    int count = 0;\n    int j = 1;\n    // For each index i, find the first index j s.t. nums[j] > nums[i] + m,\n    // so numPairDistancesNoGreaterThan for the index i will be j - i - 1.\n    for (int i = 0; i < nums.size(); ++i) {\n      while (j < nums.size() && nums[j] <= nums[i] + m)\n        ++j;\n      count += j - i - 1;\n    }\n    return count;\n  }\n};\n", "72": "class Solution {\n public:\n  int minDistance(string word1, string word2) {\n    const int m = word1.length();\n    const int n = word2.length();\n    // dp[i][j] := the minimum number of operations to convert word1[0..i) to\n    // word2[0..j)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i)\n      dp[i][0] = i;\n\n    for (int j = 1; j <= n; ++j)\n      dp[0][j] = j;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (word1[i - 1] == word2[j - 1])\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n\n    return dp[m][n];\n  }\n};\n", "720": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  const string* word = nullptr;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  string longestWord(vector<string>& words) {\n    for (const string& word : words)\n      insert(word);\n    return longestWordFrom(root);\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->word = &word;\n  }\n\n  string longestWordFrom(shared_ptr<TrieNode> node) {\n    string ans = node->word ? *node->word : \"\";\n\n    for (shared_ptr<TrieNode> child : node->children)\n      if (child && child->word) {\n        string childWord = longestWordFrom(child);\n        if (childWord.length() > ans.length())\n          ans = childWord;\n      }\n\n    return ans;\n  }\n};\n", "721": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), sz(n, 1) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionBySize(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (sz[i] < sz[j]) {\n      sz[j] += sz[i];\n      id[i] = j;\n    } else {\n      sz[i] += sz[j];\n      id[j] = i;\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> sz;\n};\n\nclass Solution {\n public:\n  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n    vector<vector<string>> ans;\n    unordered_map<string, int> emailToIndex;        // {email: index}\n    unordered_map<int, set<string>> indexToEmails;  // {index: {emails}}\n    UnionFind uf(accounts.size());\n\n    for (int i = 0; i < accounts.size(); ++i) {\n      const string name = accounts[i][0];\n      for (int j = 1; j < accounts[i].size(); ++j) {\n        const string email = accounts[i][j];\n        const auto it = emailToIndex.find(email);\n        if (it == emailToIndex.end()) {\n          emailToIndex[email] = i;\n        } else {\n          uf.unionBySize(i, it->second);\n        }\n      }\n    }\n\n    for (const auto& [email, index] : emailToIndex)\n      indexToEmails[uf.find(index)].insert(email);\n\n    for (const auto& [index, emails] : indexToEmails) {\n      const string name = accounts[index][0];\n      vector<string> row{name};\n      row.insert(row.end(), emails.begin(), emails.end());\n      ans.push_back(row);\n    }\n\n    return ans;\n  }\n};\n", "722": "class Solution {\n public:\n  vector<string> removeComments(vector<string>& source) {\n    vector<string> ans;\n    bool commenting = false;\n    string modified;\n\n    for (const string& line : source) {\n      for (int i = 0; i < line.length();) {\n        if (i + 1 == line.length()) {\n          if (!commenting)\n            modified += line[i];\n          ++i;\n          break;\n        }\n        const string& twoChars = line.substr(i, 2);\n        if (twoChars == \"/*\" && !commenting) {\n          commenting = true;\n          i += 2;\n        } else if (twoChars == \"*/\" && commenting) {\n          commenting = false;\n          i += 2;\n        } else if (twoChars == \"//\") {\n          if (!commenting)\n            break;\n          else\n            i += 2;\n        } else {\n          if (!commenting)\n            modified += line[i];\n          ++i;\n        }\n      }\n      if (modified.length() > 0 && !commenting) {\n        ans.push_back(modified);\n        modified = \"\";\n      }\n    }\n\n    return ans;\n  }\n};\n", "723": "class Solution {\n public:\n  vector<vector<int>> candyCrush(vector<vector<int>>& board) {\n    const int m = board.size();\n    const int n = board[0].size();\n    bool haveCrushes = true;\n\n    while (haveCrushes) {\n      haveCrushes = false;\n\n      for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j) {\n          const int val = abs(board[i][j]);\n          if (val == 0)\n            continue;\n          // Crush the vertical candies.\n          if (j + 2 < n && abs(board[i][j + 1]) == val &&\n              abs(board[i][j + 2]) == val) {\n            haveCrushes = true;\n            for (int k = j; k < j + 3; ++k)\n              board[i][k] = -val;\n          }\n          // Crush the horizontal candies.\n          if (i + 2 < m && abs(board[i + 1][j]) == val &&\n              abs(board[i + 2][j]) == val) {\n            haveCrushes = true;\n            for (int k = i; k < i + 3; ++k)\n              board[k][j] = -val;\n          }\n        }\n\n      if (haveCrushes) {\n        // For each column, drop the candies.\n        for (int j = 0; j < n; ++j) {\n          int nextIndex = m - 1;\n          for (int i = m - 1; i >= 0; --i)\n            if (board[i][j] > 0)\n              board[nextIndex--][j] = board[i][j];\n          // Set board[0..nextIndex][j] to 0s.\n          for (int i = nextIndex; i >= 0; --i)\n            board[i][j] = 0;\n        }\n      }\n    }\n\n    return board;\n  }\n};\n", "724": "class Solution {\n public:\n  int pivotIndex(vector<int>& nums) {\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    int prefix = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (prefix == sum - prefix - nums[i])\n        return i;\n      prefix += nums[i];\n    }\n\n    return -1;\n  }\n};\n", "725": "class Solution {\n public:\n  vector<ListNode*> splitListToParts(ListNode* root, int k) {\n    vector<ListNode*> ans(k);\n    const int length = getLength(root);\n    const int subLength = length / k;\n    int remainder = length % k;\n\n    ListNode* prev = nullptr;\n    ListNode* head = root;\n\n    for (int i = 0; i < k; ++i, --remainder) {\n      ans[i] = head;\n      for (int j = 0; j < subLength + (remainder > 0); ++j) {\n        prev = head;\n        head = head->next;\n      }\n      if (prev != nullptr)\n        prev->next = nullptr;\n    }\n\n    return ans;\n  }\n\n private:\n  int getLength(ListNode* root) {\n    int length = 0;\n    for (ListNode* curr = root; curr; curr = curr->next)\n      ++length;\n    return length;\n  }\n};\n", "726": "class Solution {\n public:\n  string countOfAtoms(string formula) {\n    string ans;\n    int i = 0;\n\n    for (const auto& [elem, freq] : parse(formula, i)) {\n      ans += elem;\n      if (freq > 1)\n        ans += to_string(freq);\n    }\n\n    return ans;\n  }\n\n private:\n  map<string, int> parse(const string& s, int& i) {\n    map<string, int> count;\n\n    while (i < s.length())\n      if (s[i] == '(') {\n        for (const auto& [elem, freq] : parse(s, ++i))\n          count[elem] += freq;\n      } else if (s[i] == ')') {\n        const int num = getNum(s, ++i);\n        for (auto&& [_, freq] : count)\n          freq *= num;\n        return count;  // Return back to the previous scope.\n      } else {         // `s[i]` must be uppercased.\n        const string& elem = getElem(s, i);\n        const int num = getNum(s, i);\n        count[elem] += num;\n      }\n\n    return count;\n  }\n\n  string getElem(const string& s, int& i) {\n    const int elemStart = i++;  // `s[elemStart]` is uppercased.\n    while (i < s.length() && islower(s[i]))\n      ++i;\n    return s.substr(elemStart, i - elemStart);\n  }\n\n  int getNum(const string& s, int& i) {\n    const int numStart = i;\n    while (i < s.length() && isdigit(s[i]))\n      ++i;\n    const string& numString = s.substr(numStart, i - numStart);\n    return numString.empty() ? 1 : stoi(numString);\n  }\n};\n", "727": "class Solution {\n public:\n  string minWindow(string s1, string s2) {\n    const int m = s2.length();\n    const int n = s1.length();\n    // dp[i][j] := the start index (1-indexed) of the minimum window of s2[0..i)\n    // and s1[0..j).\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    // Fill in the placeholder values.\n    for (int j = 0; j <= n; ++j)\n      dp[0][j] = j + 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s2[i - 1] == s1[j - 1])\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = dp[i][j - 1];\n\n    int bestLeft = 0;\n    int minLength = INT_MAX;\n\n    for (int j = 1; j <= n; ++j)\n      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {\n        bestLeft = dp[m][j] - 1;\n        minLength = j - dp[m][j] + 1;\n      }\n\n    return minLength == INT_MAX ? \"\" : s1.substr(bestLeft, minLength);\n  }\n};\n", "728": "class Solution {\n public:\n  vector<int> selfDividingNumbers(int left, int right) {\n    vector<int> ans;\n\n    for (int num = left; num <= right; ++num)\n      if (selfDividingNumbers(num))\n        ans.push_back(num);\n\n    return ans;\n  }\n\n private:\n  bool selfDividingNumbers(int num) {\n    for (int n = num; n > 0; n /= 10)\n      if (n % 10 == 0 || num % (n % 10) != 0)\n        return false;\n    return true;\n  }\n};\n", "729": "class MyCalendar {\n public:\n  bool book(int start, int end) {\n    auto lo = line.lower_bound(end);\n\n    if (lo == line.begin() || (--lo)->second <= start) {\n      line[start] = end;\n      return true;\n    }\n\n    return false;\n  }\n\n private:\n  map<int, int> line;\n};\n", "73": "class Solution {\n public:\n  void setZeroes(vector<vector<int>>& matrix) {\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    bool shouldFillFirstRow = false;\n    bool shouldFillFirstCol = false;\n\n    for (int j = 0; j < n; ++j)\n      if (matrix[0][j] == 0) {\n        shouldFillFirstRow = true;\n        break;\n      }\n\n    for (int i = 0; i < m; ++i)\n      if (matrix[i][0] == 0) {\n        shouldFillFirstCol = true;\n        break;\n      }\n\n    // Store the information in the first row and the first column.\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][j] == 0) {\n          matrix[i][0] = 0;\n          matrix[0][j] = 0;\n        }\n\n    // Fill 0s for the matrix except the first row and the first column.\n    for (int i = 1; i < m; ++i)\n      for (int j = 1; j < n; ++j)\n        if (matrix[i][0] == 0 || matrix[0][j] == 0)\n          matrix[i][j] = 0;\n\n    // Fill 0s for the first row if needed.\n    if (shouldFillFirstRow)\n      for (int j = 0; j < n; ++j)\n        matrix[0][j] = 0;\n\n    // Fill 0s for the first column if needed.\n    if (shouldFillFirstCol)\n      for (int i = 0; i < m; ++i)\n        matrix[i][0] = 0;\n  }\n};\n", "730": "class Solution {\n public:\n  int countPalindromicSubsequences(string s) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = s.length();\n    // dp[i][j] := the number of different non-empty palindromic subsequences in\n    // s[i..j]\n    vector<vector<long>> dp(n, vector<long>(n));\n\n    for (int i = 0; i < n; ++i)\n      dp[i][i] = 1;\n\n    for (int d = 1; d < n; ++d)\n      for (int i = 0; i + d < n; ++i) {\n        const int j = i + d;\n        if (s[i] == s[j]) {\n          int lo = i + 1;\n          int hi = j - 1;\n          while (lo <= hi && s[lo] != s[i])\n            ++lo;\n          while (lo <= hi && s[hi] != s[i])\n            --hi;\n          if (lo > hi)\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2;\n          else if (lo == hi)\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1;\n          else\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1];\n        } else {\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];\n        }\n        dp[i][j] = (dp[i][j] + kMod) % kMod;\n      }\n\n    return dp[0][n - 1];\n  }\n};\n", "731": "class MyCalendarTwo {\n public:\n  bool book(int start, int end) {\n    ++line[start];\n    --line[end];\n\n    int activeEvents = 0;\n\n    for (const auto& [_, count] : line) {\n      activeEvents += count;\n      if (activeEvents > 2) {\n        if (--line[start] == 0)\n          line.erase(start);\n        if (++line[end] == 0)\n          line.erase(end);\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n private:\n  map<int, int> line;\n};\n", "732": "class MyCalendarThree {\n public:\n  int book(int start, int end) {\n    ++line[start];\n    --line[end];\n\n    int ans = 0;\n    int activeEvents = 0;\n\n    for (const auto& [_, count] : line) {\n      activeEvents += count;\n      ans = max(ans, activeEvents);\n    }\n\n    return ans;\n  }\n\n private:\n  map<int, int> line;\n};\n", "733": "class Solution {\n public:\n  vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc,\n                                int newColor) {\n    dfs(image, sr, sc,\n        vector<vector<bool>>(image.size(), vector<bool>(image[0].size())),\n        image[sr][sc], newColor);\n    return image;\n  }\n\n private:\n  void dfs(vector<vector<int>>& image, int i, int j,\n           vector<vector<bool>>&& seen, int startColor, int newColor) {\n    if (i < 0 || i == image.size() || j < 0 || j == image[0].size())\n      return;\n    if (image[i][j] != startColor || seen[i][j])\n      return;\n\n    image[i][j] = newColor;\n    seen[i][j] = true;\n\n    dfs(image, i + 1, j, std::move(seen), startColor, newColor);\n    dfs(image, i - 1, j, std::move(seen), startColor, newColor);\n    dfs(image, i, j + 1, std::move(seen), startColor, newColor);\n    dfs(image, i, j - 1, std::move(seen), startColor, newColor);\n  }\n};\n", "734": "class Solution {\n public:\n  bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2,\n                           vector<vector<string>>& similarPairs) {\n    if (sentence1.size() != sentence2.size())\n      return false;\n\n    // map[key] := all the similar words of key\n    unordered_map<string, unordered_set<string>> map;\n\n    for (const vector<string>& pair : similarPairs) {\n      map[pair[1]].insert(pair[0]);\n      map[pair[0]].insert(pair[1]);\n    }\n\n    for (int i = 0; i < sentence1.size(); ++i) {\n      if (sentence1[i] == sentence2[i])\n        continue;\n      if (!map.contains(sentence1[i]))\n        return false;\n      if (!map[sentence1[i]].contains(sentence2[i]))\n        return false;\n    }\n\n    return true;\n  }\n};\n", "735": "class Solution {\n public:\n  vector<int> asteroidCollision(vector<int>& asteroids) {\n    vector<int> stack;\n\n    for (const int a : asteroids)\n      if (a > 0) {\n        stack.push_back(a);\n      } else {  // a < 0\n        // Destroy the previous positive one(s).\n        while (!stack.empty() && stack.back() > 0 && stack.back() < -a)\n          stack.pop_back();\n        if (stack.empty() || stack.back() < 0)\n          stack.push_back(a);\n        else if (stack.back() == -a)\n          stack.pop_back();  // Both asteroids explode.\n        else                 // stack[-1] > the current asteroid.\n          ;                  // Destroy the current asteroid, so do nothing.\n      }\n\n    return stack;\n  }\n};\n", "736": "class Solution {\n public:\n  int evaluate(string expression) {\n    return evaluate(expression, unordered_map<string, int>());\n  }\n\n private:\n  int evaluate(const string& e, unordered_map<string, int> scope) {\n    if (isdigit(e[0]) || e[0] == '-')\n      return stoi(e);\n    if (const auto it = scope.find(e); it != scope.cend())\n      return it->second;\n\n    const int spaceIndex = e.find_first_of(' ');\n    const string nextExpression =\n        e.substr(spaceIndex + 1, e.length() - spaceIndex - 2);  // -2: \"()\"\n    const vector<string> tokens = split(nextExpression);\n\n    // Note that e[0] == '('.\n    if (e[1] == 'm')  // 'mult'\n      return evaluate(tokens[0], scope) * evaluate(tokens[1], scope);\n    if (e[1] == 'a')  // 'add'\n      return evaluate(tokens[0], scope) + evaluate(tokens[1], scope);\n\n    // 'let'\n    for (int i = 0; i + 1 < tokens.size(); i += 2)\n      scope[tokens[i]] = evaluate(tokens[i + 1], scope);\n    return evaluate(tokens.back(), scope);\n  };\n\n  vector<string> split(const string& e) {\n    vector<string> tokens;\n    string s;\n    int opened = 0;\n\n    for (const char c : e) {\n      if (c == '(')\n        ++opened;\n      else if (c == ')')\n        --opened;\n      if (opened == 0 && c == ' ') {\n        tokens.push_back(s);\n        s = \"\";\n      } else {\n        s += c;\n      }\n    }\n\n    if (!s.empty())\n      tokens.push_back(s);\n    return tokens;\n  }\n};\n", "737": "class Solution {\n public:\n  bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2,\n                              vector<vector<string>>& pairs) {\n    if (words1.size() != words2.size())\n      return false;\n\n    // graph[key] := all the similar words of key\n    unordered_map<string, unordered_set<string>> graph;\n\n    for (const vector<string>& pair : pairs) {\n      graph[pair[1]].insert(pair[0]);\n      graph[pair[0]].insert(pair[1]);\n    }\n\n    for (int i = 0; i < words1.size(); ++i) {\n      if (words1[i] == words2[i])\n        continue;\n      if (!graph.contains(words1[i]))\n        return false;\n      if (!dfs(graph, words1[i], words2[i], {}))\n        return false;\n    }\n\n    return true;\n  }\n\n private:\n  bool dfs(const unordered_map<string, unordered_set<string>>& graph,\n           const string& source, const string& target,\n           unordered_set<string>&& seen) {\n    if (graph.at(source).contains(target))\n      return true;\n\n    seen.insert(source);\n\n    for (const string& child : graph.at(source)) {\n      if (seen.contains(child))\n        continue;\n      if (dfs(graph, child, target, std::move(seen)))\n        return true;\n    }\n\n    return false;\n  }\n};\n", "738": "class Solution {\n public:\n  int monotoneIncreasingDigits(int n) {\n    string s = to_string(n);\n    const int n = s.length();\n    int k = n;  // s[k..n) -> '9'\n\n    for (int i = n - 1; i > 0; --i)\n      if (s[i] < s[i - 1]) {\n        --s[i - 1];\n        k = i;\n      }\n\n    for (int i = k; i < n; ++i)\n      s[i] = '9';\n\n    return stoi(s);\n  }\n};\n", "739": "class Solution {\n public:\n  vector<int> dailyTemperatures(vector<int>& temperatures) {\n    vector<int> ans(temperatures.size());\n    stack<int> stack;  // a decreasing stack\n\n    for (int i = 0; i < temperatures.size(); ++i) {\n      while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {\n        const int index = stack.top();\n        stack.pop();\n        ans[index] = i - index;\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "74": "class Solution {\n public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if (matrix.empty())\n      return false;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int l = 0;\n    int r = m * n;\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      const int i = mid / n;\n      const int j = mid % n;\n      if (matrix[i][j] == target)\n        return true;\n      if (matrix[i][j] < target)\n        l = mid + 1;\n      else\n        r = mid;\n    }\n\n    return false;\n  }\n};\n", "740": "class Solution {\n public:\n  int deleteAndEarn(vector<int>& nums) {\n    // Reduce to 198. House Robber\n    vector<int> bucket(10001);\n\n    for (const int num : nums)\n      bucket[num] += num;\n\n    int prev1 = 0;\n    int prev2 = 0;\n\n    for (const int num : bucket) {\n      const int dp = max(prev1, prev2 + num);\n      prev2 = prev1;\n      prev1 = dp;\n    }\n\n    return prev1;\n  }\n};\n", "741": "class Solution {\n public:\n  int cherryPickup(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    // dp[x1][y1][x2] := the maximum cherries we could pick from\n    // g[0][0] -> g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1],\n    // where y2 = x1 + y1 - x2 (reducing states from 4 to 3)\n    vector<vector<vector<int>>> dp(\n        n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -1)));\n    dp[1][1][1] = grid[0][0];\n\n    for (int x1 = 1; x1 <= n; ++x1)\n      for (int y1 = 1; y1 <= n; ++y1)\n        for (int x2 = 1; x2 <= n; ++x2) {\n          const int y2 = x1 + y1 - x2;\n          if (y2 < 1 || y2 > n)\n            continue;\n          if (grid[x1 - 1][y1 - 1] == -1 || grid[x2 - 1][y2 - 1] == -1)\n            continue;\n          const int ans = max({dp[x1 - 1][y1][x2], dp[x1 - 1][y1][x2 - 1],\n                               dp[x1][y1 - 1][x2], dp[x1][y1 - 1][x2 - 1]});\n          if (ans < 0)\n            continue;\n          dp[x1][y1][x2] = ans + grid[x1 - 1][y1 - 1];\n          if (x1 != x2)\n            dp[x1][y1][x2] += grid[x2 - 1][y2 - 1];\n        }\n\n    return max(0, dp[n][n][n]);\n  }\n};\n", "742": "class Solution {\n public:\n  int findClosestLeaf(TreeNode* root, int k) {\n    int ans = -1;\n    int minDist = 1000;\n    // {node: distance to TreeNode(k)}\n    unordered_map<TreeNode*, int> nodeToDist;\n\n    getDists(root, k, nodeToDist);\n    getClosestLeaf(root, 0, nodeToDist, minDist, ans);\n\n    return ans;\n  }\n\n private:\n  void getDists(TreeNode* root, int k,\n                unordered_map<TreeNode*, int>& nodeToDist) {\n    if (root == nullptr)\n      return;\n    if (root->val == k) {\n      nodeToDist[root] = 0;\n      return;\n    }\n\n    getDists(root->left, k, nodeToDist);\n    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {\n      // The TreeNode(k) is in the left subtree.\n      nodeToDist[root] = it->second + 1;\n      return;\n    }\n\n    getDists(root->right, k, nodeToDist);\n    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())\n      // The TreeNode(k) is in the right subtree.\n      nodeToDist[root] = it->second + 1;\n  }\n\n  void getClosestLeaf(TreeNode* root, int dist,\n                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,\n                      int& ans) {\n    if (root == nullptr)\n      return;\n    if (nodeToDist.contains(root))\n      dist = nodeToDist[root];\n    if (root->left == nullptr && root->right == nullptr) {\n      if (dist < minDist) {\n        minDist = dist;\n        ans = root->val;\n      }\n      return;\n    }\n\n    getClosestLeaf(root->left, dist + 1, nodeToDist, minDist, ans);\n    getClosestLeaf(root->right, dist + 1, nodeToDist, minDist, ans);\n  }\n};\n", "743": "class Solution {\n public:\n  int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& time : times) {\n      const int u = time[0] - 1;\n      const int v = time[1] - 1;\n      const int w = time[2];\n      graph[u].emplace_back(v, w);\n    }\n\n    return dijkstra(graph, k - 1);\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n    vector<int> dist(graph.size(), INT_MAX);\n\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v]) {\n          dist[v] = d + w;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    const int maxDist = ranges::max(dist);\n    return maxDist == INT_MAX ? -1 : maxDist;\n  }\n};\n", "744": "class Solution {\n public:\n  char nextGreatestLetter(vector<char>& letters, char target) {\n    int l = 0;\n    int r = letters.size();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (letters[m] > target)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return letters[l % letters.size()];\n  }\n};\n", "745": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int weight = -1;\n  TrieNode() : children(27) {}\n};\n\nclass Trie {\n public:\n  void insert(const string& word, int weight) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      node->weight = weight;\n    }\n  }\n\n  int startsWith(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return -1;\n      node = node->children[i];\n    }\n    return node->weight;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n};\n\nclass WordFilter {\n public:\n  WordFilter(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i)\n      for (int j = 0; j <= words[i].length(); ++j)\n        trie.insert(words[i].substr(j) + '{' + words[i], i);\n  }\n\n  int f(string prefix, string suffix) {\n    return trie.startsWith(suffix + '{' + prefix);\n  }\n\n private:\n  Trie trie;\n};\n", "746": "class Solution {\n public:\n  int minCostClimbingStairs(vector<int>& cost) {\n    const int n = cost.size();\n\n    for (int i = 2; i < n; ++i)\n      cost[i] += min(cost[i - 1], cost[i - 2]);\n\n    return min(cost[n - 1], cost[n - 2]);\n  }\n};\n", "747": "class Solution {\n public:\n  int dominantIndex(vector<int>& nums) {\n    int ans;\n    int mx = 0;\n    int secondMax = 0;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (nums[i] > mx) {\n        secondMax = mx;\n        mx = nums[i];\n        ans = i;\n      } else if (nums[i] > secondMax) {\n        secondMax = nums[i];\n      }\n\n    return mx >= 2 * secondMax ? ans : -1;\n  }\n};\n", "748": "class Solution {\n public:\n  string shortestCompletingWord(string licensePlate, vector<string>& words) {\n    string ans(16, '.');\n    vector<int> count(26);\n\n    for (const char c : licensePlate)\n      if (isalpha(c))\n        ++count[tolower(c) - 'a'];\n\n    for (const string& word : words)\n      if (word.length() < ans.length() && isComplete(count, getCount(word)))\n        ans = word;\n\n    return ans;\n  }\n\n private:\n  // Returns true if c1 is a subset of c2.\n  bool isComplete(const vector<int>& c1, const vector<int> c2) {\n    for (int i = 0; i < 26; ++i)\n      if (c1[i] > c2[i])\n        return false;\n    return true;\n  }\n\n  vector<int> getCount(const string& word) {\n    vector<int> count(26);\n    for (const char c : word)\n      ++count[c - 'a'];\n    return count;\n  }\n};\n", "749": "struct Region {\n  // Given m = the number of rows and n = the number of columns, (x, y) will be\n  // hashed as x * n + y.\n  unordered_set<int> infected;\n  unordered_set<int> noninfected;\n  int wallsRequired = 0;\n};\n\nclass Solution {\n public:\n  int containVirus(vector<vector<int>>& isInfected) {\n    const int m = isInfected.size();\n    const int n = isInfected[0].size();\n    int ans = 0;\n\n    while (true) {\n      vector<Region> regions;\n      vector<vector<bool>> seen(m, vector<bool>(n));\n\n      for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n          if (isInfected[i][j] == 1 && !seen[i][j]) {\n            Region region;\n            // Use DFS to find all the regions (1s).\n            dfs(isInfected, i, j, region, seen);\n            if (!region.noninfected.empty())\n              regions.push_back(region);\n          }\n\n      if (regions.empty())\n        break;  // No region causes further infection.\n\n      // Regions that infect the most neighbors will be sorted to the back of\n      // the array.\n      ranges::sort(regions, ranges::less{}, [](const Region& region) {\n        return region.noninfected.size();\n      });\n\n      // Build walls around the region that infects the most neighbors.\n      Region mostInfectedRegion = regions.back();\n      regions.pop_back();\n      ans += mostInfectedRegion.wallsRequired;\n\n      for (const int neighbor : mostInfectedRegion.infected) {\n        const int i = neighbor / n;\n        const int j = neighbor % n;\n        // The isInfected is now contained and won't be infected anymore.\n        isInfected[i][j] = 2;\n      }\n\n      // For remaining regions, infect their neighbors.\n      for (const Region& region : regions)\n        for (const int neighbor : region.noninfected) {\n          const int i = neighbor / n;\n          const int j = neighbor % n;\n          isInfected[i][j] = 1;\n        }\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& isInfected, int i, int j, Region& region,\n           vector<vector<bool>>& seen) {\n    if (i < 0 || i == isInfected.size() || j < 0 || j == isInfected[0].size())\n      return;\n    if (seen[i][j] || isInfected[i][j] == 2)\n      return;\n    if (isInfected[i][j] == 0) {\n      region.noninfected.insert(i * isInfected[0].size() + j);\n      ++region.wallsRequired;\n      return;\n    }\n\n    // isInfected[i][j] == 1\n    seen[i][j] = true;\n    region.infected.insert(i * isInfected[0].size() + j);\n\n    dfs(isInfected, i + 1, j, region, seen);\n    dfs(isInfected, i - 1, j, region, seen);\n    dfs(isInfected, i, j + 1, region, seen);\n    dfs(isInfected, i, j - 1, region, seen);\n  }\n};\n", "75": "class Solution {\n public:\n  void sortColors(vector<int>& nums) {\n    int l = 0;                // The next 0 should be placed in l.\n    int r = nums.size() - 1;  // The next 2 should be placed in r.\n\n    for (int i = 0; i <= r;)\n      if (nums[i] == 0)\n        swap(nums[i++], nums[l++]);\n      else if (nums[i] == 1)\n        ++i;\n      else\n        // We may swap a 0 to index i, but we're still not sure whether this 0\n        // is placed in the correct index, so we can't move pointer i.\n        swap(nums[i], nums[r--]);\n  }\n};\n", "750": "class Solution {\n public:\n  int countCornerRectangles(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int row1 = 0; row1 < grid.size() - 1; ++row1)\n      for (int row2 = row1 + 1; row2 < grid.size(); ++row2) {\n        int count = 0;\n        for (int j = 0; j < grid[0].size(); ++j)\n          if (grid[row1][j] && grid[row2][j])\n            ++count;\n        ans += count * (count - 1) / 2;\n      }\n\n    return ans;\n  }\n};\n", "751": "class Solution {\n public:\n  vector<string> ipToCIDR(string ip, int n) {\n    vector<string> ans;\n    long num = getNum(ip);\n\n    while (n > 0) {\n      const long lowbit = num & -num;\n      const long count = lowbit == 0 ? maxLow(n) : firstFit(lowbit, n);\n      ans.push_back(getCIDR(num, getPrefix(count)));\n      n -= count;\n      num += count;\n    }\n\n    return ans;\n  }\n\n private:\n  long getNum(const string& ip) {\n    istringstream iss(ip);\n    long num = 0;\n    for (string token; getline(iss, token, '.');)\n      num = num * 256 + stol(token);\n    return num;\n  }\n\n  // Returns the maximum i s.t. 2^i < n.\n  int maxLow(int n) {\n    for (int i = 0; i < 32; ++i)\n      if (1 << i + 1 > n)\n        return 1 << i;\n    throw;\n  }\n\n  long firstFit(long lowbit, long n) {\n    while (lowbit > n)\n      lowbit >>= 1;\n    return lowbit;\n  }\n\n  string getCIDR(long num, long prefix) {\n    const long d = num & 255;\n    num >>= 8;\n    const long c = num & 255;\n    num >>= 8;\n    const long b = num & 255;\n    num >>= 8;\n    const long a = num & 255;\n    return to_string(a) + '.' + to_string(b) + '.' + to_string(c) + '.' +\n           to_string(d) + '/' + to_string(prefix);\n  }\n\n  // e.g. count = 8 = 2^3 -> prefix = 32 - 3 = 29\n  //      count = 1 = 2^0 -> prefix = 32 - 0 = 32\n  int getPrefix(long count) {\n    for (int i = 0; i < 32; ++i)\n      if (count == 1 << i)\n        return 32 - i;\n    throw;\n  }\n};\n", "752": "class Solution {\n public:\n  int openLock(vector<string>& deadends, string target) {\n    unordered_set<string> seen{deadends.begin(), deadends.end()};\n    if (seen.contains(\"0000\"))\n      return -1;\n    if (target == \"0000\")\n      return 0;\n\n    queue<string> q{{\"0000\"}};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        string word = q.front();\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n          const char cache = word[i];\n          // Increase the i-th digit by 1.\n          word[i] = word[i] == '9' ? '0' : word[i] + 1;\n          if (word == target)\n            return step;\n          if (!seen.contains(word)) {\n            q.push(word);\n            seen.insert(word);\n          }\n          word[i] = cache;\n          // Decrease the i-th digit by 1.\n          word[i] = word[i] == '0' ? '9' : word[i] - 1;\n          if (word == target)\n            return step;\n          if (!seen.contains(word)) {\n            q.push(word);\n            seen.insert(word);\n          }\n          word[i] = cache;\n        }\n      }\n\n    return -1;\n  }\n};\n", "753": "class Solution {\n public:\n  string crackSafe(int n, int k) {\n    string ans(n, '0');\n    dfs(pow(k, n), n, k, {ans}, ans);\n    return ans;\n  }\n\n private:\n  bool dfs(int passwordSize, int n, int k, unordered_set<string>&& seen,\n           string& path) {\n    if (seen.size() == passwordSize)\n      return true;\n\n    string prefix = path.substr(path.length() - n + 1);\n\n    for (char c = '0'; c < '0' + k; ++c) {\n      prefix.push_back(c);\n      if (!seen.contains(prefix)) {\n        seen.insert(prefix);\n        path.push_back(c);\n        if (dfs(passwordSize, n, k, std::move(seen), path))\n          return true;\n        path.pop_back();\n        seen.erase(prefix);\n      }\n      prefix.pop_back();\n    }\n\n    return false;\n  }\n};\n", "754": "class Solution {\n public:\n  int reachNumber(int target) {\n    const int newTarget = abs(target);\n    int ans = 0;\n    int pos = 0;\n\n    while (pos < newTarget)\n      pos += ++ans;\n    while ((pos - newTarget) % 2 == 1)\n      pos += ++ans;\n\n    return ans;\n  }\n};\n", "755": "class Solution {\n public:\n  vector<int> pourWater(vector<int>& heights, int volume, int k) {\n    int i = k;\n\n    while (volume-- > 0) {\n      while (i > 0 && heights[i] >= heights[i - 1])\n        --i;\n      while (i + 1 < heights.size() && heights[i] >= heights[i + 1])\n        ++i;\n      while (i > k && heights[i] == heights[i - 1])\n        --i;\n      ++heights[i];\n    }\n\n    return heights;\n  }\n};\n", "756": "class Solution {\n public:\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\n    unordered_map<string, vector<char>> prefixToBlocks;\n\n    for (const string& a : allowed)\n      prefixToBlocks[a.substr(0, 2)].push_back(a[2]);\n\n    return dfs(bottom, \"\", 0, prefixToBlocks);\n  }\n\n private:\n  bool dfs(const string& row, const string& nextRow, int i,\n           const unordered_map<string, vector<char>>& prefixToBlocks) {\n    if (row.length() == 1)\n      return true;\n    if (nextRow.length() + 1 == row.length())\n      return dfs(nextRow, \"\", 0, prefixToBlocks);\n\n    const string& prefix = row.substr(i, 2);\n\n    if (const auto it = prefixToBlocks.find(prefix);\n        it != prefixToBlocks.cend())\n      for (const char c : it->second)\n        if (dfs(row, nextRow + c, i + 1, prefixToBlocks))\n          return true;\n\n    return false;\n  }\n};\n", "757": "class Solution {\n public:\n  int intersectionSizeTwo(vector<vector<int>>& intervals) {\n    int ans = 0;\n    int mx = -1;\n    int secondMax = -1;\n\n    ranges::sort(intervals, ranges::less{}, [](const vector<int>& interval) {\n      const int start = interval[0];\n      const int end = interval[1];\n      return pair<int, int>{end, -start};\n    });\n\n    for (const vector<int>& interval : intervals) {\n      const int start = interval[0];\n      const int end = interval[1];\n      // The maximum and the second maximum still satisfy.\n      if (mx >= start && secondMax >= start)\n        continue;\n      if (mx >= start) {\n        // The maximum still satisfy.\n        secondMax = mx;\n        mx = end;  // Add `end` to the set.\n        ans += 1;\n      } else {\n        // The maximum and the second maximum can't satisfy.\n        mx = end;             // Add `end` to the set.\n        secondMax = end - 1;  // Add `end - 1` to the set.\n        ans += 2;\n      }\n    }\n\n    return ans;\n  }\n};\n", "758": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  bool isWord = false;\n  TrieNode() : children(26) {}\n};\n\nclass Solution {\n public:\n  string boldWords(vector<string>& words, string s) {\n    const int n = s.length();\n    string ans;\n    // bold[i] := true if s[i] should be bolded\n    vector<bool> bold(n);\n\n    for (const string& word : words)\n      insert(word);\n\n    int boldEnd = -1;  // `s[i..boldEnd]` should be bolded.\n    for (int i = 0; i < n; ++i) {\n      boldEnd = max(boldEnd, find(s, i));\n      bold[i] = boldEnd >= i;\n    }\n\n    // Construct the string with the bold tags.\n    int i = 0;\n    while (i < n)\n      if (bold[i]) {\n        int j = i;\n        while (j < n && bold[j])\n          ++j;\n        // `s[i..j)` should be bolded.\n        ans += \"<b>\" + s.substr(i, j - i) + \"</b>\";\n        i = j;\n      } else {\n        ans += s[i++];\n      }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n    }\n    node->isWord = true;\n  }\n\n  int find(const string& s, int i) {\n    shared_ptr<TrieNode> node = root;\n    int ans = -1;\n    for (int j = i; j < s.length(); ++j) {\n      const int index = s[j] - 'a';\n      if (node->children[index] == nullptr)\n        return ans;\n      node = node->children[index];\n      if (node->isWord)\n        ans = j;\n    }\n    return ans;\n  }\n};\n", "759": "class Solution {\n public:\n  vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {\n    vector<Interval> ans;\n    vector<Interval> intervals;\n\n    for (const vector<Interval>& s : schedule)\n      intervals.insert(intervals.end(), s.begin(), s.end());\n\n    ranges::sort(intervals, ranges::less{},\n                 [](const Interval& interval) { return interval.start; });\n\n    int prevEnd = intervals[0].end;\n\n    for (const auto& [start, end] : intervals) {\n      if (start > prevEnd)\n        ans.emplace_back(prevEnd, start);\n      prevEnd = max(prevEnd, end);\n    }\n\n    return ans;\n  }\n};\n", "76": "class Solution {\n public:\n  string minWindow(string s, string t) {\n    vector<int> count(128);\n    int required = t.length();\n    int bestLeft = -1;\n    int minLength = s.length() + 1;\n\n    for (const char c : t)\n      ++count[c];\n\n    for (int l = 0, r = 0; r < s.length(); ++r) {\n      if (--count[s[r]] >= 0)\n        --required;\n      while (required == 0) {\n        if (r - l + 1 < minLength) {\n          bestLeft = l;\n          minLength = r - l + 1;\n        }\n        if (++count[s[l++]] > 0)\n          ++required;\n      }\n    }\n\n    return bestLeft == -1 ? \"\" : s.substr(bestLeft, minLength);\n  }\n};\n", "760": "class Solution {\n public:\n  vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> ans;\n    unordered_map<int, stack<int>> numToIndices;\n\n    for (int i = 0; i < nums2.size(); ++i)\n      numToIndices[nums2[i]].push(i);\n\n    for (const int num : nums1)\n      ans.push_back(numToIndices[num].top()), numToIndices[num].pop();\n\n    return ans;\n  }\n};\n", "761": "class Solution {\n public:\n  string makeLargestSpecial(string s) {\n    vector<string> specials;\n    int count = 0;\n\n    for (int i = 0, j = 0; j < s.length(); ++j) {\n      count += s[j] == '1' ? 1 : -1;\n      if (count == 0) {  // Find a special string.\n        const string& inner = s.substr(i + 1, j - i - 1);\n        specials.push_back('1' + makeLargestSpecial(inner) + '0');\n        i = j + 1;\n      }\n    }\n\n    ranges::sort(specials, greater<>());\n    return join(specials);\n  }\n\n private:\n  string join(const vector<string>& specials) {\n    string joined;\n    for (const string& special : specials)\n      joined += special;\n    return joined;\n  }\n};\n", "762": "class Solution {\n public:\n  int countPrimeSetBits(int left, int right) {\n    // {2, 3, 5, 7, 11, 13, 17, 19}-th bits are 1s.\n    // 0b10100010100010101100 = 665772\n    constexpr int magic = 665772;\n    int ans = 0;\n\n    for (unsigned num = left; num <= right; ++num)\n      if (magic >> popcount(num) & 1)\n        ++ans;\n\n    return ans;\n  }\n};\n", "763": "class Solution {\n public:\n  vector<int> partitionLabels(string s) {\n    vector<int> ans;\n    vector<int> rightmost(26);\n\n    for (int i = 0; i < s.length(); ++i)\n      rightmost[s[i] - 'a'] = i;\n\n    int l = 0;  // the leftmost index of the current running string\n    int r = 0;  // the rightmost index of the current running string\n\n    for (int i = 0; i < s.length(); ++i) {\n      r = max(r, rightmost[s[i] - 'a']);\n      if (r == i) {\n        ans.push_back(i - l + 1);\n        l = i + 1;\n      }\n    }\n\n    return ans;\n  }\n};\n", "764": "class Solution {\n public:\n  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n    vector<vector<int>> grid(n, vector<int>(n, n));\n\n    for (const vector<int>& mine : mines)\n      grid[mine[0]][mine[1]] = 0;\n\n    // Extend the four directions. If meet 0, need to start over from 0.\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0, leftToRight = 0; j < n; ++j) {\n        leftToRight = (grid[i][j] == 0 ? 0 : leftToRight + 1);\n        grid[i][j] = min(grid[i][j], leftToRight);\n      }\n      for (int j = n - 1, rightToLeft = 0; j >= 0; --j) {\n        rightToLeft = (grid[i][j] == 0 ? 0 : rightToLeft + 1);\n        grid[i][j] = min(grid[i][j], rightToLeft);\n      }\n      for (int j = 0, upToDown = 0; j < n; ++j) {\n        upToDown = (grid[j][i] == 0 ? 0 : upToDown + 1);\n        grid[j][i] = min(grid[j][i], upToDown);\n      }\n      for (int j = n - 1, downToUp = 0; j >= 0; --j) {\n        downToUp = (grid[j][i] == 0) ? 0 : downToUp + 1;\n        grid[j][i] = min(grid[j][i], downToUp);\n      }\n    }\n\n    int ans = 0;\n\n    for (const vector<int>& row : grid)\n      ans = max(ans, ranges::max(row));\n\n    return ans;\n  }\n};\n", "765": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int minSwapsCouples(vector<int>& row) {\n    const int n = row.size() / 2;\n    UnionFind uf(n);\n\n    for (int i = 0; i < n; ++i) {\n      const int a = row[2 * i];\n      const int b = row[2 * i + 1];\n      uf.unionByRank(a / 2, b / 2);\n    }\n\n    return n - uf.getCount();\n  }\n};\n", "766": "class Solution {\n public:\n  bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n    if (matrix.empty())\n      return true;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    vector<int> buffer(n);\n\n    // Load the row[0] to the buffer.\n    for (int j = 0; j < n; ++j)\n      buffer[j] = matrix[0][j];\n\n    // Roll the array.\n    for (int i = 1; i < m; ++i) {\n      for (int j = 0; j + 1 < n; ++j)\n        if (buffer[j] != matrix[i][j + 1])\n          return false;\n      buffer = matrix[i];\n    }\n\n    return true;\n  }\n};\n", "767": "class Solution {\n public:\n  string reorganizeString(string s) {\n    const int n = s.length();\n    vector<int> count(128);\n    char maxChar = 'a' - 1;\n\n    for (const char c : s)\n      ++count[c];\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c] > count[maxChar])\n        maxChar = c;\n\n    if (count[maxChar] > (n + 1) / 2)\n      return \"\";\n\n    string ans(n, ' ');\n    int i = 0;  // ans' index\n\n    auto fillIn = [&](char c) {\n      ans[i] = c;\n      i += 2;\n      if (i >= n)\n        i = 1;\n    };\n\n    // Fill in 0, 2, 4, ... indices with `maxCount` letters.\n    while (count[maxChar]-- > 0)\n      fillIn(maxChar);\n\n    // Fill in the remaining letters.\n    for (char c = 'a'; c <= 'z'; ++c)\n      while (count[c] > 0) {\n        --count[c];\n        fillIn(c);\n      }\n\n    return ans;\n  }\n};\n", "768": "class Solution {\n public:\n  int maxChunksToSorted(vector<int>& arr) {\n    const int n = arr.size();\n    int ans = 0;\n    vector<int> maxL(n);  // l[i] := max(arr[0..i])\n    vector<int> minR(n);  // r[i] := min(arr[i..n))\n\n    for (int i = 0; i < n; ++i)\n      maxL[i] = i == 0 ? arr[i] : max(arr[i], maxL[i - 1]);\n\n    for (int i = n - 1; i >= 0; --i)\n      minR[i] = i == n - 1 ? arr[i] : min(arr[i], minR[i + 1]);\n\n    for (int i = 0; i + 1 < n; ++i)\n      if (maxL[i] <= minR[i + 1])\n        ++ans;\n\n    return ans + 1;\n  }\n};\n", "769": "class Solution {\n public:\n  int maxChunksToSorted(vector<int>& arr) {\n    int ans = 0;\n    int mx = INT_MIN;\n\n    for (int i = 0; i < arr.size(); ++i) {\n      mx = max(mx, arr[i]);\n      if (mx == i)\n        ++ans;\n    }\n\n    return ans;\n  }\n};\n", "77": "class Solution {\n public:\n  vector<vector<int>> combine(int n, int k) {\n    vector<vector<int>> ans;\n    dfs(n, k, 1, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(int n, int k, int s, vector<int>&& path, vector<vector<int>>& ans) {\n    if (path.size() == k) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (int i = s; i <= n; ++i) {\n      path.push_back(i);\n      dfs(n, k, i + 1, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "770": "class Poly {\n  friend Poly operator+(const Poly& lhs, const Poly& rhs) {\n    Poly res(lhs);\n    for (const auto& [term, coef] : rhs.terms)\n      res.terms[term] += coef;\n    return res;\n  }\n\n  friend Poly operator-(const Poly& lhs, const Poly& rhs) {\n    Poly res(lhs);\n    for (const auto& [term, coef] : rhs.terms)\n      res.terms[term] -= coef;\n    return res;\n  }\n\n  friend Poly operator*(const Poly& lhs, const Poly& rhs) {\n    Poly res;\n    for (const auto& [a, aCoef] : lhs.terms)\n      for (const auto& [b, bCoef] : rhs.terms)\n        res.terms[merge(a, b)] += aCoef * bCoef;\n    return res;\n  }\n\n  // Friend ostream& operator<<(ostream& os, const Poly& poly) {\n  //   os << \"{\";\n  //   for (const auto& [term, coef] : poly.terms)\n  //     os << term << \": \" << coef << \", \";\n  //   os << \"}\";\n  //   return os;\n  // }\n\n public:\n  vector<string> toList() {\n    vector<string> res;\n    vector<string> keys;\n    for (const auto& [term, _] : terms)\n      keys.push_back(term);\n    ranges::sort(keys, [&](const string& a, const string& b) {\n      // the minimum degree is the last\n      if (a == \"1\")\n        return false;\n      if (b == \"1\")\n        return true;\n      const vector<string> as = split(a, '*');\n      const vector<string> bs = split(b, '*');\n      // the maximum degree is the first\n      // Break ties by their lexicographic orders.\n      return as.size() == bs.size() ? a < b : as.size() > bs.size();\n    });\n    auto concat = [&](const string& term) -> string {\n      if (term == \"1\")\n        return to_string(terms[term]);\n      return to_string(terms[term]) + '*' + term;\n    };\n    for (const string& key : keys)\n      if (terms[key])\n        res.push_back(concat(key));\n    return res;\n  }\n\n  Poly() = default;\n  Poly(const string& term, int coef) {\n    terms[term] = coef;\n  }\n\n private:\n  unordered_map<string, int> terms;\n\n  // e.g. merge(\"a*b\", \"a*c\") -> \"a*a*b*c\"\n  static string merge(const string& a, const string& b) {\n    if (a == \"1\")\n      return b;\n    if (b == \"1\")\n      return a;\n    string res;\n    vector<string> A = split(a, '*');\n    vector<string> B = split(b, '*');\n    int i = 0;  // A's index\n    int j = 0;  // B's index\n    while (i < A.size() && j < B.size())\n      if (A[i] < B[j])\n        res += '*' + A[i++];\n      else\n        res += '*' + B[j++];\n    while (i < A.size())\n      res += '*' + A[i++];\n    while (j < B.size())\n      res += '*' + B[j++];\n    return res.substr(1);\n  }\n\n  static vector<string> split(const string& token, char c) {\n    vector<string> vars;\n    istringstream iss(token);\n    for (string var; getline(iss, var, c);)\n      vars.push_back(var);\n    return vars;\n  }\n};\n\nclass Solution {\n public:\n  vector<string> basicCalculatorIV(string expression, vector<string>& evalvars,\n                                   vector<int>& evalints) {\n    vector<string> tokens = getTokens(expression);\n    unordered_map<string, int> evalMap;\n\n    for (int i = 0; i < evalvars.size(); ++i)\n      evalMap[evalvars[i]] = evalints[i];\n\n    for (string& token : tokens)\n      if (const auto it = evalMap.find(token); it != evalMap.cend())\n        token = to_string(it->second);\n\n    const vector<string>& postfix = infixToPostfix(tokens);\n    return evaluate(postfix).toList();\n  }\n\n private:\n  vector<string> getTokens(const string& s) {\n    vector<string> tokens;\n    int i = 0;\n    for (int j = 0; j < s.length(); ++j)\n      if (s[j] == ' ') {\n        if (i < j)\n          tokens.push_back(s.substr(i, j - i));\n        i = j + 1;\n      } else if (string(\"()+-*\").find(s[j]) != string::npos) {\n        if (i < j)\n          tokens.push_back(s.substr(i, j - i));\n        tokens.push_back(s.substr(j, 1));\n        i = j + 1;\n      }\n    if (i < s.length())\n      tokens.push_back(s.substr(i));\n    return tokens;\n  }\n\n  bool isOperator(const string& token) {\n    return token == \"+\" || token == \"-\" || token == \"*\";\n  }\n\n  vector<string> infixToPostfix(const vector<string>& tokens) {\n    vector<string> postfix;\n    stack<string> ops;\n\n    auto precedes = [](const string& prevOp, const string& currOp) -> bool {\n      if (prevOp == \"(\")\n        return false;\n      return prevOp == \"*\" || currOp == \"+\" || currOp == \"-\";\n    };\n\n    for (const string& token : tokens)\n      if (token == \"(\") {\n        ops.push(token);\n      } else if (token == \")\") {\n        while (ops.top() != \"(\")\n          postfix.push_back(ops.top()), ops.pop();\n        ops.pop();\n      } else if (isOperator(token)) {\n        while (!ops.empty() && precedes(ops.top(), token))\n          postfix.push_back(ops.top()), ops.pop();\n        ops.push(token);\n      } else {  // isOperand(token)\n        postfix.push_back(token);\n      }\n\n    while (!ops.empty())\n      postfix.push_back(ops.top()), ops.pop();\n\n    return postfix;\n  }\n\n  Poly evaluate(const vector<string>& postfix) {\n    vector<Poly> polys;\n    for (const string& token : postfix)\n      if (isOperator(token)) {\n        const Poly b = polys.back();\n        polys.pop_back();\n        const Poly a = polys.back();\n        polys.pop_back();\n        if (token == \"+\")\n          polys.push_back(a + b);\n        else if (token == \"-\")\n          polys.push_back(a - b);\n        else  // token == \"*\"\n          polys.push_back(a * b);\n      } else if (token[0] == '-' ||\n                 ranges::all_of(token, [](char c) { return isdigit(c); })) {\n        polys.push_back(Poly(\"1\", stoi(token)));\n      } else {\n        polys.push_back(Poly(token, 1));\n      }\n    return polys[0];\n  }\n};\n", "771": "class Solution {\n public:\n  int numJewelsInStones(string jewels, string stones) {\n    int ans = 0;\n    unordered_set<char> jewelsSet(jewels.begin(), jewels.end());\n\n    for (const char stone : stones)\n      if (jewelsSet.contains(stone))\n        ++ans;\n\n    return ans;\n  }\n};\n", "772": "class Solution {\n public:\n  int calculate(string s) {\n    stack<int> nums;\n    stack<int> ops;\n    bool hasPrevNum = false;\n\n    auto calc = [&]() {\n      const int b = nums.top();\n      nums.pop();\n      const int a = nums.top();\n      nums.pop();\n      const char op = ops.top();\n      ops.pop();\n      if (op == '+')\n        nums.push(a + b);\n      else if (op == '-')\n        nums.push(a - b);\n      else if (op == '*')\n        nums.push(a * b);\n      else  // op == '/'\n        nums.push(a / b);\n    };\n\n    for (int i = 0; i < s.length(); ++i) {\n      const char c = s[i];\n      if (isdigit(c)) {\n        int num = c - '0';\n        while (i + 1 < s.length() && isdigit(s[i + 1]))\n          num = num * 10 + (s[i++ + 1] - '0');\n        nums.push(num);\n        hasPrevNum = true;\n      } else if (c == '(') {\n        ops.push('(');\n        hasPrevNum = false;\n      } else if (c == ')') {\n        while (ops.top() != '(')\n          calc();\n        ops.pop();  // Pop '('.\n      } else if (c == '+' || c == '-' || c == '*' || c == '/') {\n        if (!hasPrevNum)\n          nums.push(0);\n        while (!ops.empty() && precedes(ops.top(), c))\n          calc();\n        ops.push(c);\n      }\n    }\n\n    while (!ops.empty())\n      calc();\n\n    return nums.top();\n  }\n\n private:\n  // Returns true if the previous character is a operator and the priority of\n  // the previous operator >= the priority of the current character (operator).\n  bool precedes(char prev, char curr) {\n    if (prev == '(')\n      return false;\n    return prev == '*' || prev == '/' || curr == '+' || curr == '-';\n  }\n};\n", "773": "class Solution {\n public:\n  int slidingPuzzle(vector<vector<int>>& board) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    constexpr int m = 2;\n    constexpr int n = 3;\n    constexpr char goal[] = \"123450\";\n    string start;\n\n    // Hash the 2D vector into a string.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        start += '0' + board[i][j];\n\n    if (start == goal)\n      return 0;\n\n    queue<string> q{{start}};\n    unordered_set<string> seen{start};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        string s = q.front();\n        q.pop();\n        const int zeroIndex = s.find('0');\n        const int i = zeroIndex / n;\n        const int j = zeroIndex % n;\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          const int swappedIndex = x * n + y;\n          swap(s[zeroIndex], s[swappedIndex]);\n          if (s == goal)\n            return step;\n          if (!seen.contains(s)) {\n            q.push(s);\n            seen.insert(s);\n          }\n          swap(s[zeroIndex], s[swappedIndex]);\n        }\n      }\n\n    return -1;\n  }\n};\n", "774": "class Solution {\n public:\n  double minmaxGasDist(vector<int>& stations, int k) {\n    constexpr double kErr = 1e-6;\n    double l = 0;\n    double r = stations.back() - stations[0];\n\n    while (r - l > kErr) {\n      const double m = (l + r) / 2;\n      if (check(stations, k, m))\n        r = m;\n      else\n        l = m;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns true if can use <= k gas stations to ensure that each adjacent\n  // distance between gas stations <= m.\n  bool check(const vector<int>& stations, int k, double m) {\n    for (int i = 1; i < stations.size(); ++i) {\n      const int diff = stations[i] - stations[i - 1];\n      if (diff > m) {\n        k -= ceil(diff / m) - 1;\n        if (k < 0)\n          return false;\n      }\n    }\n    return true;\n  };\n};\n", "775": "class Solution {\n public:\n  bool isIdealPermutation(vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i)\n      if (abs(nums[i] - i) > 1)\n        return false;\n    return true;\n  }\n};\n", "776": "class Solution {\n public:\n  vector<TreeNode*> splitBST(TreeNode* root, int target) {\n    if (root == nullptr)\n      return {nullptr, nullptr};\n    if (root->val > target) {\n      const vector<TreeNode*> res = splitBST(root->left, target);\n      root->left = res[1];\n      return {res[0], root};\n    } else {  // root->val <= target\n      const vector<TreeNode*> res = splitBST(root->right, target);\n      root->right = res[0];\n      return {root, res[1]};\n    }\n  }\n};\n", "777": "class Solution {\n public:\n  bool canTransform(string start, string end) {\n    if (removeX(start) != removeX(end))\n      return false;\n\n    int i = 0;  // start's index\n    int j = 0;  // end's index\n\n    while (i < start.length() && j < end.length()) {\n      while (i < start.length() && start[i] == 'X')\n        ++i;\n      while (j < end.length() && end[j] == 'X')\n        ++j;\n      if (i == start.length() && j == end.length())\n        return true;\n      if (i == start.length() || j == end.length())\n        return false;\n      // L can only move to left.\n      if (start[i] == 'L' && i < j)\n        return false;\n      // R can only move to right.\n      if (start[i] == 'R' && i > j)\n        return false;\n      ++i;\n      ++j;\n    }\n\n    return true;\n  }\n\n private:\n  string removeX(const string& s) {\n    string t = s;\n    std::erase(t, 'X');\n    return t;\n  }\n};\n", "778": "class Solution {\n public:\n  int swimInWater(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int n = grid.size();\n    int ans = grid[0][0];\n    using T = tuple<int, int, int>;  // (grid[i][j], i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<bool>> seen(n, vector<bool>(n));\n\n    minHeap.emplace(grid[0][0], 0, 0);\n    seen[0][0] = true;\n\n    while (!minHeap.empty()) {\n      const auto [height, i, j] = minHeap.top();\n      minHeap.pop();\n      ans = max(ans, height);\n      if (i == n - 1 && j == n - 1)\n        break;\n      for (const auto& [dx, dy] : kDirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == n || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        minHeap.emplace(grid[x][y], x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    return ans;\n  }\n};\n", "779": "class Solution {\n public:\n  int kthGrammar(int n, int k) {\n    if (n == 1)\n      return 0;\n    if (k % 2 == 1)\n      return kthGrammar(n - 1, (k + 1) / 2) != 0;  // the left node\n    return kthGrammar(n - 1, k / 2) == 0;          // the right node\n  }\n};\n", "78": "class Solution {\n public:\n  vector<vector<int>> subsets(vector<int>& nums) {\n    vector<vector<int>> ans;\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    ans.push_back(path);\n\n    for (int i = s; i < nums.size(); ++i) {\n      path.push_back(nums[i]);\n      dfs(nums, i + 1, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "780": "class Solution {\n public:\n  bool reachingPoints(int sx, int sy, int tx, int ty) {\n    while (sx < tx && sy < ty)\n      if (tx > ty)\n        tx %= ty;\n      else\n        ty %= tx;\n\n    return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||\n           sy == ty && sx <= tx && (tx - sx) % sy == 0;\n  }\n};\n", "781": "class Solution {\n public:\n  int numRabbits(vector<int>& answers) {\n    int ans = 0;\n    vector<int> count(1000);\n\n    for (const int answer : answers) {\n      if (count[answer] % (answer + 1) == 0)\n        ans += answer + 1;\n      ++count[answer];\n    }\n\n    return ans;\n  }\n};\n", "782": "class Solution {\n public:\n  int movesToChessboard(vector<vector<int>>& board) {\n    const int n = board.size();\n    int rowSum = 0;\n    int colSum = 0;\n    int rowSwaps = 0;\n    int colSwaps = 0;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] == 1)\n          return -1;\n\n    for (int i = 0; i < n; ++i) {\n      rowSum += board[0][i];\n      colSum += board[i][0];\n    }\n\n    if (rowSum != n / 2 && rowSum != (n + 1) / 2)\n      return -1;\n    if (colSum != n / 2 && colSum != (n + 1) / 2)\n      return -1;\n\n    for (int i = 0; i < n; ++i) {\n      rowSwaps += board[i][0] == (i & 1);\n      colSwaps += board[0][i] == (i & 1);\n    }\n\n    if (n % 2 == 1) {\n      if (rowSwaps % 2 == 1)\n        rowSwaps = n - rowSwaps;\n      if (colSwaps % 2 == 1)\n        colSwaps = n - colSwaps;\n    } else {\n      rowSwaps = min(rowSwaps, n - rowSwaps);\n      colSwaps = min(colSwaps, n - colSwaps);\n    }\n\n    return (rowSwaps + colSwaps) / 2;\n  }\n};\n", "783": "class Solution {\n public:\n  int minDiffInBST(TreeNode* root) {\n    int ans = INT_MAX;\n    inorder(root, ans);\n    return ans;\n  }\n\n private:\n  int pred = -1;\n\n  void inorder(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return;\n\n    inorder(root->left, ans);\n    if (pred >= 0)\n      ans = min(ans, root->val - pred);\n    pred = root->val;\n    inorder(root->right, ans);\n  }\n};\n", "784": "class Solution {\n public:\n  vector<string> letterCasePermutation(string s) {\n    vector<string> ans;\n    dfs(s, 0, ans);\n    return ans;\n  }\n\n private:\n  void dfs(string& s, int i, vector<string>& ans) {\n    if (i == s.length()) {\n      ans.push_back(s);\n      return;\n    }\n    if (isdigit(s[i])) {\n      dfs(s, i + 1, ans);\n      return;\n    }\n\n    s[i] = tolower(s[i]);\n    dfs(s, i + 1, ans);\n    s[i] = toupper(s[i]);\n    dfs(s, i + 1, ans);\n  }\n};\n", "786": "class Solution {\n public:\n  vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\n    const int n = arr.size();\n    double l = 0.0;\n    double r = 1.0;\n\n    while (l < r) {\n      const double m = (l + r) / 2.0;\n      int fractionsNoGreaterThanM = 0;\n      int p = 0;\n      int q = 1;\n\n      // For each index i, find the first index j s.t. arr[i] / arr[j] <= m,\n      // so fractionsNoGreaterThanM for index i will be n - j.\n      for (int i = 0, j = 1; i < n; ++i) {\n        while (j < n && arr[i] > m * arr[j])\n          ++j;\n        if (j == n)\n          break;\n        fractionsNoGreaterThanM += n - j;\n        if (p * arr[j] < q * arr[i]) {\n          p = arr[i];\n          q = arr[j];\n        }\n      }\n\n      if (fractionsNoGreaterThanM == k)\n        return {p, q};\n      if (fractionsNoGreaterThanM > k)\n        r = m;\n      else\n        l = m;\n    }\n\n    throw;\n  }\n};\n", "787": "class Solution {\n public:\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\n                        int k) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const vector<int>& flight : flights) {\n      const int u = flight[0];\n      const int v = flight[1];\n      const int w = flight[2];\n      graph[u].emplace_back(v, w);\n    }\n\n    return dijkstra(graph, src, dst, k);\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,\n               int k) {\n    vector<vector<int>> dist(graph.size(), vector<int>(k + 2, INT_MAX));\n\n    dist[src][k + 1] = 0;\n    using T = tuple<int, int, int>;  // (d, u, stops)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    minHeap.emplace(dist[src][k + 1], src, k + 1);\n\n    while (!minHeap.empty()) {\n      const auto [d, u, stops] = minHeap.top();\n      minHeap.pop();\n      if (u == dst)\n        return d;\n      if (stops == 0 || d > dist[u][stops])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w < dist[v][stops - 1]) {\n          dist[v][stops - 1] = d + w;\n          minHeap.emplace(dist[v][stops - 1], v, stops - 1);\n        }\n    }\n\n    return -1;\n  }\n};\n", "788": "class Solution {\n public:\n  int rotatedDigits(int n) {\n    int ans = 0;\n\n    for (int i = 1; i <= n; ++i)\n      if (isGoodNumber(i))\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  bool isGoodNumber(int i) {\n    bool isRotated = false;\n\n    for (const char c : to_string(i)) {\n      if (c == '0' || c == '1' || c == '8')\n        continue;\n      if (c == '2' || c == '5' || c == '6' || c == '9')\n        isRotated = true;\n      else\n        return false;\n    }\n\n    return isRotated;\n  }\n};\n", "789": "class Solution {\n public:\n  bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {\n    const int d = abs(target[0]) + abs(target[1]);\n\n    for (const vector<int>& ghost : ghosts)\n      if (d >= abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]))\n        return false;\n\n    return true;\n  }\n};\n", "79": "class Solution {\n public:\n  bool exist(vector<vector<char>>& board, string word) {\n    for (int i = 0; i < board.size(); ++i)\n      for (int j = 0; j < board[0].size(); ++j)\n        if (dfs(board, word, i, j, 0))\n          return true;\n    return false;\n  }\n\n private:\n  bool dfs(vector<vector<char>>& board, const string& word, int i, int j,\n           int s) {\n    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())\n      return false;\n    if (board[i][j] != word[s] || board[i][j] == '*')\n      return false;\n    if (s == word.length() - 1)\n      return true;\n\n    const char cache = board[i][j];\n    board[i][j] = '*';\n    const bool isExist = dfs(board, word, i + 1, j, s + 1) ||\n                         dfs(board, word, i - 1, j, s + 1) ||\n                         dfs(board, word, i, j + 1, s + 1) ||\n                         dfs(board, word, i, j - 1, s + 1);\n    board[i][j] = cache;\n\n    return isExist;\n  }\n};\n", "790": "class Solution {\n public:\n  int numTilings(int n) {\n    constexpr int kMod = 1'000'000'007;\n    vector<long> dp(1001);\n    dp[1] = 1;\n    dp[2] = 2;\n    dp[3] = 5;\n\n    for (int i = 4; i <= n; ++i)\n      dp[i] = (2 * dp[i - 1] + dp[i - 3]) % kMod;\n\n    return dp[n];\n  }\n};\n", "791": "class Solution {\n public:\n  string customSortString(string order, string s) {\n    string ans;\n    vector<int> count(128);\n\n    for (const char c : s)\n      ++count[c];\n\n    for (const char c : order)\n      while (count[c]-- > 0)\n        ans += c;\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      while (count[c]-- > 0)\n        ans += c;\n\n    return ans;\n  }\n};\n", "792": "class Solution {\n public:\n  int numMatchingSubseq(string s, vector<string>& words) {\n    int ans = 0;\n    // [(i, j)] := words[i] and the letter words[i][j] is waiting for\n    vector<vector<pair<int, int>>> bucket(26);\n\n    // For each word, it's waiting for word[0].\n    for (int i = 0; i < words.size(); ++i)\n      bucket[words[i][0] - 'a'].emplace_back(i, 0);\n\n    for (const char c : s) {\n      // Let prevBucket = bucket[c] and clear bucket[c].\n      vector<pair<int, int>> prevBucket;\n      swap(prevBucket, bucket[c - 'a']);\n      for (auto& [i, j] : prevBucket)\n        // All the letters in words[i] are matched.\n        if (++j == words[i].length())\n          ++ans;\n        else\n          bucket[words[i][j] - 'a'].emplace_back(i, j);\n    }\n\n    return ans;\n  }\n};\n", "793": "class Solution {\n public:\n  int preimageSizeFZF(int k) {\n    long l = 0;\n    long r = 5L * k;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (trailingZeroes(m) >= k)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return trailingZeroes(l) == k ? 5 : 0;\n  }\n\n private:\n  // Same as 172. Factorial Trailing Zeroes\n  int trailingZeroes(long n) {\n    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\n  }\n};\n", "794": "class Solution {\n public:\n  bool validTicTacToe(vector<string>& board) {\n    const int countX = sum(board, 'X');\n    const int countO = sum(board, 'O');\n\n    if (countX < countO || countX - countO > 1)\n      return false;\n    if (isWinned(board, 'X') && countX == countO ||\n        isWinned(board, 'O') && countX != countO)\n      return false;\n\n    return true;\n  }\n\n private:\n  int sum(const vector<string>& board, char c) {\n    int ans = 0;\n\n    for (const string& row : board)\n      ans += ranges::count(row, c);\n\n    return ans;\n  }\n\n  bool isWinned(const vector<string>& board, char c) {\n    vector<string> rotated = rotate(board);\n\n    auto equalsToThree = [&c](const string& row) {\n      return ranges::count(row, c) == 3;\n    };\n\n    return ranges::any_of(board, equalsToThree) ||\n           ranges::any_of(rotated, equalsToThree) ||\n           board[0][0] == c && board[1][1] == c && board[2][2] == c ||\n           board[0][2] == c && board[1][1] == c && board[2][0] == c;\n  }\n\n  vector<string> rotate(const vector<string>& board) {\n    vector<string> rotated(3);\n\n    for (const string& row : board)\n      for (int i = 0; i < 3; ++i)\n        rotated[i].push_back(row[i]);\n\n    return rotated;\n  }\n};\n", "795": "class Solution {\n public:\n  int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {\n    int ans = 0;\n    int l = -1;\n    int r = -1;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (nums[i] > right)  // Handle the reset value.\n        l = i;\n      if (nums[i] >= left)  // Handle the reset and the needed value.\n        r = i;\n      ans += r - l;\n    }\n\n    return ans;\n  }\n};\n", "796": "class Solution {\n public:\n  bool rotateString(string s, string goal) {\n    return s.length() == goal.length() && (s + s).find(goal) != string::npos;\n  }\n};\n", "797": "class Solution {\n public:\n  vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n    vector<vector<int>> ans;\n    dfs(graph, 0, {0}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    if (u == graph.size() - 1) {\n      ans.push_back(path);\n      return;\n    }\n\n    for (const int v : graph[u]) {\n      path.push_back(v);\n      dfs(graph, v, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "798": "class Solution {\n public:\n  int bestRotation(vector<int>& nums) {\n    const int n = nums.size();\n    // rotate[i] := the number of points lost after rotating left i times\n    vector<int> rotate(n);\n\n    // Rotating i - nums[i] times makes nums[i] == its new index.\n    // So, rotating i - nums[i] + 1 times will \"start\" to make nums[i] > its\n    // index, which is the starting index to lose point.\n    for (int i = 0; i < n; ++i)\n      --rotate[(i - nums[i] + 1 + n) % n];\n\n    // Each time of the rotation, make index 0 to index n - 1 to get 1 point.\n    for (int i = 1; i < n; ++i)\n      rotate[i] += rotate[i - 1] + 1;\n\n    return distance(rotate.begin(), ranges::max_element(rotate));\n  }\n};\n", "799": "class Solution {\n public:\n  double champagneTower(int poured, int query_row, int query_glass) {\n    vector<double> dp(query_row + 1);\n    dp[0] = poured;\n\n    for (int i = 0; i < query_row; ++i) {\n      vector<double> newDp(query_row + 1);\n      for (int j = 0; j <= i; ++j)\n        if (dp[j] > 1) {\n          newDp[j] += (dp[j] - 1) / 2.0;\n          newDp[j + 1] += (dp[j] - 1) / 2.0;\n        }\n      dp = std::move(newDp);\n    }\n\n    return min(1.0, dp[query_glass]);\n  }\n};\n", "8": "class Solution {\n public:\n  int myAtoi(string s) {\n    trim(s);\n    if (s.empty())\n      return 0;\n\n    const int sign = s[0] == '-' ? -1 : 1;\n    if (s[0] == '+' || s[0] == '-')\n      s = s.substr(1);\n\n    long num = 0;\n\n    for (const char c : s) {\n      if (!isdigit(c))\n        break;\n      num = num * 10 + (c - '0');\n      if (sign * num < INT_MIN)\n        return INT_MIN;\n      if (sign * num > INT_MAX)\n        return INT_MAX;\n    }\n\n    return sign * num;\n  }\n\n private:\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n};\n", "80": "class Solution {\n public:\n  int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n\n    for (const int num : nums)\n      if (i < 2 || num > nums[i - 2])\n        nums[i++] = num;\n\n    return i;\n  }\n};\n", "800": "class Solution {\n public:\n  string similarRGB(string color) {\n    const vector<string> kShorthands = {\"00\", \"11\", \"22\", \"33\", \"44\", \"55\",\n                                        \"66\", \"77\", \"88\", \"99\", \"aa\", \"bb\",\n                                        \"cc\", \"dd\", \"ee\", \"ff\"};\n    string ans = \"#\";\n\n    for (int i = 1; i < color.length(); i += 2) {\n      const int currValue = stoi(color.substr(i, 2), 0, 16);\n      ans += findClosestShorthand(kShorthands, currValue);\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int maxSimilarity = 255 * 255;\n\n  string findClosestShorthand(const vector<string>& shorthands,\n                              int targetValue) {\n    string closest = shorthands[0];\n    int minSimilarity = maxSimilarity;\n\n    for (const string& shorthand : shorthands) {\n      const int shorthandValue = stoi(shorthand, 0, 16);\n      const int similarity = pow((targetValue - shorthandValue), 2);\n      if (similarity < minSimilarity) {\n        closest = shorthand;\n        minSimilarity = similarity;\n      }\n    }\n\n    return closest;\n  }\n};\n", "801": "class Solution {\n public:\n  int minSwap(vector<int>& nums1, vector<int>& nums2) {\n    int keepAt = 0;\n    int swapAt = 1;\n    int prevKeepAt = 0;\n    int prevSwapAt = 1;\n\n    for (int i = 1; i < nums1.size(); ++i) {\n      keepAt = INT_MAX;\n      swapAt = INT_MAX;\n      if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n        keepAt = prevKeepAt;\n        swapAt = prevSwapAt + 1;\n      }\n      if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n        keepAt = min(keepAt, prevSwapAt);\n        swapAt = min(swapAt, prevKeepAt + 1);\n      }\n      prevKeepAt = keepAt;\n      prevSwapAt = swapAt;\n    }\n\n    return min(keepAt, swapAt);\n  }\n};\n", "802": "enum class State { kInit, kVisiting, kVisited };\n\nclass Solution {\n public:\n  vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n    vector<int> ans;\n    vector<State> states(graph.size());\n\n    for (int i = 0; i < graph.size(); ++i)\n      if (!hasCycle(graph, i, states))\n        ans.push_back(i);\n\n    return ans;\n  }\n\n private:\n  bool hasCycle(const vector<vector<int>>& graph, int u,\n                vector<State>& states) {\n    if (states[u] == State::kVisiting)\n      return true;\n    if (states[u] == State::kVisited)\n      return false;\n    states[u] = State::kVisiting;\n    for (const int v : graph[u])\n      if (hasCycle(graph, v, states))\n        return true;\n    states[u] = State::kVisited;\n    return false;\n  }\n};\n", "803": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), sz(n, 1) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionBySize(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (sz[i] < sz[j]) {\n      sz[j] += sz[i];\n      id[i] = j;\n    } else {\n      sz[i] += sz[j];\n      id[j] = i;\n    }\n  }\n\n  int getStableSize() {\n    // Bricks connected with 0 (top) are stable.\n    return sz[find(0)];\n  }\n\n private:\n  vector<int> id;\n  vector<int> sz;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\n    m = grid.size();\n    n = grid[0].size();\n\n    UnionFind uf(m * n + 1);  // 0 := top (stable)\n\n    // Mark cells to hit as 2.\n    for (const vector<int>& hit : hits) {\n      const int i = hit[0];\n      const int j = hit[1];\n      if (grid[i][j] == 1)\n        grid[i][j] = 2;\n    }\n\n    // Union all the 1s.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          unionNeighbors(grid, uf, i, j);\n\n    vector<int> ans(hits.size());\n    int stableSize = uf.getStableSize();\n\n    for (int i = hits.size() - 1; i >= 0; --i) {\n      const int x = hits[i][0];\n      const int y = hits[i][1];\n      if (grid[x][y] == 2) {  // cells marked from 1 to 2\n        grid[x][y] = 1;       // Unhit and restore it back to 1.\n        unionNeighbors(grid, uf, x, y);\n        const int newStableSize = uf.getStableSize();\n        if (newStableSize > stableSize)\n          ans[i] = newStableSize - stableSize - 1;  // 1 := the hit cell\n        stableSize = newStableSize;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  static constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n  int m;\n  int n;\n\n  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,\n                      int j) {\n    const int hash = getHash(i, j);\n\n    for (const auto& [dx, dy] : kDirs) {\n      const int x = i + dx;\n      const int y = j + dy;\n      if (x < 0 || x == m || y < 0 || y == n)\n        continue;\n      if (grid[x][y] != 1)\n        continue;\n      uf.unionBySize(hash, getHash(x, y));\n    }\n\n    if (i == 0)\n      uf.unionBySize(hash, 0);\n  }\n\n  int getHash(int i, int j) {\n    return i * n + j + 1;\n  }\n};\n", "804": "class Solution {\n public:\n  int uniqueMorseRepresentations(vector<string>& words) {\n    const vector<string> morse{\n        \".-\",   \"-...\", \"-.-.\", \"-..\",  \".\",   \"..-.\", \"--.\",  \"....\", \"..\",\n        \".---\", \"-.-\",  \".-..\", \"--\",   \"-.\",  \"---\",  \".--.\", \"--.-\", \".-.\",\n        \"...\",  \"-\",    \"..-\",  \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n    unordered_set<string> transformations;\n\n    for (const string& word : words) {\n      string transformation;\n      for (const char c : word)\n        transformation += morse[c - 'a'];\n      transformations.insert(transformation);\n    }\n\n    return transformations.size();\n  }\n};\n", "805": "class Solution {\n public:\n  bool splitArraySameAverage(vector<int>& nums) {\n    const int n = nums.size();\n    const int sum = accumulate(nums.begin(), nums.end(), 0);\n    if (!isPossible(sum, n))\n      return false;\n\n    vector<unordered_set<int>> sums(n / 2 + 1);\n    sums[0].insert(0);\n\n    for (const int num : nums)\n      for (int i = n / 2; i > 0; --i)\n        for (const int val : sums[i - 1])\n          sums[i].insert(num + val);\n\n    for (int i = 1; i < n / 2 + 1; ++i)\n      if (i * sum % n == 0 && sums[i].contains(i * sum / n))\n        return true;\n\n    return false;\n  }\n\n private:\n  bool isPossible(int sum, int n) {\n    for (int i = 1; i < n / 2 + 1; ++i)\n      if (i * sum % n == 0)\n        return true;\n    return false;\n  }\n};\n", "806": "class Solution {\n public:\n  vector<int> numberOfLines(vector<int>& widths, string s) {\n    int numLines = 1;\n    int runningWidth = 0;\n\n    for (const char c : s) {\n      const int width = widths[c - 'a'];\n      if (runningWidth + width <= 100) {\n        runningWidth += width;\n      } else {\n        ++numLines;\n        runningWidth = width;\n      }\n    }\n\n    return {numLines, runningWidth};\n  }\n};\n", "807": "class Solution {\n public:\n  int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {\n    const int n = grid.size();\n    int ans = 0;\n    vector<int> rowMax(n);\n    vector<int> colMax(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        rowMax[i] = max(rowMax[i], grid[i][j]);\n        colMax[j] = max(colMax[j], grid[i][j]);\n      }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        ans += min(rowMax[i], colMax[j]) - grid[i][j];\n\n    return ans;\n  }\n};\n", "808": "class Solution {\n public:\n  double soupServings(int n) {\n    return n >= 4800 ? 1.0 : dfs((n + 24) / 25, (n + 24) / 25);\n  }\n\n private:\n  vector<vector<double>> mem =\n      vector<vector<double>>(4800 / 25, vector<double>(4800 / 25));\n\n  double dfs(int a, int b) {\n    if (a <= 0 && b <= 0)\n      return 0.5;\n    if (a <= 0)\n      return 1.0;\n    if (b <= 0)\n      return 0.0;\n    if (mem[a][b] > 0)\n      return mem[a][b];\n    return mem[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) +\n                               dfs(a - 2, b - 2) + dfs(a - 1, b - 3));\n  }\n};\n", "809": "class Solution {\n public:\n  int expressiveWords(string s, vector<string>& words) {\n    int ans = 0;\n\n    for (const string& word : words)\n      if (isStretchy(s, word))\n        ++ans;\n\n    return ans;\n  }\n\n private:\n  bool isStretchy(const string& s, const string& word) {\n    const int n = s.length();\n    const int m = word.length();\n\n    int j = 0;\n    for (int i = 0; i < n; ++i)\n      if (j < m && s[i] == word[j])\n        ++j;\n      else if (i > 1 && s[i] == s[i - 1] && s[i - 1] == s[i - 2])\n        continue;\n      else if (0 < i && i + 1 < n && s[i - 1] == s[i] && s[i] == s[i + 1])\n        continue;\n      else\n        return false;\n\n    return j == m;\n  }\n};\n", "81": "class Solution {\n public:\n  bool search(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l <= r) {\n      const int m = (l + r) / 2;\n      if (nums[m] == target)\n        return true;\n      if (nums[l] == nums[m] && nums[m] == nums[r]) {\n        ++l;\n        --r;\n      } else if (nums[l] <= nums[m]) {  // nums[l..m] are sorted\n        if (nums[l] <= target && target < nums[m])\n          r = m - 1;\n        else\n          l = m + 1;\n      } else {  // nums[m..n - 1] are sorted\n        if (nums[m] < target && target <= nums[r])\n          l = m + 1;\n        else\n          r = m - 1;\n      }\n    }\n\n    return false;\n  }\n};\n", "810": "class Solution {\n public:\n  bool xorGame(vector<int>& nums) {\n    const int xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\n    return xors == 0 || nums.size() % 2 == 0;\n  }\n};\n", "811": "class Solution {\n public:\n  vector<string> subdomainVisits(vector<string>& cpdomains) {\n    vector<string> ans;\n    unordered_map<string, int> count;\n\n    for (const string& cpdomain : cpdomains) {\n      const int space = cpdomain.find(' ');\n      const int num = stoi(cpdomain.substr(0, space));\n      const string& domain = cpdomain.substr(space + 1);\n      count[domain] += num;\n      for (int i = 0; i < domain.length(); ++i)\n        if (domain[i] == '.')\n          count[domain.substr(i + 1)] += num;\n    }\n\n    for (const auto& [subdomain, freq] : count)\n      ans.push_back(to_string(freq) + ' ' + subdomain);\n\n    return ans;\n  }\n};\n", "812": "class Solution {\n public:\n  double largestTriangleArea(vector<vector<int>>& points) {\n    double ans = 0;\n\n    for (const vector<int>& A : points)\n      for (const vector<int>& B : points)\n        for (const vector<int>& C : points)\n          ans = max(ans, 0.5 * abs((B[0] - A[0]) * (C[1] - A[1]) -\n                                   (C[0] - A[0]) * (B[1] - A[1])));\n\n    return ans;\n  }\n};\n", "813": "class Solution {\n public:\n  double largestSumOfAverages(vector<int>& nums, int K) {\n    const int n = nums.size();\n    // dp[i][k] := the maximum score to partition the first i nums into k groups\n    vector<vector<double>> dp(n + 1, vector<double>(K + 1));\n    vector<double> prefix(n + 1);\n\n    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);\n\n    for (int i = 1; i <= n; ++i)\n      dp[i][1] = prefix[i] / i;\n\n    for (int k = 2; k <= K; ++k)\n      for (int i = k; i <= n; ++i)\n        for (int j = k - 1; j < i; ++j) {\n          const double average = (prefix[i] - prefix[j]) / (i - j);\n          dp[i][k] = max(dp[i][k], dp[j][k - 1] + average);\n        }\n\n    return dp[n][K];\n  }\n};\n", "814": "class Solution {\n public:\n  TreeNode* pruneTree(TreeNode* root) {\n    if (root == nullptr)\n      return nullptr;\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (root->left == nullptr && root->right == nullptr && root->val == 0)\n      return nullptr;\n    return root;\n  }\n};\n", "815": "class Solution {\n public:\n  int numBusesToDestination(vector<vector<int>>& routes, int source,\n                            int target) {\n    if (source == target)\n      return 0;\n\n    unordered_map<int, vector<int>> graph;  // {route: [buses]}\n    unordered_set<int> usedBuses;\n\n    for (int i = 0; i < routes.size(); ++i)\n      for (const int route : routes[i])\n        graph[route].push_back(i);\n\n    queue<int> q{{source}};\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int route = q.front();\n        q.pop();\n        for (const int bus : graph[route])\n          if (usedBuses.insert(bus).second)\n            for (const int nextRoute : routes[bus]) {\n              if (nextRoute == target)\n                return step;\n              q.push(nextRoute);\n            }\n      }\n\n    return -1;\n  }\n};\n", "816": "class Solution {\n public:\n  vector<string> ambiguousCoordinates(string s) {\n    vector<string> ans;\n    s = s.substr(1, s.length() - 2);\n\n    for (int i = 1; i < s.length(); ++i)\n      for (const string& x : splits(s.substr(0, i)))\n        for (const string& y : splits(s.substr(i)))\n          ans.push_back('(' + x + \", \" + y + ')');\n\n    return ans;\n  }\n\n private:\n  vector<string> splits(const string& s) {\n    if (s.empty() || s.length() > 1 && s.front() == '0' && s.back() == '0')\n      return {};\n    if (s.back() == '0')\n      return {s};\n    if (s.front() == '0')\n      return {\"0.\" + s.substr(1)};\n\n    vector<string> candidates{s};\n    for (int i = 1; i < s.length(); ++i)\n      candidates.push_back(s.substr(0, i) + '.' + s.substr(i));\n    return candidates;\n  }\n};\n", "817": "class Solution {\n public:\n  int numComponents(ListNode* head, vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> setNums{nums.begin(), nums.end()};\n\n    for (; head; head = head->next)\n      if (setNums.contains(head->val) &&\n          (!head->next || !setNums.contains(head->next->val)))\n        ++ans;\n\n    return ans;\n  }\n};\n", "818": "class Solution {\n public:\n  int racecar(int target) {\n    vector<int> mem(target + 1, -1);\n    return racecar(target, mem);\n  }\n\n private:\n  int racecar(int i, vector<int>& mem) {\n    if (mem[i] >= 0)\n      return mem[i];\n\n    int res = INT_MAX;\n    int x = 1;             // xA := (2^x - 1) unit distance\n    int j = (1 << x) - 1;  // j = 2^x - 1, k = 2^y - 1\n\n    // (xA + 1R) + (yA + 1R) + racecar(i - (j - k))\n    for (; j < i; j = (1 << ++x) - 1)\n      for (int y = 0, k = 0; k < j; k = (1 << ++y) - 1)\n        res = min(res, (x + 1) + (y + 1) + racecar(i - (j - k), mem));\n\n    // xA || (xA + 1R) + racecar(j - i)\n    return mem[i] = min(res, i == j ? x : x + 1 + racecar(j - i, mem));\n  }\n};\n", "819": "class Solution {\n public:\n  string mostCommonWord(string paragraph, vector<string>& banned) {\n    string ans;\n    int maxCount = 0;\n    unordered_map<string, int> count;\n    unordered_set<string> bannedSet{banned.begin(), banned.end()};\n\n    // Make the paragraph lowercased and remove all the punctuations.\n    for (char& c : paragraph)\n      c = isalpha(c) ? tolower(c) : ' ';\n\n    istringstream iss(paragraph);\n\n    for (string word; iss >> word;)\n      if (!bannedSet.contains(word))\n        ++count[word];\n\n    for (const auto& [word, freq] : count)\n      if (freq > maxCount) {\n        maxCount = freq;\n        ans = word;\n      }\n\n    return ans;\n  }\n};\n", "82": "class Solution {\n public:\n  ListNode* deleteDuplicates(ListNode* head) {\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n\n    while (head != nullptr) {\n      while (head->next && head->val == head->next->val)\n        head = head->next;\n      if (prev->next == head)\n        prev = prev->next;\n      else\n        prev->next = head->next;\n      head = head->next;\n    }\n\n    return dummy.next;\n  }\n};\n", "820": "class Solution {\n public:\n  int minimumLengthEncoding(vector<string>& words) {\n    unordered_set<string_view> wordsSet(words.begin(), words.end());\n\n    for (const string& word : words) {\n      const string_view sv(word);\n      for (int i = 1; i < word.length(); ++i)\n        wordsSet.erase(sv.substr(i));\n    }\n\n    return accumulate(\n        wordsSet.begin(), wordsSet.end(), 0,\n        [](int acc, const auto& sv) { return acc + sv.length() + 1; });\n  }\n};\n", "821": "class Solution {\n public:\n  vector<int> shortestToChar(string s, char c) {\n    const int n = s.length();\n    vector<int> ans(n);\n    int prev = -n;\n\n    for (int i = 0; i < n; ++i) {\n      if (s[i] == c)\n        prev = i;\n      ans[i] = i - prev;\n    }\n\n    for (int i = prev - 1; i >= 0; --i) {\n      if (s[i] == c)\n        prev = i;\n      ans[i] = min(ans[i], prev - i);\n    }\n\n    return ans;\n  }\n};\n", "822": "class Solution {\n public:\n  int flipgame(vector<int>& fronts, vector<int>& backs) {\n    constexpr int kMax = 2001;\n    int ans = kMax;\n    unordered_set<int> same;\n\n    for (int i = 0; i < fronts.size(); ++i)\n      if (fronts[i] == backs[i])\n        same.insert(fronts[i]);\n\n    for (const int front : fronts)\n      if (!same.contains(front))\n        ans = min(ans, front);\n\n    for (const int back : backs)\n      if (!same.contains(back))\n        ans = min(ans, back);\n\n    return ans == kMax ? 0 : ans;\n  }\n};\n", "823": "class Solution {\n public:\n  int numFactoredBinaryTrees(vector<int>& arr) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = arr.size();\n    // dp[i] := the number of binary trees with arr[i] as the root\n    vector<long> dp(n, 1);\n    unordered_map<int, int> numToIndex;\n\n    ranges::sort(arr);\n\n    for (int i = 0; i < n; ++i)\n      numToIndex[arr[i]] = i;\n\n    for (int i = 0; i < n; ++i)  // arr[i] is the root\n      for (int j = 0; j < i; ++j)\n        if (arr[i] % arr[j] == 0) {  // arr[j] is the left subtree\n          const int right = arr[i] / arr[j];\n          if (const auto it = numToIndex.find(right); it != numToIndex.cend()) {\n            dp[i] += dp[j] * dp[it->second];\n            dp[i] %= kMod;\n          }\n        }\n\n    return accumulate(dp.begin(), dp.end(), 0L) % kMod;\n  }\n};\n", "824": "class Solution {\n public:\n  string toGoatLatin(string sentence) {\n    string ans;\n    istringstream iss(sentence);\n\n    int i = 1;\n    for (string word; iss >> word;) {\n      if (i > 1)\n        ans += ' ';\n      if (isVowel(word[0]))\n        ans += word;\n      else\n        ans += word.substr(1) + word[0];\n      ans += \"ma\" + string(i++, 'a');\n    }\n\n    return ans;\n  }\n\n private:\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "825": "class Solution {\n public:\n  int numFriendRequests(vector<int>& ages) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int age : ages)\n      ++count[age];\n\n    for (const auto& [ageA, countA] : count)\n      for (const auto& [ageB, countB] : count)\n        if (request(ageA, ageB))\n          if (ageA == ageB)\n            ans += countA * (countB - 1);\n          else\n            ans += countA * countB;\n\n    return ans;\n  }\n\n private:\n  bool request(int ageA, int ageB) {\n    return !(ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100);\n  }\n};\n", "826": "class Solution {\n public:\n  int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,\n                          vector<int>& worker) {\n    int ans = 0;\n    vector<pair<int, int>> jobs;\n\n    for (int i = 0; i < difficulty.size(); ++i)\n      jobs.emplace_back(difficulty[i], profit[i]);\n\n    ranges::sort(jobs);\n    ranges::sort(worker);\n\n    int i = 0;\n    int maxProfit = 0;\n\n    for (const int w : worker) {\n      for (; i < jobs.size() && w >= jobs[i].first; ++i)\n        maxProfit = max(maxProfit, jobs[i].second);\n      ans += maxProfit;\n    }\n\n    return ans;\n  }\n};\n", "827": "class Solution {\n public:\n  int largestIsland(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int maxSize = 0;\n    // sizes[i] := the size of the i-th connected component (starting from 2)\n    vector<int> sizes{0, 0};\n\n    // For each 1 in the grid, paint all the connected 1s with the next\n    // available color (2, 3, and so on). Also, remember the size of the island\n    // we just painted with that color.\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          sizes.push_back(paint(grid, i, j, sizes.size()));  // Paint 2, 3, ...\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 0) {\n          const unordered_set<int> neighborIds{\n              getId(grid, i + 1, j), getId(grid, i - 1, j),\n              getId(grid, i, j + 1), getId(grid, i, j - 1)};\n          maxSize = max(maxSize, 1 + getSize(neighborIds, sizes));\n        }\n\n    return maxSize == 0 ? m * n : maxSize;\n  }\n\n private:\n  int paint(vector<vector<int>>& grid, int i, int j, int id) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return 0;\n    if (grid[i][j] != 1)\n      return 0;\n    grid[i][j] = id;  // grid[i][j] is part of the id-th connected component.\n    return 1 + paint(grid, i + 1, j, id) + paint(grid, i - 1, j, id) +\n           paint(grid, i, j + 1, id) + paint(grid, i, j - 1, id);\n  }\n\n  // Gets the id of grid[i][j] and returns 0 if it's out-of-bounds.\n  int getId(const vector<vector<int>>& grid, int i, int j) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return 0;  // Invalid\n    return grid[i][j];\n  }\n\n  int getSize(const unordered_set<int>& neighborIds, const vector<int>& sizes) {\n    int size = 0;\n    for (const int neighborId : neighborIds)\n      size += sizes[neighborId];\n    return size;\n  }\n};\n", "828": "class Solution {\n public:\n  int uniqueLetterString(string s) {\n    const int n = s.length();\n    int ans = 0;\n    // lastSeen[c] := the index of the last time ('a' + i) appeared\n    vector<int> lastSeen(26, -1);\n    // prevSeen[c] := the previous index of the last time ('a' + i) appeared\n    vector<int> prevLastSeen(26, -1);\n\n    for (int i = 0; i < n; ++i) {\n      const int c = s[i] - 'A';\n      if (lastSeen[c] != -1)\n        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c]);\n      prevLastSeen[c] = lastSeen[c];\n      lastSeen[c] = i;\n    }\n\n    for (int c = 0; c < 26; ++c)\n      ans += (n - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c]);\n\n    return ans;\n  }\n};\n", "829": "class Solution {\n public:\n  int consecutiveNumbersSum(int n) {\n    int ans = 0;\n    for (int i = 1, triangleNum = i; triangleNum <= n; ++i, triangleNum += i)\n      if ((n - triangleNum) % i == 0)\n        ++ans;\n    return ans;\n  }\n};\n", "83": "class Solution {\n public:\n  ListNode* deleteDuplicates(ListNode* head) {\n    ListNode* curr = head;\n\n    while (curr != nullptr) {\n      while (curr->next && curr->val == curr->next->val)\n        curr->next = curr->next->next;\n      curr = curr->next;\n    }\n\n    return head;\n  }\n};\n", "830": "class Solution {\n public:\n  vector<vector<int>> largeGroupPositions(string s) {\n    const int n = s.length();\n    vector<vector<int>> ans;\n\n    for (int i = 0, j = 0; i < n; i = j) {\n      while (j < n && s[j] == s[i])\n        ++j;\n      if (j - i >= 3)\n        ans.push_back({i, j - 1});\n    }\n\n    return ans;\n  }\n};\n", "831": "class Solution {\n public:\n  string maskPII(string s) {\n    const int atIndex = s.find('@');\n    if (atIndex != string::npos) {\n      ranges::transform(s, s.begin(), ::tolower);\n      return s.substr(0, 1) + \"*****\" + s.substr(atIndex - 1);\n    }\n\n    string ans;\n    for (const char c : s)\n      if (isdigit(c))\n        ans += c;\n\n    if (ans.length() == 10)\n      return \"***-***-\" + ans.substr(ans.length() - 4);\n    return '+' + string(ans.length() - 10, '*') + \"-***-***-\" +\n           ans.substr(ans.length() - 4);\n  }\n};\n", "832": "class Solution {\n public:\n  vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\n    const int n = A.size();\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < (n + 1) / 2; ++j) {\n        const int temp = A[i][j];\n        A[i][j] = A[i][n - j - 1] ^ 1;\n        A[i][n - j - 1] = temp ^ 1;\n      }\n\n    return A;\n  }\n};\n", "833": "class Solution {\n public:\n  string findReplaceString(string s, vector<int>& indices,\n                           vector<string>& sources, vector<string>& targets) {\n    vector<tuple<int, string, string>> operations;\n\n    for (int i = 0; i < indices.size(); ++i)\n      operations.emplace_back(indices[i], sources[i], targets[i]);\n\n    ranges::sort(operations, greater<>());\n\n    for (const auto& [index, source, target] : operations)\n      if (string_view(s.data() + index, source.length()) == source)\n        s = s.substr(0, index) + target + s.substr(index + source.length());\n\n    return s;\n  }\n};\n", "834": "class Solution {\n public:\n  vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {\n    vector<int> ans(n);\n    vector<int> count(n, 1);\n    vector<unordered_set<int>> tree(n);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      tree[u].insert(v);\n      tree[v].insert(u);\n    }\n\n    postorder(tree, 0, /*prev=*/-1, count, ans);\n    preorder(tree, 0, /*prev=*/-1, count, ans);\n    return ans;\n  }\n\n private:\n  void postorder(const vector<unordered_set<int>>& tree, int u, int prev,\n                 vector<int>& count, vector<int>& ans) {\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      postorder(tree, v, u, count, ans);\n      count[u] += count[v];\n      ans[u] += ans[v] + count[v];\n    }\n  }\n\n  void preorder(const vector<unordered_set<int>>& tree, int u, int prev,\n                vector<int>& count, vector<int>& ans) {\n    for (const int v : tree[u]) {\n      if (v == prev)\n        continue;\n      // count[v] us are 1 step closer from v than prev.\n      // (n - count[v]) us are 1 step farther from v than prev.\n      ans[v] = ans[u] - count[v] + (tree.size() - count[v]);\n      preorder(tree, v, u, count, ans);\n    }\n  }\n};\n", "835": "class Solution {\n public:\n  int largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) {\n    constexpr int kMagic = 100;\n    const int n = img1.size();\n    int ans = 0;\n    vector<pair<int, int>> ones1;\n    vector<pair<int, int>> ones2;\n    unordered_map<int, int> offsetCount;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (img1[i][j] == 1)\n          ones1.emplace_back(i, j);\n        if (img2[i][j] == 1)\n          ones2.emplace_back(i, j);\n      }\n\n    for (const auto& [ax, ay] : ones1)\n      for (const auto& [bx, by] : ones2)\n        ++offsetCount[(ax - bx) * kMagic + (ay - by)];\n\n    for (const auto& [_, count] : offsetCount)\n      ans = max(ans, count);\n\n    return ans;\n  }\n};\n", "836": "class Solution {\n public:\n  bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {\n    return rec1[0] < rec2[2] && rec2[0] < rec1[2] &&  //\n           rec1[1] < rec2[3] && rec2[1] < rec1[3];\n  }\n};\n", "837": "class Solution {\n public:\n  double new21Game(int n, int k, int maxPts) {\n    // When the game ends, the point is in [k..k - 1 maxPts].\n    //   P = 1, if n >= k - 1 + maxPts\n    //   P = 0, if n < k (note that the constraints already have k <= n)\n    if (k == 0 || n >= k - 1 + maxPts)\n      return 1.0;\n\n    double ans = 0.0;\n    vector<double> dp(n + 1);  // dp[i] := the probability to have i points\n    dp[0] = 1.0;\n    double windowSum = dp[0];  // P(i - 1) + P(i - 2) + ... + P(i - maxPts)\n\n    for (int i = 1; i <= n; ++i) {\n      // The probability to get i points is\n      // P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts\n      dp[i] = windowSum / maxPts;\n      if (i < k)\n        windowSum += dp[i];\n      else  // The game ends.\n        ans += dp[i];\n      if (i - maxPts >= 0)\n        windowSum -= dp[i - maxPts];\n    }\n\n    return ans;\n  }\n};\n", "838": "class Solution {\n public:\n  string pushDominoes(string dominoes) {\n    int L = -1;\n    int R = -1;\n\n    for (int i = 0; i <= dominoes.length(); ++i)\n      if (i == dominoes.length() || dominoes[i] == 'R') {\n        if (L < R)\n          while (R < i)\n            dominoes[R++] = 'R';\n        R = i;\n      } else if (dominoes[i] == 'L') {\n        if (R < L || L == -1 && R == -1) {\n          if (L == -1 && R == -1)\n            ++L;\n          while (L < i)\n            dominoes[L++] = 'L';\n        } else {\n          int l = R + 1;\n          int r = i - 1;\n          while (l < r) {\n            dominoes[l++] = 'R';\n            dominoes[r--] = 'L';\n          }\n        }\n        L = i;\n      }\n\n    return dominoes;\n  }\n};\n", "839": "class UnionFind {\n public:\n  UnionFind(int n) : count(n), id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n    --count;\n  }\n\n  int getCount() const {\n    return count;\n  }\n\n private:\n  int count;\n  vector<int> id;\n  vector<int> rank;\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n};\n\nclass Solution {\n public:\n  int numSimilarGroups(vector<string>& A) {\n    UnionFind uf(A.size());\n\n    for (int i = 1; i < A.size(); ++i)\n      for (int j = 0; j < i; ++j)\n        if (isSimilar(A[i], A[j]))\n          uf.unionByRank(i, j);\n\n    return uf.getCount();\n  }\n\n private:\n  bool isSimilar(const string& X, const string& Y) {\n    int diff = 0;\n    for (int i = 0; i < X.length(); ++i)\n      if (X[i] != Y[i] && ++diff > 2)\n        return false;\n    return true;\n  }\n};\n", "84": "class Solution {\n public:\n  int largestRectangleArea(vector<int>& heights) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = 0; i <= heights.size(); ++i) {\n      while (!stack.empty() &&\n             (i == heights.size() || heights[stack.top()] > heights[i])) {\n        const int h = heights[stack.top()];\n        stack.pop();\n        const int w = stack.empty() ? i : i - stack.top() - 1;\n        ans = max(ans, h * w);\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "840": "class Solution {\n public:\n  int numMagicSquaresInside(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i + 2 < grid.size(); ++i)\n      for (int j = 0; j + 2 < grid[0].size(); ++j)\n        if (grid[i][j] % 2 == 0 && grid[i + 1][j + 1] == 5)\n          ans += isMagic(grid, i, j);\n\n    return ans;\n  }\n\n private:\n  int isMagic(const vector<vector<int>>& grid, int i, int j) {\n    string s;\n\n    for (const int num : {0, 1, 2, 5, 8, 7, 6, 3})\n      s += to_string(grid[i + num / 3][j + num % 3]);\n\n    return string(\"4381672943816729\").find(s) != string::npos ||\n           string(\"9276183492761834\").find(s) != string::npos;\n  }\n};\n", "841": "class Solution {\n public:\n  bool canVisitAllRooms(vector<vector<int>>& rooms) {\n    vector<bool> seen(rooms.size());\n    dfs(rooms, 0, seen);\n    return ranges::all_of(seen, [](int s) { return s == true; });\n  }\n\n private:\n  void dfs(const vector<vector<int>>& rooms, int node, vector<bool>& seen) {\n    seen[node] = true;\n    for (const int child : rooms[node])\n      if (!seen[child])\n        dfs(rooms, child, seen);\n  }\n};\n", "842": "class Solution {\n public:\n  vector<int> splitIntoFibonacci(string num) {\n    vector<int> ans;\n    dfs(num, 0, ans);\n    return ans;\n  }\n\n private:\n  bool dfs(const string& num, int s, vector<int>& ans) {\n    if (s == num.length() && ans.size() >= 3)\n      return true;\n\n    for (int i = s; i < num.length(); ++i) {\n      if (num[s] == '0' && i > s)\n        break;\n      const long val = stol(num.substr(s, i + 1 - s));\n      if (val > INT_MAX)\n        break;\n      if (ans.size() >= 2 &&\n          val > ans[ans.size() - 2] + static_cast<long>(ans.back()))\n        break;\n      if (ans.size() <= 1 ||\n          val == ans[ans.size() - 2] + static_cast<long>(ans.back())) {\n        ans.push_back(val);\n        if (dfs(num, i + 1, ans))\n          return true;\n        ans.pop_back();\n      }\n    }\n\n    return false;\n  }\n};\n", "843": "/**\n * // This is the Master's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Master {\n *  public:\n *   int guess(string word);\n * };\n */\nclass Solution {\n public:\n  void findSecretWord(vector<string>& words, Master& master) {\n    srand(time(nullptr));\n\n    for (int i = 0; i < 10; ++i) {\n      const string& guessedWord = words[rand() % words.size()];\n      const int matches = master.guess(guessedWord);\n      if (matches == 6)\n        break;\n      vector<string> updated;\n      for (const string& word : words)\n        if (getMatches(guessedWord, word) == matches)\n          updated.push_back(word);\n      words = std::move(updated);\n    }\n  }\n\n private:\n  int getMatches(const string& s1, const string& s2) {\n    int matches = 0;\n    for (int i = 0; i < s1.length(); ++i)\n      if (s1[i] == s2[i])\n        ++matches;\n    return matches;\n  }\n};\n", "844": "class Solution {\n public:\n  bool backspaceCompare(string s, string t) {\n    int i = s.length() - 1;  // s' index\n    int j = t.length() - 1;  // t's index\n\n    while (true) {\n      // Delete characters of s if needed.\n      int backspace = 0;\n      while (i >= 0 && (s[i] == '#' || backspace > 0)) {\n        backspace += s[i] == '#' ? 1 : -1;\n        --i;\n      }\n      // Delete characters of t if needed.\n      backspace = 0;\n      while (j >= 0 && (t[j] == '#' || backspace > 0)) {\n        backspace += t[j] == '#' ? 1 : -1;\n        --j;\n      }\n      if (i >= 0 && j >= 0 && s[i] == t[j]) {\n        --i;\n        --j;\n      } else {\n        break;\n      }\n    }\n\n    return i == -1 && j == -1;\n  }\n};\n", "845": "class Solution {\n public:\n  int longestMountain(vector<int>& arr) {\n    int ans = 0;\n\n    for (int i = 0; i + 1 < arr.size();) {\n      while (i + 1 < arr.size() && arr[i] == arr[i + 1])\n        ++i;\n\n      int increasing = 0;\n      int decreasing = 0;\n\n      while (i + 1 < arr.size() && arr[i] < arr[i + 1]) {\n        ++increasing;\n        ++i;\n      }\n\n      while (i + 1 < arr.size() && arr[i] > arr[i + 1]) {\n        ++decreasing;\n        ++i;\n      }\n\n      if (increasing > 0 && decreasing > 0)\n        ans = max(ans, increasing + decreasing + 1);\n    }\n\n    return ans;\n  }\n};\n", "846": "class Solution {\n public:\n  bool isNStraightHand(vector<int>& hand, int groupSize) {\n    map<int, int> count;\n\n    for (const int card : hand)\n      ++count[card];\n\n    for (const auto& [start, _] : count) {\n      const int value = count[start];\n      if (value > 0)\n        for (int i = start; i < start + groupSize; ++i) {\n          count[i] -= value;\n          if (count[i] < 0)\n            return false;\n        }\n    }\n\n    return true;\n  }\n};\n", "847": "class Solution {\n public:\n  int shortestPathLength(vector<vector<int>>& graph) {\n    const int n = graph.size();\n    const int goal = (1 << n) - 1;\n    queue<pair<int, int>> q;  // (u, state)\n    vector<vector<bool>> seen(n, vector<bool>(1 << n));\n\n    for (int i = 0; i < n; ++i)\n      q.emplace(i, 1 << i);\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [u, state] = q.front();\n        q.pop();\n        if (state == goal)\n          return step;\n        if (seen[u][state])\n          continue;\n        seen[u][state] = true;\n        for (const int v : graph[u])\n          q.emplace(v, state | 1 << v);\n      }\n\n    return -1;\n  }\n};\n", "848": "class Solution {\n public:\n  string shiftingLetters(string s, vector<int>& shifts) {\n    string ans;\n\n    for (int i = shifts.size() - 2; i >= 0; --i)\n      shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n\n    for (int i = 0; i < s.length(); ++i)\n      ans += (s[i] - 'a' + shifts[i]) % 26 + 'a';\n\n    return ans;\n  }\n};\n", "849": "class Solution {\n public:\n  int maxDistToClosest(vector<int>& seats) {\n    const int n = seats.size();\n    int ans = 0;\n    int j = -1;\n\n    for (int i = 0; i < n; ++i)\n      if (seats[i] == 1) {\n        ans = j == -1 ? i : max(ans, (i - j) / 2);\n        j = i;\n      }\n\n    return max(ans, n - j - 1);\n  }\n};\n", "85": "class Solution {\n public:\n  int maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty())\n      return 0;\n\n    int ans = 0;\n    vector<int> hist(matrix[0].size());\n\n    for (const vector<char>& row : matrix) {\n      for (int i = 0; i < row.size(); ++i)\n        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;\n      ans = max(ans, largestRectangleArea(hist));\n    }\n\n    return ans;\n  }\n\n private:\n  int largestRectangleArea(const vector<int>& heights) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = 0; i <= heights.size(); ++i) {\n      while (!stack.empty() &&\n             (i == heights.size() || heights[stack.top()] > heights[i])) {\n        const int h = heights[stack.top()];\n        stack.pop();\n        const int w = stack.empty() ? i : i - stack.top() - 1;\n        ans = max(ans, h * w);\n      }\n      stack.push(i);\n    }\n\n    return ans;\n  }\n};\n", "850": "struct Event {\n  int x;\n  int y1;\n  int y2;\n  char type;\n};\n\nclass Solution {\n public:\n  int rectangleArea(vector<vector<int>>& rectangles) {\n    constexpr int kMod = 1'000'000'007;\n    vector<Event> events;\n\n    for (const vector<int>& r : rectangles) {\n      events.emplace_back(r[0], r[1], r[3], 's');\n      events.emplace_back(r[2], r[1], r[3], 'e');\n    }\n\n    ranges::sort(events, ranges::less{},\n                 [](const Event& event) { return event.x; });\n\n    long ans = 0;\n    int prevX = 0;\n    vector<pair<int, int>> yPairs;\n\n    for (const auto& [currX, y1, y2, type] : events) {\n      if (currX > prevX) {\n        const int width = currX - prevX;\n        ans = (ans + width * getHeight(yPairs)) % kMod;\n        prevX = currX;\n      }\n      if (type == 's') {\n        yPairs.emplace_back(y1, y2);\n        ranges::sort(yPairs);\n      } else {  // type == 'e'\n        const auto it =\n            find(yPairs.begin(), yPairs.end(), pair<int, int>(y1, y2));\n        yPairs.erase(it);\n      }\n    }\n\n    return ans % kMod;\n  }\n\n private:\n  long getHeight(const vector<pair<int, int>>& yPairs) {\n    int height = 0;\n    int prevY = 0;\n\n    for (const auto& [y1, y2] : yPairs) {\n      prevY = max(prevY, y1);\n      if (y2 > prevY) {\n        height += y2 - prevY;\n        prevY = y2;\n      }\n    }\n\n    return height;\n  }\n};\n", "851": "class Solution {\n public:\n  vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\n    const int n = quiet.size();\n    vector<int> ans(n, -1);\n    vector<vector<int>> graph(n);\n\n    for (const vector<int>& r : richer) {\n      const int u = r[1];\n      const int v = r[0];\n      graph[u].push_back(v);\n    }\n\n    for (int i = 0; i < n; ++i)\n      dfs(graph, i, quiet, ans);\n\n    return ans;\n  }\n\n private:\n  int dfs(const vector<vector<int>>& graph, int u, const vector<int>& quiet,\n          vector<int>& ans) {\n    if (ans[u] != -1)\n      return ans[u];\n\n    ans[u] = u;\n\n    for (const int v : graph[u]) {\n      const int res = dfs(graph, v, quiet, ans);\n      if (quiet[res] < quiet[ans[u]])\n        ans[u] = res;\n    }\n\n    return ans[u];\n  }\n};\n", "852": "class Solution {\n public:\n  int peakIndexInMountainArray(vector<int>& arr) {\n    int l = 0;\n    int r = arr.size() - 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (arr[m] >= arr[m + 1])\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n};\n", "853": "struct Car {\n  int pos;\n  double time;  // the time to reach the target\n};\n\nclass Solution {\n public:\n  int carFleet(int target, vector<int>& position, vector<int>& speed) {\n    int ans = 0;\n    vector<Car> cars(position.size());\n\n    for (int i = 0; i < position.size(); ++i)\n      cars[i] = {position[i], (double)(target - position[i]) / speed[i]};\n\n    ranges::sort(cars, ranges::greater{},\n                 [](const Car& car) { return car.pos; });\n\n    double maxTime = 0;  // the time of the slowest car to reach the target\n\n    for (const Car& car : cars)\n      // A car needs more time to reach the target, so it becomes the slowest.\n      if (car.time > maxTime) {\n        maxTime = car.time;\n        ++ans;\n      }\n\n    return ans;\n  }\n};\n", "854": "class Solution {\n public:\n  int kSimilarity(string s1, string s2) {\n    queue<string> q{{s1}};\n    unordered_set<string> seen{{s1}};\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        string curr = q.front();\n        q.pop();\n        if (curr == s2)\n          return step;\n        for (const string& child : getChildren(curr, s2)) {\n          if (seen.contains(child))\n            continue;\n          q.push(child);\n          seen.insert(child);\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  vector<string> getChildren(string& curr, const string& target) {\n    vector<string> children;\n    int i = 0;  // the first index s.t. curr[i] != target[i]\n    while (curr[i] == target[i])\n      ++i;\n\n    for (int j = i + 1; j < curr.length(); ++j)\n      if (curr[j] == target[i]) {\n        swap(curr[i], curr[j]);\n        children.push_back(curr);\n        swap(curr[i], curr[j]);\n      }\n\n    return children;\n  }\n};\n", "855": "class ExamRoom {\n public:\n  ExamRoom(int n) : n(n) {}\n\n  int seat() {\n    if (students.empty()) {\n      students.push_back(0);\n      map[0] = students.begin();\n      return 0;\n    }\n\n    int prevStudent = -1;\n    int maxDistToClosest = 0;\n    int val = 0;              // the inserted value\n    list<int>::iterator pos;  // the inserted position\n\n    for (auto it = students.begin(); it != students.end(); ++it) {\n      if (prevStudent == -1) {   // We haven't insert anything before.\n        maxDistToClosest = *it;  // the distance between it and the begining\n        pos = it;\n      } else if ((*it - prevStudent) / 2 > maxDistToClosest) {\n        maxDistToClosest = (*it - prevStudent) / 2;\n        val = (*it + prevStudent) / 2;\n        pos = it;\n      }\n      prevStudent = *it;\n    }\n\n    if (n - 1 - students.back() > maxDistToClosest) {\n      pos = students.end();\n      val = n - 1;\n    }\n\n    map[val] = students.insert(pos, val);\n    return val;\n  }\n\n  void leave(int p) {\n    students.erase(map[p]);\n  }\n\n private:\n  const int n;\n  list<int> students;\n  unordered_map<int, list<int>::iterator> map;  // {p: student iterator}\n};\n", "856": "class Solution {\n public:\n  int scoreOfParentheses(string s) {\n    int ans = 0;\n    int layer = 0;\n\n    for (int i = 0; i + 1 < s.length(); ++i) {\n      const char a = s[i];\n      const char b = s[i + 1];\n      if (a == '(' && b == ')')\n        ans += 1 << layer;\n      layer += a == '(' ? 1 : -1;\n    }\n\n    return ans;\n  }\n};\n", "857": "class Solution {\n public:\n  double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {\n    double ans = DBL_MAX;\n    int qualitySum = 0;\n    // (wagePerQuality, quality) sorted by wagePerQuality\n    vector<pair<double, int>> workers;\n    priority_queue<int> maxHeap;\n\n    for (int i = 0; i < quality.size(); ++i)\n      workers.emplace_back((double)wage[i] / quality[i], quality[i]);\n\n    ranges::sort(workers);\n\n    for (const auto& [wagePerQuality, q] : workers) {\n      maxHeap.push(q);\n      qualitySum += q;\n      if (maxHeap.size() > k)\n        qualitySum -= maxHeap.top(), maxHeap.pop();\n      if (maxHeap.size() == k)\n        ans = min(ans, qualitySum * wagePerQuality);\n    }\n\n    return ans;\n  }\n};\n", "858": "class Solution {\n public:\n  int mirrorReflection(int p, int q) {\n    while (p % 2 == 0 && q % 2 == 0) {\n      p /= 2;\n      q /= 2;\n    }\n\n    if (p % 2 == 0)\n      return 2;\n    if (q % 2 == 0)\n      return 0;\n    return 1;\n  }\n};\n", "859": "class Solution {\n public:\n  bool buddyStrings(string s, string goal) {\n    if (s.length() != goal.length())\n      return false;\n    if (s == goal && hasDuplicateLetters(s))\n      return true;\n\n    vector<int> diffIndices;\n\n    for (int i = 0; i < s.length(); ++i)\n      if (s[i] != goal[i])\n        diffIndices.push_back(i);\n\n    return diffIndices.size() == 2 &&\n           s[diffIndices[0]] == goal[diffIndices[1]] &&\n           s[diffIndices[1]] == goal[diffIndices[0]];\n  }\n\n private:\n  bool hasDuplicateLetters(const string& s) {\n    vector<int> count(26);\n    for (const char c : s)\n      ++count[c - 'a'];\n    return ranges::any_of(count, [](int freq) { return freq > 1; });\n  }\n};\n", "86": "class Solution {\n public:\n  ListNode* partition(ListNode* head, int x) {\n    ListNode beforeHead(0);\n    ListNode afterHead(0);\n    ListNode* before = &beforeHead;\n    ListNode* after = &afterHead;\n\n    for (; head; head = head->next)\n      if (head->val < x) {\n        before->next = head;\n        before = head;\n      } else {\n        after->next = head;\n        after = head;\n      }\n\n    after->next = nullptr;\n    before->next = afterHead.next;\n\n    return beforeHead.next;\n  };\n};\n", "860": "class Solution {\n public:\n  bool lemonadeChange(vector<int>& bills) {\n    int fives = 0;\n    int tens = 0;\n\n    for (const int bill : bills) {\n      if (bill == 5) {\n        ++fives;\n      } else if (bill == 10) {\n        --fives;\n        ++tens;\n      } else {  // bill == 20\n        if (tens > 0) {\n          --tens;\n          --fives;\n        } else {\n          fives -= 3;\n        }\n      }\n      if (fives < 0)\n        return false;\n    }\n\n    return true;\n  }\n};\n", "861": "class Solution {\n public:\n  int matrixScore(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int ans = m;  // All the cells in the first column are 1.\n\n    for (int j = 1; j < n; ++j) {\n      int onesCount = 0;\n      for (int i = 0; i < m; ++i)\n        // The best strategy is flipping the rows with a leading 0..\n        onesCount += grid[i][j] == grid[i][0];\n      ans = ans * 2 + max(onesCount, m - onesCount);\n    }\n\n    return ans;\n  }\n};\n", "862": "class Solution {\n public:\n  int shortestSubarray(vector<int>& nums, int k) {\n    const int n = nums.size();\n    int ans = n + 1;\n    deque<int> dq;\n    vector<long> prefix{0};\n\n    for (int i = 0; i < n; ++i)\n      prefix.push_back(prefix.back() + nums[i]);\n\n    for (int i = 0; i < n + 1; ++i) {\n      while (!dq.empty() && prefix[i] - prefix[dq.front()] >= k)\n        ans = min(ans, i - dq.front()), dq.pop_front();\n      while (!dq.empty() && prefix[i] <= prefix[dq.back()])\n        dq.pop_back();\n      dq.push_back(i);\n    }\n\n    return ans <= n ? ans : -1;\n  }\n};\n", "863": "class Solution {\n public:\n  vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n    vector<int> ans;\n    unordered_map<TreeNode*, int> nodeToDist;  // {node: distance to target}\n\n    getDists(root, target, nodeToDist);\n    dfs(root, k, 0, nodeToDist, ans);\n    return ans;\n  }\n\n private:\n  void getDists(TreeNode* root, TreeNode* target,\n                unordered_map<TreeNode*, int>& nodeToDist) {\n    if (root == nullptr)\n      return;\n    if (root == target) {\n      nodeToDist[root] = 0;\n      return;\n    }\n\n    getDists(root->left, target, nodeToDist);\n    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {\n      // The target is in the left subtree.\n      nodeToDist[root] = it->second + 1;\n      return;\n    }\n\n    getDists(root->right, target, nodeToDist);\n    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())\n      // The target is in the right subtree.\n      nodeToDist[root] = it->second + 1;\n  }\n\n  void dfs(TreeNode* root, int k, int dist,\n           unordered_map<TreeNode*, int>& nodeToDist, vector<int>& ans) {\n    if (root == nullptr)\n      return;\n    if (const auto it = nodeToDist.find(root); it != nodeToDist.cend())\n      dist = it->second;\n    if (dist == k)\n      ans.push_back(root->val);\n\n    dfs(root->left, k, dist + 1, nodeToDist, ans);\n    dfs(root->right, k, dist + 1, nodeToDist, ans);\n  }\n};\n", "864": "struct T {\n  int i;\n  int j;\n  int keys;  // the keys in the bitmask\n};\n\nclass Solution {\n public:\n  int shortestPathAllKeys(vector<string>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].length();\n    const int keysCount = getKeysCount(grid);\n    const int kKeys = (1 << keysCount) - 1;\n    const vector<int> start = getStart(grid);\n    queue<T> q{{{start[0], start[1], 0}}};\n    vector<vector<vector<bool>>> seen(\n        m, vector<vector<bool>>(n, vector<bool>(kKeys)));\n    seen[start[0]][start[1]][0] = true;\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j, keys] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          const char c = grid[x][y];\n          if (c == '#')\n            continue;\n          const int newKeys = 'a' <= c && c <= 'f' ? keys | 1 << c - 'a' : keys;\n          if (newKeys == kKeys)\n            return step;\n          if (seen[x][y][newKeys])\n            continue;\n          if ('A' <= c && c <= 'F' && (newKeys >> c - 'A' & 1) == 0)\n            continue;\n          q.emplace(x, y, newKeys);\n          seen[x][y][newKeys] = true;\n        }\n      }\n\n    return -1;\n  }\n\n private:\n  int getKeysCount(const vector<string>& grid) {\n    int count = 0;\n    for (const string& s : grid)\n      count += ranges::count_if(s, [](char c) { return 'a' <= c && c <= 'f'; });\n    return count;\n  }\n\n  vector<int> getStart(const vector<string>& grid) {\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].length(); ++j)\n        if (grid[i][j] == '@')\n          return {i, j};\n    throw;\n  }\n};\n", "865": "struct T {\n  TreeNode* lca;\n  int depth;\n};\n\nclass Solution {\n public:\n  TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n    return dfs(root).lca;\n  }\n\n private:\n  T dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {nullptr, 0};\n\n    const T left = dfs(root->left);\n    const T right = dfs(root->right);\n    if (left.depth > right.depth)\n      return {left.lca, left.depth + 1};\n    if (left.depth < right.depth)\n      return {right.lca, right.depth + 1};\n    return {root, left.depth + 1};\n  }\n};\n", "866": "class Solution {\n public:\n  int primePalindrome(int n) {\n    if (n <= 2)\n      return 2;\n    if (n == 3)\n      return 3;\n    if (n <= 5)\n      return 5;\n    if (n <= 7)\n      return 7;\n    if (n <= 11)\n      return 11;\n\n    int nLength = to_string(n).length();\n\n    while (true) {\n      for (const int num : getPalindromes(nLength))\n        if (num >= n && isPrime(num))\n          return num;\n      ++nLength;\n    }\n\n    throw;\n  }\n\n private:\n  vector<int> getPalindromes(int n) {\n    vector<int> palindromes;\n    const int length = n / 2;\n\n    for (int i = pow(10, length - 1); i < pow(10, length); ++i) {\n      const string s = to_string(i);\n      string reversedS = s;\n      ranges::reverse(reversedS);\n      for (int j = 0; j < 10; ++j)\n        palindromes.push_back(stoi(s + to_string(j) + reversedS));\n    }\n\n    return palindromes;\n  }\n\n  bool isPrime(int num) {\n    for (int i = 2; i < sqrt(num) + 1; ++i)\n      if (num % i == 0)\n        return false;\n    return true;\n  }\n};\n", "867": "class Solution {\n public:\n  vector<vector<int>> transpose(vector<vector<int>>& A) {\n    vector<vector<int>> ans(A[0].size(), vector<int>(A.size()));\n\n    for (int i = 0; i < A.size(); ++i)\n      for (int j = 0; j < A[0].size(); ++j)\n        ans[j][i] = A[i][j];\n\n    return ans;\n  }\n};\n", "868": "class Solution {\n public:\n  int binaryGap(int n) {\n    int ans = 0;\n\n    // d := the distance between any two 1s\n    for (int d = -32; n; n /= 2, ++d)\n      if (n % 2 == 1) {\n        ans = max(ans, d);\n        d = 0;\n      }\n\n    return ans;\n  }\n};\n", "869": "class Solution {\n public:\n  bool reorderedPowerOf2(int n) {\n    int count = counter(n);\n\n    for (int i = 0; i < 30; ++i)\n      if (counter(1 << i) == count)\n        return true;\n\n    return false;\n  }\n\n private:\n  int counter(int n) {\n    int count = 0;\n\n    for (; n > 0; n /= 10)\n      count += pow(10, n % 10);\n\n    return count;\n  }\n};\n", "87": "class Solution {\n public:\n  bool isScramble(string s1, string s2) {\n    if (s1 == s2)\n      return true;\n    const string hashKey = s1 + '+' + s2;\n    if (const auto it = mem.find(hashKey); it != mem.cend())\n      return it->second;\n\n    vector<int> count(128);\n\n    for (int i = 0; i < s1.length(); ++i) {\n      ++count[s1[i]];\n      --count[s2[i]];\n    }\n\n    if (ranges::any_of(count, [](int c) { return c != 0; }))\n      return mem[hashKey] = false;\n\n    for (int i = 1; i < s1.length(); ++i) {\n      if (isScramble(s1.substr(0, i), s2.substr(0, i)) &&\n          isScramble(s1.substr(i), s2.substr(i)))\n        return mem[hashKey] = true;\n      if (isScramble(s1.substr(0, i), s2.substr(s2.length() - i)) &&\n          isScramble(s1.substr(i), s2.substr(0, s2.length() - i)))\n        return mem[hashKey] = true;\n    }\n\n    return mem[hashKey] = false;\n  }\n\n private:\n  unordered_map<string, bool> mem;\n};\n", "870": "class Solution {\n public:\n  vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\n    multiset<int> set{nums1.begin(), nums1.end()};\n\n    for (int i = 0; i < nums2.size(); ++i) {\n      const auto p =\n          *set.rbegin() <= nums2[i] ? set.begin() : set.upper_bound(nums2[i]);\n      nums1[i] = *p;\n      set.erase(p);\n    }\n\n    return nums1;\n  }\n};\n", "871": "class Solution {\n public:\n  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n    int ans = 0;\n    int i = 0;  // stations' index\n    int curr = startFuel;\n    priority_queue<int> maxHeap;\n\n    while (curr < target) {\n      // Add all the reachable stops to maxHeap\n      while (i < stations.size() && curr >= stations[i][0])\n        maxHeap.push(stations[i++][1]);\n      if (maxHeap.empty())  // Can't be refueled.\n        return -1;\n      curr += maxHeap.top(), maxHeap.pop();  // Pop out the largest gas.\n      ++ans;                                 // Then, refuel once.\n    }\n\n    return ans;\n  }\n};\n", "872": "class Solution {\n public:\n  bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n    vector<int> leaves1;\n    vector<int> leaves2;\n    dfs(root1, leaves1);\n    dfs(root2, leaves2);\n    return leaves1 == leaves2;\n  }\n\n  void dfs(TreeNode* root, vector<int>& leaves) {\n    if (root == nullptr)\n      return;\n    if (root->left == nullptr && root->right == nullptr) {\n      leaves.push_back(root->val);\n      return;\n    }\n\n    dfs(root->left, leaves);\n    dfs(root->right, leaves);\n  }\n};\n", "873": "class Solution {\n public:\n  int lenLongestFibSubseq(vector<int>& arr) {\n    const int n = arr.size();\n    int ans = 0;\n    vector<vector<int>> dp(n, vector<int>(n, 2));\n    unordered_map<int, int> numToIndex;\n\n    for (int i = 0; i < n; ++i)\n      numToIndex[arr[i]] = i;\n\n    for (int j = 0; j < n; ++j)\n      for (int k = j + 1; k < n; ++k) {\n        const int ai = arr[k] - arr[j];\n        if (ai < arr[j] && numToIndex.contains(ai)) {\n          const int i = numToIndex[ai];\n          dp[j][k] = dp[i][j] + 1;\n          ans = max(ans, dp[j][k]);\n        }\n      }\n\n    return ans;\n  }\n};\n", "874": "class Solution {\n public:\n  int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int ans = 0;\n    int d = 0;  // 0 := north, 1 := east, 2 := south, 3 := west\n    int x = 0;  // the start x\n    int y = 0;  // the start y\n    unordered_set<pair<int, int>, PairHash> obstaclesSet;\n\n    for (const vector<int>& obstacle : obstacles) {\n      const int x = obstacle[0];\n      const int y = obstacle[1];\n      obstaclesSet.insert({x, y});\n    }\n\n    for (const int command : commands) {\n      if (command == -1) {\n        d = (d + 1) % 4;\n      } else if (command == -2) {\n        d = (d + 3) % 4;\n      } else {\n        for (int step = 0; step < command; ++step) {\n          if (obstaclesSet.contains({x + kDirs[d][0], y + kDirs[d][1]}))\n            break;\n          x += kDirs[d][0];\n          y += kDirs[d][1];\n        }\n      }\n      ans = max(ans, x * x + y * y);\n    }\n\n    return ans;\n  }\n\n private:\n  struct PairHash {\n    size_t operator()(const pair<int, int>& p) const {\n      return p.first ^ p.second;\n    }\n  };\n};\n", "875": "class Solution {\n public:\n  int minEatingSpeed(vector<int>& piles, int h) {\n    int l = 1;\n    int r = ranges::max(piles);\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (eatHours(piles, m) <= h)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l;\n  }\n\n private:\n  // Returns the hours to eat all the piles with speed m.\n  int eatHours(const vector<int>& piles, int m) {\n    return accumulate(piles.begin(), piles.end(), 0, [&](int acc, int pile) {\n      return acc + (pile - 1) / m + 1;  // ceil(pile / m)\n    });\n  }\n};\n", "876": "class Solution {\n public:\n  ListNode* middleNode(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    return slow;\n  }\n};\n", "877": "class Solution {\n public:\n  bool stoneGame(vector<int>& piles) {\n    const int n = piles.size();\n    vector<int> dp = piles;\n\n    for (int d = 1; d < n; ++d)\n      for (int j = n - 1; j - d >= 0; --j) {\n        const int i = j - d;\n        dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1]);\n      }\n\n    return dp[n - 1] > 0;\n  }\n};\n", "878": "class Solution {\n public:\n  int nthMagicalNumber(long n, long a, long b) {\n    constexpr int kMod = 1'000'000'007;\n    const long lcm = a * b / __gcd(a, b);\n    long l = min(a, b);\n    long r = min(a, b) * n;\n\n    while (l < r) {\n      const long m = (l + r) / 2;\n      if (m / a + m / b - m / lcm >= n)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l % kMod;\n  }\n};\n", "879": "class Solution {\n public:\n  int profitableSchemes(int n, int minProfit, vector<int>& group,\n                        vector<int>& profit) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j] := the number of schemes, where <= i members, generating\n    // >= j profits\n    vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1));\n\n    for (int i = 0; i <= n; ++i)\n      dp[i][0] = 1;\n\n    for (int k = 1; k <= group.size(); ++k) {\n      const int g = group[k - 1];\n      const int p = profit[k - 1];\n      for (int i = n; i >= g; --i)\n        for (int j = minProfit; j >= 0; --j) {\n          dp[i][j] += dp[i - g][max(0, j - p)];\n          dp[i][j] %= kMod;\n        }\n    }\n\n    return dp[n][minProfit];\n  }\n};\n", "88": "class Solution {\n public:\n  void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1;      // nums1's index (the actual nums)\n    int j = n - 1;      // nums2's index\n    int k = m + n - 1;  // nums1's index (the next filled position)\n\n    while (j >= 0)\n      if (i >= 0 && nums1[i] > nums2[j])\n        nums1[k--] = nums1[i--];\n      else\n        nums1[k--] = nums2[j--];\n  }\n};\n", "880": "class Solution {\n public:\n  string decodeAtIndex(string s, int k) {\n    long size = 0;  // the length of the decoded `s`\n\n    for (const char c : s)\n      if (isdigit(c))\n        size *= c - '0';\n      else\n        ++size;\n\n    for (int i = s.length() - 1; i >= 0; --i) {\n      k %= size;\n      if (k == 0 && isalpha(s[i]))\n        return string(1, s[i]);\n      if (isdigit(s[i]))\n        size /= s[i] - '0';\n      else\n        --size;\n    }\n\n    throw;\n  }\n};\n", "881": "class Solution {\n public:\n  int numRescueBoats(vector<int>& people, int limit) {\n    int ans = 0;\n\n    ranges::sort(people);\n\n    for (int i = 0, j = people.size() - 1; i <= j; ++ans) {\n      const int remain = limit - people[j--];\n      if (people[i] <= remain)\n        ++i;\n    }\n\n    return ans;\n  }\n};\n", "882": "class Solution {\n public:\n  int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {\n    vector<vector<pair<int, int>>> graph(n);\n    vector<int> dist(graph.size(), maxMoves + 1);\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int cnt = edge[2];\n      graph[u].emplace_back(v, cnt);\n      graph[v].emplace_back(u, cnt);\n    }\n\n    const int reachableNodes = dijkstra(graph, 0, maxMoves, dist);\n    int reachableSubnodes = 0;\n\n    for (const vector<int>& edge : edges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int cnt = edge[2];\n      // the number of reachable nodes of `edge` from `u`\n      const int a = dist[u] > maxMoves ? 0 : min(maxMoves - dist[u], cnt);\n      // the number of reachable nodes of `edge` from `v`\n      const int b = dist[v] > maxMoves ? 0 : min(maxMoves - dist[v], cnt);\n      reachableSubnodes += min(a + b, cnt);\n    }\n\n    return reachableNodes + reachableSubnodes;\n  }\n\n private:\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n               int maxMoves, vector<int>& dist) {\n    dist[src] = 0;\n    using P = pair<int, int>;  // (d, u)\n    priority_queue<P, vector<P>, greater<>> minHeap;\n    minHeap.emplace(dist[src], src);\n\n    while (!minHeap.empty()) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      // Already took `maxMoves` to reach `u`, so can't explore anymore.\n      if (d >= maxMoves)\n        break;\n      if (d > dist[u])\n        continue;\n      for (const auto& [v, w] : graph[u])\n        if (d + w + 1 < dist[v]) {\n          dist[v] = d + w + 1;\n          minHeap.emplace(dist[v], v);\n        }\n    }\n\n    return ranges::count_if(dist, [&](int d) { return d <= maxMoves; });\n  }\n};\n", "883": "class Solution {\n public:\n  int projectionArea(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i) {\n      int maxOfRow = 0;\n      int maxOfCol = 0;\n      for (int j = 0; j < grid.size(); ++j) {\n        maxOfRow = max(maxOfRow, grid[i][j]);\n        maxOfCol = max(maxOfCol, grid[j][i]);\n        if (grid[i][j])\n          ++ans;\n      }\n      ans += maxOfRow + maxOfCol;\n    }\n\n    return ans;\n  }\n};\n", "884": "class Solution {\n public:\n  vector<string> uncommonFromSentences(string A, string B) {\n    vector<string> ans;\n    unordered_map<string, int> count;\n    istringstream iss(A + ' ' + B);\n\n    while (iss >> A)\n      ++count[A];\n\n    for (const auto& [word, freq] : count)\n      if (freq == 1)\n        ans.push_back(word);\n\n    return ans;\n  }\n};\n", "885": "class Solution {\n public:\n  vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart,\n                                      int cStart) {\n    const vector<int> dx{1, 0, -1, 0};\n    const vector<int> dy{0, 1, 0, -1};\n    vector<vector<int>> ans{{rStart, cStart}};\n\n    for (int i = 0; ans.size() < rows * cols; ++i)\n      for (int step = 0; step < i / 2 + 1; ++step) {\n        rStart += dy[i % 4];\n        cStart += dx[i % 4];\n        if (0 <= rStart && rStart < rows && 0 <= cStart && cStart < cols)\n          ans.push_back({rStart, cStart});\n      }\n\n    return ans;\n  }\n};\n", "886": "enum Color { kWhite, kRed, kGreen };\n\nclass Solution {\n public:\n  bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n    vector<vector<int>> graph(n + 1);\n    vector<Color> colors(n + 1, Color::kWhite);\n\n    for (const vector<int>& d : dislikes) {\n      const int u = d[0];\n      const int v = d[1];\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    // Reduce to 785. Is Graph Bipartite?\n    for (int i = 1; i <= n; ++i)\n      if (colors[i] == Color::kWhite &&\n          !isValidColor(graph, i, colors, Color::kRed))\n        return false;\n\n    return true;\n  }\n\n private:\n  bool isValidColor(const vector<vector<int>>& graph, int u,\n                    vector<Color>& colors, Color color) {\n    // Always paint red for a white node.\n    if (colors[u] != Color::kWhite)\n      return colors[u] == color;\n\n    colors[u] = color;  // Always paint the node with `color`.\n\n    // All the children should have valid colors.\n    for (const int v : graph[u])\n      if (!isValidColor(graph, v, colors,\n                        color == Color::kRed ? Color::kGreen : Color::kRed))\n        return false;\n\n    return true;\n  }\n};\n", "887": "class Solution {\n public:\n  int superEggDrop(int k, int n) {\n    vector<vector<int>> mem(k + 1, vector<int>(n + 1, -1));\n    return drop(k, n, mem);\n  }\n\n private:\n  // Returns the minimum number of moves to know f with k eggs and n floors.\n  int drop(int k, int n, vector<vector<int>>& mem) {\n    if (k == 0)  // no eggs -> done\n      return 0;\n    if (k == 1)  // one egg -> drop from 1-th floor to n-th floor\n      return n;\n    if (n == 0)  // no floor -> done\n      return 0;\n    if (n == 1)  // one floor -> drop from that floor\n      return 1;\n    if (mem[k][n] != -1)\n      return mem[k][n];\n\n    //   broken[i] := drop(k - 1, i - 1) is increasing with i\n    // unbroken[i] := drop(k,     n - i) is decreasing with i\n    // mem[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n\n    // Find the first index i s.t broken[i] >= unbroken[i], which minimizes\n    // max(broken[i], unbroken[i]).\n\n    int l = 1;\n    int r = n + 1;\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      const int broken = drop(k - 1, m - 1, mem);\n      const int unbroken = drop(k, n - m, mem);\n      if (broken >= unbroken)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return mem[k][n] = 1 + drop(k - 1, l - 1, mem);\n  }\n};\n", "888": "class Solution {\n public:\n  vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\n    const int diff = (accumulate(aliceSizes.begin(), aliceSizes.end(), 0) -\n                      accumulate(bobSizes.begin(), bobSizes.end(), 0)) /\n                     2;\n    const unordered_set<int> bobSizesSet{bobSizes.begin(), bobSizes.end()};\n\n    for (const int aliceSize : aliceSizes) {\n      const int target = aliceSize - diff;\n      if (bobSizesSet.contains(target))\n        return {aliceSize, target};\n    }\n\n    throw;\n  }\n};\n", "889": "class Solution {\n public:\n  TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\n    unordered_map<int, int> postToIndex;\n\n    for (int i = 0; i < post.size(); ++i)\n      postToIndex[post[i]] = i;\n\n    return build(pre, 0, pre.size() - 1, post, 0, post.size() - 1, postToIndex);\n  }\n\n private:\n  TreeNode* build(const vector<int>& pre, int preStart, int preEnd,\n                  const vector<int>& post, int postStart, int postEnd,\n                  const unordered_map<int, int>& postToIndex) {\n    if (preStart > preEnd)\n      return nullptr;\n    if (preStart == preEnd)\n      return new TreeNode(pre[preStart]);\n\n    const int rootVal = pre[preStart];\n    const int leftRootVal = pre[preStart + 1];\n    const int leftRootPostIndex = postToIndex.at(leftRootVal);\n    const int leftSize = leftRootPostIndex - postStart + 1;\n\n    TreeNode* root = new TreeNode(rootVal);\n    root->left = build(pre, preStart + 1, preStart + leftSize, post, postStart,\n                       leftRootPostIndex, postToIndex);\n    root->right = build(pre, preStart + leftSize + 1, preEnd, post,\n                        leftRootPostIndex + 1, postEnd - 1, postToIndex);\n    return root;\n  }\n};\n", "89": "class Solution {\n public:\n  vector<int> grayCode(int n) {\n    vector<int> ans{0};\n\n    for (int i = 0; i < n; ++i)\n      for (int j = ans.size() - 1; j >= 0; --j)\n        ans.push_back(ans[j] | 1 << i);\n\n    return ans;\n  }\n};\n", "890": "class Solution {\n public:\n  vector<string> findAndReplacePattern(vector<string>& words, string pattern) {\n    vector<string> ans;\n\n    for (const string& word : words)\n      if (isIsomorphic(word, pattern))\n        ans.push_back(word);\n\n    return ans;\n  }\n\n private:\n  bool isIsomorphic(const string& w, const string& p) {\n    vector<int> map_w(128);\n    vector<int> map_p(128);\n\n    for (int i = 0; i < w.length(); ++i) {\n      if (map_w[w[i]] != map_p[p[i]])\n        return false;\n      map_w[w[i]] = i + 1;\n      map_p[p[i]] = i + 1;\n    }\n\n    return true;\n  }\n};\n", "891": "class Solution {\n public:\n  int sumSubseqWidths(vector<int>& nums) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = nums.size();\n    long ans = 0;\n    long exp = 1;\n\n    ranges::sort(nums);\n\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\n      ans += (nums[i] - nums[n - 1 - i]) * exp;\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "892": "class Solution {\n public:\n  int surfaceArea(vector<vector<int>>& grid) {\n    int ans = 0;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid.size(); ++j) {\n        if (grid[i][j])\n          ans += grid[i][j] * 4 + 2;\n        if (i > 0)\n          ans -= min(grid[i][j], grid[i - 1][j]) * 2;\n        if (j > 0)\n          ans -= min(grid[i][j], grid[i][j - 1]) * 2;\n      }\n\n    return ans;\n  }\n};\n", "893": "class Solution {\n public:\n  int numSpecialEquivGroups(vector<string>& words) {\n    unordered_set<string> set;\n\n    for (const string& word : words) {\n      string even;\n      string odd;\n      for (int i = 0; i < word.length(); ++i)\n        if (i % 2 == 0)\n          even += word[i];\n        else\n          odd += word[i];\n      ranges::sort(even);\n      ranges::sort(odd);\n      set.insert(even + odd);\n    }\n\n    return set.size();\n  }\n};\n", "894": "class Solution {\n public:\n  vector<TreeNode*> allPossibleFBT(int n) {\n    if (n % 2 == 0)\n      return {};\n    if (n == 1)\n      return {new TreeNode(0)};\n    if (const auto it = mem.find(n); it != mem.cend())\n      return it->second;\n\n    vector<TreeNode*> ans;\n\n    for (int leftCount = 0; leftCount < n; ++leftCount) {\n      const int rightCount = n - 1 - leftCount;\n      for (TreeNode* left : allPossibleFBT(leftCount))\n        for (TreeNode* right : allPossibleFBT(rightCount)) {\n          ans.push_back(new TreeNode(0));\n          ans.back()->left = left;\n          ans.back()->right = right;\n        }\n    }\n\n    return mem[n] = ans;\n  }\n\n private:\n  unordered_map<int, vector<TreeNode*>> mem;\n};\n", "895": "class FreqStack {\n public:\n  void push(int val) {\n    countToStack[++count[val]].push(val);\n    maxFreq = max(maxFreq, count[val]);\n  }\n\n  int pop() {\n    const int val = countToStack[maxFreq].top();\n    countToStack[maxFreq].pop();\n    --count[val];\n    if (countToStack[maxFreq].empty())\n      --maxFreq;\n    return val;\n  }\n\n private:\n  int maxFreq = 0;\n  unordered_map<int, int> count;\n  unordered_map<int, stack<int>> countToStack;\n};\n", "896": "class Solution {\n public:\n  bool isMonotonic(vector<int>& nums) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (int i = 1; i < nums.size(); ++i) {\n      increasing &= nums[i] >= nums[i - 1];\n      decreasing &= nums[i] <= nums[i - 1];\n    }\n\n    return increasing || decreasing;\n  }\n};\n", "897": "class Solution {\n public:\n  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\n    if (root == nullptr)\n      return tail;\n\n    TreeNode* ans = increasingBST(root->left, root);\n    root->left = nullptr;\n    root->right = increasingBST(root->right, tail);\n    return ans;\n  }\n};\n", "898": "class Solution {\n public:\n  int subarrayBitwiseORs(vector<int>& arr) {\n    vector<int> s;\n    int l = 0;\n\n    for (const int a : arr) {\n      const int r = s.size();\n      s.push_back(a);\n      // s[l..r) are values generated in the previous iteration\n      for (int i = l; i < r; ++i)\n        if (s.back() != (s[i] | a))\n          s.push_back(s[i] | a);\n      l = r;\n    }\n\n    return unordered_set<int>(s.begin(), s.end()).size();\n  }\n};\n", "899": "class Solution {\n public:\n  string orderlyQueue(string s, int k) {\n    if (k > 1) {\n      ranges::sort(s);\n      return s;\n    }\n\n    string ans = s;\n\n    for (int i = 1; i < s.length(); ++i)\n      ans = min(ans, s.substr(i) + s.substr(0, i));\n\n    return ans;\n  }\n};\n", "9": "class Solution {\n public:\n  bool isPalindrome(int x) {\n    if (x < 0)\n      return false;\n\n    long reversed = 0;\n    int y = x;\n\n    while (y > 0) {\n      reversed = reversed * 10 + y % 10;\n      y /= 10;\n    }\n\n    return reversed == x;\n  }\n};\n", "90": "class Solution {\n public:\n  vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n    vector<vector<int>> ans;\n    ranges::sort(nums);\n    dfs(nums, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const vector<int>& nums, int s, vector<int>&& path,\n           vector<vector<int>>& ans) {\n    ans.push_back(path);\n\n    for (int i = s; i < nums.size(); ++i) {\n      if (i > s && nums[i] == nums[i - 1])\n        continue;\n      path.push_back(nums[i]);\n      dfs(nums, i + 1, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "900": "class RLEIterator {\n public:\n  RLEIterator(vector<int>& encoding) : encoding(encoding) {}\n\n  int next(int n) {\n    while (index < encoding.size() && encoding[index] < n) {\n      n -= encoding[index];\n      index += 2;\n    }\n\n    if (index == encoding.size())\n      return -1;\n\n    encoding[index] -= n;\n    return encoding[index + 1];\n  }\n\n private:\n  int index = 0;\n  vector<int> encoding;\n};\n", "901": "class StockSpanner {\n public:\n  int next(int price) {\n    int span = 1;\n    while (!stack.empty() && stack.top().first <= price)\n      span += stack.top().second, stack.pop();\n    stack.emplace(price, span);\n    return span;\n  }\n\n private:\n  stack<pair<int, int>> stack;  // (price, span)\n};\n", "902": "class Solution {\n public:\n  int atMostNGivenDigitSet(vector<string>& digits, int n) {\n    int ans = 0;\n    const string num = to_string(n);\n\n    for (int i = 1; i < num.length(); ++i)\n      ans += pow(digits.size(), i);\n\n    for (int i = 0; i < num.length(); ++i) {\n      bool dHasSameNum = false;\n      for (const string& digit : digits) {\n        if (digit[0] < num[i])\n          ans += pow(digits.size(), num.length() - i - 1);\n        else if (digit[0] == num[i])\n          dHasSameNum = true;\n      }\n      if (!dHasSameNum)\n        return ans;\n    }\n\n    return ans + 1;\n  }\n};\n", "903": "class Solution {\n public:\n  int numPermsDISequence(string s) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = s.length();\n    vector<int> dp(n + 1);\n\n    // When there's only one digit, the number of permutations is 1.\n    for (int j = 0; j <= n; ++j)\n      dp[j] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n      vector<int> newDp(n + 1);\n      if (s[i - 1] == 'I') {  // s[i - 1] == 'I'\n        // Calculate the postfix sum to prevent duplicate calculation.\n        int postfixsum = 0;\n        for (int j = n - i; j >= 0; --j) {\n          postfixsum = (postfixsum + dp[j + 1]) % kMod;\n          newDp[j] = postfixsum;\n        }\n      } else {  // s[i - 1] == 'D'\n        // Calculate the prefix sum to prevent duplicate calculation.\n        int prefix = 0;\n        for (int j = 0; j <= n - i; ++j) {\n          prefix = (prefix + dp[j]) % kMod;\n          newDp[j] = prefix;\n        }\n      }\n      dp = std::move(newDp);\n    }\n\n    return dp[0];\n  }\n};\n", "904": "class Solution {\n public:\n  int totalFruit(vector<int>& fruits) {\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (int l = 0, r = 0; r < fruits.size(); ++r) {\n      ++count[fruits[r]];\n      while (count.size() > 2) {\n        if (--count[fruits[l]] == 0)\n          count.erase(fruits[l]);\n        ++l;\n      }\n      ans = max(ans, r - l + 1);\n    }\n\n    return ans;\n  }\n};\n", "905": "class Solution {\n public:\n  vector<int> sortArrayByParity(vector<int>& nums) {\n    int l = 0;\n    int r = nums.size() - 1;\n\n    while (l < r) {\n      if (nums[l] % 2 == 1 && nums[r] % 2 == 0)\n        swap(nums[l], nums[r]);\n      if (nums[l] % 2 == 0)\n        ++l;\n      if (nums[r] % 2 == 1)\n        --r;\n    }\n\n    return nums;\n  }\n};\n", "906": "class Solution {\n public:\n  int superpalindromesInRange(string left, string right) {\n    int ans = 0;\n    const long l = stoll(left);\n    const long r = stoll(right);\n\n    for (long i = sqrt(l); i * i <= r;) {\n      const long palindrome = nextPalindrome(i);\n      const long squared = palindrome * palindrome;\n      if (squared <= r && isPalindrome(squared))\n        ++ans;\n      i = palindrome + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  long nextPalindrome(int num) {\n    const string s = to_string(num);\n    const int n = s.length();\n    string half = s.substr(0, (n + 1) / 2);\n    string reversedHalf = reversed(half.substr(0, n / 2));\n    const long candidate = stoll(half + reversedHalf);\n    if (candidate >= num)\n      return candidate;\n    half = to_string(stoll(half) + 1);\n    reversedHalf = reversed(half.substr(0, n / 2));\n    return stoll(half + reversedHalf);\n  }\n\n  string reversed(const string& s) {\n    return {s.rbegin(), s.rend()};\n  }\n\n  bool isPalindrome(long num) {\n    const string s = to_string(num);\n    int l = 0;\n    int r = s.length() - 1;\n    while (l < r)\n      if (s[l++] != s[r--])\n        return false;\n    return true;\n  }\n};\n", "907": "class Solution {\n public:\n  int sumSubarrayMins(vector<int>& arr) {\n    constexpr int kMod = 1'000'000'007;\n    const int n = arr.size();\n    long ans = 0;\n    // prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]\n    vector<int> prevMin(n, -1);\n    // nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]\n    vector<int> nextMin(n, n);\n    stack<int> stack;\n\n    for (int i = 0; i < n; ++i) {\n      while (!stack.empty() && arr[stack.top()] > arr[i]) {\n        const int index = stack.top();\n        stack.pop();\n        nextMin[index] = i;\n      }\n      if (!stack.empty())\n        prevMin[i] = stack.top();\n      stack.push(i);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      ans += static_cast<long>(arr[i]) * (i - prevMin[i]) * (nextMin[i] - i);\n      ans %= kMod;\n    }\n\n    return ans;\n  }\n};\n", "908": "class Solution {\n public:\n  int smallestRangeI(vector<int>& nums, int k) {\n    const int mx = ranges::max(nums);\n    const int mn = ranges::min(nums);\n    return max(0, mx - mn - 2 * k);\n  }\n};\n", "909": "class Solution {\n public:\n  int snakesAndLadders(vector<vector<int>>& board) {\n    const int n = board.size();\n    queue<int> q{{1}};\n    vector<bool> seen(1 + n * n);\n    vector<int> arr(1 + n * n);  // 2D -> 1D\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        arr[(n - 1 - i) * n + ((n - i) % 2 == 0 ? n - j : j + 1)] = board[i][j];\n\n    for (int step = 1; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const int curr = q.front();\n        q.pop();\n        for (int next = curr + 1; next <= min(curr + 6, n * n); ++next) {\n          const int dest = arr[next] > 0 ? arr[next] : next;\n          if (dest == n * n)\n            return step;\n          if (seen[dest])\n            continue;\n          q.push(dest);\n          seen[dest] = true;\n        }\n      }\n\n    return -1;\n  }\n};\n", "91": "class Solution {\n public:\n  int numDecodings(string s) {\n    const int n = s.length();\n    // dp[i] := the number of ways to decode s[i..n)\n    vector<int> dp(n + 1);\n    dp[n] = 1;  // \"\"\n    dp[n - 1] = isValid(s[n - 1]);\n\n    for (int i = n - 2; i >= 0; --i) {\n      if (isValid(s[i]))\n        dp[i] += dp[i + 1];\n      if (isValid(s[i], s[i + 1]))\n        dp[i] += dp[i + 2];\n    }\n\n    return dp[0];\n  }\n\n private:\n  bool isValid(char c) {\n    return c != '0';\n  }\n\n  bool isValid(char c1, char c2) {\n    return c1 == '1' || c1 == '2' && c2 < '7';\n  }\n};\n", "910": "class Solution {\n public:\n  int smallestRangeII(vector<int>& nums, int k) {\n    ranges::sort(nums);\n\n    int ans = nums.back() - nums.front();\n    const int left = nums.front() + k;\n    const int right = nums.back() - k;\n\n    for (int i = 0; i + 1 < nums.size(); ++i) {\n      const int mn = min(left, nums[i + 1] - k);\n      const int mx = max(right, nums[i] + k);\n      ans = min(ans, mx - mn);\n    }\n\n    return ans;\n  }\n};\n", "911": "class TopVotedCandidate {\n public:\n  TopVotedCandidate(vector<int>& persons, vector<int>& times) : times(times) {\n    unordered_map<int, int> count;  // {person: voted}\n    int lead = -1;\n\n    for (int i = 0; i < persons.size(); ++i) {\n      if (++count[persons[i]] >= count[lead])\n        lead = persons[i];\n      timeToLead[times[i]] = lead;\n    }\n  }\n\n  int q(int t) {\n    auto it = --ranges::upper_bound(times, t);\n    return timeToLead[*it];\n  }\n\n private:\n  const vector<int> times;\n  unordered_map<int, int> timeToLead;\n};\n", "912": "class Solution {\n public:\n  vector<int> sortArray(vector<int>& nums) {\n    heapSort(nums);\n    return nums;\n  }\n\n private:\n  void heapSort(vector<int>& nums) {\n    buildMaxHeap(nums);\n    int heapSize = nums.size();\n    for (int i = nums.size() - 1; i > 0; --i) {\n      swap(nums[i], nums[0]);\n      --heapSize;\n      maxHeapify(nums, 0, heapSize);\n    }\n  }\n\n  void buildMaxHeap(vector<int>& nums) {\n    for (int i = nums.size() / 2; i >= 0; --i)\n      maxHeapify(nums, i, nums.size());\n  }\n\n  void maxHeapify(vector<int>& nums, int i, int heapSize) {\n    const int l = 2 * i + 1;\n    const int r = 2 * i + 2;\n    int largest = i;\n    if (l < heapSize && nums[largest] < nums[l])\n      largest = l;\n    if (r < heapSize && nums[largest] < nums[r])\n      largest = r;\n    if (largest != i) {\n      swap(nums[largest], nums[i]);\n      maxHeapify(nums, largest, heapSize);\n    }\n  }\n};\n", "913": "enum class State { kDraw, kMouseWin, kCatWin };\n\nclass Solution {\n public:\n  int catMouseGame(vector<vector<int>>& graph) {\n    const int n = graph.size();\n    // result of (cat, mouse, move)\n    // move := 0 (mouse) / 1 (cat)\n    vector<vector<vector<State>>> states(\n        n, vector<vector<State>>(n, vector<State>(2)));\n    vector<vector<vector<int>>> outDegree(\n        n, vector<vector<int>>(n, vector<int>(2)));\n    queue<tuple<int, int, int, State>> q;  // (cat, mouse, move, state)\n\n    for (int cat = 0; cat < n; ++cat)\n      for (int mouse = 0; mouse < n; ++mouse) {\n        outDegree[cat][mouse][0] = graph[mouse].size();\n        outDegree[cat][mouse][1] =\n            graph[cat].size() - ranges::count(graph[cat], 0);\n      }\n\n    // Start from the states s.t. the winner can be determined.\n    for (int cat = 1; cat < n; ++cat)\n      for (int move = 0; move < 2; ++move) {\n        // Mouse is in the hole.\n        states[cat][0][move] = State::kMouseWin;\n        q.emplace(cat, 0, move, State::kMouseWin);\n        // Cat catches mouse.\n        states[cat][cat][move] = State::kCatWin;\n        q.emplace(cat, cat, move, State::kCatWin);\n      }\n\n    while (!q.empty()) {\n      const auto [cat, mouse, move, state] = q.front();\n      q.pop();\n      if (cat == 2 && mouse == 1 && move == 0)\n        return static_cast<int>(state);\n      const int prevMove = move ^ 1;\n      for (const int prev : graph[prevMove ? cat : mouse]) {\n        const int prevCat = prevMove ? prev : cat;\n        if (prevCat == 0)  // invalid\n          continue;\n        const int prevMouse = prevMove ? mouse : prev;\n        // The state has been determined.\n        if (states[prevCat][prevMouse][prevMove] != State::kDraw)\n          continue;\n        if (prevMove == 0 && state == State::kMouseWin ||\n            prevMove == 1 && state == State::kCatWin ||\n            --outDegree[prevCat][prevMouse][prevMove] == 0) {\n          states[prevCat][prevMouse][prevMove] = state;\n          q.emplace(prevCat, prevMouse, prevMove, state);\n        }\n      }\n    }\n\n    return static_cast<int>(states[2][1][0]);\n  }\n};\n", "914": "class Solution {\n public:\n  bool hasGroupsSizeX(vector<int>& deck) {\n    unordered_map<int, int> count;\n    int gcd = 0;\n\n    for (const int d : deck)\n      ++count[d];\n\n    for (const auto& [_, value] : count)\n      gcd = __gcd(gcd, value);\n\n    return gcd >= 2;\n  }\n};\n", "915": "class Solution {\n public:\n  int partitionDisjoint(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> mn(n);\n    mn[n - 1] = nums[n - 1];\n    int mx = INT_MIN;\n\n    for (int i = n - 2; i >= 0; --i)\n      mn[i] = min(mn[i + 1], nums[i]);\n\n    for (int i = 0; i < n; ++i) {\n      mx = max(mx, nums[i]);\n      if (mx <= mn[i + 1])\n        return i + 1;\n    }\n\n    throw;\n  }\n};\n", "916": "class Solution {\n public:\n  vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\n    vector<string> ans;\n    vector<int> countB(26);\n\n    for (const string& b : B) {\n      vector<int> temp = counter(b);\n      for (int i = 0; i < 26; ++i)\n        countB[i] = max(countB[i], temp[i]);\n    }\n\n    for (const string& a : A)\n      if (isUniversal(counter(a), countB))\n        ans.push_back(a);\n\n    return ans;\n  }\n\n private:\n  vector<int> counter(const string& s) {\n    vector<int> count(26);\n    for (char c : s)\n      ++count[c - 'a'];\n    return count;\n  }\n\n  bool isUniversal(vector<int> countA, vector<int>& countB) {\n    for (int i = 0; i < 26; ++i)\n      if (countA[i] < countB[i])\n        return false;\n    return true;\n  }\n};\n", "917": "class Solution {\n public:\n  string reverseOnlyLetters(string s) {\n    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n      while (i < j && !isalpha(s[i]))\n        ++i;\n      while (i < j && !isalpha(s[j]))\n        --j;\n      swap(s[i], s[j]);\n    }\n    return s;\n  }\n};\n", "918": "class Solution {\n public:\n  int maxSubarraySumCircular(vector<int>& nums) {\n    int totalSum = 0;\n    int currMaxSum = 0;\n    int currMinSum = 0;\n    int maxSum = INT_MIN;\n    int minSum = INT_MAX;\n\n    for (const int num : nums) {\n      totalSum += num;\n      currMaxSum = max(currMaxSum + num, num);\n      currMinSum = min(currMinSum + num, num);\n      maxSum = max(maxSum, currMaxSum);\n      minSum = min(minSum, currMinSum);\n    }\n\n    return maxSum < 0 ? maxSum : max(maxSum, totalSum - minSum);\n  }\n};\n", "919": "class CBTInserter {\n public:\n  CBTInserter(TreeNode* root) {\n    tree.push_back(root);\n    for (int i = 0; i < tree.size(); ++i) {\n      TreeNode* node = tree[i];\n      if (node->left)\n        tree.push_back(node->left);\n      if (node->right)\n        tree.push_back(node->right);\n    }\n  }\n\n  int insert(int v) {\n    const int n = tree.size();\n    tree.push_back(new TreeNode(v));\n    auto& parent = tree[(n - 1) / 2];\n    if (n % 2 == 1)\n      parent->left = tree.back();\n    else\n      parent->right = tree.back();\n    return parent->val;\n  }\n\n  TreeNode* get_root() {\n    return tree[0];\n  }\n\n private:\n  vector<TreeNode*> tree;\n};\n", "92": "class Solution {\n public:\n  ListNode* reverseBetween(ListNode* head, int m, int n) {\n    if (!head || m == n)\n      return head;\n\n    ListNode dummy(0, head);\n    ListNode* prev = &dummy;\n\n    for (int i = 0; i < m - 1; ++i)\n      prev = prev->next;  // Point to the node before the sublist [m, n].\n\n    ListNode* tail = prev->next;  // Be the tail of the sublist [m, n]\n\n    // Reverse the sublist [m, n] one by one.\n    for (int i = 0; i < n - m; ++i) {\n      ListNode* cache = tail->next;\n      tail->next = cache->next;\n      cache->next = prev->next;\n      prev->next = cache;\n    }\n\n    return dummy.next;\n  }\n};\n", "920": "class Solution {\n public:\n  int numMusicPlaylists(int n, int goal, int k) {\n    constexpr int kMod = 1'000'000'007;\n    // dp[i][j] := the number of playlists with i songs and j different songs\n    vector<vector<long>> dp(goal + 1, vector<long>(n + 1));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= goal; ++i)\n      for (int j = 1; j <= n; ++j) {\n        dp[i][j] += dp[i - 1][j - 1] * (n - (j - 1));  // The last song is new.\n        dp[i][j] += dp[i - 1][j] * max(0, j - k);      // The last song is old.\n        dp[i][j] %= kMod;\n      }\n\n    return dp[goal][n];\n  }\n};\n", "921": "class Solution {\n public:\n  int minAddToMakeValid(string s) {\n    int l = 0;\n    int r = 0;\n\n    for (const char c : s)\n      if (c == '(') {\n        ++l;\n      } else {\n        if (l == 0)\n          ++r;\n        else\n          --l;\n      }\n\n    return l + r;\n  }\n};\n", "922": "class Solution {\n public:\n  vector<int> sortArrayByParityII(vector<int>& nums) {\n    const int n = nums.size();\n\n    for (int i = 0, j = 1; i < n; i += 2, j += 2) {\n      while (i < n && nums[i] % 2 == 0)\n        i += 2;\n      while (j < n && nums[j] % 2 == 1)\n        j += 2;\n      if (i < n)\n        swap(nums[i], nums[j]);\n    }\n\n    return nums;\n  }\n};\n", "923": "class Solution {\n public:\n  int threeSumMulti(vector<int>& arr, int target) {\n    constexpr int kMod = 1'000'000'007;\n    int ans = 0;\n    unordered_map<int, int> count;\n\n    for (const int a : arr)\n      ++count[a];\n\n    for (const auto& [i, x] : count)\n      for (const auto& [j, y] : count) {\n        const int k = target - i - j;\n        const auto it = count.find(k);\n        if (it == count.cend())\n          continue;\n        if (i == j && j == k)\n          ans = (ans + static_cast<long>(x) * (x - 1) * (x - 2) / 6) % kMod;\n        else if (i == j && j != k)\n          ans = (ans + static_cast<long>(x) * (x - 1) / 2 * it->second) % kMod;\n        else if (i < j && j < k)\n          ans = (ans + static_cast<long>(x) * y * it->second) % kMod;\n      }\n\n    return ans;\n  }\n};\n", "924": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n    const int n = graph.size();\n    UnionFind uf(n);\n    vector<int> ufSize(n);\n    vector<int> malwareCount(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j)\n        if (graph[i][j] == 1)\n          uf.unionByRank(i, j);\n\n    for (int i = 0; i < n; ++i)\n      ++ufSize[uf.find(i)];\n\n    for (const int i : initial)\n      ++malwareCount[uf.find(i)];\n\n    ranges::sort(initial);\n\n    int ans = initial[0];\n    int maxUfSize = 0;\n\n    // Find the maximum union's malware if it only contains 1 malware.\n    for (const int i : initial) {\n      const int id = uf.find(i);\n      if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {\n        maxUfSize = ufSize[id];\n        ans = i;\n      }\n    }\n\n    return ans;\n  }\n};\n", "925": "class Solution {\n public:\n  bool isLongPressedName(string name, string typed) {\n    int i = 0;\n\n    for (int j = 0; j < typed.length(); ++j)\n      if (i < name.length() && name[i] == typed[j])\n        ++i;\n      else if (j == 0 || typed[j] != typed[j - 1])\n        return false;\n\n    return i == name.length();\n  }\n};\n", "926": "class Solution {\n public:\n  int minFlipsMonoIncr(string s) {\n    // the number of characters to be flilpped to make the substring so far\n    // monotone increasing\n    int dp = 0;\n    int count1 = 0;\n\n    for (const char c : s)\n      if (c == '0')\n        // 1. Flip '0'.\n        // 2. Keep '0' and flip all the previous 1s.\n        dp = min(dp + 1, count1);\n      else\n        ++count1;\n\n    return dp;\n  }\n};\n", "927": "class Solution {\n public:\n  vector<int> threeEqualParts(vector<int>& arr) {\n    const int ones = ranges::count_if(arr, [](int a) { return a == 1; });\n\n    if (ones == 0)\n      return {0, static_cast<int>(arr.size()) - 1};\n    if (ones % 3 != 0)\n      return {-1, -1};\n\n    int k = ones / 3;\n    int i;\n    int j;\n    int first;\n    int second;\n    int third;\n\n    for (i = 0; i < arr.size(); ++i)\n      if (arr[i] == 1) {\n        first = i;\n        break;\n      }\n\n    int gapOnes = k;\n\n    for (j = i + 1; j < arr.size(); ++j)\n      if (arr[j] == 1 && --gapOnes == 0) {\n        second = j;\n        break;\n      }\n\n    gapOnes = k;\n\n    for (i = j + 1; i < arr.size(); ++i)\n      if (arr[i] == 1 && --gapOnes == 0) {\n        third = i;\n        break;\n      }\n\n    while (third < arr.size() && arr[first] == arr[second] &&\n           arr[second] == arr[third]) {\n      ++first;\n      ++second;\n      ++third;\n    }\n\n    if (third == arr.size())\n      return {first - 1, second};\n    return {-1, -1};\n  }\n};\n", "928": "class Solution {\n public:\n  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n    int ans = 0;\n    int minCount = graph.size();\n\n    ranges::sort(initial);\n\n    for (const int i : initial) {\n      const int count = bfs(graph, i, initial);\n      if (count < minCount) {\n        minCount = count;\n        ans = i;\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {\n    queue<int> q;\n    vector<bool> seen(graph.size());\n    seen[removed] = true;\n\n    int count = 0;\n\n    for (const int i : initial)\n      if (i != removed) {\n        q.push(i);\n        seen[i] = true;\n      }\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      ++count;\n      for (int i = 0; i < graph.size(); ++i) {\n        if (seen[i])\n          continue;\n        if (i != u && graph[i][u]) {\n          q.push(i);\n          seen[i] = true;\n        }\n      }\n    }\n\n    return count;\n  }\n};\n", "929": "class Solution {\n public:\n  int numUniqueEmails(vector<string>& emails) {\n    unordered_set<string> normalized;\n\n    for (const string& email : emails) {\n      string local;\n      for (const char c : email) {\n        if (c == '+' || c == '@')\n          break;\n        if (c == '.')\n          continue;\n        local += c;\n      }\n      string atDomain = email.substr(email.find('@'));\n      normalized.insert(local + atDomain);\n    }\n\n    return normalized.size();\n  }\n};\n", "93": "class Solution {\n public:\n  vector<string> restoreIpAddresses(const string& s) {\n    vector<string> ans;\n    dfs(s, 0, {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(const string& s, int start, vector<string>&& path,\n           vector<string>& ans) {\n    if (path.size() == 4 && start == s.length()) {\n      ans.push_back(path[0] + \".\" + path[1] + \".\" + path[2] + \".\" + path[3]);\n      return;\n    }\n    if (path.size() == 4 || start == s.length())\n      return;\n\n    for (int length = 1; length <= 3; ++length) {\n      if (start + length > s.length())\n        return;  // out-of-bounds\n      if (length > 1 && s[start] == '0')\n        return;  // leading '0'\n      const string& num = s.substr(start, length);\n      if (stoi(num) > 255)\n        return;\n      path.push_back(num);\n      dfs(s, start + length, std::move(path), ans);\n      path.pop_back();\n    }\n  }\n};\n", "930": "class Solution {\n public:\n  int numSubarraysWithSum(vector<int>& nums, int goal) {\n    return numSubarraysWithSumAtMost(nums, goal) -\n           numSubarraysWithSumAtMost(nums, goal - 1);\n  }\n\n private:\n  int numSubarraysWithSumAtMost(const vector<int>& nums, int goal) {\n    int res = 0;\n    int count = 0;\n    for (int l = 0, r = 0; r < nums.size();) {\n      count += nums[r++];\n      while (l < r && count > goal)\n        count -= nums[l++];\n      // nums[l..r), nums[l + 1..r), ..., nums[r - 1]\n      res += r - l;\n    }\n    return res;\n  }\n};\n", "931": "class Solution {\n public:\n  int minFallingPathSum(vector<vector<int>>& A) {\n    const int n = A.size();\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        int mn = INT_MAX;\n        for (int k = max(0, j - 1); k < min(n, j + 2); ++k)\n          mn = min(mn, A[i - 1][k]);\n        A[i][j] += mn;\n      }\n\n    return ranges::min(A[n - 1]);\n  }\n};\n", "932": "class Solution {\n public:\n  vector<int> beautifulArray(int n) {\n    vector<int> arr(n);\n    iota(arr.begin(), arr.end(), 1);\n    divide(arr, 0, n - 1, 1);\n    return arr;\n  }\n\n private:\n  void divide(vector<int>& arr, int l, int r, int mask) {\n    if (l >= r)\n      return;\n    const int m = partition(arr, l, r, mask);\n    divide(arr, l, m, mask << 1);\n    divide(arr, m + 1, r, mask << 1);\n  }\n\n  int partition(vector<int>& arr, int l, int r, int mask) {\n    int nextSwapped = l;\n    for (int i = l; i <= r; ++i)\n      if (arr[i] & mask)\n        swap(arr[i], arr[nextSwapped++]);\n    return nextSwapped - 1;\n  }\n};\n", "933": "class RecentCounter {\n public:\n  int ping(int t) {\n    q.push(t);\n    while (q.front() < t - 3000)\n      q.pop();\n    return q.size();\n  }\n\n private:\n  queue<int> q;\n};\n", "934": "class Solution {\n public:\n  int shortestBridge(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int n = grid.size();\n    queue<pair<int, int>> q;\n\n    markGridTwo(grid, q);\n\n    for (int ans = 0; !q.empty(); ++ans)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == n || y < 0 || y == n)\n            continue;\n          if (grid[x][y] == 2)\n            continue;\n          if (grid[x][y] == 1)\n            return ans;\n          grid[x][y] = 2;\n          q.emplace(x, y);\n        }\n      }\n\n    throw;\n  }\n\n private:\n  // Marks one group to 2s by DFS.\n  void markGridTwo(vector<vector<int>>& grid, queue<pair<int, int>>& q) {\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == 1) {\n          markGridTwo(grid, i, j, q);\n          return;\n        }\n  }\n\n  // Marks one group to 2s by DFS and pushes them to the queue.\n  void markGridTwo(vector<vector<int>>& grid, int i, int j,\n                   queue<pair<int, int>>& q) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] != 1)\n      return;\n    grid[i][j] = 2;\n    q.emplace(i, j);\n    markGridTwo(grid, i + 1, j, q);\n    markGridTwo(grid, i - 1, j, q);\n    markGridTwo(grid, i, j + 1, q);\n    markGridTwo(grid, i, j - 1, q);\n  }\n};\n", "935": "class Solution {\n public:\n  int knightDialer(int n) {\n    constexpr int kDirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},\n                                 {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\n    constexpr int kMod = 1'000'000'007;\n\n    // dp[i][j] := the number of ways to stand on (i, j)\n    vector<vector<int>> dp(4, vector<int>(3, 1));\n    dp[3][0] = dp[3][2] = 0;\n\n    for (int k = 0; k < n - 1; ++k) {\n      vector<vector<int>> newDp(4, vector<int>(3));\n      for (int i = 0; i < 4; ++i)\n        for (int j = 0; j < 3; ++j) {\n          if (isNotNumericCell(i, j))\n            continue;\n          for (const auto& [dx, dy] : kDirs) {\n            const int x = i + dx;\n            const int y = j + dy;\n            if (x < 0 || x >= 4 || y < 0 || y >= 3)\n              continue;\n            if (isNotNumericCell(x, y))\n              continue;\n            newDp[i][j] = (newDp[i][j] + dp[x][y]) % kMod;\n          }\n        }\n      dp = std::move(newDp);\n    }\n\n    int ans = 0;\n\n    for (const vector<int>& row : dp)\n      for (const int a : row)\n        ans = (ans + a) % kMod;\n\n    return ans;\n  }\n\n private:\n  bool isNotNumericCell(int i, int j) {\n    return i == 3 && (j == 0 || j == 2);\n  }\n};\n", "936": "class Solution {\n public:\n  vector<int> movesToStamp(string stamp, string target) {\n    vector<int> ans;\n    // stamped[i] := true if we already stamped target by stamping on index i\n    vector<bool> stamped(target.length());\n    int stampedCount = 0;  // Our goal is to make stampedCount = |target|.\n\n    while (stampedCount < target.length()) {\n      bool isStamped = false;\n      // Try to stamp target[i..i + |stamp|) for each index.\n      for (int i = 0; i <= target.length() - stamp.length(); ++i) {\n        if (stamped[i])\n          continue;\n        const int stampified = stampify(stamp, target, i);\n        if (stampified == 0)\n          continue;\n        stampedCount += stampified;\n        isStamped = true;\n        stamped[i] = true;\n        ans.push_back(i);\n      }\n      // After trying to stamp on each index, we can't find a valid stamp.\n      if (!isStamped)\n        return {};\n    }\n\n    ranges::reverse(ans);\n    return ans;\n  }\n\n private:\n  // Stamps target[i..i + |stamp|) and returns the number of newly stamped\n  // characters.\n  // e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\".\n  int stampify(const string& stamp, string& target, int s) {\n    int stampified = stamp.length();\n\n    for (int i = 0; i < stamp.length(); ++i)\n      if (target[s + i] == '*')  // It's already been stamped.\n        --stampified;\n      else if (target[s + i] != stamp[i])\n        return 0;  // We can't stamp on the index i.\n\n    if (stampified > 0)\n      fill(target.begin() + s, target.begin() + s + stamp.length(), '*');\n\n    return stampified;\n  }\n};\n", "937": "class Solution {\n public:\n  vector<string> reorderLogFiles(vector<string>& logs) {\n    vector<string> ans;\n    vector<string> digitLogs;\n    vector<pair<string, string>> letterLogs;\n\n    for (const string& log : logs) {\n      const int i = log.find_first_of(' ');\n      if (isdigit(log[i + 1]))\n        digitLogs.push_back(log);\n      else\n        letterLogs.emplace_back(log.substr(0, i), log.substr(i + 1));\n    }\n\n    ranges::sort(letterLogs, ranges::less{},\n                 [](const pair<string, string>& letterLog) {\n      const auto& [identifier, letters] = letterLog;\n      return pair<string, string>{letters, identifier};\n    });\n\n    for (const auto& [identifier, letters] : letterLogs)\n      ans.push_back(identifier + ' ' + letters);\n\n    for (const string& digitLog : digitLogs)\n      ans.push_back(digitLog);\n\n    return ans;\n  }\n};\n", "938": "class Solution {\n public:\n  int rangeSumBST(TreeNode* root, int L, int R) {\n    if (root == nullptr)\n      return 0;\n    if (root->val < L)\n      return rangeSumBST(root->right, L, R);\n    if (root->val > R)\n      return rangeSumBST(root->left, L, R);\n    return root->val + rangeSumBST(root->left, L, R) +\n           rangeSumBST(root->right, L, R);\n  }\n};\n", "939": "class Solution {\n public:\n  int minAreaRect(vector<vector<int>>& points) {\n    int ans = INT_MAX;\n    unordered_map<int, unordered_set<int>> xToYs;\n\n    for (const vector<int>& p : points)\n      xToYs[p[0]].insert(p[1]);\n\n    for (int i = 1; i < points.size(); ++i)\n      for (int j = 0; j < i; ++j) {\n        const vector<int>& p = points[i];\n        const vector<int>& q = points[j];\n        if (p[0] == q[0] || p[1] == q[1])\n          continue;\n        if (xToYs[p[0]].contains(q[1]) && xToYs[q[0]].contains(p[1]))\n          ans = min(ans, abs(p[0] - q[0]) * abs(p[1] - q[1]));\n      }\n\n    return ans == INT_MAX ? 0 : ans;\n  }\n};\n", "94": "class Solution {\n public:\n  vector<int> inorderTraversal(TreeNode* root) {\n    vector<int> ans;\n    stack<TreeNode*> stack;\n\n    while (root != nullptr || !stack.empty()) {\n      while (root != nullptr) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      ans.push_back(root->val);\n      root = root->right;\n    }\n\n    return ans;\n  }\n};\n", "940": "class Solution {\n public:\n  int distinctSubseqII(string s) {\n    constexpr int kMod = 1'000'000'007;\n    // endsIn[i] := the number of subsequence that end in ('a' + i)\n    vector<long> endsIn(26);\n\n    for (const char c : s)\n      endsIn[c - 'a'] = accumulate(endsIn.begin(), endsIn.end(), 1L) % kMod;\n\n    return accumulate(endsIn.begin(), endsIn.end(), 0L) % kMod;\n  }\n};\n", "941": "class Solution {\n public:\n  bool validMountainArray(vector<int>& arr) {\n    if (arr.size() < 3)\n      return false;\n\n    int l = 0;\n    int r = arr.size() - 1;\n\n    while (l + 1 < arr.size() && arr[l] < arr[l + 1])\n      ++l;\n    while (r > 0 && arr[r] < arr[r - 1])\n      --r;\n\n    return l > 0 && r < arr.size() - 1 && l == r;\n  }\n};\n", "942": "class Solution {\n public:\n  vector<int> diStringMatch(string s) {\n    vector<int> ans;\n    int mn = 0;\n    int mx = s.length();\n\n    for (const char c : s)\n      ans.push_back(c == 'I' ? mn++ : mx--);\n    ans.push_back(mn);\n\n    return ans;\n  }\n};\n", "943": "class Solution {\n public:\n  string shortestSuperstring(vector<string>& words) {\n    const int n = words.size();\n    // cost[i][j] := the cost to append words[j] after words[i]\n    vector<vector<int>> cost(n, vector<int>(n));\n    // dp[s][j] := the minimum cost to visit nodes of s ending in j, s is a\n    // binary Value, e.g. dp[6][2] means the minimum cost to visit {1, 2} ending\n    // in 2 (6 = 2^1 + 2^2)\n    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX / 2));\n    // parent[s][j] := the parent of \"nodes of s ending in j\"\n    vector<vector<int>> parent(1 << n, vector<int>(n, -1));\n\n    // Returns the cost to append b after a.\n    auto getCost = [](const string& a, const string& b) {\n      int cost = b.length();\n      const int minLength = min(a.length(), b.length());\n      for (int k = 1; k <= minLength; ++k)\n        if (a.substr(a.length() - k) == b.substr(0, k))\n          cost = b.length() - k;\n      return cost;\n    };\n\n    // Pre-calculate the `cost` array to save time.\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        cost[i][j] = getCost(words[i], words[j]);\n        cost[j][i] = getCost(words[j], words[i]);\n      }\n\n    for (int i = 0; i < n; ++i)\n      dp[1 << i][i] = words[i].length();\n\n    // Enumerate all the states ending in different nodes.\n    for (int s = 1; s < (1 << n); ++s)\n      for (int i = 0; i < n; ++i) {\n        if ((s & (1 << i)) == 0)\n          continue;\n        for (int j = 0; j < n; ++j)\n          if (dp[s - (1 << i)][j] + cost[j][i] < dp[s][i]) {\n            dp[s][i] = dp[s - (1 << i)][j] + cost[j][i];\n            parent[s][i] = j;\n          }\n      }\n\n    string ans;\n    const vector<int>& dpBack = dp.back();\n    int j = distance(dpBack.begin(), ranges::min_element(dpBack));\n    int s = (1 << n) - 1;  // 2^0 + 2^1 + ... + 2^(n - 1)\n\n    // Traverse back to build the string.\n    while (s > 0) {\n      const int i = parent[s][j];\n      if (i == -1)\n        ans = words[j] + ans;\n      else\n        ans = words[j].substr(words[j].length() - cost[i][j]) + ans;\n      s -= 1 << j;\n      j = i;\n    }\n\n    return ans;\n  }\n};\n", "944": "class Solution {\n public:\n  int minDeletionSize(vector<string>& strs) {\n    int ans = 0;\n\n    for (int j = 0; j < strs[0].length(); ++j)\n      for (int i = 0; i + 1 < strs.size(); ++i)\n        if (strs[i][j] > strs[i + 1][j]) {\n          ++ans;\n          break;\n        }\n\n    return ans;\n  }\n};\n", "945": "class Solution {\n public:\n  int minIncrementForUnique(vector<int>& nums) {\n    int ans = 0;\n    int minAvailable = 0;\n\n    ranges::sort(nums);\n\n    for (const int num : nums) {\n      ans += max(minAvailable - num, 0);\n      minAvailable = max(minAvailable, num) + 1;\n    }\n\n    return ans;\n  }\n};\n", "946": "class Solution {\n public:\n  bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n    stack<int> stack;\n    int i = 0;  // popped's index\n\n    for (const int x : pushed) {\n      stack.push(x);\n      while (!stack.empty() && stack.top() == popped[i]) {\n        stack.pop();\n        ++i;\n      }\n    }\n\n    return stack.empty();\n  }\n};\n", "947": "class Solution {\n public:\n  int removeStones(vector<vector<int>>& stones) {\n    int numOfIslands = 0;\n    vector<vector<int>> graph(stones.size());\n    unordered_set<int> seen;\n\n    for (int i = 0; i < stones.size(); ++i)\n      for (int j = i + 1; j < stones.size(); ++j)\n        if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n          graph[i].push_back(j);\n          graph[j].push_back(i);\n        }\n\n    for (int i = 0; i < stones.size(); ++i)\n      if (seen.insert(i).second) {\n        dfs(graph, i, seen);\n        ++numOfIslands;\n      }\n\n    return stones.size() - numOfIslands;\n  }\n\n private:\n  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {\n    for (const int v : graph[u])\n      if (seen.insert(v).second)\n        dfs(graph, v, seen);\n  }\n};\n", "948": "class Solution {\n public:\n  int bagOfTokensScore(vector<int>& tokens, int power) {\n    int ans = 0;\n    int score = 0;\n    int i = 0;                  // the index of the smallest token\n    int j = tokens.size() - 1;  // the index of the largest token\n\n    ranges::sort(tokens);\n\n    while (i <= j && (power >= tokens[i] || score)) {\n      while (i <= j && power >= tokens[i]) {\n        // Play the smallest face up.\n        power -= tokens[i++];\n        ++score;\n      }\n      ans = max(ans, score);\n      if (i <= j && score) {\n        // Play the largest face down.\n        power += tokens[j--];\n        --score;\n      }\n    }\n\n    return ans;\n  }\n};\n", "949": "class Solution {\n public:\n  string largestTimeFromDigits(vector<int>& arr) {\n    string ans;\n\n    for (int i = 0; i < 4; ++i)\n      for (int j = 0; j < 4; ++j)\n        for (int k = 0; k < 4; ++k) {\n          if (i == j || i == k || j == k)\n            continue;\n          const string hours = to_string(arr[i]) + to_string(arr[j]);\n          const string minutes =\n              to_string(arr[k]) + to_string(arr[6 - i - j - k]);\n          if (hours < \"24\" && minutes < \"60\")\n            ans = max(ans, hours + ':' + minutes);\n        }\n\n    return ans;\n  }\n};\n", "95": "class Solution {\n public:\n  vector<TreeNode*> generateTrees(int n) {\n    if (n == 0)\n      return {};\n    return generateTrees(1, n);\n  }\n\n private:\n  vector<TreeNode*> generateTrees(int min, int max) {\n    if (min > max)\n      return {nullptr};\n\n    vector<TreeNode*> ans;\n\n    for (int i = min; i <= max; ++i)\n      for (TreeNode* left : generateTrees(min, i - 1))\n        for (TreeNode* right : generateTrees(i + 1, max)) {\n          ans.push_back(new TreeNode(i));\n          ans.back()->left = left;\n          ans.back()->right = right;\n        }\n\n    return ans;\n  }\n};\n", "950": "class Solution {\n public:\n  vector<int> deckRevealedIncreasing(vector<int>& deck) {\n    ranges::sort(deck, greater<int>());\n\n    deque<int> dq{deck[0]};\n\n    for (int i = 1; i < deck.size(); ++i) {\n      dq.push_front(dq.back());\n      dq.pop_back();\n      dq.push_front(deck[i]);\n    }\n\n    return {dq.begin(), dq.end()};\n  }\n};\n", "951": "class Solution {\n public:\n  bool flipEquiv(TreeNode* root1, TreeNode* root2) {\n    if (root1 == nullptr)\n      return root2 == nullptr;\n    if (root2 == nullptr)\n      return root1 == nullptr;\n    if (root1->val != root2->val)\n      return false;\n    return flipEquiv(root1->left, root2->left) &&\n               flipEquiv(root1->right, root2->right) ||\n           flipEquiv(root1->left, root2->right) &&\n               flipEquiv(root1->right, root2->left);\n  }\n};\n", "952": "class UnionFind {\n public:\n  UnionFind(int n) : id(n), rank(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = j;\n    } else if (rank[i] > rank[j]) {\n      id[j] = i;\n    } else {\n      id[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int largestComponentSize(vector<int>& nums) {\n    const int n = ranges::max(nums);\n    int ans = 0;\n    UnionFind uf(n + 1);\n    unordered_map<int, int> count;\n\n    for (const int num : nums)\n      for (int x = 2; x <= sqrt(num); ++x)\n        if (num % x == 0) {\n          uf.unionByRank(num, x);\n          uf.unionByRank(num, num / x);\n        }\n\n    for (const int num : nums)\n      ans = max(ans, ++count[uf.find(num)]);\n\n    return ans;\n  }\n};\n", "953": "class Solution {\n public:\n  bool isAlienSorted(vector<string>& words, const string& order) {\n    vector<char> map(26);  // e.g. order = \"bca\" -> map = ['c', 'a', 'b']\n\n    for (int i = 0; i < 26; ++i)\n      map[order[i] - 'a'] = i + 'a';\n\n    for (string& word : words)\n      for (char& c : word)\n        c = map[c - 'a'];\n\n    return is_sorted(words.begin(), words.end());\n  }\n};\n", "954": "class Solution {\n public:\n  bool canReorderDoubled(vector<int>& arr) {\n    unordered_map<int, int> count;\n\n    for (const int a : arr)\n      ++count[a];\n\n    ranges::sort(arr, ranges::less{}, [](const int a) { return abs(a); });\n\n    for (const int a : arr) {\n      if (count[a] == 0)\n        continue;\n      if (count[2 * a] == 0)\n        return false;\n      --count[a];\n      --count[2 * a];\n    }\n\n    return true;\n  }\n};\n", "955": "class Solution {\n public:\n  int minDeletionSize(vector<string>& strs) {\n    const int n = strs.size();\n    int ans = 0;\n    // sorted[i] := true if strs[i] < strs[i + 1]\n    vector<bool> sorted(n - 1);\n\n    for (int j = 0; j < strs[0].length(); ++j) {\n      int i;\n      for (i = 0; i + 1 < n; ++i)\n        if (!sorted[i] && strs[i][j] > strs[i + 1][j]) {\n          ++ans;\n          break;\n        }\n      // Already compared each pair, so update the sorted array if needed.\n      if (i + 1 == n)\n        for (i = 0; i + 1 < n; ++i)\n          sorted[i] = sorted[i] || strs[i][j] < strs[i + 1][j];\n    }\n\n    return ans;\n  }\n};\n", "956": "class Solution {\n public:\n  int tallestBillboard(vector<int>& rods) {\n    const int sum = accumulate(rods.begin(), rods.end(), 0);\n    // dp[i] := the maximum min-height of using rods so far to pile two piles\n    // that have height difference i\n    vector<int> dp(sum + 1, -1);\n    dp[0] = 0;\n\n    for (const int h : rods) {\n      vector<int> prev(dp);\n      for (int i = 0; i <= sum - h; ++i) {\n        if (prev[i] < 0)\n          continue;\n        // Don't use this rod.\n        dp[i] = max(dp[i], prev[i]);\n        // Put on the taller pile.\n        dp[i + h] = max(dp[i + h], prev[i]);\n        // Put on the shorter pile.\n        dp[abs(i - h)] = max(dp[abs(i - h)], prev[i] + min(i, h));\n      }\n    }\n\n    return dp[0];\n  }\n};\n", "957": "class Solution {\n public:\n  vector<int> prisonAfterNDays(vector<int>& cells, int n) {\n    vector<int> firstDayCells;\n    vector<int> nextDayCells(cells.size());\n\n    for (int day = 0; n-- > 0; cells = nextDayCells, ++day) {\n      for (int i = 1; i + 1 < cells.size(); ++i)\n        nextDayCells[i] = cells[i - 1] == cells[i + 1];\n      if (day == 0)\n        firstDayCells = nextDayCells;\n      else if (nextDayCells == firstDayCells)\n        n %= day;\n    }\n\n    return cells;\n  }\n};\n", "958": "class Solution {\n public:\n  bool isCompleteTree(TreeNode* root) {\n    const int count = getCount(root);\n    return validIndex(root, 1, count);\n  }\n\n private:\n  int getCount(TreeNode* root) {\n    if (root == nullptr)\n      return 0;\n    return 1 + getCount(root->left) + getCount(root->right);\n  }\n\n  // Returns true if there's no index > the number of nodes.\n  bool validIndex(TreeNode* root, int index, int count) {\n    if (root == nullptr)\n      return true;\n    if (index > count)\n      return false;\n    return validIndex(root->left, index * 2, count) &&\n           validIndex(root->right, index * 2 + 1, count);\n  }\n};\n", "959": "class Solution {\n public:\n  int regionsBySlashes(vector<string>& grid) {\n    const int n = grid.size();\n    // G := upscaled grid\n    vector<vector<int>> g(n * 3, vector<int>(n * 3));\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == '/') {\n          g[i * 3][j * 3 + 2] = 1;\n          g[i * 3 + 1][j * 3 + 1] = 1;\n          g[i * 3 + 2][j * 3] = 1;\n        } else if (grid[i][j] == '\\\\') {\n          g[i * 3][j * 3] = 1;\n          g[i * 3 + 1][j * 3 + 1] = 1;\n          g[i * 3 + 2][j * 3 + 2] = 1;\n        }\n\n    int ans = 0;\n\n    for (int i = 0; i < n * 3; ++i)\n      for (int j = 0; j < n * 3; ++j)\n        if (g[i][j] == 0) {\n          dfs(g, i, j);\n          ++ans;\n        }\n\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& g, int i, int j) {\n    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())\n      return;\n    if (g[i][j] != 0)\n      return;\n\n    g[i][j] = 2;  // Mark 2 as visited.\n    dfs(g, i + 1, j);\n    dfs(g, i - 1, j);\n    dfs(g, i, j + 1);\n    dfs(g, i, j - 1);\n  }\n};\n", "96": "class Solution {\n public:\n  int numTrees(int n) {\n    // dp[i] := the number of unique BST's that store values 1..i\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < i; ++j)\n        dp[i] += dp[j] * dp[i - j - 1];\n\n    return dp[n];\n  }\n};\n", "960": "class Solution {\n public:\n  int minDeletionSize(vector<string>& strs) {\n    const int k = strs[0].length();\n    // dp[i] the length of LIS ending in strs[*][i]\n    vector<int> dp(k, 1);\n\n    for (int i = 1; i < k; ++i)\n      for (int j = 0; j < i; ++j)\n        if (ranges::all_of(strs, [&](const string& s) { return s[j] <= s[i]; }))\n          dp[i] = max(dp[i], dp[j] + 1);\n\n    return k - ranges::max(dp);\n  }\n};\n", "961": "class Solution {\n public:\n  int repeatedNTimes(vector<int>& nums) {\n    for (int i = 0; i + 2 < nums.size(); ++i)\n      if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])\n        return nums[i];\n    return nums.back();\n  }\n};\n", "962": "class Solution {\n public:\n  int maxWidthRamp(vector<int>& nums) {\n    int ans = 0;\n    stack<int> stack;\n\n    for (int i = 0; i < nums.size(); ++i)\n      if (stack.empty() || nums[i] < nums[stack.top()])\n        stack.push(i);\n\n    for (int i = nums.size() - 1; i > ans; --i)\n      while (!stack.empty() && nums[i] >= nums[stack.top()])\n        ans = max(ans, i - stack.top()), stack.pop();\n\n    return ans;\n  }\n};\n", "963": "class Solution {\n public:\n  double minAreaFreeRect(vector<vector<int>>& points) {\n    long ans = LONG_MAX;\n    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\n\n    for (const vector<int>& A : points)\n      for (const vector<int>& B : points) {\n        const int center = hash(A, B);\n        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\n      }\n\n    // For all pair points \"that share the same center\".\n    for (const auto& [_, points] : centerToPoints)\n      for (const auto& [ax, ay, bx, by] : points)\n        for (const auto& [cx, cy, dx, dy] : points)\n          // AC is perpendicular to AD.\n          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.\n          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\n            const long squaredArea =\n                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\n            if (squaredArea > 0)\n              ans = min(ans, squaredArea);\n          }\n\n    return ans == LONG_MAX ? 0 : sqrt(ans);\n  }\n\n private:\n  int hash(const vector<int>& p, const vector<int>& q) {\n    return ((long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\n  }\n\n  long dist(int px, int py, int qx, int qy) {\n    return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n  }\n};\n", "964": "class Solution {\n public:\n  int leastOpsExpressTarget(int x, int target) {\n    return dfs(x, target, {});\n  }\n\n private:\n  int dfs(int x, int target, unordered_map<int, int>&& mem) {\n    if (const auto it = mem.find(target); it != mem.cend())\n      return it->second;\n    if (x > target)\n      return min(2 * target - 1, 2 * (x - target));\n    if (x == target)\n      return 0;\n\n    long prod = x;\n    int n = 0;\n    while (prod < target) {\n      prod *= x;\n      ++n;\n    }\n    if (prod == target)\n      return mem[target] = n;\n\n    int ans = dfs(x, target - prod / x, std::move(mem)) + n;\n    if (prod < 2 * target)\n      ans = min(ans, dfs(x, prod - target, std::move(mem)) + n + 1);\n    return mem[target] = ans;\n  }\n};\n", "965": "class Solution {\n public:\n  bool isUnivalTree(TreeNode* root) {\n    if (root == nullptr)\n      return true;\n    if (root->left != nullptr && root->left->val != root->val)\n      return false;\n    if (root->right != nullptr && root->right->val != root->val)\n      return false;\n    return isUnivalTree(root->left) && isUnivalTree(root->right);\n  }\n};\n", "966": "class Solution {\n public:\n  vector<string> spellchecker(vector<string>& wordlist,\n                              vector<string>& queries) {\n    vector<string> ans;\n    unordered_map<string, string> dict;\n\n    for (const string& word : wordlist) {\n      dict.insert({word, word});\n      dict.insert({lowerKey(word), word});\n      dict.insert({vowelKey(word), word});\n    }\n\n    for (const string& query : queries)\n      if (const auto it = dict.find(query); it != dict.cend())\n        ans.push_back(it->second);\n      else if (const auto it = dict.find(lowerKey(query)); it != dict.cend())\n        ans.push_back(it->second);\n      else if (const auto it = dict.find(vowelKey(query)); it != dict.cend())\n        ans.push_back(it->second);\n      else\n        ans.push_back(\"\");\n\n    return ans;\n  }\n\n private:\n  string lowerKey(const string& word) {\n    string s{\"$\"};\n    for (const char c : word)\n      s += tolower(c);\n    return s;\n  }\n\n  string vowelKey(const string& word) {\n    string s;\n    for (const char c : word)\n      s += isVowel(c) ? '*' : tolower(c);\n    return s;\n  }\n\n  bool isVowel(char c) {\n    static constexpr string_view kVowels = \"aeiouAEIOU\";\n    return kVowels.find(c) != string_view::npos;\n  }\n};\n", "967": "class Solution {\n public:\n  vector<int> numsSameConsecDiff(int n, int k) {\n    if (n == 1)\n      return {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    vector<int> ans;\n\n    if (k == 0) {\n      for (char c = '1'; c <= '9'; ++c)\n        ans.push_back(stoi(string(n, c)));\n      return ans;\n    }\n\n    for (int num = 1; num <= 9; ++num)\n      dfs(n - 1, k, num, ans);\n\n    return ans;\n  }\n\n private:\n  void dfs(int n, int k, int num, vector<int>& ans) {\n    if (n == 0) {\n      ans.push_back(num);\n      return;\n    }\n\n    const int lastDigit = num % 10;\n\n    for (const int nextDigit : {lastDigit - k, lastDigit + k})\n      if (0 <= nextDigit && nextDigit <= 9)\n        dfs(n - 1, k, num * 10 + nextDigit, ans);\n  }\n};\n", "968": "class Solution {\n public:\n  int minCameraCover(TreeNode* root) {\n    vector<int> ans = dfs(root);\n    return min(ans[1], ans[2]);\n  }\n\n private:\n  // 0 := all the nodes below the root are covered except the root\n  // 1 := all the nodes below and including the root are covered with no camera\n  // 2 := all nodes below and including the root are covered with a camera\n  vector<int> dfs(TreeNode* root) {\n    if (root == nullptr)\n      return {0, 0, 1000};\n\n    vector<int> l = dfs(root->left);\n    vector<int> r = dfs(root->right);\n\n    const int s0 = l[1] + r[1];\n    const int s1 = min(l[2] + min(r[1], r[2]),  //\n                       r[2] + min(l[1], l[2]));\n    const int s2 = min({l[0], l[1], l[2]}) +  //\n                   min({r[0], r[1], r[2]}) + 1;\n    return {s0, s1, s2};\n  }\n};\n", "969": "class Solution {\n public:\n  vector<int> pancakeSort(vector<int>& arr) {\n    vector<int> ans;\n\n    for (int target = arr.size(); target >= 1; --target) {\n      int index = find(arr, target);\n      reverse(arr.begin(), arr.begin() + index + 1);\n      reverse(arr.begin(), arr.begin() + target);\n      ans.push_back(index + 1);\n      ans.push_back(target);\n    }\n\n    return ans;\n  }\n\n private:\n  int find(vector<int>& arr, int target) {\n    for (int i = 0; i < arr.size(); ++i)\n      if (arr[i] == target)\n        return i;\n    throw;\n  }\n};\n", "97": "class Solution {\n public:\n  bool isInterleave(string s1, string s2, string s3) {\n    const int m = s1.length();\n    const int n = s2.length();\n    if (m + n != s3.length())\n      return false;\n\n    vector<bool> dp(n + 1);\n\n    for (int i = 0; i <= m; ++i)\n      for (int j = 0; j <= n; ++j)\n        if (i == 0 && j == 0)\n          dp[j] = true;\n        else if (i == 0)\n          dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\n        else if (j == 0)\n          dp[j] = dp[j] && s1[i - 1] == s3[i - 1];\n        else\n          dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1] ||\n                  dp[j - 1] && s2[j - 1] == s3[i + j - 1];\n\n    return dp[n];\n  }\n};\n", "970": "class Solution {\n public:\n  vector<int> powerfulIntegers(int x, int y, int bound) {\n    unordered_set<int> ans;\n\n    for (int i = 1; i < bound; i *= x) {\n      for (int j = 1; i + j <= bound; j *= y) {\n        ans.insert(i + j);\n        if (y == 1)\n          break;\n      }\n      if (x == 1)\n        break;\n    }\n\n    return {ans.begin(), ans.end()};\n  }\n};\n", "971": "class Solution {\n public:\n  vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\n    vector<int> ans;\n    dfs(root, 0, voyage, ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int&& i, const vector<int>& voyage,\n           vector<int>& ans) {\n    if (root == nullptr)\n      return;\n    if (root->val != voyage[i++]) {\n      ans.clear();\n      ans.push_back(-1);\n      return;\n    }\n\n    if (i < voyage.size() && root->left && root->left->val != voyage[i]) {\n      // Flip the root.\n      ans.push_back(root->val);\n      dfs(root->right, std::move(i), voyage, ans);\n      dfs(root->left, std::move(i), voyage, ans);\n    } else {\n      dfs(root->left, std::move(i), voyage, ans);\n      dfs(root->right, std::move(i), voyage, ans);\n    }\n  }\n};\n", "972": "class Solution {\n public:\n  bool isRationalEqual(string s, string t) {\n    return abs(valueOf(s) - valueOf(t)) < 1e-9;\n  }\n\n private:\n  const vector<double> ratios{1.0, 1.0 / 9, 1.0 / 99, 1.0 / 999, 1.0 / 9999};\n\n  double valueOf(const string& s) {\n    if (s.find('(') == string::npos)\n      return stod(s);\n\n    // Get the indices..\n    const int leftParenIndex = s.find_first_of('(');\n    const int rightParenIndex = s.find_first_of(')');\n    const int dotIndex = s.find_first_of('.');\n\n    // integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n    const double integerAndNonRepeating = stod(s.substr(0, leftParenIndex));\n    const int nonRepeatingLength = leftParenIndex - dotIndex - 1;\n\n    // repeating := <RepeatingPart>\n    const int repeating = stoi(s.substr(leftParenIndex + 1, rightParenIndex));\n    const int repeatingLength = rightParenIndex - leftParenIndex - 1;\n    return integerAndNonRepeating +\n           repeating * pow(0.1, nonRepeatingLength) * ratios[repeatingLength];\n  }\n};\n", "973": "class Solution {\n public:\n  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n    quickSelect(points, 0, points.size() - 1, k);\n    return {points.begin(), points.begin() + k};\n  };\n\n private:\n  void quickSelect(vector<vector<int>>& points, int l, int r, int k) {\n    const vector<int> pivot = points[r];\n\n    int nextSwapped = l;\n    for (int i = l; i < r; ++i)\n      if (squareDist(points[i]) <= squareDist(pivot))\n        swap(points[nextSwapped++], points[i]);\n    swap(points[nextSwapped], points[r]);\n\n    const int count = nextSwapped - l + 1;  // the number of points <= pivot\n    if (count == k)\n      return;\n    if (count > k)\n      quickSelect(points, l, nextSwapped - 1, k);\n    else\n      quickSelect(points, nextSwapped + 1, r, k - count);\n  }\n\n  int squareDist(const vector<int>& p) {\n    return p[0] * p[0] + p[1] * p[1];\n  }\n};\n", "974": "class Solution {\n public:\n  int subarraysDivByK(vector<int>& nums, int k) {\n    int ans = 0;\n    int prefix = 0;\n    vector<int> count(k);\n    count[0] = 1;\n\n    for (const int num : nums) {\n      prefix = (prefix + num % k + k) % k;\n      ans += count[prefix];\n      ++count[prefix];\n    }\n\n    return ans;\n  }\n};\n", "975": "class Solution {\n public:\n  int oddEvenJumps(vector<int>& arr) {\n    const int n = arr.size();\n    map<int, int> map;  // {num: min index}\n    // inc[i] := true if can reach arr[n - 1] from i using increasing jumps\n    vector<bool> inc(n);\n    // dec[i] := true if can reach arr[n - 1] from i using decreasing jumps\n    vector<bool> dec(n);\n\n    map[arr[n - 1]] = n - 1;\n    inc.back() = true;\n    dec.back() = true;\n\n    for (int i = n - 2; i >= 0; --i) {\n      const auto lo = map.lower_bound(arr[i]);  // the minimum value >= arr[i]\n      const auto hi = map.upper_bound(arr[i]);  // the minimum value > arr[i]\n      if (lo != map.cend())\n        inc[i] = dec[lo->second];\n      if (hi != map.cbegin())\n        dec[i] = inc[prev(hi)->second];\n      map[arr[i]] = i;\n    }\n\n    return ranges::count(inc, true);\n  }\n};\n", "976": "class Solution {\n public:\n  int largestPerimeter(vector<int>& nums) {\n    ranges::sort(nums);\n\n    for (int i = nums.size() - 1; i > 1; --i)\n      if (nums[i - 2] + nums[i - 1] > nums[i])\n        return nums[i - 2] + nums[i - 1] + nums[i];\n\n    return 0;\n  }\n};\n", "977": "class Solution {\n public:\n  vector<int> sortedSquares(vector<int>& nums) {\n    const int n = nums.size();\n    vector<int> ans(n);\n    int i = n - 1;\n\n    for (int l = 0, r = n - 1; l <= r;)\n      if (abs(nums[l]) > abs(nums[r]))\n        ans[i--] = nums[l] * nums[l++];\n      else\n        ans[i--] = nums[r] * nums[r--];\n\n    return ans;\n  }\n};\n", "978": "class Solution {\n public:\n  int maxTurbulenceSize(vector<int>& arr) {\n    int ans = 1;\n    int increasing = 1;\n    int decreasing = 1;\n\n    for (int i = 1; i < arr.size(); ++i) {\n      if (arr[i] > arr[i - 1]) {\n        increasing = decreasing + 1;\n        decreasing = 1;\n      } else if (arr[i] < arr[i - 1]) {\n        decreasing = increasing + 1;\n        increasing = 1;\n      } else {\n        increasing = 1;\n        decreasing = 1;\n      }\n      ans = max({ans, increasing, decreasing});\n    }\n\n    return ans;\n  }\n};\n", "979": "class Solution {\n public:\n  int distributeCoins(TreeNode* root) {\n    int ans = 0;\n    dfs(root, ans);\n    return ans;\n  }\n\n private:\n  // Returns the number of coins I can give (positive) / take (negative).\n  int dfs(TreeNode* root, int& ans) {\n    if (root == nullptr)\n      return 0;\n\n    const int l = dfs(root->left, ans);\n    const int r = dfs(root->right, ans);\n    ans += abs(l) + abs(r);\n    return (root->val - 1) + l + r;\n  }\n};\n", "98": "class Solution {\n public:\n  bool isValidBST(TreeNode* root) {\n    stack<TreeNode*> stack;\n    TreeNode* pred = nullptr;\n\n    while (root != nullptr || !stack.empty()) {\n      while (root != nullptr) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      if (pred && pred->val >= root->val)\n        return false;\n      pred = root;\n      root = root->right;\n    }\n\n    return true;\n  }\n};\n", "980": "class Solution {\n public:\n  int uniquePathsIII(vector<vector<int>>& grid) {\n    int ans = 0;\n    int empty = 1;\n    int sx;\n    int sy;\n    int ex;\n    int ey;\n\n    for (int i = 0; i < grid.size(); ++i)\n      for (int j = 0; j < grid[0].size(); ++j)\n        if (grid[i][j] == 0) {\n          ++empty;\n        } else if (grid[i][j] == 1) {\n          sx = i;\n          sy = j;\n        } else if (grid[i][j] == 2) {\n          ex = i;\n          ey = j;\n        }\n\n    dfs(grid, empty, sx, sy, ex, ey, ans);\n\n    return ans;\n  }\n\n private:\n  void dfs(vector<vector<int>>& grid, int empty, int i, int j, int ex, int ey,\n           int& ans) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] < 0)\n      return;\n    if (i == ex && j == ey) {\n      if (empty == 0)\n        ++ans;\n      return;\n    }\n\n    grid[i][j] = -2;\n    dfs(grid, empty - 1, i + 1, j, ex, ey, ans);\n    dfs(grid, empty - 1, i - 1, j, ex, ey, ans);\n    dfs(grid, empty - 1, i, j + 1, ex, ey, ans);\n    dfs(grid, empty - 1, i, j - 1, ex, ey, ans);\n    grid[i][j] = 0;\n  }\n};\n", "981": "struct T {\n  string value;\n  int timestamp;\n};\n\nclass TimeMap {\n public:\n  void set(string key, string value, int timestamp) {\n    map[key].emplace_back(value, timestamp);\n  }\n\n  string get(string key, int timestamp) {\n    if (!map.contains(key))\n      return \"\";\n\n    const vector<T>& A = map[key];\n    int l = 0;\n    int r = A.size();\n\n    while (l < r) {\n      const int m = (l + r) / 2;\n      if (A[m].timestamp > timestamp)\n        r = m;\n      else\n        l = m + 1;\n    }\n\n    return l == 0 ? \"\" : A[l - 1].value;\n  }\n\n private:\n  unordered_map<string, vector<T>> map;\n};\n", "982": "class Solution {\n public:\n  int countTriplets(vector<int>& nums) {\n    constexpr int kMax = 1 << 16;\n    int ans = 0;\n    vector<int> count(kMax);  // {nums[i] & nums[j]: times}\n\n    for (const int a : nums)\n      for (const int b : nums)\n        ++count[a & b];\n\n    for (const int num : nums)\n      for (int i = 0; i < kMax; ++i)\n        if ((num & i) == 0)\n          ans += count[i];\n\n    return ans;\n  }\n};\n", "983": "class Solution {\n public:\n  int mincostTickets(vector<int>& days, vector<int>& costs) {\n    int ans = 0;\n    queue<pair<int, int>> last7;\n    queue<pair<int, int>> last30;\n\n    for (const int day : days) {\n      while (!last7.empty() && last7.front().first + 7 <= day)\n        last7.pop();\n      while (!last30.empty() && last30.front().first + 30 <= day)\n        last30.pop();\n      last7.emplace(day, ans + costs[1]);\n      last30.emplace(day, ans + costs[2]);\n      ans = min({ans + costs[0], last7.front().second, last30.front().second});\n    }\n\n    return ans;\n  }\n};\n", "984": "class Solution {\n public:\n  string strWithout3a3b(int A, int B, char a = 'a', char b = 'b') {\n    if (A < B)\n      return strWithout3a3b(B, A, b, a);\n    if (B == 0)\n      return string(min(A, 2), a);\n\n    const int useA = min(A, 2);\n    const int useB = (A - useA >= B) ? 1 : 0;\n    return string(useA, a) + string(useB, b) +\n           strWithout3a3b(A - useA, B - useB, a, b);\n  }\n};\n", "985": "class Solution {\n public:\n  vector<int> sumEvenAfterQueries(vector<int>& nums,\n                                  vector<vector<int>>& queries) {\n    vector<int> ans;\n    int sum = accumulate(nums.begin(), nums.end(), 0, [](int acc, int num) {\n      return acc + (num % 2 == 0 ? num : 0);\n    });\n\n    for (const vector<int>& query : queries) {\n      const int val = query[0];\n      const int index = query[1];\n      if (nums[index] % 2 == 0)\n        sum -= nums[index];\n      nums[index] += val;\n      if (nums[index] % 2 == 0)\n        sum += nums[index];\n      ans.push_back(sum);\n    }\n\n    return ans;\n  }\n};\n", "986": "class Solution {\n public:\n  vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList,\n                                           vector<vector<int>>& secondList) {\n    vector<vector<int>> ans;\n    short i = 0;\n    short j = 0;\n\n    while (i < firstList.size() && j < secondList.size()) {\n      // lo := the start of the intersection\n      // hi := the end of the intersection\n      const int lo = max(firstList[i][0], secondList[j][0]);\n      const int hi = min(firstList[i][1], secondList[j][1]);\n      if (lo <= hi)\n        ans.push_back({lo, hi});\n      firstList[i][1] < secondList[j][1] ? ++i : ++j;\n    }\n\n    return ans;\n  }\n};\n", "987": "class Solution {\n public:\n  vector<vector<int>> verticalTraversal(TreeNode* root) {\n    vector<vector<int>> ans;\n    map<int, multiset<pair<int, int>>> xToSortedPairs;  // {x: {(-y, val)}}\n\n    dfs(root, 0, 0, xToSortedPairs);\n\n    for (const auto& [_, pairs] : xToSortedPairs) {\n      vector<int> vals;\n      for (const pair<int, int>& pair : pairs)\n        vals.push_back(pair.second);\n      ans.push_back(vals);\n    }\n\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, int x, int y,\n           map<int, multiset<pair<int, int>>>& xToSortedPairs) {\n    if (root == nullptr)\n      return;\n    xToSortedPairs[x].emplace(y, root->val);\n    dfs(root->left, x - 1, y + 1, xToSortedPairs);\n    dfs(root->right, x + 1, y + 1, xToSortedPairs);\n  }\n};\n", "988": "class Solution {\n public:\n  string smallestFromLeaf(TreeNode* root) {\n    string ans;\n    dfs(root, \"\", ans);\n    return ans;\n  }\n\n private:\n  void dfs(TreeNode* root, string&& path, string& ans) {\n    if (root == nullptr)\n      return;\n\n    path.push_back(root->val + 'a');\n\n    if (root->left == nullptr && root->right == nullptr) {\n      ranges::reverse(path);\n      if (ans == \"\" || ans > path)\n        ans = path;\n      ranges::reverse(path);  // Roll back.\n    }\n\n    dfs(root->left, std::move(path), ans);\n    dfs(root->right, std::move(path), ans);\n    path.pop_back();\n  }\n};\n", "989": "class Solution {\n public:\n  vector<int> addToArrayForm(vector<int>& num, int k) {\n    for (int i = num.size() - 1; i >= 0; --i) {\n      num[i] += k;\n      k = num[i] / 10;\n      num[i] %= 10;\n    }\n\n    while (k > 0) {\n      num.insert(num.begin(), k % 10);\n      k /= 10;\n    }\n\n    return num;\n  }\n};\n", "99": "class Solution {\n public:\n  void recoverTree(TreeNode* root) {\n    TreeNode* pred = nullptr;\n    TreeNode* x = nullptr;  // the first wrong node\n    TreeNode* y = nullptr;  // the second wrong node\n\n    stack<TreeNode*> stack;\n\n    while (root != nullptr || !stack.empty()) {\n      while (root != nullptr) {\n        stack.push(root);\n        root = root->left;\n      }\n      root = stack.top(), stack.pop();\n      if (pred && root->val < pred->val) {\n        y = root;\n        if (x == nullptr)\n          x = pred;\n      }\n      pred = root;\n      root = root->right;\n    }\n\n    swap(x, y);\n  }\n\n  void swap(TreeNode* x, TreeNode* y) {\n    const int temp = x->val;\n    x->val = y->val;\n    y->val = temp;\n  }\n};\n", "990": "class UnionFind {\n public:\n  UnionFind(int n) : id(n) {\n    iota(id.begin(), id.end(), 0);\n  }\n\n  void union_(int u, int v) {\n    id[find(u)] = find(v);\n  }\n\n  int find(int u) {\n    return id[u] == u ? u : id[u] = find(id[u]);\n  }\n\n private:\n  vector<int> id;\n};\n\nclass Solution {\n public:\n  bool equationsPossible(vector<string>& equations) {\n    UnionFind uf(26);\n\n    for (const string& e : equations)\n      if (e[1] == '=') {\n        const int x = e[0] - 'a';\n        const int y = e[3] - 'a';\n        uf.union_(x, y);\n      }\n\n    for (const string& e : equations)\n      if (e[1] == '!') {\n        const int x = e[0] - 'a';\n        const int y = e[3] - 'a';\n        if (uf.find(x) == uf.find(y))\n          return false;\n      }\n\n    return true;\n  }\n};\n", "991": "class Solution {\n public:\n  int brokenCalc(int startValue, int target) {\n    int ops = 0;\n\n    while (startValue < target) {\n      if (target % 2 == 0)\n        target /= 2;\n      else\n        ++target;\n      ++ops;\n    }\n\n    return ops + startValue - target;\n  }\n};\n", "992": "class Solution {\n public:\n  int subarraysWithKDistinct(vector<int>& nums, int k) {\n    return subarraysWithAtMostKDistinct(nums, k) -\n           subarraysWithAtMostKDistinct(nums, k - 1);\n  }\n\n private:\n  int subarraysWithAtMostKDistinct(const vector<int>& nums, int k) {\n    int res = 0;\n    vector<int> count(nums.size() + 1);\n\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\n      if (++count[nums[r]] == 1)\n        --k;\n      while (k == -1)\n        if (--count[nums[l++]] == 0)\n          ++k;\n      res += r - l + 1;  // nums[l..r], nums[l + 1..r], ..., nums[r]\n    }\n\n    return res;\n  }\n};\n", "993": "class Solution {\n public:\n  bool isCousins(TreeNode* root, int x, int y) {\n    if (root == nullptr)\n      return false;\n\n    queue<TreeNode*> queue{{root}};\n\n    while (!queue.empty()) {\n      bool isFindX = false;\n      bool isFindY = false;\n      for (int i = queue.size(); i > 0; --i) {\n        root = queue.front(), queue.pop();\n        if (root->val == x)\n          isFindX = true;\n        else if (root->val == y)\n          isFindY = true;\n        else if (root->left && root->right) {\n          if (root->left->val == x && root->right->val == y)\n            return false;\n          if (root->left->val == y && root->right->val == x)\n            return false;\n        }\n        if (root->left)\n          queue.push(root->left);\n        if (root->right)\n          queue.push(root->right);\n      }\n      if (isFindX && isFindY)\n        return true;\n      else if (isFindX || isFindY)\n        return false;\n    }\n\n    return false;\n  }\n};\n", "994": "class Solution {\n public:\n  int orangesRotting(vector<vector<int>>& grid) {\n    constexpr int kDirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    int countFresh = 0;\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          ++countFresh;\n        else if (grid[i][j] == 2)\n          q.emplace(i, j);\n\n    if (countFresh == 0)\n      return 0;\n\n    int step = 0;\n    for (; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [i, j] = q.front();\n        q.pop();\n        for (const auto& [dx, dy] : kDirs) {\n          const int x = i + dx;\n          const int y = j + dy;\n          if (x < 0 || x == m || y < 0 || y == n)\n            continue;\n          if (grid[x][y] != 1)\n            continue;\n          grid[x][y] = 2;   // Mark grid[x][y] as rotten.\n          q.emplace(x, y);  // Push the newly rotten orange to the queue.\n          --countFresh;     // Decrease the count of fresh oranges by 1.\n        }\n      }\n\n    return countFresh == 0 ? step - 1 : -1;\n  }\n};\n", "995": "class Solution {\n public:\n  int minKBitFlips(vector<int>& nums, int k) {\n    int ans = 0;\n    int flippedTime = 0;\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (i >= k && nums[i - k] == 2)\n        --flippedTime;\n      if (flippedTime % 2 == nums[i]) {\n        if (i + k > nums.size())\n          return -1;\n        ++ans;\n        ++flippedTime;\n        nums[i] = 2;\n      }\n    }\n\n    return ans;\n  }\n};\n", "996": "class Solution {\n public:\n  int numSquarefulPerms(vector<int>& nums) {\n    int ans = 0;\n    ranges::sort(nums);\n    dfs(nums, vector<bool>(nums.size()), {}, ans);\n    return ans;\n  }\n\n private:\n  void dfs(vector<int>& nums, vector<bool>&& used, vector<int>&& path,\n           int& ans) {\n    if (path.size() > 1 && !isSquare(path.back() + path[path.size() - 2]))\n      return;\n    if (path.size() == nums.size()) {\n      ++ans;\n      return;\n    }\n\n    for (int i = 0; i < nums.size(); ++i) {\n      if (used[i])\n        continue;\n      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])\n        continue;\n      used[i] = true;\n      path.push_back(nums[i]);\n      dfs(nums, std::move(used), std::move(path), ans);\n      path.pop_back();\n      used[i] = false;\n    }\n  }\n\n  bool isSquare(int num) {\n    const int root = sqrt(num);\n    return root * root == num;\n  }\n};\n", "997": "class Solution {\n public:\n  int findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> count(n + 1);\n\n    for (vector<int>& t : trust) {\n      --count[t[0]];\n      ++count[t[1]];\n    }\n\n    for (int i = 1; i < n + 1; ++i)\n      if (count[i] == n - 1)\n        return i;\n\n    return -1;\n  }\n};\n", "998": "class Solution {\n public:\n  TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\n    if (root->val < val)\n      return new TreeNode(val, root, nullptr);\n    TreeNode* curr = root;\n    while (curr->right && curr->right->val > val)\n      curr = curr->right;\n    TreeNode* inserted = new TreeNode(val, curr->right, nullptr);\n    curr->right = inserted;\n    return root;\n  }\n};\n", "999": "class Solution {\n public:\n  int numRookCaptures(vector<vector<char>>& board) {\n    int ans = 0;\n    int i0 = 0;\n    int j0 = 0;\n\n    for (int i = 0; i < 8; ++i)\n      for (int j = 0; j < 8; ++j)\n        if (board[i][j] == 'R') {\n          i0 = i;\n          j0 = j;\n        }\n\n    for (const vector<int>& d :\n         vector<vector<int>>({{1, 0}, {0, 1}, {-1, 0}, {0, -1}}))\n      for (int i = i0 + d[0], j = j0 + d[1]; 0 <= i && i < 8 && 0 <= j && j < 8;\n           i += d[0], j += d[1]) {\n        if (board[i][j] == 'p')\n          ++ans;\n        if (board[i][j] != '.')\n          break;\n      }\n\n    return ans;\n  }\n};\n"};